(function(root, factory) {
    if ('object' == typeof exports && 'object' == typeof module) module.exports = factory(require("reconnecting-websocket"), require("jsonwebtoken"), require("axios"), require("ws"), require("node-fetch"), require("os"), require("crypto"));
    else if ('function' == typeof define && define.amd) define([
        "reconnecting-websocket",
        "jsonwebtoken",
        "axios",
        "ws",
        "node-fetch",
        "os",
        "crypto"
    ], factory);
    else if ('object' == typeof exports) exports["CozeJs"] = factory(require("reconnecting-websocket"), require("jsonwebtoken"), require("axios"), require("ws"), require("node-fetch"), require("os"), require("crypto"));
    else root["CozeJs"] = factory(root["reconnecting-websocket"], root["jsonwebtoken"], root["axios"], root["ws"], root["node-fetch"], root["os"], root["crypto"]);
})(global, (__WEBPACK_EXTERNAL_MODULE_reconnecting_websocket__, __WEBPACK_EXTERNAL_MODULE_jsonwebtoken__, __WEBPACK_EXTERNAL_MODULE_axios__, __WEBPACK_EXTERNAL_MODULE_ws__, __WEBPACK_EXTERNAL_MODULE_node_fetch__, __WEBPACK_EXTERNAL_MODULE_os__, __WEBPACK_EXTERNAL_MODULE_crypto__)=>(()=>{
        "use strict";
        var __webpack_modules__ = {
            axios: function(module1) {
                module1.exports = __WEBPACK_EXTERNAL_MODULE_axios__;
            },
            crypto: function(module1) {
                module1.exports = __WEBPACK_EXTERNAL_MODULE_crypto__;
            },
            jsonwebtoken: function(module1) {
                module1.exports = __WEBPACK_EXTERNAL_MODULE_jsonwebtoken__;
            },
            "node-fetch": function(module1) {
                module1.exports = __WEBPACK_EXTERNAL_MODULE_node_fetch__;
            },
            os: function(module1) {
                module1.exports = __WEBPACK_EXTERNAL_MODULE_os__;
            },
            "reconnecting-websocket": function(module1) {
                module1.exports = __WEBPACK_EXTERNAL_MODULE_reconnecting_websocket__;
            },
            ws: function(module1) {
                module1.exports = __WEBPACK_EXTERNAL_MODULE_ws__;
            }
        };
        /************************************************************************/ // The module cache
        var __webpack_module_cache__ = {};
        // The require function
        function __webpack_require__(moduleId) {
            // Check if module is in cache
            var cachedModule = __webpack_module_cache__[moduleId];
            if (void 0 !== cachedModule) return cachedModule.exports;
            // Create a new module (and put it into the cache)
            var module1 = __webpack_module_cache__[moduleId] = {
                exports: {}
            };
            // Execute the module function
            __webpack_modules__[moduleId](module1, module1.exports, __webpack_require__);
            // Return the exports of the module
            return module1.exports;
        }
        /************************************************************************/ // webpack/runtime/compat_get_default_export
        (()=>{
            // getDefaultExport function for compatibility with non-ESM modules
            __webpack_require__.n = function(module1) {
                var getter = module1 && module1.__esModule ? function() {
                    return module1['default'];
                } : function() {
                    return module1;
                };
                __webpack_require__.d(getter, {
                    a: getter
                });
                return getter;
            };
        })();
        // webpack/runtime/define_property_getters
        (()=>{
            __webpack_require__.d = function(exports1, definition) {
                for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
                    enumerable: true,
                    get: definition[key]
                });
            };
        })();
        // webpack/runtime/has_own_property
        (()=>{
            __webpack_require__.o = function(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            };
        })();
        // webpack/runtime/make_namespace_object
        (()=>{
            // define __esModule on exports
            __webpack_require__.r = function(exports1) {
                if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
                    value: 'Module'
                });
                Object.defineProperty(exports1, '__esModule', {
                    value: true
                });
            };
        })();
        /************************************************************************/ var __webpack_exports__ = {};
        // ESM COMPAT FLAG
        __webpack_require__.r(__webpack_exports__);
        // EXPORTS
        __webpack_require__.d(__webpack_exports__, {
            VariableChannel: ()=>/* reexport */ bots_VariableChannel,
            Transcriptions: ()=>/* reexport */ Transcriptions,
            InternalServerError: ()=>/* reexport */ InternalServerError,
            fetchAPI: ()=>/* reexport */ fetchAPI,
            COZE_CN_BASE_WS_URL: ()=>/* reexport */ COZE_CN_BASE_WS_URL,
            APIError: ()=>/* reexport */ APIError,
            Knowledge: ()=>/* reexport */ Knowledge,
            CozeAPI: ()=>/* binding */ CozeAPI,
            OldDocuments: ()=>/* reexport */ Documents,
            POLL_INTERVAL: ()=>/* reexport */ POLL_INTERVAL,
            WebSocketAPI: ()=>/* reexport */ WebSocketAPI,
            Websockets: ()=>/* reexport */ Websockets,
            handleAdditionalMessages: ()=>/* reexport */ handleAdditionalMessages,
            Documents: ()=>/* reexport */ documents_Documents,
            Variables: ()=>/* reexport */ Variables,
            Audio: ()=>/* reexport */ Audio,
            Files: ()=>/* reexport */ Files,
            ChatEventType: ()=>/* reexport */ chat_ChatEventType,
            ChatStatus: ()=>/* reexport */ chat_ChatStatus,
            NotFoundError: ()=>/* reexport */ NotFoundError,
            APIConnectionError: ()=>/* reexport */ APIConnectionError,
            COZE_COM_BASE_WS_URL: ()=>/* reexport */ COZE_COM_BASE_WS_URL,
            Rooms: ()=>/* reexport */ Rooms,
            Users: ()=>/* reexport */ Users,
            VoiceprintGroups: ()=>/* reexport */ VoiceprintGroups,
            WorkSpaces: ()=>/* reexport */ WorkSpaces,
            JSONParseError: ()=>/* reexport */ JSONParseError,
            castToError: ()=>/* reexport */ castToError,
            getDeviceToken: ()=>/* reexport */ getDeviceToken,
            getDeviceCode: ()=>/* reexport */ getDeviceCode,
            getJWTToken: ()=>/* reexport */ getJWTToken,
            getPKCEOAuthToken: ()=>/* reexport */ getPKCEOAuthToken,
            getWebAuthenticationUrl: ()=>/* reexport */ getWebAuthenticationUrl,
            handleParameters: ()=>/* reexport */ handleParameters,
            COZE_COM_BASE_URL: ()=>/* reexport */ COZE_COM_BASE_URL,
            AuthenticationError: ()=>/* reexport */ AuthenticationError,
            COZE_CN_BASE_URL: ()=>/* reexport */ COZE_CN_BASE_URL,
            VariableType: ()=>/* reexport */ bots_VariableType,
            getPKCEAuthenticationUrl: ()=>/* reexport */ getPKCEAuthenticationUrl,
            TemplateEntityType: ()=>/* reexport */ templates_TemplateEntityType,
            Conversations: ()=>/* reexport */ Conversations,
            Workflows: ()=>/* reexport */ Workflows,
            GatewayError: ()=>/* reexport */ GatewayError,
            RoomMode: ()=>/* reexport */ rooms_RoomMode,
            PermissionDeniedError: ()=>/* reexport */ PermissionDeniedError,
            APIUserAbortError: ()=>/* reexport */ APIUserAbortError,
            Bots: ()=>/* reexport */ Bots,
            Chat: ()=>/* reexport */ Chat,
            RateLimitError: ()=>/* reexport */ RateLimitError,
            Runs: ()=>/* reexport */ Runs,
            SuggestReplyMode: ()=>/* reexport */ bots_SuggestReplyMode,
            TimeoutError: ()=>/* reexport */ TimeoutError,
            VoiceprintFeature: ()=>/* reexport */ VoiceprintFeature,
            WebsocketsEventType: ()=>/* reexport */ types_WebsocketsEventType,
            PKCEAuthErrorType: ()=>/* reexport */ auth_PKCEAuthErrorType,
            _getJWTToken: ()=>/* reexport */ _getJWTToken,
            MAX_POLL_INTERVAL: ()=>/* reexport */ MAX_POLL_INTERVAL,
            WorkflowChat: ()=>/* reexport */ WorkflowChat,
            WorkflowEventType: ()=>/* reexport */ runs_WorkflowEventType,
            Templates: ()=>/* reexport */ Templates,
            getWebOAuthToken: ()=>/* reexport */ getWebOAuthToken,
            refreshOAuthToken: ()=>/* reexport */ refreshOAuthToken,
            Images: ()=>/* reexport */ Images,
            BadRequestError: ()=>/* reexport */ BadRequestError,
            CozeError: ()=>/* reexport */ CozeError,
            RoleType: ()=>/* reexport */ chat_RoleType,
            Voices: ()=>/* reexport */ Voices,
            Messages: ()=>/* reexport */ messages_Messages,
            WorkflowEvent: ()=>/* reexport */ WorkflowEvent,
            adapterFetch: ()=>/* reexport */ adapterFetch,
            Datasets: ()=>/* reexport */ Datasets
        });
        class APIResource {
            constructor(client){
                this._client = client;
            }
        }
        /* eslint-disable @typescript-eslint/no-namespace */ class Bots extends APIResource {
            /**
   * Create a new agent. | 调用接口创建一个新的智能体。
   * @docs en:https://www.coze.com/docs/developer_guides/create_bot?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/create_bot?_lang=zh
   * @param params - Required The parameters for creating a bot. | 创建 Bot 的参数。
   * @param params.space_id - Required The Space ID of the space where the agent is located. | Bot 所在的空间的 Space ID。
   * @param params.name - Required The name of the agent. It should be 1 to 20 characters long. | Bot 的名称。
   * @param params.description - Optional The description of the agent. It can be 0 to 500 characters long. | Bot 的描述信息。
   * @param params.icon_file_id - Optional The file ID for the agent's avatar. | 作为智能体头像的文件 ID。
   * @param params.prompt_info - Optional The personality and reply logic of the agent. | Bot 的提示词配置。
   * @param params.onboarding_info - Optional The settings related to the agent's opening remarks. | Bot 的开场白配置。
   * @returns Information about the created bot. | 创建的 Bot 信息。
   */ async create(params, options) {
                const apiUrl = '/v1/bot/create';
                const result = await this._client.post(apiUrl, params, false, options);
                return result.data;
            }
            /**
   * Update the configuration of an agent. | 调用接口修改智能体的配置。
   * @docs en:https://www.coze.com/docs/developer_guides/update_bot?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/update_bot?_lang=zh
   * @param params - Required The parameters for updating a bot. | 修改 Bot 的参数。
   * @param params.bot_id - Required The ID of the agent that the API interacts with. | 待修改配置的智能体ID。
   * @param params.name - Optional The name of the agent. | Bot 的名称。
   * @param params.description - Optional The description of the agent. | Bot 的描述信息。
   * @param params.icon_file_id - Optional The file ID for the agent's avatar. | 作为智能体头像的文件 ID。
   * @param params.prompt_info - Optional The personality and reply logic of the agent. | Bot 的提示词配置。
   * @param params.onboarding_info - Optional The settings related to the agent's opening remarks. | Bot 的开场白配置。
   * @param params.knowledge - Optional Knowledge configurations of the agent. | Bot 的知识库配置。
   * @returns Undefined | 无返回值
   */ async update(params, options) {
                const apiUrl = '/v1/bot/update';
                const result = await this._client.post(apiUrl, params, false, options);
                return result.data;
            }
            /**
   * Get the agents published as API service. | 调用接口查看指定空间发布到 Agent as API 渠道的智能体列表。
   * @docs en:https://www.coze.com/docs/developer_guides/published_bots_list?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/published_bots_list?_lang=zh
   * @param params - Required The parameters for listing bots. | 列出 Bot 的参数。
   * @param params.space_id - Required The ID of the space. | Bot 所在的空间的 Space ID。
   * @param params.page_size - Optional Pagination size. | 分页大小。
   * @param params.page_index - Optional Page number for paginated queries. | 分页查询时的页码。
   * @returns List of published bots. | 已发布的 Bot 列表。
   */ async list(params, options) {
                const apiUrl = '/v1/space/published_bots_list';
                const result = await this._client.get(apiUrl, params, false, options);
                return result.data;
            }
            /**
   * Publish the specified agent as an API service. | 调用接口创建一个新的智能体。
   * @docs en:https://www.coze.com/docs/developer_guides/publish_bot?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/publish_bot?_lang=zh
   * @param params - Required The parameters for publishing a bot. | 发布 Bot 的参数。
   * @param params.bot_id - Required The ID of the agent that the API interacts with. | 要发布的智能体ID。
   * @param params.connector_ids - Required The list of publishing channel IDs for the agent. | 智能体的发布渠道 ID 列表。
   * @returns Undefined | 无返回值
   */ async publish(params, options) {
                const apiUrl = '/v1/bot/publish';
                const result = await this._client.post(apiUrl, params, false, options);
                return result.data;
            }
            /**
   * Get the configuration information of the agent. | 获取指定智能体的配置信息。
   * @docs en:https://www.coze.com/docs/developer_guides/get_metadata?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/get_metadata?_lang=zh
   * @param params - Required The parameters for retrieving a bot. | 获取 Bot 的参数。
   * @param params.bot_id - Required The ID of the agent that the API interacts with. | 要查看的智能体ID。
   * @returns Information about the bot. | Bot 的配置信息。
   */ async retrieve(params, options) {
                const apiUrl = '/v1/bot/get_online_info';
                const result = await this._client.get(apiUrl, params, false, options);
                return result.data;
            }
        }
        var bots_SuggestReplyMode = /*#__PURE__*/ function(SuggestReplyMode) {
            /**
   * The bot does not suggest replies.
   */ SuggestReplyMode["DISABLE"] = "disable";
            /**
   * The bot suggests replies.
   */ SuggestReplyMode["ENABLE"] = "enable";
            /**
   * The bot suggests replies based on the customized prompt.
   */ SuggestReplyMode["CUSTOMIZED"] = "customized";
            return SuggestReplyMode;
        }({});
        var bots_VariableType = /*#__PURE__*/ function(VariableType) {
            /**
   * The variable is a key-value pair.
   */ VariableType["KVVariable"] = "KVVariable";
            /**
   * The variable is a list.
   */ VariableType["ListVariable"] = "ListVariable";
            return VariableType;
        }({});
        var bots_VariableChannel = /*#__PURE__*/ function(VariableChannel) {
            /**
   * The variable is a custom variable.
   */ VariableChannel["Custom"] = "custom";
            /**
   * The variable is a system variable.
   */ VariableChannel["System"] = "system";
            /**
   * The variable is a location variable.
   */ VariableChannel["Location"] = "location";
            /**
   * The variable is a Feishu variable.
   */ VariableChannel["Feishu"] = "feishu";
            /**
   * The variable is an app variable.
   */ VariableChannel["APP"] = "app";
            return VariableChannel;
        }({});
        /* eslint-disable security/detect-object-injection */ /* eslint-disable @typescript-eslint/no-explicit-any */ function safeJsonParse(jsonString) {
            let defaultValue = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '';
            try {
                return JSON.parse(jsonString);
            } catch (error) {
                return defaultValue;
            }
        }
        function sleep(ms) {
            return new Promise((resolve)=>{
                setTimeout(resolve, ms);
            });
        }
        function isUniApp() {
            return 'undefined' != typeof uni;
        }
        function isBrowser() {
            return 'undefined' != typeof window;
        }
        function isPlainObject(obj) {
            if ('object' != typeof obj || null === obj) return false;
            const proto = Object.getPrototypeOf(obj);
            if (null === proto) return true;
            let baseProto = proto;
            while(null !== Object.getPrototypeOf(baseProto))baseProto = Object.getPrototypeOf(baseProto);
            return proto === baseProto;
        }
        function mergeConfig() {
            for(var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++)objects[_key] = arguments[_key];
            return objects.reduce((result, obj)=>{
                if (void 0 === obj) return result || {};
                for(const key in obj)if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    if (isPlainObject(obj[key]) && !Array.isArray(obj[key])) result[key] = mergeConfig(result[key] || {}, obj[key]);
                    else result[key] = obj[key];
                }
                return result;
            }, {});
        }
        function isPersonalAccessToken(token) {
            return !!(null == token ? void 0 : token.startsWith('pat_'));
        }
        function buildWebsocketUrl(path, params) {
            const queryString = Object.entries(params || {}).filter((param)=>{
                let [_, value] = param;
                return null != value && '' !== value;
            }).map((param)=>{
                let [key, value] = param;
                return `${key}=${value}`;
            }).join('&');
            return `${path}${queryString ? `?${queryString}` : ''}`;
        }
        const isBrowserExtension = ()=>'undefined' != typeof chrome && !!chrome.runtime && !!chrome.runtime.id;
        /* eslint-disable max-params */ class CozeError extends Error {
        }
        class APIError extends CozeError {
            static makeMessage(status, errorBody, message, headers) {
                if (!errorBody && message) return message;
                if (errorBody) {
                    const list = [];
                    const { code, msg, error } = errorBody;
                    if (code) list.push(`code: ${code}`);
                    if (msg) list.push(`msg: ${msg}`);
                    if ((null == error ? void 0 : error.detail) && msg !== error.detail) list.push(`detail: ${error.detail}`);
                    const logId = (null == error ? void 0 : error.logid) || (null == headers ? void 0 : headers['x-tt-logid']);
                    if (logId) list.push(`logid: ${logId}`);
                    return list.join(', ');
                }
                if (status) return `http status code: ${status} (no body)`;
                return '(no status code or body)';
            }
            static generate(status, errorResponse, message, headers) {
                if (!status) return new APIConnectionError({
                    cause: castToError(errorResponse)
                });
                const error = errorResponse;
                // https://www.coze.cn/docs/developer_guides/coze_error_codes
                if (400 === status || (null == error ? void 0 : error.code) === 4000) return new BadRequestError(status, error, message, headers);
                if (401 === status || (null == error ? void 0 : error.code) === 4100) return new AuthenticationError(status, error, message, headers);
                if (403 === status || (null == error ? void 0 : error.code) === 4101) return new PermissionDeniedError(status, error, message, headers);
                if (404 === status || (null == error ? void 0 : error.code) === 4200) return new NotFoundError(status, error, message, headers);
                if (429 === status || (null == error ? void 0 : error.code) === 4013) return new RateLimitError(status, error, message, headers);
                if (408 === status) return new TimeoutError(status, error, message, headers);
                if (502 === status) return new GatewayError(status, error, message, headers);
                if (status >= 500) return new InternalServerError(status, error, message, headers);
                return new APIError(status, error, message, headers);
            }
            constructor(status, error, message, headers){
                var _error_detail, _error_error;
                super(`${APIError.makeMessage(status, error, message, headers)}`);
                this.status = status;
                this.headers = headers;
                this.logid = (null == error ? void 0 : null === (_error_detail = error.detail) || void 0 === _error_detail ? void 0 : _error_detail.logid) || (null == headers ? void 0 : headers['x-tt-logid']);
                // this.error = error;
                this.code = null == error ? void 0 : error.code;
                this.msg = null == error ? void 0 : error.msg;
                this.detail = null == error ? void 0 : null === (_error_error = error.error) || void 0 === _error_error ? void 0 : _error_error.detail;
                this.rawError = error;
            }
        }
        class APIConnectionError extends APIError {
            constructor({ message }){
                super(void 0, void 0, message || 'Connection error.', void 0), this.status = void 0;
            // if (cause) {
            //   this.cause = cause;
            // }
            }
        }
        class APIUserAbortError extends APIError {
            constructor(message){
                super(void 0, void 0, message || 'Request was aborted.', void 0), this.name = 'UserAbortError', this.status = void 0;
            }
        }
        class BadRequestError extends APIError {
            constructor(...args){
                super(...args), this.name = 'BadRequestError', this.status = 400;
            }
        }
        class AuthenticationError extends APIError {
            constructor(...args){
                super(...args), this.name = 'AuthenticationError', this.status = 401;
            }
        }
        class PermissionDeniedError extends APIError {
            constructor(...args){
                super(...args), this.name = 'PermissionDeniedError', this.status = 403;
            }
        }
        class NotFoundError extends APIError {
            constructor(...args){
                super(...args), this.name = 'NotFoundError', this.status = 404;
            }
        }
        class TimeoutError extends APIError {
            constructor(...args){
                super(...args), this.name = 'TimeoutError', this.status = 408;
            }
        }
        class RateLimitError extends APIError {
            constructor(...args){
                super(...args), this.name = 'RateLimitError', this.status = 429;
            }
        }
        class InternalServerError extends APIError {
            constructor(...args){
                super(...args), this.name = 'InternalServerError', this.status = 500;
            }
        }
        class GatewayError extends APIError {
            constructor(...args){
                super(...args), this.name = 'GatewayError', this.status = 502;
            }
        }
        const castToError = (err)=>{
            if (err instanceof Error) return err;
            return new Error(err);
        };
        class JSONParseError extends Error {
            constructor({ message, cause }){
                super(message);
                this.cause = cause;
            }
        }
        class Messages extends APIResource {
            /**
   * Get the list of messages in a chat. | 获取对话中的消息列表。
   * @docs en:https://www.coze.com/docs/developer_guides/chat_message_list?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/chat_message_list?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | 会话 ID。
   * @param chat_id - Required The ID of the chat. | 对话 ID。
   * @returns An array of chat messages. | 对话消息数组。
   */ async list(conversation_id, chat_id, options) {
                const apiUrl = `/v3/chat/message/list?conversation_id=${conversation_id}&chat_id=${chat_id}`;
                const result = await this._client.get(apiUrl, void 0, false, options);
                return result.data;
            }
        }
        const uuid = ()=>(Math.random() * new Date().getTime()).toString();
        const handleAdditionalMessages = (additional_messages)=>null == additional_messages ? void 0 : additional_messages.map((i)=>({
                    ...i,
                    content: 'object' == typeof i.content ? JSON.stringify(i.content) : i.content
                }));
        const handleParameters = (parameters)=>{
            if (parameters) {
                for (const [key, value] of Object.entries(parameters))if ('object' == typeof value) parameters[key] = JSON.stringify(value);
            }
            return parameters;
        };
        class Chat extends APIResource {
            /**
   * Call the Chat API to send messages to a published Coze agent. | 调用此接口发起一次对话，支持添加上下文
   * @docs en:https://www.coze.com/docs/developer_guides/chat_v3?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/chat_v3?_lang=zh
   * @param params - Required The parameters for creating a chat session. | 创建会话的参数。
   * @param params.bot_id - Required The ID of the agent. | 要进行会话聊天的 Bot ID。
   * @param params.user_id - Optional The ID of the user interacting with the Bot. | 标识当前与 Bot 交互的用户。
   * @param params.additional_messages - Optional Additional messages for the conversation. | 对话的附加信息。
   * @param params.custom_variables - Optional Variables defined in the Bot. | Bot 中定义变量。
   * @param params.auto_save_history - Optional Whether to automatically save the conversation history. | 是否自动保存历史对话记录。
   * @param params.meta_data - Optional Additional metadata for the message. | 创建消息时的附加消息。
   * @param params.conversation_id - Optional The ID of the conversation. | 标识对话发生在哪一次会话中。
   * @param params.extra_params - Optional Extra parameters for the conversation. | 附加参数。
   * @param params.shortcut_command - Optional The shortcut command information. | 快捷指令信息。
   * @param params.parameters - Optional custom parameters. | 自定义参数。
   * @returns The data of the created chat. | 创建的对话数据。
   */ async create(params, options) {
                if (!params.user_id) params.user_id = uuid();
                const { conversation_id, ...rest } = params;
                const apiUrl = `/v3/chat${conversation_id ? `?conversation_id=${conversation_id}` : ''}`;
                const payload = {
                    ...rest,
                    additional_messages: handleAdditionalMessages(params.additional_messages),
                    shortcut_command: params.shortcut_command ? {
                        ...params.shortcut_command,
                        parameters: handleParameters(params.shortcut_command.parameters)
                    } : void 0,
                    stream: false
                };
                const result = await this._client.post(apiUrl, payload, false, options);
                return result.data;
            }
            /**
   * Call the Chat API to send messages to a published Coze agent. | 调用此接口发起一次对话，支持添加上下文
   * @docs en:https://www.coze.com/docs/developer_guides/chat_v3?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/chat_v3?_lang=zh
   * @param params - Required The parameters for creating a chat session. | 创建会话的参数。
   * @param params.bot_id - Required The ID of the agent. | 要进行会话聊天的 Bot ID。
   * @param params.user_id - Optional The ID of the user interacting with the Bot. | 标识当前与 Bot 交互的用户。
   * @param params.additional_messages - Optional Additional messages for the conversation. | 对话的附加信息。
   * @param params.custom_variables - Optional Variables defined in the Bot. | Bot 中定义的变量。
   * @param params.auto_save_history - Optional Whether to automatically save the conversation history. | 是否自动保存历史对话记录。
   * @param params.meta_data - Optional Additional metadata for the message. | 创建消息时的附加消息。
   * @param params.conversation_id - Optional The ID of the conversation. | 标识对话发生在哪一次会话中。
   * @param params.extra_params - Optional Extra parameters for the conversation. | 附加参数。
   * @param params.shortcut_command - Optional The shortcut command information. | 快捷指令信息。
   * @param params.parameters - Optional custom parameters. | 自定义参数。
   * @returns
   */ async createAndPoll(params, options) {
                if (!params.user_id) params.user_id = uuid();
                const { conversation_id, ...rest } = params;
                const apiUrl = `/v3/chat${conversation_id ? `?conversation_id=${conversation_id}` : ''}`;
                const payload = {
                    ...rest,
                    additional_messages: handleAdditionalMessages(params.additional_messages),
                    shortcut_command: params.shortcut_command ? {
                        ...params.shortcut_command,
                        parameters: handleParameters(params.shortcut_command.parameters)
                    } : void 0,
                    stream: false
                };
                const result = await this._client.post(apiUrl, payload, false, options);
                const chatId = result.data.id;
                const conversationId = result.data.conversation_id;
                let chat;
                while(true){
                    await sleep(100);
                    chat = await this.retrieve(conversationId, chatId);
                    if ('completed' === chat.status || 'failed' === chat.status || 'requires_action' === chat.status) break;
                }
                const messageList = await this.messages.list(conversationId, chatId);
                return {
                    chat,
                    messages: messageList
                };
            }
            /**
   * Call the Chat API to send messages to a published Coze agent with streaming response. | 调用此接口发起一次对话，支持流式响应。
   * @docs en:https://www.coze.com/docs/developer_guides/chat_v3?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/chat_v3?_lang=zh
   * @param params - Required The parameters for streaming a chat session. | 流式会话的参数。
   * @param params.bot_id - Required The ID of the agent. | 要进行会话聊天的 Bot ID。
   * @param params.user_id - Optional The ID of the user interacting with the Bot. | 标识当前与 Bot 交互的用户。
   * @param params.additional_messages - Optional Additional messages for the conversation. | 对话的附加信息。
   * @param params.custom_variables - Optional Variables defined in the Bot. | Bot 中定义的变量。
   * @param params.auto_save_history - Optional Whether to automatically save the conversation history. | 是否自动保存历史对话记录。
   * @param params.meta_data - Optional Additional metadata for the message. | 创建消息时的附加消息。
   * @param params.conversation_id - Optional The ID of the conversation. | 标识对话发生在哪一次会话中。
   * @param params.extra_params - Optional Extra parameters for the conversation. | 附加参数。
   * @param params.shortcut_command - Optional The shortcut command information. | 快捷指令信息。
   * @param params.parameters - Optional custom parameters. | 自定义参数。
   * @returns A stream of chat data. | 对话数据流。
   */ async *stream(params, options) {
                if (!params.user_id) params.user_id = uuid();
                const { conversation_id, ...rest } = params;
                const apiUrl = `/v3/chat${conversation_id ? `?conversation_id=${conversation_id}` : ''}`;
                const payload = {
                    ...rest,
                    additional_messages: handleAdditionalMessages(params.additional_messages),
                    shortcut_command: params.shortcut_command ? {
                        ...params.shortcut_command,
                        parameters: handleParameters(params.shortcut_command.parameters)
                    } : void 0,
                    stream: true
                };
                const result = await this._client.post(apiUrl, payload, true, options);
                for await (const message of result)if ("done" === message.event) {
                    const ret = {
                        event: message.event,
                        data: '[DONE]'
                    };
                    yield ret;
                } else try {
                    const ret = {
                        event: message.event,
                        data: JSON.parse(message.data)
                    };
                    yield ret;
                } catch (error) {
                    throw new CozeError(`Could not parse message into JSON:${message.data}`);
                }
            }
            /**
   * Get the detailed information of the chat. | 查看对话的详细信息。
   * @docs en:https://www.coze.com/docs/developer_guides/retrieve_chat?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/retrieve_chat?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | 会话 ID。
   * @param chat_id - Required The ID of the chat. | 对话 ID。
   * @returns The data of the retrieved chat. | 检索到的对话数据。
   */ async retrieve(conversation_id, chat_id, options) {
                const apiUrl = `/v3/chat/retrieve?conversation_id=${conversation_id}&chat_id=${chat_id}`;
                const result = await this._client.post(apiUrl, void 0, false, options);
                return result.data;
            }
            /**
   * Cancel a chat session. | 取消对话会话。
   * @docs en:https://www.coze.com/docs/developer_guides/cancel_chat?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/cancel_chat?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | 会话 ID。
   * @param chat_id - Required The ID of the chat. | 对话 ID。
   * @returns The data of the canceled chat. | 取消的对话数据。
   */ async cancel(conversation_id, chat_id, options) {
                const apiUrl = '/v3/chat/cancel';
                const payload = {
                    conversation_id,
                    chat_id
                };
                const result = await this._client.post(apiUrl, payload, false, options);
                return result.data;
            }
            /**
   * Submit tool outputs for a chat session. | 提交对话会话的工具输出。
   * @docs en:https://www.coze.com/docs/developer_guides/chat_submit_tool_outputs?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/chat_submit_tool_outputs?_lang=zh
   * @param params - Required Parameters for submitting tool outputs. | 提交工具输出的参数。
   * @param params.conversation_id - Required The ID of the conversation. | 会话 ID。
   * @param params.chat_id - Required The ID of the chat. | 对话 ID。
   * @param params.tool_outputs - Required The outputs of the tool. | 工具的输出。
   * @param params.stream - Optional Whether to use streaming response. | 是否使用流式响应。
   * @returns The data of the submitted tool outputs or a stream of chat data. | 提交的工具输出数据或对话数据流。
   */ async *submitToolOutputs(params, options) {
                const { conversation_id, chat_id, ...rest } = params;
                const apiUrl = `/v3/chat/submit_tool_outputs?conversation_id=${params.conversation_id}&chat_id=${params.chat_id}`;
                const payload = {
                    ...rest
                };
                if (false === params.stream) {
                    const response = await this._client.post(apiUrl, payload, false, options);
                    return response.data;
                }
                {
                    const result = await this._client.post(apiUrl, payload, true, options);
                    for await (const message of result)if ("done" === message.event) {
                        const ret = {
                            event: message.event,
                            data: '[DONE]'
                        };
                        yield ret;
                    } else try {
                        const ret = {
                            event: message.event,
                            data: JSON.parse(message.data)
                        };
                        yield ret;
                    } catch (error) {
                        throw new CozeError(`Could not parse message into JSON:${message.data}`);
                    }
                }
            }
            constructor(...args){
                super(...args), this.messages = new Messages(this._client);
            }
        }
        var chat_ChatStatus = /*#__PURE__*/ function(ChatStatus) {
            ChatStatus["CREATED"] = "created";
            ChatStatus["IN_PROGRESS"] = "in_progress";
            ChatStatus["COMPLETED"] = "completed";
            ChatStatus["FAILED"] = "failed";
            ChatStatus["REQUIRES_ACTION"] = "requires_action";
            ChatStatus["CANCELED"] = "canceled";
            ChatStatus["UNKNOWN"] = "unknown";
            return ChatStatus;
        }({});
        var chat_ChatEventType = /*#__PURE__*/ function(ChatEventType) {
            ChatEventType["CONVERSATION_CHAT_CREATED"] = "conversation.chat.created";
            ChatEventType["CONVERSATION_CHAT_IN_PROGRESS"] = "conversation.chat.in_progress";
            ChatEventType["CONVERSATION_CHAT_COMPLETED"] = "conversation.chat.completed";
            ChatEventType["CONVERSATION_CHAT_FAILED"] = "conversation.chat.failed";
            ChatEventType["CONVERSATION_CHAT_REQUIRES_ACTION"] = "conversation.chat.requires_action";
            ChatEventType["CONVERSATION_MESSAGE_DELTA"] = "conversation.message.delta";
            ChatEventType["CONVERSATION_MESSAGE_COMPLETED"] = "conversation.message.completed";
            ChatEventType["CONVERSATION_AUDIO_DELTA"] = "conversation.audio.delta";
            ChatEventType["DONE"] = "done";
            ChatEventType["ERROR"] = "error";
            return ChatEventType;
        }({});
        var chat_RoleType = /*#__PURE__*/ function(RoleType) {
            RoleType["User"] = "user";
            RoleType["Assistant"] = "assistant";
            return RoleType;
        }({});
        class messages_Messages extends APIResource {
            /**
   * Create a message and add it to the specified conversation. | 创建一条消息，并将其添加到指定的会话中。
   * @docs en: https://www.coze.com/docs/developer_guides/create_message?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/create_message?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | Conversation ID，即会话的唯一标识。
   * @param params - Required The parameters for creating a message | 创建消息所需的参数
   * @param params.role - Required The entity that sent this message. Possible values: user, assistant. | 发送这条消息的实体。取值：user, assistant。
   * @param params.content - Required The content of the message. | 消息的内容。
   * @param params.content_type - Required The type of the message content. | 消息内容的类型。
   * @param params.meta_data - Optional Additional information when creating a message. | 创建消息时的附加消息。
   * @returns Information about the new message. | 消息详情。
   */ async create(conversation_id, params, options) {
                const apiUrl = `/v1/conversation/message/create?conversation_id=${conversation_id}`;
                const response = await this._client.post(apiUrl, params, false, options);
                return response.data;
            }
            /**
   * Modify a message, supporting the modification of message content, additional content, and message type. | 修改一条消息，支持修改消息内容、附加内容和消息类型。
   * @docs en: https://www.coze.com/docs/developer_guides/modify_message?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/modify_message?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | Conversation ID，即会话的唯一标识。
   * @param message_id - Required The ID of the message. | Message ID，即消息的唯一标识。
   * @param params - Required The parameters for modifying a message | 修改消息所需的参数
   * @param params.meta_data - Optional Additional information when modifying a message. | 修改消息时的附加消息。
   * @param params.content - Optional The content of the message. | 消息的内容。
   * @param params.content_type - Optional The type of the message content. | 消息内容的类型。
   * @returns Information about the modified message. | 消息详情。
   */ // eslint-disable-next-line max-params
            async update(conversation_id, message_id, params, options) {
                const apiUrl = `/v1/conversation/message/modify?conversation_id=${conversation_id}&message_id=${message_id}`;
                const response = await this._client.post(apiUrl, params, false, options);
                return response.message;
            }
            /**
   * Get the detailed information of specified message. | 查看指定消息的详细信息。
   * @docs en: https://www.coze.com/docs/developer_guides/retrieve_message?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/retrieve_message?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | Conversation ID，即会话的唯一标识。
   * @param message_id - Required The ID of the message. | Message ID，即消息的唯一标识。
   * @returns Information about the message. | 消息详情。
   */ async retrieve(conversation_id, message_id, options) {
                const apiUrl = `/v1/conversation/message/retrieve?conversation_id=${conversation_id}&message_id=${message_id}`;
                const response = await this._client.get(apiUrl, null, false, options);
                return response.data;
            }
            /**
   * List messages in a conversation. | 列出会话中的消息。
   * @docs en: https://www.coze.com/docs/developer_guides/message_list?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/message_list?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | Conversation ID，即会话的唯一标识。
   * @param params - Optional The parameters for listing messages | 列出消息所需的参数
   * @param params.order - Optional The order of the messages. | 消息的顺序。
   * @param params.chat_id - Optional The ID of the chat. | 聊天 ID。
   * @param params.before_id - Optional The ID of the message before which to list. | 列出此消息之前的消息 ID。
   * @param params.after_id - Optional The ID of the message after which to list. | 列出此消息之后的消息 ID。
   * @param params.limit - Optional The maximum number of messages to return. | 返回的最大消息数。
   * @returns A list of messages. | 消息列表。
   */ async list(conversation_id, params, options) {
                const apiUrl = `/v1/conversation/message/list?conversation_id=${conversation_id}`;
                const response = await this._client.post(apiUrl, params, false, options);
                return response;
            }
            /**
   * Call the API to delete a message within a specified conversation. | 调用接口在指定会话中删除消息。
   * @docs en: https://www.coze.com/docs/developer_guides/delete_message?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/delete_message?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | Conversation ID，即会话的唯一标识。
   * @param message_id - Required The ID of the message. | Message ID，即消息的唯一标识。
   * @returns Details of the deleted message. | 已删除的消息详情。
   */ async delete(conversation_id, message_id, options) {
                const apiUrl = `/v1/conversation/message/delete?conversation_id=${conversation_id}&message_id=${message_id}`;
                const response = await this._client.post(apiUrl, void 0, false, options);
                return response.data;
            }
        }
        class Conversations extends APIResource {
            /**
   * Create a conversation. Conversation is an interaction between an agent and a user, including one or more messages. | 调用接口创建一个会话。
   * @docs en: https://www.coze.com/docs/developer_guides/create_conversation?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/create_conversation?_lang=zh
   * @param params - Required The parameters for creating a conversation | 创建会话所需的参数
   * @param params.messages - Optional Messages in the conversation. | 会话中的消息内容。
   * @param params.meta_data - Optional Additional information when creating a message. | 创建消息时的附加消息。
   * @param params.bot_id - Optional Bind and isolate conversation on different bots. | 绑定和隔离不同Bot的会话。
   * @returns Information about the created conversation. | 会话的基础信息。
   */ async create(params, options) {
                const apiUrl = '/v1/conversation/create';
                const response = await this._client.post(apiUrl, params, false, options);
                return response.data;
            }
            /**
   * Get the information of specific conversation. | 通过会话 ID 查看会话信息。
   * @docs en: https://www.coze.com/docs/developer_guides/retrieve_conversation?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/retrieve_conversation?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | Conversation ID，即会话的唯一标识。
   * @returns Information about the conversation. | 会话的基础信息。
   */ async retrieve(conversation_id, options) {
                const apiUrl = `/v1/conversation/retrieve?conversation_id=${conversation_id}`;
                const response = await this._client.get(apiUrl, null, false, options);
                return response.data;
            }
            /**
   * List all conversations. | 列出 Bot 下所有会话。
   * @param params
   * @param params.bot_id - Required Bot ID. | Bot ID。
   * @param params.page_num - Optional The page number. | 页码，默认值为 1。
   * @param params.page_size - Optional The number of conversations per page. | 每页的会话数量，默认值为 50。
   * @returns Information about the conversations. | 会话的信息。
   */ async list(params, options) {
                const apiUrl = '/v1/conversations';
                const response = await this._client.get(apiUrl, params, false, options);
                return response.data;
            }
            /**
   * Clear a conversation. | 清空会话。
   * @param conversation_id - Required The ID of the conversation. | Conversation ID，即会话的唯一标识。
   * @returns Information about the conversation session. | 会话的会话 ID。
   */ async clear(conversation_id, options) {
                const apiUrl = `/v1/conversations/${conversation_id}/clear`;
                const response = await this._client.post(apiUrl, null, false, options);
                return response.data;
            }
            constructor(...args){
                super(...args), this.messages = new messages_Messages(this._client);
            }
        }
        // EXTERNAL MODULE: external "axios"
        var external_axios_ = __webpack_require__("axios");
        var external_axios_default = /*#__PURE__*/ __webpack_require__.n(external_axios_);
        class Files extends APIResource {
            /**
   * Upload files to Coze platform. | 调用接口上传文件到扣子。
   * @docs en: https://www.coze.com/docs/developer_guides/upload_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/upload_files?_lang=zh
   * @param params - Required The parameters for file upload | 上传文件所需的参数
   * @param params.file - Required The file to be uploaded. | 需要上传的文件。
   * @returns Information about the new file. | 已上传的文件信息。
   */ async upload(params, options) {
                const apiUrl = '/v1/files/upload';
                const response = await this._client.post(apiUrl, (0, external_axios_.toFormData)(params), false, options);
                return response.data;
            }
            /**
   * Get the information of the specific file uploaded to Coze platform. | 查看已上传的文件详情。
   * @docs en: https://www.coze.com/docs/developer_guides/retrieve_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/retrieve_files?_lang=zh
   * @param file_id - Required The ID of the uploaded file. | 已上传的文件 ID。
   * @returns Information about the uploaded file. | 已上传的文件信息。
   */ async retrieve(file_id, options) {
                const apiUrl = `/v1/files/retrieve?file_id=${file_id}`;
                const response = await this._client.get(apiUrl, null, false, options);
                return response.data;
            }
        }
        class Runs extends APIResource {
            /**
   * Initiates a workflow run. | 启动工作流运行。
   * @docs en: https://www.coze.com/docs/developer_guides/workflow_run?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/workflow_run?_lang=zh
   * @param params.workflow_id - Required The ID of the workflow to run. | 必选 要运行的工作流 ID。
   * @param params.bot_id - Optional The ID of the bot associated with the workflow. | 可选 与工作流关联的机器人 ID。
   * @param params.parameters - Optional Parameters for the workflow execution. | 可选 工作流执行的参数。
   * @param params.ext - Optional Additional information for the workflow execution. | 可选 工作流执行的附加信息。
   * @param params.execute_mode - Optional The mode in which to execute the workflow. | 可选 工作流执行的模式。
   * @param params.connector_id - Optional The ID of the connector to use for the workflow. | 可选 用于工作流的连接器 ID。
   * @param params.app_id - Optional The ID of the app.  | 可选 要进行会话聊天的 App ID
   * @returns RunWorkflowData | 工作流运行数据
   */ async create(params, options) {
                const apiUrl = '/v1/workflow/run';
                const response = await this._client.post(apiUrl, params, false, options);
                return response;
            }
            /**
   * Streams the workflow run events. | 流式传输工作流运行事件。
   * @docs en: https://www.coze.com/docs/developer_guides/workflow_stream_run?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/workflow_stream_run?_lang=zh
   * @param params.workflow_id - Required The ID of the workflow to run. | 必选 要运行的工作流 ID。
   * @param params.bot_id - Optional The ID of the bot associated with the workflow. | 可选 与工作流关联的机器人 ID。
   * @param params.parameters - Optional Parameters for the workflow execution. | 可选 工作流执行的参数。
   * @param params.ext - Optional Additional information for the workflow execution. | 可选 工作流执行的附加信息。
   * @param params.execute_mode - Optional The mode in which to execute the workflow. | 可选 工作流执行的模式。
   * @param params.connector_id - Optional The ID of the connector to use for the workflow. | 可选 用于工作流的连接器 ID。
   * @param params.app_id - Optional The ID of the app.  | 可选 要进行会话聊天的 App ID
   * @returns Stream<WorkflowEvent, { id: string; event: string; data: string }> | 工作流事件流
   */ async *stream(params, options) {
                const apiUrl = '/v1/workflow/stream_run';
                const result = await this._client.post(apiUrl, params, true, options);
                for await (const message of result)try {
                    if ("Done" === message.event) yield new WorkflowEvent(Number(message.id), "Done");
                    else yield new WorkflowEvent(Number(message.id), message.event, JSON.parse(message.data));
                } catch (error) {
                    throw new CozeError(`Could not parse message into JSON:${message.data}`);
                }
            }
            /**
   * Resumes a paused workflow run. | 恢复暂停的工作流运行。
   * @docs en: https://www.coze.com/docs/developer_guides/workflow_resume?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/workflow_resume?_lang=zh
   * @param params.workflow_id - Required The ID of the workflow to resume. | 必选 要恢复的工作流 ID。
   * @param params.event_id - Required The ID of the event to resume from. | 必选 要从中恢复的事件 ID。
   * @param params.resume_data - Required Data needed to resume the workflow. | 必选 恢复工作流所需的数据。
   * @param params.interrupt_type - Required The type of interruption to resume from. | 必选 要恢复的中断类型。
   * @returns AsyncGenerator<WorkflowEvent, { id: string; event: string; data: string }> | 工作流事件流
   */ async *resume(params, options) {
                const apiUrl = '/v1/workflow/stream_resume';
                const result = await this._client.post(apiUrl, params, true, options);
                for await (const message of result)try {
                    if ("Done" === message.event) yield new WorkflowEvent(Number(message.id), "Done");
                    else yield new WorkflowEvent(Number(message.id), message.event, JSON.parse(message.data));
                } catch (error) {
                    throw new CozeError(`Could not parse message into JSON:${message.data}`);
                }
            }
            /**
   * Get the workflow run history | 工作流异步运行后，查看执行结果
   * @docs zh: https://www.coze.cn/open/docs/developer_guides/workflow_history
   * @param workflowId - Required The ID of the workflow. | 必选 工作流 ID。
   * @param executeId - Required The ID of the workflow execution. | 必选 工作流执行 ID。
   * @returns WorkflowExecuteHistory[] | 工作流执行历史
   */ async history(workflowId, executeId, options) {
                const apiUrl = `/v1/workflows/${workflowId}/run_histories/${executeId}`;
                const response = await this._client.get(apiUrl, void 0, false, options);
                return response.data;
            }
        }
        var runs_WorkflowEventType = /*#__PURE__*/ function(WorkflowEventType) {
            // The output message from the workflow node, such as the output message from
            // the message node or end node. You can view the specific message content in data.
            WorkflowEventType["MESSAGE"] = "Message";
            // An error has occurred. You can view the error_code and error_message in data to
            // troubleshoot the issue.
            // 报错。可以在 data 中查看 error_code 和 error_message，排查问题。
            WorkflowEventType["ERROR"] = "Error";
            // End. Indicates the end of the workflow execution, where data is empty.
            // 结束。表示工作流执行结束，此时 data 为空。
            WorkflowEventType["DONE"] = "Done";
            // Interruption. Indicates the workflow has been interrupted, where the data field
            // contains specific interruption information.
            // 中断。表示工作流中断，此时 data 字段中包含具体的中断信息。
            WorkflowEventType["INTERRUPT"] = "Interrupt";
            return WorkflowEventType;
        }({});
        class WorkflowEvent {
            constructor(id, event, data){
                this.id = id;
                this.event = event;
                this.data = data;
            }
        }
        class WorkflowChat extends APIResource {
            /**
   * Execute a chat workflow. | 执行对话流
   * @docs en: https://www.coze.cn/docs/developer_guides/workflow_chat?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/workflow_chat?_lang=zh
   * @param params.workflow_id - Required The ID of the workflow to chat with. | 必选 要对话的工作流 ID。
   * @param params.additional_messages - Required Array of messages for the chat. | 必选 对话的消息数组。
   * @param params.parameters - Optional  Parameters for the workflow execution. | 必选 工作流执行的参数。
   * @param params.app_id - Optional The ID of the app. | 可选 应用 ID。
   * @param params.bot_id - Optional The ID of the bot. | 可选 Bot ID。
   * @param params.conversation_id - Optional The ID of the conversation. | 可选 会话 ID。
   * @param params.ext - Optional Additional information for the chat. | 可选 对话的附加信息。
   * @returns AsyncGenerator<StreamChatData> | 对话数据流
   */ async *stream(params, options) {
                const apiUrl = '/v1/workflows/chat';
                const payload = {
                    ...params,
                    additional_messages: handleAdditionalMessages(params.additional_messages)
                };
                const result = await this._client.post(apiUrl, payload, true, options);
                for await (const message of result)if (message.event === chat_ChatEventType.DONE) {
                    const ret = {
                        event: message.event,
                        data: '[DONE]'
                    };
                    yield ret;
                } else try {
                    const ret = {
                        event: message.event,
                        data: JSON.parse(message.data)
                    };
                    yield ret;
                } catch (error) {
                    throw new CozeError(`Could not parse message into JSON:${message.data}`);
                }
            }
        }
        class Workflows extends APIResource {
            constructor(...args){
                super(...args), this.runs = new Runs(this._client), this.chat = new WorkflowChat(this._client);
            }
        }
        class WorkSpaces extends APIResource {
            /**
   * View the list of workspaces that the current Coze user has joined. | 查看当前扣子用户加入的空间列表。
   * @docs en: https://www.coze.com/docs/developer_guides/list_workspace?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/list_workspace?_lang=zh
   * @param params.page_num - Optional The page number for paginated queries. Default is 1.
   * | 可选 分页查询时的页码。默认为 1，即从第一页数据开始返回。
   * @param params.page_size - Optional The size of pagination. Default is 10. Maximum is 50. | 可选 分页大小。默认为 10，最大为 50。
   * @returns OpenSpaceData | 工作空间列表
   */ async list(params, options) {
                const apiUrl = '/v1/workspaces';
                const response = await this._client.get(apiUrl, params, false, options);
                return safeJsonParse(response, response).data;
            }
        }
        // Required header for knowledge APIs
        const documents_headers = {
            'agw-js-conv': 'str'
        };
        class Documents extends APIResource {
            /**
   * @deprecated  The method is deprecated and will be removed in a future version. Please use 'client.datasets.documents.list' instead.
   *
   * View the file list of a specified knowledge base, which includes lists of documents, spreadsheets, or images.
   * | 调用接口查看指定知识库的内容列表，即文件、表格或图像列表。
   * @docs en: https://www.coze.com/docs/developer_guides/list_knowledge_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/list_knowledge_files?_lang=zh
   * @param params.dataset_id - Required The ID of the knowledge base. | 必选 待查看文件的知识库 ID。
   * @param params.page - Optional The page number for paginated queries. Default is 1. | 可选 分页查询时的页码。默认为 1。
   * @param params.page_size - Optional The size of pagination. Default is 10. | 可选 分页大小。默认为 10。
   * @returns ListDocumentData | 知识库文件列表
   */ list(params, options) {
                const apiUrl = '/open_api/knowledge/document/list';
                const response = this._client.get(apiUrl, params, false, mergeConfig(options, {
                    headers: documents_headers
                }));
                return response;
            }
            /**
   * @deprecated  The method is deprecated and will be removed in a future version. Please use 'client.datasets.documents.create' instead.
   *
   * Upload files to the specific knowledge. | 调用此接口向指定知识库中上传文件。
   * @docs en: https://www.coze.com/docs/developer_guides/create_knowledge_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/create_knowledge_files?_lang=zh
   * @param params.dataset_id - Required The ID of the knowledge. | 必选 知识库 ID。
   * @param params.document_bases - Required The metadata information of the files awaiting upload. | 必选 待上传文件的元数据信息。
   * @param params.chunk_strategy - Required when uploading files to a new knowledge for the first time. Chunk strategy.
   * | 向新知识库首次上传文件时必选 分段规则。
   * @returns DocumentInfo[] | 已上传文件的基本信息
   */ async create(params, options) {
                const apiUrl = '/open_api/knowledge/document/create';
                const response = await this._client.post(apiUrl, params, false, mergeConfig(options, {
                    headers: documents_headers
                }));
                return response.document_infos;
            }
            /**
   * @deprecated  The method is deprecated and will be removed in a future version. Please use 'client.datasets.documents.delete' instead.
   *
   * Delete text, images, sheets, and other files in the knowledge base, supporting batch deletion.
   * | 删除知识库中的文本、图像、表格等文件，支持批量删除。
   * @docs en: https://www.coze.com/docs/developer_guides/delete_knowledge_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/delete_knowledge_files?_lang=zh
   * @param params.document_ids - Required The list of knowledge base files to be deleted. | 必选 待删除的文件 ID。
   * @returns void | 无返回
   */ async delete(params, options) {
                const apiUrl = '/open_api/knowledge/document/delete';
                await this._client.post(apiUrl, params, false, mergeConfig(options, {
                    headers: documents_headers
                }));
            }
            /**
   * @deprecated  The method is deprecated and will be removed in a future version. Please use 'client.datasets.documents.update' instead.
   *
   * Modify the knowledge base file name and update strategy. | 调用接口修改知识库文件名称和更新策略。
   * @docs en: https://www.coze.com/docs/developer_guides/modify_knowledge_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/modify_knowledge_files?_lang=zh
   * @param params.document_id - Required The ID of the knowledge base file. | 必选 待修改的知识库文件 ID。
   * @param params.document_name - Optional The new name of the knowledge base file. | 可选 知识库文件的新名称。
   * @param params.update_rule - Optional The update strategy for online web pages. | 可选 在线网页更新策略。
   * @returns void | 无返回
   */ async update(params, options) {
                const apiUrl = '/open_api/knowledge/document/update';
                await this._client.post(apiUrl, params, false, mergeConfig(options, {
                    headers: documents_headers
                }));
            }
        }
        class Knowledge extends APIResource {
            constructor(...args){
                super(...args), /**
   * @deprecated
   */ this.documents = new Documents(this._client);
            }
        }
        // Required header for knowledge APIs
        const documents_documents_headers = {
            'agw-js-conv': 'str'
        };
        class documents_Documents extends APIResource {
            /**
   * View the file list of a specified knowledge base, which includes lists of documents, spreadsheets, or images.
   * | 调用接口查看指定知识库的内容列表，即文件、表格或图像列表。
   * @docs en: https://www.coze.com/docs/developer_guides/list_knowledge_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/list_knowledge_files?_lang=zh
   * @param params.dataset_id - Required The ID of the knowledge base. | 必选 待查看文件的知识库 ID。
   * @param params.page - Optional The page number for paginated queries. Default is 1. | 可选 分页查询时的页码。默认为 1。
   * @param params.page_size - Optional The size of pagination. Default is 10. | 可选 分页大小。默认为 10。
   * @returns ListDocumentData | 知识库文件列表
   */ async list(params, options) {
                const apiUrl = '/open_api/knowledge/document/list';
                const response = await this._client.post(apiUrl, params, false, mergeConfig(options, {
                    headers: documents_documents_headers
                }));
                return response;
            }
            /**
   * Upload files to the specific knowledge. | 调用此接口向指定知识库中上传文件。
   * @docs en: https://www.coze.com/docs/developer_guides/create_knowledge_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/create_knowledge_files?_lang=zh
   * @param params.dataset_id - Required The ID of the knowledge. | 必选 知识库 ID。
   * @param params.document_bases - Required The metadata information of the files awaiting upload. | 必选 待上传文件的元数据信息。
   * @param params.chunk_strategy - Required when uploading files to a new knowledge for the first time. Chunk strategy.
   * | 向新知识库首次上传文件时必选 分段规则。
   * @returns DocumentInfo[] | 已上传文件的基本信息
   */ async create(params, options) {
                const apiUrl = '/open_api/knowledge/document/create';
                const response = await this._client.post(apiUrl, params, false, mergeConfig(options, {
                    headers: documents_documents_headers
                }));
                return response.document_infos;
            }
            /**
   * Delete text, images, sheets, and other files in the knowledge base, supporting batch deletion.
   * | 删除知识库中的文本、图像、表格等文件，支持批量删除。
   * @docs en: https://www.coze.com/docs/developer_guides/delete_knowledge_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/delete_knowledge_files?_lang=zh
   * @param params.document_ids - Required The list of knowledge base files to be deleted. | 必选 待删除的文件 ID。
   * @returns void | 无返回
   */ async delete(params, options) {
                const apiUrl = '/open_api/knowledge/document/delete';
                await this._client.post(apiUrl, params, false, mergeConfig(options, {
                    headers: documents_documents_headers
                }));
            }
            /**
   * Modify the knowledge base file name and update strategy. | 调用接口修改知识库文件名称和更新策略。
   * @docs en: https://www.coze.com/docs/developer_guides/modify_knowledge_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/modify_knowledge_files?_lang=zh
   * @param params.document_id - Required The ID of the knowledge base file. | 必选 待修改的知识库文件 ID。
   * @param params.document_name - Optional The new name of the knowledge base file. | 可选 知识库文件的新名称。
   * @param params.update_rule - Optional The update strategy for online web pages. | 可选 在线网页更新策略。
   * @returns void | 无返回
   */ async update(params, options) {
                const apiUrl = '/open_api/knowledge/document/update';
                await this._client.post(apiUrl, params, false, mergeConfig(options, {
                    headers: documents_documents_headers
                }));
            }
        }
        class Images extends APIResource {
            /**
   * Update the description of an image in the knowledge base | 更新知识库中的图片描述
   * @docs en: https://www.coze.com/docs/developer_guides/developer_guides/update_image_caption?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/developer_guides/update_image_caption?_lang=zh
   * @param datasetId - The ID of the dataset | 必选 知识库 ID
   * @param documentId - The ID of the document | 必选 知识库文件 ID
   * @param params - The parameters for updating the image
   * @param params.caption - Required. The description of the image | 必选 图片的描述信息
   * @returns undefined
   */ // eslint-disable-next-line max-params
            async update(datasetId, documentId, params, options) {
                const apiUrl = `/v1/datasets/${datasetId}/images/${documentId}`;
                await this._client.put(apiUrl, params, false, options);
            }
            /**
   * List images in the knowledge base | 列出知识库中的图片
   * @docs en: https://www.coze.com/docs/developer_guides/developer_guides/get_images?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/developer_guides/get_images?_lang=zh
   * @param datasetId - The ID of the dataset | 必选 知识库 ID
   * @param params - The parameters for listing images
   * @param params.page_num - Optional. Page number for pagination, minimum value is 1, defaults to 1 | 可选 分页查询时的页码。默认为 1。
   * @param params.page_size - Optional. Number of items per page, range 1-299, defaults to 10 | 可选 分页大小。默认为 10。
   * @param params.keyword - Optional. Search keyword for image descriptions | 可选 图片描述的搜索关键词。
   * @param params.has_caption - Optional. Filter for images with/without captions | 可选 是否过滤有/无描述的图片。
   */ async list(datasetId, params, options) {
                const apiUrl = `/v1/datasets/${datasetId}/images`;
                const response = await this._client.get(apiUrl, params, false, options);
                return response.data;
            }
        }
        class Datasets extends APIResource {
            /**
   * Creates a new dataset | 创建数据集
   * @docs en: https://www.coze.com/docs/developer_guides/create_dataset?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/create_dataset?_lang=zh
   * @param params - The parameters for creating a dataset
   * @param {string} params.name - Required. Dataset name, maximum length of 100 characters | 必选 数据集名称，最大长度为 100 个字符
   * @param {string} params.space_id - Required. Space ID where the dataset belongs | 必选 数据集所属的空间 ID
   * @param {number} params.format_type - Required. Dataset type (0: Text type, 2: Image type) | 必选 数据集类型 (0: 文本类型, 2: 图片类型)
   * @param {string} [params.description] - Optional. Dataset description | 可选 数据集描述
   * @param {string} [params.file_id] - Optional. Dataset icon file ID from file upload
   */ async create(params, options) {
                const apiUrl = '/v1/datasets';
                const response = await this._client.post(apiUrl, params, false, options);
                return response.data;
            }
            /**
   * Lists all datasets in a space | 列出空间中的所有数据集
   * @docs en: https://www.coze.com/docs/developer_guides/list_dataset?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/list_dataset?_lang=zh
   * @param params - The parameters for listing datasets | 列出数据集的参数
   * @param {string} params.space_id - Required. Space ID where the datasets belong | 必选 数据集所属的空间 ID
   * @param {string} [params.name] - Optional. Dataset name for fuzzy search | 可选 数据集名称用于模糊搜索
   * @param {number} [params.format_type] - Optional. Dataset type (0: Text type, 2: Image type) | 可选 数据集类型 (0: 文本类型, 2: 图片类型)
   * @param {number} [params.page_num] - Optional. Page number for pagination (default: 1) | 可选 分页查询时的页码。默认为 1。
   * @param {number} [params.page_size] - Optional. Number of items per page (default: 10) | 可选 分页大小。默认为 10。
   */ async list(params, options) {
                const apiUrl = '/v1/datasets';
                const response = await this._client.get(apiUrl, params, false, options);
                return response.data;
            }
            /**
   * Updates a dataset | 更新数据集
   * @docs en: https://www.coze.com/docs/developer_guides/update_dataset?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/update_dataset?_lang=zh
   * @param dataset_id - Required. The ID of the dataset to update | 必选 数据集 ID
   * @param params - Required. The parameters for updating the dataset | 必选 更新数据集的参数
   * @param params.name - Required. Dataset name, maximum length of 100 characters. | 必选 数据集名称，最大长度为 100 个字符。
   * @param params.file_id - Optional. Dataset icon, should pass the file_id obtained from the file upload interface. | 可选 数据集图标，应传递从文件上传接口获取的 file_id。
   * @param params.description - Optional. Dataset description. | 可选 数据集描述。
   */ async update(dataset_id, params, options) {
                const apiUrl = `/v1/datasets/${dataset_id}`;
                await this._client.put(apiUrl, params, false, options);
            }
            /**
   * Deletes a dataset | 删除数据集
   * @docs en: https://www.coze.com/docs/developer_guides/delete_dataset?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/delete_dataset?_lang=zh
   * @param dataset_id - Required. The ID of the dataset to delete | 必选 数据集 ID
   */ async delete(dataset_id, options) {
                const apiUrl = `/v1/datasets/${dataset_id}`;
                await this._client.delete(apiUrl, false, options);
            }
            /**
   * Views the progress of dataset upload | 查看数据集上传进度
   * @docs en: https://www.coze.com/docs/developer_guides/get_dataset_progress?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/get_dataset_progress?_lang=zh
   * @param dataset_id - Required. The ID of the dataset to process | 必选 数据集 ID
   * @param params - Required. The parameters for processing the dataset | 必选 处理数据集的参数
   * @param params.dataset_ids - Required. List of dataset IDs | 必选 数据集 ID 列表
   */ async process(dataset_id, params, options) {
                const apiUrl = `/v1/datasets/${dataset_id}/process`;
                const response = await this._client.post(apiUrl, params, false, options);
                return response.data;
            }
            constructor(...args){
                super(...args), this.documents = new documents_Documents(this._client), this.images = new Images(this._client);
            }
        }
        class Voices extends APIResource {
            /**
   * @description Clone a voice | 音色克隆
   * @param params
   * @param params.voice_name - Required. Voice name, cannot be empty and must be longer than 6 characters
   * | 复刻的音色名称，不能为空，长度大于 6
   * @param params.file - Required. Audio file | 音频文件
   * @param params.audio_format - Required. Only supports "wav", "mp3", "ogg", "m4a", "aac", "pcm" formats
   * | 只支持 "wav", "mp3", "ogg", "m4a", "aac", "pcm" 格式
   * @param params.language - Optional. Only supports "zh", "en" "ja" "es" "id" "pt" languages
   * | 只支持 "zh", "en" "ja" "es" "id" "pt" 语种
   * @param params.voice_id - Optional. If provided, will train on existing voice and override previous training
   * | 传入的话就会在原有的音色上去训练，覆盖前面训练好的音色
   * @param params.preview_text - Optional. If provided, will generate preview audio based on this text, otherwise uses default text
   * | 如果传入会基于该文本生成预览音频，否则使用默认的文本
   * @param params.text - Optional. Users can read this text, service will compare audio with text. Returns error if difference is too large
   * | 可以让用户按照该文本念诵，服务会对比音频与该文本的差异。若差异过大会返回错误
   * @param params.space_id - Optional.  The space id of the voice. | 空间ID
   * @param params.description- Optional. The description of the voice. | 音色描述
   * @param options - Request options
   * @returns Clone voice data
   */ async clone(params, options) {
                const apiUrl = '/v1/audio/voices/clone';
                const response = await this._client.post(apiUrl, (0, external_axios_.toFormData)(params), false, options);
                return response.data;
            }
            /**
   * @description List voices | 获取音色列表
   * @param params
   * @param params.filter_system_voice - Optional. Whether to filter system voices, default is false
   * | 是否过滤系统音色, 默认不过滤
   * @param params.page_num - Optional. Starts from 1 by default, value must be > 0
   * | 不传默认从 1 开始，传值需要 > 0
   * @param params.page_size - Optional. Default is 100, value must be (0, 100]
   * | 不传默认 100，传值需要 (0, 100]
   * @param params.model_type - Optional. The type of the voice model, if not filled, all will be returned.
   * @param options - Request options
   * @returns List voices data
   */ async list(params, options) {
                const apiUrl = '/v1/audio/voices';
                const response = await this._client.get(apiUrl, params, false, options);
                return response.data;
            }
        }
        class Transcriptions extends APIResource {
            /**
   * ASR voice to text | ASR 语音转文本
   * @param params - Required The parameters for file upload | 上传文件所需的参数
   * @param params.file - Required The audio file to be uploaded. | 需要上传的音频文件。
   */ async create(params, options) {
                const apiUrl = '/v1/audio/transcriptions';
                const response = await this._client.post(apiUrl, (0, external_axios_.toFormData)(params), false, options);
                return response.data;
            }
        }
        class Speech extends APIResource {
            /**
   * @description Speech synthesis | 语音合成
   * @param params
   * @param params.input - Required. Text to generate audio | 要为其生成音频的文本
   * @param params.voice_id - Required. Voice ID | 生成音频的音色 ID
   * @param params.response_format - Optional. Audio encoding format,
   * supports "wav", "pcm", "ogg", "opus", "mp3", default is "mp3"
   * | 音频编码格式，支持 "wav", "pcm", "ogg", "opus", "mp3"，默认是 "mp3"
   * @param options - Request options
   * @returns Speech synthesis data
   */ async create(params, options) {
                const apiUrl = '/v1/audio/speech';
                const response = await this._client.post(apiUrl, {
                    ...params,
                    sample_rate: params.sample_rate || 24000
                }, false, mergeConfig(options, {
                    responseType: 'arraybuffer'
                }));
                return response;
            }
        }
        class Rooms extends APIResource {
            async create(params, options) {
                const apiUrl = '/v1/audio/rooms';
                const response = await this._client.post(apiUrl, params, false, options);
                return response.data;
            }
        }
        var rooms_RoomMode = /*#__PURE__*/ function(RoomMode) {
            RoomMode["Default"] = "default";
            RoomMode["S2S"] = "s2s";
            RoomMode["Podcast"] = "podcast";
            return RoomMode;
        }({});
        class VoiceprintFeature extends APIResource {
            /**
   * Create voiceprint feature
   */ async create(groupId, params, options) {
                const apiUrl = `/v1/audio/voiceprint_groups/${groupId}/features`;
                const response = await this._client.post(apiUrl, (0, external_axios_.toFormData)(params), false, options);
                return response.data;
            }
            /**
   * Update voiceprint feature
   */ // eslint-disable-next-line max-params
            async update(groupId, featureId, params, options) {
                const apiUrl = `/v1/audio/voiceprint_groups/${groupId}/features/${featureId}`;
                const response = await this._client.put(apiUrl, (0, external_axios_.toFormData)(params), false, options);
                return response.data;
            }
            /**
   * Delete voiceprint feature
   */ async delete(groupId, featureId, options) {
                const apiUrl = `/v1/audio/voiceprint_groups/${groupId}/features/${featureId}`;
                const response = await this._client.delete(apiUrl, false, options);
                return response.data;
            }
            /**
   * Get voiceprint feature list
   */ async list(groupId, params, options) {
                const apiUrl = `/v1/audio/voiceprint_groups/${groupId}/features`;
                const response = await this._client.get(apiUrl, params, false, options);
                return response.data;
            }
            /**
   * Speaker identification
   */ async speakerIdentify(groupId, params, options) {
                const apiUrl = `/v1/audio/voiceprint_groups/${groupId}/speaker_identify`;
                const response = await this._client.post(apiUrl, (0, external_axios_.toFormData)(params), false, options);
                return response.data;
            }
        }
        class VoiceprintGroups extends APIResource {
            /**
   * Create voiceprint group
   */ async create(params, options) {
                const apiUrl = '/v1/audio/voiceprint_groups';
                const response = await this._client.post(apiUrl, params, false, options);
                return response.data;
            }
            /**
   * Get voiceprint group list
   */ async list(params, options) {
                const apiUrl = '/v1/audio/voiceprint_groups';
                const response = await this._client.get(apiUrl, params, false, options);
                return response.data;
            }
            /**
   * Update voiceprint group
   */ async update(groupId, params, options) {
                const apiUrl = `/v1/audio/voiceprint_groups/${groupId}`;
                const response = await this._client.put(apiUrl, params, false, options);
                return response.data;
            }
            /**
   * Delete voiceprint group
   */ async delete(groupId, options) {
                const apiUrl = `/v1/audio/voiceprint_groups/${groupId}`;
                const response = await this._client.delete(apiUrl, false, options);
                return response.data;
            }
            constructor(...args){
                super(...args), this.features = new VoiceprintFeature(this._client);
            }
        }
        class Audio extends APIResource {
            constructor(...args){
                super(...args), this.rooms = new Rooms(this._client), this.voices = new Voices(this._client), this.speech = new Speech(this._client), this.transcriptions = new Transcriptions(this._client), this.voiceprintGroups = new VoiceprintGroups(this._client);
            }
        }
        class Templates extends APIResource {
            /**
   * Duplicate a template. | 复制一个模板。
   * @param templateId - Required. The ID of the template to duplicate. | 要复制的模板的 ID。
   * @param params - Optional. The parameters for the duplicate operation. | 可选参数，用于复制操作。
   * @param params.workspace_id - Required. The ID of the workspace to duplicate the template into. | 要复制到的目标工作空间的 ID。
   * @param params.name - Optional. The name of the new template. | 新模板的名称。
   * @returns TemplateDuplicateRes | 复制模板结果
   */ async duplicate(templateId, params, options) {
                const apiUrl = `/v1/templates/${templateId}/duplicate`;
                const response = await this._client.post(apiUrl, params, false, options);
                return response.data;
            }
        }
        var templates_TemplateEntityType = /*#__PURE__*/ function(TemplateEntityType) {
            TemplateEntityType["AGENT"] = "agent";
            return TemplateEntityType;
        }({});
        class chat_Chat extends APIResource {
            async create(req, options) {
                const apiUrl = buildWebsocketUrl('/v1/chat', req);
                return await this._client.makeWebsocket(apiUrl, options);
            }
        }
        class transcriptions_Transcriptions extends APIResource {
            async create(req, options) {
                const apiUrl = buildWebsocketUrl('/v1/audio/transcriptions', req);
                return await this._client.makeWebsocket(apiUrl, options);
            }
        }
        class speech_Speech extends APIResource {
            async create(req, options) {
                const apiUrl = buildWebsocketUrl('/v1/audio/speech', req);
                return await this._client.makeWebsocket(apiUrl, options);
            }
        }
        class SimultInterpretation extends APIResource {
            async create(options) {
                const apiUrl = '/v1/audio/simult_interpretation';
                return await this._client.makeWebsocket(apiUrl, options);
            }
        }
        class audio_Audio extends APIResource {
            constructor(...args){
                super(...args), this.speech = new speech_Speech(this._client), this.transcriptions = new transcriptions_Transcriptions(this._client), this.simultInterpretation = new SimultInterpretation(this._client);
            }
        }
        // Common types (not exported)
        // Keep all existing exports but use the base types where applicable
        var types_WebsocketsEventType = /*#__PURE__*/ function(WebsocketsEventType) {
            // Common
            /** SDK error */ WebsocketsEventType["CLIENT_ERROR"] = "client_error";
            /** Connection closed */ WebsocketsEventType["CLOSED"] = "closed";
            /** All events */ WebsocketsEventType["ALL"] = "all";
            // Error
            /** Received error event */ WebsocketsEventType["ERROR"] = "error";
            // v1/audio/speech
            /** Send text to server */ WebsocketsEventType["INPUT_TEXT_BUFFER_APPEND"] = "input_text_buffer.append";
            /** No text to send, after audio all received, can close connection */ WebsocketsEventType["INPUT_TEXT_BUFFER_COMPLETE"] = "input_text_buffer.complete";
            /** Send speech config to server */ WebsocketsEventType["SPEECH_UPDATE"] = "speech.update";
            /** Received `speech.updated` event */ WebsocketsEventType["SPEECH_UPDATED"] = "speech.updated";
            /** After speech created */ WebsocketsEventType["SPEECH_CREATED"] = "speech.created";
            /** Received `input_text_buffer.complete` event */ WebsocketsEventType["INPUT_TEXT_BUFFER_COMPLETED"] = "input_text_buffer.completed";
            /** Received `speech.update` event */ WebsocketsEventType["SPEECH_AUDIO_UPDATE"] = "speech.audio.update";
            /** All audio received, can close connection */ WebsocketsEventType["SPEECH_AUDIO_COMPLETED"] = "speech.audio.completed";
            // v1/audio/transcriptions
            /** Send audio to server */ WebsocketsEventType["INPUT_AUDIO_BUFFER_APPEND"] = "input_audio_buffer.append";
            /** No audio to send, after text all received, can close connection */ WebsocketsEventType["INPUT_AUDIO_BUFFER_COMPLETE"] = "input_audio_buffer.complete";
            /** Send transcriptions config to server */ WebsocketsEventType["TRANSCRIPTIONS_UPDATE"] = "transcriptions.update";
            /** Send `input_audio_buffer.clear` event */ WebsocketsEventType["INPUT_AUDIO_BUFFER_CLEAR"] = "input_audio_buffer.clear";
            /** After transcriptions created */ WebsocketsEventType["TRANSCRIPTIONS_CREATED"] = "transcriptions.created";
            /** Received `input_audio_buffer.complete` event */ WebsocketsEventType["INPUT_AUDIO_BUFFER_COMPLETED"] = "input_audio_buffer.completed";
            /** Received `transcriptions.update` event */ WebsocketsEventType["TRANSCRIPTIONS_MESSAGE_UPDATE"] = "transcriptions.message.update";
            /** All audio received, can close connection */ WebsocketsEventType["TRANSCRIPTIONS_MESSAGE_COMPLETED"] = "transcriptions.message.completed";
            /** Received `input_audio_buffer.cleared` event */ WebsocketsEventType["INPUT_AUDIO_BUFFER_CLEARED"] = "input_audio_buffer.cleared";
            /** Received `transcriptions.updated` event */ WebsocketsEventType["TRANSCRIPTIONS_UPDATED"] = "transcriptions.updated";
            // v1/chat
            /** Send chat config to server */ WebsocketsEventType["CHAT_UPDATE"] = "chat.update";
            /** Send tool outputs to server */ WebsocketsEventType["CONVERSATION_CHAT_SUBMIT_TOOL_OUTPUTS"] = "conversation.chat.submit_tool_outputs";
            /** After chat created */ WebsocketsEventType["CHAT_CREATED"] = "chat.created";
            /** After chat updated */ WebsocketsEventType["CHAT_UPDATED"] = "chat.updated";
            /** Audio AST completed, chat started */ WebsocketsEventType["CONVERSATION_CHAT_CREATED"] = "conversation.chat.created";
            /** Message created */ WebsocketsEventType["CONVERSATION_MESSAGE_CREATE"] = "conversation.message.create";
            /** Clear conversation */ WebsocketsEventType["CONVERSATION_CLEAR"] = "conversation.clear";
            /** Chat in progress */ WebsocketsEventType["CONVERSATION_CHAT_IN_PROGRESS"] = "conversation.chat.in_progress";
            /** Get agent text message update */ WebsocketsEventType["CONVERSATION_MESSAGE_DELTA"] = "conversation.message.delta";
            /** Need plugin submit */ WebsocketsEventType["CONVERSATION_CHAT_REQUIRES_ACTION"] = "conversation.chat.requires_action";
            /** Message completed */ WebsocketsEventType["CONVERSATION_MESSAGE_COMPLETED"] = "conversation.message.completed";
            /** Get agent audio message update */ WebsocketsEventType["CONVERSATION_AUDIO_DELTA"] = "conversation.audio.delta";
            /** Audio message completed */ WebsocketsEventType["CONVERSATION_AUDIO_COMPLETED"] = "conversation.audio.completed";
            /** All message received, can close connection */ WebsocketsEventType["CONVERSATION_CHAT_COMPLETED"] = "conversation.chat.completed";
            /** Chat failed */ WebsocketsEventType["CONVERSATION_CHAT_FAILED"] = "conversation.chat.failed";
            /** Received `conversation.cleared` event */ WebsocketsEventType["CONVERSATION_CLEARED"] = "conversation.cleared";
            /** Speech started */ WebsocketsEventType["INPUT_AUDIO_BUFFER_SPEECH_STARTED"] = "input_audio_buffer.speech_started";
            /** Speech stopped */ WebsocketsEventType["INPUT_AUDIO_BUFFER_SPEECH_STOPPED"] = "input_audio_buffer.speech_stopped";
            /** Chat interrupted by client */ WebsocketsEventType["CONVERSATION_CHAT_CANCEL"] = "conversation.chat.cancel";
            /** Chat canceled */ WebsocketsEventType["CONVERSATION_CHAT_CANCELED"] = "conversation.chat.canceled";
            /** Audio transcript update */ WebsocketsEventType["CONVERSATION_AUDIO_TRANSCRIPT_UPDATE"] = "conversation.audio_transcript.update";
            /** Audio transcript completed */ WebsocketsEventType["CONVERSATION_AUDIO_TRANSCRIPT_COMPLETED"] = "conversation.audio_transcript.completed";
            /** Audio sentence start */ WebsocketsEventType["CONVERSATION_AUDIO_SENTENCE_START"] = "conversation.audio.sentence_start";
            /** Audio dump */ WebsocketsEventType["DUMP_AUDIO"] = "dump.audio";
            // v1/audio/simult_interpretation
            WebsocketsEventType["SIMULT_INTERPRETATION_UPDATE"] = "simult_interpretation.update";
            WebsocketsEventType["SIMULT_INTERPRETATION_CREATED"] = "simult_interpretation.created";
            WebsocketsEventType["SIMULT_INTERPRETATION_UPDATED"] = "simult_interpretation.updated";
            WebsocketsEventType["SIMULT_INTERPRETATION_AUDIO_DELTA"] = "simult_interpretation.audio.delta";
            WebsocketsEventType["SIMULT_INTERPRETATION_TRANSCRIPTION_DELTA"] = "simult_interpretation.transcription.delta";
            WebsocketsEventType["SIMULT_INTERPRETATION_TRANSLATION_DELTA"] = "simult_interpretation.translation.delta";
            WebsocketsEventType["SIMULT_INTERPRETATION_MESSAGE_COMPLETED"] = "simult_interpretation.message.completed";
            return WebsocketsEventType;
        }({});
        class Websockets extends APIResource {
            constructor(...args){
                super(...args), this.audio = new audio_Audio(this._client), this.chat = new chat_Chat(this._client);
            }
        }
        class Variables extends APIResource {
            /**
   * Set values for user variables
   * @docs en: https://www.coze.com/open/docs/developer_guides/update_variable
   * @docs zh: https://www.coze.cn/open/docs/developer_guides/update_variable
   * @param params - The parameters for the variable update
   * @param options - Optional request options
   */ async update(params, options) {
                const apiUrl = '/v1/variables';
                await this._client.put(apiUrl, params, false, options);
            }
            /**
   * Get the values of user variables
   * @docs en: https://www.coze.com/open/docs/developer_guides/read_variable
   * @docs zh: https://www.coze.cn/open/docs/developer_guides/read_variable
   * @param params - The parameters for the variable retrieval
   * @param options - Optional request options
   */ async retrieve(params, options) {
                const apiUrl = '/v1/variables';
                const response = await this._client.get(apiUrl, params, false, options);
                return response.data;
            }
        }
        /**
 * Users client for interacting with user-related APIs
 */ class Users extends APIResource {
            /**
   * Get information about the authenticated user.
   * @param options - Optional request configuration options.
   * @returns Information about the authenticated user.
   */ async me(options) {
                const apiUrl = '/v1/users/me';
                const result = await this._client.get(apiUrl, void 0, false, options);
                return result.data;
            }
        }
        // EXTERNAL MODULE: external "ws"
        var external_ws_ = __webpack_require__("ws");
        var external_ws_default = /*#__PURE__*/ __webpack_require__.n(external_ws_);
        // EXTERNAL MODULE: external "reconnecting-websocket"
        var external_reconnecting_websocket_ = __webpack_require__("reconnecting-websocket");
        var external_reconnecting_websocket_default = /*#__PURE__*/ __webpack_require__.n(external_reconnecting_websocket_);
        class WebSocketAPI {
            // Standard WebSocket properties
            get readyState() {
                return this.rws.readyState;
            }
            // Standard WebSocket methods
            send(data) {
                return this.rws.send(JSON.stringify(data));
            }
            close(code, reason) {
                return this.rws.close(code, reason);
            }
            reconnect(code, reason) {
                return this.rws.reconnect(code, reason);
            }
            // Event listener methods
            addEventListener(type, listener) {
                this.rws.addEventListener(type, listener);
            }
            removeEventListener(type, listener) {
                this.rws.removeEventListener(type, listener);
            }
            constructor(url, options = {}){
                // Event handler methods
                this.onmessage = null;
                this.onopen = null;
                this.onclose = null;
                this.onerror = null;
                const separator = url.includes('?') ? '&' : '?';
                const { authorization } = options.headers || {};
                // Get the appropriate WebSocket implementation
                let WebSocketImpl;
                if (isUniApp()) {
                    // Use MiniApp WebSocket implementation
                    const factory = 'function' == typeof getMiniAppWebSocketFactory ? getMiniAppWebSocketFactory() : null;
                    WebSocketImpl = factory ? factory.getWebSocketImplementation() : window.WebSocket;
                } else // Use browser's native WebSocket
                WebSocketImpl = isBrowser() ? window.WebSocket : class extends external_ws_default() {
                    constructor(url2, protocols){
                        super(url2, protocols, {
                            headers: options.headers
                        });
                    }
                };
                this.rws = new (external_reconnecting_websocket_default())(`${url}${separator}authorization=${authorization}`, [], {
                    WebSocket: WebSocketImpl,
                    ...options
                });
                this.rws.addEventListener('message', (event)=>{
                    try {
                        var _this_onmessage, _this;
                        const data = JSON.parse(event.data);
                        null === (_this_onmessage = (_this = this).onmessage) || void 0 === _this_onmessage || _this_onmessage.call(_this, data, event);
                    } catch (error) {
                        console.error('WebSocketAPI onmessage error', error);
                    }
                });
                this.rws.addEventListener('open', (event)=>{
                    var _this_onopen, _this;
                    null === (_this_onopen = (_this = this).onopen) || void 0 === _this_onopen || _this_onopen.call(_this, event);
                });
                this.rws.addEventListener('close', (event)=>{
                    var _this_onclose, _this;
                    null === (_this_onclose = (_this = this).onclose) || void 0 === _this_onclose || _this_onclose.call(_this, event);
                });
                this.rws.addEventListener('error', (event)=>{
                    var _event_target__req_res, _event_target__req, _event_target, _event_target__req_res1, _event_target__req1, _event_target1, _this_onerror, _this;
                    const { readyState } = this.rws;
                    if (3 === readyState) return;
                    const statusCode = null === (_event_target = event.target) || void 0 === _event_target ? void 0 : null === (_event_target__req = _event_target._req) || void 0 === _event_target__req ? void 0 : null === (_event_target__req_res = _event_target__req.res) || void 0 === _event_target__req_res ? void 0 : _event_target__req_res.statusCode;
                    const rawHeaders = (null === (_event_target1 = event.target) || void 0 === _event_target1 ? void 0 : null === (_event_target__req1 = _event_target1._req) || void 0 === _event_target__req1 ? void 0 : null === (_event_target__req_res1 = _event_target__req1.res) || void 0 === _event_target__req_res1 ? void 0 : _event_target__req_res1.rawHeaders) || [];
                    const logidIndex = rawHeaders.findIndex((header)=>'X-Tt-Logid' === header);
                    const logid = -1 !== logidIndex ? rawHeaders[logidIndex + 1] : void 0;
                    const error = {
                        id: '0',
                        event_type: types_WebsocketsEventType.ERROR,
                        data: {
                            code: -1,
                            msg: 'WebSocket error'
                        },
                        detail: {
                            logid
                        }
                    };
                    if (401 === statusCode) {
                        error.data.code = 401;
                        error.data.msg = 'Unauthorized';
                    } else if (403 === statusCode) {
                        error.data.code = 403;
                        error.data.msg = 'Forbidden';
                    } else {
                        error.data.code = 500;
                        var _event_error;
                        error.data.msg = String(null !== (_event_error = null == event ? void 0 : event.error) && void 0 !== _event_error ? _event_error : '') || 'WebSocket error';
                    }
                    null === (_this_onerror = (_this = this).onerror) || void 0 === _this_onerror || _this_onerror.call(_this, error, event);
                });
            }
        }
        // EXTERNAL MODULE: external "os"
        var external_os_ = __webpack_require__("os");
        var external_os_default = /*#__PURE__*/ __webpack_require__.n(external_os_);
        var package_namespaceObject = JSON.parse('{"name":"@coze/api","version":"1.3.2","description":"Official Coze Node.js SDK for seamless AI integration into your applications | 扣子官方 Node.js SDK，助您轻松集成 AI 能力到应用中","keywords":["coze","ai","nodejs","sdk","chatbot","typescript"],"homepage":"https://github.com/coze-dev/coze-js/tree/main/packages/coze-js","bugs":{"url":"https://github.com/coze-dev/coze-js/issues"},"repository":{"type":"git","url":"https://github.com/coze-dev/coze-js.git","directory":"packages/coze-js"},"license":"MIT","author":"Leeight <leeight@gmail.com>","exports":{".":"./src/index.ts","./ws-tools":"./src/ws-tools/index.ts"},"main":"src/index.ts","unpkg":"dist/umd/index.js","module":"src/index.ts","browser":{"crypto":false,"os":false,"jsonwebtoken":false,"node-fetch":false,"ws":false},"typesVersions":{"*":{".":["dist/types/index.d.ts"],"ws-tools":["dist/types/ws-tools/ws-tools/index.d.ts"]}},"files":["dist","LICENSE","README.md","README.zh-CN.md"],"scripts":{"build":"rslib build","format":"prettier --write .","lint":"eslint ./ --cache --quiet","start":"rslib build -w","test":"vitest","test:cov":"vitest --coverage --run"},"dependencies":{"agora-extension-ai-denoiser":"^1.0.0","agora-rtc-sdk-ng":"4.23.2-1","agora-rte-extension":"^1.2.4","jsonwebtoken":"^9.0.2","node-fetch":"^2.x","opus-encdec":"^0.1.1","reconnecting-websocket":"^4.4.0","uuid":"^10.0.0","ws":"^8.11.0"},"devDependencies":{"@coze-infra/eslint-config":"workspace:*","@coze-infra/ts-config":"workspace:*","@coze-infra/vitest-config":"workspace:*","@rslib/core":"0.0.18","@swc/core":"^1.3.14","@types/jsonwebtoken":"^9.0.0","@types/node":"^20","@types/node-fetch":"^2.x","@types/uuid":"^9.0.1","@types/whatwg-fetch":"^0.0.33","@types/ws":"^8.5.1","@vitest/coverage-v8":"~2.1.9","axios":"^1.7.7","typescript":"^5.5.3","vitest":"~2.1.9"},"peerDependencies":{"axios":"^1.7.1"},"publishConfig":{"access":"public","registry":"https://registry.npmjs.org"},"cozePublishConfig":{"exports":{".":{"require":"./dist/cjs/index.js","import":"./dist/esm/index.mjs","types":"./dist/types/index.d.ts"},"./ws-tools":{"require":"./dist/cjs/ws-tools/index.js","import":"./dist/esm/ws-tools/index.mjs","types":"./dist/types/ws-tools/ws-tools/index.d.ts"}},"main":"dist/cjs/index.js","module":"dist/esm/index.mjs","types":"dist/types/index.d.ts"},"overrides":{"agora-extension-ai-denoiser":{"agora-rtc-sdk-ng":"$agora-rtc-sdk-ng"}}}'); // CONCATENATED MODULE: ./src/version.ts
        const { version: version_version } = package_namespaceObject;
        const getEnv = ()=>{
            const nodeVersion = process.version.slice(1); // Remove 'v' prefix
            const { platform } = process;
            let osName = platform.toLowerCase();
            let osVersion = external_os_default().release();
            if ('darwin' === platform) {
                osName = 'macos';
                // Try to parse the macOS version
                try {
                    const darwinVersion = external_os_default().release().split('.');
                    if (darwinVersion.length >= 2) {
                        const majorVersion = parseInt(darwinVersion[0], 10);
                        if (!isNaN(majorVersion) && majorVersion >= 9) {
                            const macVersion = majorVersion - 9;
                            osVersion = `10.${macVersion}.${darwinVersion[1]}`;
                        }
                    }
                } catch (error) {
                // Keep the default os.release() value if parsing fails
                }
            } else if ('win32' === platform) {
                osName = 'windows';
                osVersion = external_os_default().release();
            } else if ('linux' === platform) {
                osName = 'linux';
                osVersion = external_os_default().release();
            }
            return {
                osName,
                osVersion,
                nodeVersion
            };
        };
        const getUserAgent = ()=>{
            const { nodeVersion, osName, osVersion } = getEnv();
            return `coze-js/${version_version} node/${nodeVersion} ${osName}/${osVersion}`.toLowerCase();
        };
        const getNodeClientUserAgent = ()=>{
            const { osVersion, nodeVersion, osName } = getEnv();
            const ua = {
                version: version_version,
                lang: 'node',
                lang_version: nodeVersion,
                os_name: osName,
                os_version: osVersion
            };
            return JSON.stringify(ua);
        };
        const getBrowserClientUserAgent = ()=>{
            const browserInfo = {
                name: 'unknown',
                version: 'unknown'
            };
            const osInfo = {
                name: 'unknown',
                version: 'unknown'
            };
            const { userAgent } = navigator;
            if (userAgent) {
                // 检测操作系统及版本
                if (userAgent.indexOf('Windows') > -1) {
                    var _userAgent_match;
                    osInfo.name = 'windows';
                    const windowsVersion = (null === (_userAgent_match = userAgent.match(/Windows NT ([0-9.]+)/)) || void 0 === _userAgent_match ? void 0 : _userAgent_match[1]) || 'unknown';
                    osInfo.version = windowsVersion;
                } else if (userAgent.indexOf('Mac OS X') > -1) {
                    var _userAgent_match1;
                    osInfo.name = 'macos';
                    // 将 10_15_7 格式转换为 10.15.7
                    osInfo.version = ((null === (_userAgent_match1 = userAgent.match(/Mac OS X ([0-9_]+)/)) || void 0 === _userAgent_match1 ? void 0 : _userAgent_match1[1]) || 'unknown').replace(/_/g, '.');
                } else if (userAgent.indexOf('Linux') > -1) {
                    var _userAgent_match2;
                    osInfo.name = 'linux';
                    osInfo.version = (null === (_userAgent_match2 = userAgent.match(/Linux ([0-9.]+)/)) || void 0 === _userAgent_match2 ? void 0 : _userAgent_match2[1]) || 'unknown';
                }
                // 检测浏览器及版本
                if (userAgent.indexOf('Chrome') > -1) {
                    var _userAgent_match3;
                    browserInfo.name = 'chrome';
                    browserInfo.version = (null === (_userAgent_match3 = userAgent.match(/Chrome\/([0-9.]+)/)) || void 0 === _userAgent_match3 ? void 0 : _userAgent_match3[1]) || 'unknown';
                } else if (userAgent.indexOf('Firefox') > -1) {
                    var _userAgent_match4;
                    browserInfo.name = 'firefox';
                    browserInfo.version = (null === (_userAgent_match4 = userAgent.match(/Firefox\/([0-9.]+)/)) || void 0 === _userAgent_match4 ? void 0 : _userAgent_match4[1]) || 'unknown';
                } else if (userAgent.indexOf('Safari') > -1) {
                    var _userAgent_match5;
                    browserInfo.name = 'safari';
                    browserInfo.version = (null === (_userAgent_match5 = userAgent.match(/Version\/([0-9.]+)/)) || void 0 === _userAgent_match5 ? void 0 : _userAgent_match5[1]) || 'unknown';
                }
            }
            const ua = {
                version: version_version,
                browser: browserInfo.name,
                browser_version: browserInfo.version,
                os_name: osInfo.name,
                os_version: osInfo.version
            };
            return JSON.stringify(ua);
        };
        // Get UniApp client user agent
        const getUniAppClientUserAgent = ()=>{
            // Get system info
            if (!(null == uni ? void 0 : uni.getSystemInfoSync)) return JSON.stringify({});
            const systemInfo = uni.getSystemInfoSync();
            const platformInfo = {
                name: 'unknown',
                version: 'unknown'
            };
            const osInfo = {
                name: 'unknown',
                version: 'unknown'
            };
            // Handle operating system info
            if ('android' === systemInfo.platform) {
                osInfo.name = 'android';
                osInfo.version = systemInfo.system || 'unknown';
            } else if ('ios' === systemInfo.platform) {
                osInfo.name = 'ios';
                osInfo.version = systemInfo.system || 'unknown';
            } else if ('windows' === systemInfo.platform) {
                osInfo.name = 'windows';
                osInfo.version = systemInfo.system || 'unknown';
            } else if ('mac' === systemInfo.platform) {
                osInfo.name = 'macos';
                osInfo.version = systemInfo.system || 'unknown';
            } else {
                // Other platforms use platform name directly
                osInfo.name = systemInfo.platform;
                osInfo.version = systemInfo.system || 'unknown';
            }
            // Handle app/platform info
            if (systemInfo.AppPlatform) {
                // App environment
                platformInfo.name = systemInfo.AppPlatform.toLowerCase();
                platformInfo.version = systemInfo.appVersion || 'unknown';
            } else if (systemInfo.uniPlatform) {
                // UniApp recognized platform
                platformInfo.name = systemInfo.uniPlatform;
                platformInfo.version = systemInfo.SDKVersion || 'unknown';
            } else {
                // Try to determine platform type from environment
                const { appName, appVersion } = systemInfo;
                if (appName) {
                    platformInfo.name = appName.toLowerCase();
                    platformInfo.version = appVersion || 'unknown';
                }
            }
            const ua = {
                version: version_version,
                framework: 'uniapp',
                platform: platformInfo.name,
                platform_version: platformInfo.version,
                os_name: osInfo.name,
                os_version: osInfo.version,
                screen_width: systemInfo.screenWidth,
                screen_height: systemInfo.screenHeight,
                device_model: systemInfo.model,
                device_brand: systemInfo.brand
            };
            return JSON.stringify(ua);
        };
        // EXTERNAL MODULE: external "node-fetch"
        var external_node_fetch_ = __webpack_require__("node-fetch");
        var external_node_fetch_default = /*#__PURE__*/ __webpack_require__.n(external_node_fetch_);
        /**
 * default coze  base URL is api.coze.com
 */ const COZE_COM_BASE_URL = 'https://api.coze.com';
        /**
 * change to api.coze.cn if you use https://coze.cn
 */ const COZE_CN_BASE_URL = 'https://api.coze.cn';
        /**
 * default base websocket URL is wss://ws.coze.com
 */ const COZE_COM_BASE_WS_URL = 'wss://ws.coze.com';
        /**
 * change to wss://ws.coze.cn if you use https://coze.cn
 */ const COZE_CN_BASE_WS_URL = 'wss://ws.coze.cn';
        const POLL_INTERVAL = 5000;
        const MAX_POLL_INTERVAL = 30000;
        /* eslint-disable @typescript-eslint/no-explicit-any */ const handleError = (error)=>{
            if (!error.isAxiosError && (!error.code || !error.message)) return APIError.generate(500, void 0, `Unexpected error: ${error.message}`, void 0);
            if ('ECONNABORTED' === error.code && error.message.includes('timeout') || 'ETIMEDOUT' === error.code) {
                var _error_response;
                return new TimeoutError(408, void 0, `Request timed out: ${error.message}`, null === (_error_response = error.response) || void 0 === _error_response ? void 0 : _error_response.headers);
            }
            if ('ERR_CANCELED' === error.code) return new APIUserAbortError(error.message);
            else {
                var _error_response1, _error_response2, _error_response3;
                return APIError.generate((null === (_error_response1 = error.response) || void 0 === _error_response1 ? void 0 : _error_response1.status) || 500, null === (_error_response2 = error.response) || void 0 === _error_response2 ? void 0 : _error_response2.data, error.message, null === (_error_response3 = error.response) || void 0 === _error_response3 ? void 0 : _error_response3.headers);
            }
        };
        // node-fetch is used for streaming requests
        const adapterFetch = async (options)=>{
            const response = await external_node_fetch_default()(options.url, {
                body: options.data,
                ...options
            });
            return {
                data: response.body,
                ...response
            };
        };
        const isSupportNativeFetch = ()=>{
            if (isBrowser() || isBrowserExtension() || isUniApp()) return true;
            // native fetch is supported in node 18.0.0 or higher
            const version = process.version.slice(1);
            return compareVersions(version, '18.0.0') >= 0;
        };
        async function fetchAPI(url) {
            let options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const axiosInstance = options.axiosInstance || external_axios_default();
            // Add version check for streaming requests
            if (options.isStreaming && isAxiosStatic(axiosInstance)) {
                const axiosVersion = axiosInstance.VERSION || external_axios_default().VERSION;
                if (!axiosVersion || compareVersions(axiosVersion, '1.7.1') < 0) throw new CozeError('Streaming requests require axios version 1.7.1 or higher. Please upgrade your axios version.');
            }
            // Check for 4101 authentication error
            // If BaseURL is set to overseas address, provide a warning to try setting it to the domestic address
            const checkError = ()=>{
                if (url.startsWith(COZE_COM_BASE_URL)) console.warn(`
鉴权失败，如果您是国内用户，请将 baseURL 设置为 ${COZE_CN_BASE_URL} 示例：
new CozeAPI({
  // ...
  baseURL: COZE_CN_BASE_URL
})`);
            };
            const response = await axiosInstance({
                url,
                responseType: options.isStreaming ? 'stream' : 'json',
                adapter: options.isStreaming ? isSupportNativeFetch() ? 'fetch' : adapterFetch : void 0,
                ...options
            }).catch((error)=>{
                if ((null == error ? void 0 : error.status) === 401) checkError();
                throw handleError(error);
            });
            return {
                async *stream () {
                    try {
                        const stream = response.data;
                        const reader = stream[Symbol.asyncIterator] ? stream[Symbol.asyncIterator]() : stream.getReader();
                        const decoder = new TextDecoder();
                        const fieldValues = {};
                        let buffer = '';
                        while(true){
                            const { done, value } = await (reader.next ? reader.next() : reader.read());
                            if (done) {
                                if (buffer) {
                                    // If the stream ends without a newline, it means an error occurred
                                    fieldValues.event = 'error';
                                    fieldValues.data = buffer;
                                    try {
                                        const error = JSON.parse(buffer);
                                        if ((null == error ? void 0 : error.code) === 4101) checkError();
                                    // eslint-disable-next-line no-empty
                                    } catch (e) {}
                                    yield fieldValues;
                                }
                                break;
                            }
                            buffer += decoder.decode(value, {
                                stream: true
                            });
                            const lines = buffer.split('\n');
                            for(let i = 0; i < lines.length - 1; i++){
                                const line = lines[i];
                                const index = line.indexOf(':');
                                if (-1 !== index) {
                                    const field = line.substring(0, index).trim();
                                    const content = line.substring(index + 1).trim();
                                    fieldValues[field] = content;
                                    if ('data' === field) yield fieldValues;
                                }
                            }
                            buffer = lines[lines.length - 1]; // Keep the last incomplete line in the buffer
                        }
                    } catch (error) {
                        handleError(error);
                    }
                },
                json: ()=>response.data,
                response
            };
        }
        // Add version comparison utility
        function compareVersions(v1, v2) {
            const v1Parts = v1.split('.').map(Number);
            const v2Parts = v2.split('.').map(Number);
            for(let i = 0; i < 3; i++){
                const part1 = v1Parts[i] || 0;
                const part2 = v2Parts[i] || 0;
                if (part1 > part2) return 1;
                if (part1 < part2) return -1;
            }
            return 0;
        }
        function isAxiosStatic(instance) {
            return !!(null == instance ? void 0 : instance.Axios);
        }
        /* eslint-disable max-params */ class APIClient {
            async getToken() {
                if ('function' == typeof this.token) return await this.token();
                return this.token;
            }
            async buildOptions(method, body, options) {
                const token = await this.getToken();
                const headers = {
                    authorization: `Bearer ${token}`
                };
                if (isUniApp()) headers['X-Coze-Client-User-Agent'] = getUniAppClientUserAgent();
                else if (isBrowser() || isBrowserExtension()) headers['X-Coze-Client-User-Agent'] = getBrowserClientUserAgent();
                else {
                    headers['User-Agent'] = getUserAgent();
                    headers['X-Coze-Client-User-Agent'] = getNodeClientUserAgent();
                }
                const config = mergeConfig(this.axiosOptions, options, {
                    headers
                }, {
                    headers: this.headers || {}
                });
                config.method = method;
                config.data = body;
                return config;
            }
            async buildWebsocketOptions(options) {
                const token = await this.getToken();
                const headers = {
                    authorization: `Bearer ${token}`
                };
                if (isUniApp()) headers['X-Coze-Client-User-Agent'] = getUniAppClientUserAgent();
                else if (isBrowser()) headers['X-Coze-Client-User-Agent'] = getBrowserClientUserAgent();
                else {
                    headers['User-Agent'] = getUserAgent();
                    headers['X-Coze-Client-User-Agent'] = getNodeClientUserAgent();
                }
                var _this__config_debug;
                const config = mergeConfig({
                    debug: null !== (_this__config_debug = this._config.debug) && void 0 !== _this__config_debug && _this__config_debug
                }, this._config.websocketOptions, options, {
                    headers
                }, {
                    headers: this.headers || {}
                });
                return config;
            }
            async makeRequest(apiUrl, method, body, isStream, options) {
                const fullUrl = `${this.baseURL}${apiUrl}`;
                try {
                    const fetchOptions = await this.buildOptions(method, body, options);
                    fetchOptions.isStreaming = isStream;
                    fetchOptions.axiosInstance = this.axiosInstance;
                    this.debugLog(null == options ? void 0 : options.debug, `--- request url: ${fullUrl}`);
                    this.debugLog(null == options ? void 0 : options.debug, '--- request options:', fetchOptions);
                    const { response, stream, json } = await fetchAPI(fullUrl, fetchOptions);
                    this.debugLog(null == options ? void 0 : options.debug, `--- response status: ${response.status}`);
                    this.debugLog(null == options ? void 0 : options.debug, '--- response headers: ', response.headers);
                    var _response_headers;
                    // Taro use `header`
                    const contentType = (null !== (_response_headers = response.headers) && void 0 !== _response_headers ? _response_headers : response.header)['content-type'];
                    if (isStream) {
                        if (contentType && contentType.includes('application/json')) {
                            const result = await json();
                            const { code, msg } = result;
                            if (0 !== code && void 0 !== code) throw APIError.generate(response.status, result, msg, response.headers);
                        }
                        return stream();
                    }
                    if (!(contentType && contentType.includes('application/json'))) return await response.data;
                    {
                        const result = await json();
                        const { code, msg } = result;
                        if (0 !== code && void 0 !== code) throw APIError.generate(response.status, result, msg, response.headers);
                        return result;
                    }
                } catch (error) {
                    var _this__config;
                    // Call the onApiError callback if provided
                    // This handles network errors and other exceptions not caught above
                    const onApiError = (null == options ? void 0 : options.onApiError) || (null === (_this__config = this._config) || void 0 === _this__config ? void 0 : _this__config.onApiError);
                    if (onApiError) onApiError(error);
                    // Re-throw the error after calling the callback
                    throw error;
                }
            }
            async post(apiUrl, body) {
                let isStream = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], options = arguments.length > 3 ? arguments[3] : void 0;
                return this.makeRequest(apiUrl, 'POST', body, isStream, options);
            }
            async get(apiUrl, param, isStream, options) {
                // 拼接参数
                const queryString = Object.entries(param || {}).filter((param)=>{
                    let [_, value] = param;
                    return null != value;
                }).map((param)=>{
                    let [key, value] = param;
                    return `${key}=${value}`;
                }).join('&');
                return this.makeRequest(queryString ? `${apiUrl}${apiUrl.includes('?') ? '&' : '?'}${queryString}` : apiUrl, 'GET', void 0, isStream, options);
            }
            async put(apiUrl, body, isStream, options) {
                return this.makeRequest(apiUrl, 'PUT', body, isStream, options);
            }
            async delete(apiUrl, isStream, options) {
                return this.makeRequest(apiUrl, 'DELETE', void 0, isStream, options);
            }
            async makeWebsocket(apiUrl, options) {
                const fullUrl = `${this.baseWsURL}${apiUrl}`;
                const websocketOptions = await this.buildWebsocketOptions(options);
                this.debugLog(null == options ? void 0 : options.debug, `--- websocket url: ${fullUrl}`);
                this.debugLog(null == options ? void 0 : options.debug, '--- websocket options:', websocketOptions);
                const ws = new WebSocketAPI(fullUrl, websocketOptions);
                return ws;
            }
            getConfig() {
                return this._config;
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            debugLog() {
                let forceDebug = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                for(var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)msgs[_key - 1] = arguments[_key];
                if (this.debug || forceDebug) console.debug(...msgs);
            }
            constructor(config){
                this._config = config;
                this.baseURL = config.baseURL || COZE_COM_BASE_URL;
                this.baseWsURL = config.baseWsURL || COZE_CN_BASE_WS_URL;
                this.token = config.token;
                this.axiosOptions = config.axiosOptions || {};
                this.axiosInstance = config.axiosInstance;
                this.debug = config.debug || false;
                this.allowPersonalAccessTokenInBrowser = config.allowPersonalAccessTokenInBrowser || false;
                this.headers = config.headers;
                if (isBrowser() && 'function' != typeof this.token && isPersonalAccessToken(this.token) && !this.allowPersonalAccessTokenInBrowser) throw new CozeError('Browser environments do not support authentication using Personal Access Token (PAT) by default.\nas it may expose secret API keys. \n\nPlease use OAuth2.0 authentication mechanism. see:\nhttps://www.coze.com/docs/developer_guides/oauth_apps?_lang=en \n\nIf you need to force use, please set the `allowPersonalAccessTokenInBrowser` option to `true`. \n\ne.g new CozeAPI({ token, allowPersonalAccessTokenInBrowser: true });\n\n');
            }
        }
        APIClient.APIError = APIError;
        APIClient.BadRequestError = BadRequestError;
        APIClient.AuthenticationError = AuthenticationError;
        APIClient.PermissionDeniedError = PermissionDeniedError;
        APIClient.NotFoundError = NotFoundError;
        APIClient.RateLimitError = RateLimitError;
        APIClient.InternalServerError = InternalServerError;
        APIClient.GatewayError = GatewayError;
        APIClient.TimeoutError = TimeoutError;
        APIClient.UserAbortError = APIUserAbortError;
        // EXTERNAL MODULE: external "crypto"
        var external_crypto_ = __webpack_require__("crypto");
        // EXTERNAL MODULE: external "jsonwebtoken"
        var external_jsonwebtoken_ = __webpack_require__("jsonwebtoken");
        var external_jsonwebtoken_default = /*#__PURE__*/ __webpack_require__.n(external_jsonwebtoken_);
        const getCrypto = ()=>{
            if (isUniApp()) return {
                getRandomValues: uni.getRandomValues,
                subtle: {
                    // TODO Currently not supporting uniapp, will provide support later if needed
                    digest: ()=>{
                        console.error('digest is not supported in uniapp');
                        throw new Error('digest is not supported in uniapp');
                    }
                }
            };
            if (isBrowser() || isBrowserExtension()) {
                if ('undefined' != typeof self && self.crypto) return self.crypto;
                if ('undefined' != typeof window && window.crypto) return window.crypto;
            }
            // #ifndef MP
            return {
                getRandomValues: (array)=>external_crypto_.randomFillSync(array),
                subtle: external_crypto_.subtle
            };
        // #endif
        };
        const generateRandomString = ()=>{
            const array = new Uint8Array(32);
            getCrypto().getRandomValues(array);
            return Array.from(array, (byte)=>byte.toString(16).padStart(2, '0')).join('');
        };
        const getWebAuthenticationUrl = (config)=>{
            var _config_baseURL;
            const baseUrl = (null !== (_config_baseURL = config.baseURL) && void 0 !== _config_baseURL ? _config_baseURL : COZE_COM_BASE_URL).replace('https://api', 'https://www');
            var _config_state;
            const params = new URLSearchParams({
                response_type: 'code',
                client_id: config.clientId,
                redirect_uri: config.redirectUrl,
                state: null !== (_config_state = config.state) && void 0 !== _config_state ? _config_state : ''
            });
            if (config.workspaceId) return `${baseUrl}/api/permission/oauth2/workspace_id/${config.workspaceId}/authorize?${params.toString()}`;
            return `${baseUrl}/api/permission/oauth2/authorize?${params.toString()}`;
        };
        const getPKCEAuthenticationUrl = async (config)=>{
            var _config_baseURL;
            const baseUrl = (null !== (_config_baseURL = config.baseURL) && void 0 !== _config_baseURL ? _config_baseURL : COZE_COM_BASE_URL).replace('https://api', 'https://www');
            const crypto = getCrypto();
            // Generate code_challenge from code_verifier
            const generateCodeChallenge = async (codeVerifier)=>{
                const encoder = new TextEncoder();
                const data = encoder.encode(codeVerifier);
                const hash = await crypto.subtle.digest('SHA-256', data);
                return btoa(String.fromCharCode(...new Uint8Array(hash))).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
            };
            // Generate a random code_verifier
            const codeVerifier = generateRandomString();
            const codeChallenge = await generateCodeChallenge(codeVerifier);
            var _config_state;
            const params = new URLSearchParams({
                response_type: 'code',
                client_id: config.clientId,
                redirect_uri: config.redirectUrl,
                state: null !== (_config_state = config.state) && void 0 !== _config_state ? _config_state : '',
                code_challenge: codeChallenge,
                code_challenge_method: config.code_challenge_method || 'S256'
            });
            if (config.workspaceId) return {
                url: `${baseUrl}/api/permission/oauth2/workspace_id/${config.workspaceId}/authorize?${params.toString()}`,
                codeVerifier
            };
            return {
                url: `${baseUrl}/api/permission/oauth2/authorize?${params.toString()}`,
                codeVerifier
            };
        };
        const getWebOAuthToken = async (config, options)=>{
            const api = new APIClient({
                token: config.clientSecret,
                baseURL: config.baseURL
            });
            const apiUrl = '/api/permission/oauth2/token';
            const payload = {
                grant_type: 'authorization_code',
                client_id: config.clientId,
                redirect_uri: config.redirectUrl,
                code: config.code
            };
            const result = await api.post(apiUrl, payload, false, options);
            return result;
        };
        const getPKCEOAuthToken = async (config, options)=>{
            const api = new APIClient({
                token: '',
                baseURL: config.baseURL
            });
            const apiUrl = '/api/permission/oauth2/token';
            const payload = {
                grant_type: 'authorization_code',
                client_id: config.clientId,
                redirect_uri: config.redirectUrl,
                code: config.code,
                code_verifier: config.codeVerifier
            };
            const result = await api.post(apiUrl, payload, false, options);
            return result;
        };
        const refreshOAuthToken = async (config, options)=>{
            const api = new APIClient({
                token: config.clientSecret || '',
                baseURL: config.baseURL
            });
            const apiUrl = '/api/permission/oauth2/token';
            const payload = {
                grant_type: 'refresh_token',
                client_id: config.clientId,
                refresh_token: config.refreshToken
            };
            const result = await api.post(apiUrl, payload, false, options);
            return result;
        };
        const getDeviceCode = async (config, options)=>{
            if (isBrowser()) throw new Error('getDeviceCode is not supported in browser');
            const api = new APIClient({
                token: '',
                baseURL: config.baseURL
            });
            let apiUrl;
            apiUrl = config.workspaceId ? `/api/permission/oauth2/workspace_id/${config.workspaceId}/device/code` : '/api/permission/oauth2/device/code';
            const payload = {
                client_id: config.clientId
            };
            const result = await api.post(apiUrl, payload, false, options);
            return result;
        };
        const _getDeviceToken = async (config, options)=>{
            const api = new APIClient({
                token: '',
                baseURL: config.baseURL
            });
            const apiUrl = '/api/permission/oauth2/token';
            const payload = {
                grant_type: 'urn:ietf:params:oauth:grant-type:device_code',
                client_id: config.clientId,
                device_code: config.deviceCode
            };
            const result = await api.post(apiUrl, payload, false, options);
            return result;
        };
        const getDeviceToken = async (config, options)=>{
            if (isBrowser()) throw new Error('getDeviceToken is not supported in browser');
            if (!config.poll) return _getDeviceToken(config, options);
            let interval = POLL_INTERVAL;
            while(true)try {
                // Attempt to get the device token
                const deviceToken = await _getDeviceToken(config, options);
                return deviceToken;
            } catch (error) {
                if (error instanceof APIError) {
                    var _error_rawError, _error_rawError1;
                    // If the error is authorization_pending, continue polling
                    if ((null == error ? void 0 : null === (_error_rawError = error.rawError) || void 0 === _error_rawError ? void 0 : _error_rawError.error) === "authorization_pending") {
                        await sleep(interval);
                        continue;
                    // If the error is slow_down, increase the interval
                    }
                    if ((null == error ? void 0 : null === (_error_rawError1 = error.rawError) || void 0 === _error_rawError1 ? void 0 : _error_rawError1.error) === "slow_down") {
                        if (interval < MAX_POLL_INTERVAL) interval += POLL_INTERVAL;
                        await sleep(interval);
                        continue;
                    }
                }
                // For any other error, throw it
                throw error;
            }
        };
        const _getJWTToken = async (config, options)=>{
            const api = new APIClient({
                token: config.token,
                baseURL: config.baseURL
            });
            let apiUrl;
            apiUrl = config.accountId ? `/api/permission/oauth2/account/${config.accountId}/token` : '/api/permission/oauth2/token';
            var _config_durationSeconds;
            const payload = {
                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                duration_seconds: null !== (_config_durationSeconds = config.durationSeconds) && void 0 !== _config_durationSeconds ? _config_durationSeconds : 900,
                scope: config.scope
            };
            const result = await api.post(apiUrl, payload, false, options);
            return result;
        };
        const getJWTToken = async (config, options)=>{
            if (isBrowser()) throw new Error('getJWTToken is not supported in browser');
            // Validate private key format
            const keyFormat = config.privateKey.includes('BEGIN RSA PRIVATE KEY') ? 'RSA' : config.privateKey.includes('BEGIN PRIVATE KEY') ? 'PKCS8' : null;
            if (!keyFormat) throw APIError.generate(400, void 0, 'Invalid private key format. Expected PEM format (RSA or PKCS8)', void 0);
            // Prepare the payload for the JWT
            const now = Math.floor(Date.now() / 1000);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const payload = {
                iss: config.appId,
                aud: config.aud,
                iat: now,
                exp: now + 3600,
                jti: generateRandomString()
            };
            if (config.sessionName) payload.session_name = config.sessionName;
            return new Promise((resolve, reject)=>{
                var _config_algorithm;
                external_jsonwebtoken_default().sign(payload, config.privateKey, {
                    algorithm: null !== (_config_algorithm = config.algorithm) && void 0 !== _config_algorithm ? _config_algorithm : 'RS256',
                    keyid: config.keyid
                }, async (err, token)=>{
                    if (err || !token) {
                        reject(err);
                        return;
                    }
                    // Exchange the JWT for an OAuth token
                    try {
                        const result = await _getJWTToken({
                            ...config,
                            token
                        }, options);
                        resolve(result);
                    } catch (err2) {
                        reject(err2);
                    }
                });
            });
        };
        var auth_PKCEAuthErrorType = /*#__PURE__*/ function(PKCEAuthErrorType) {
            PKCEAuthErrorType["AUTHORIZATION_PENDING"] = "authorization_pending";
            PKCEAuthErrorType["SLOW_DOWN"] = "slow_down";
            PKCEAuthErrorType["ACCESS_DENIED"] = "access_denied";
            PKCEAuthErrorType["EXPIRED_TOKEN"] = "expired_token";
            return PKCEAuthErrorType;
        }({});
        class CozeAPI extends APIClient {
            constructor(...args){
                super(...args), this.bots = new Bots(this), this.chat = new Chat(this), this.conversations = new Conversations(this), this.files = new Files(this), /**
   * @deprecated
   */ this.knowledge = new Knowledge(this), this.datasets = new Datasets(this), this.workflows = new Workflows(this), this.workspaces = new WorkSpaces(this), this.audio = new Audio(this), this.templates = new Templates(this), this.websockets = new Websockets(this), this.variables = new Variables(this), this.users = new Users(this);
            }
        }
        return __webpack_exports__;
    })());
