

// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module !== 'undefined' ? Module : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)

(function (root, factory, globalExport) {

	var lib, env;
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['require'], function (req) {
			lib = factory(root, req);
			return lib;
		});
	} else if (typeof module === 'object' && module.exports) {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.

		// use process.env (if available) for reading Opus environment settings:
		env = typeof process !== 'undefined' && process && process.env? process.env : root;
		lib = factory(env, module.require);
		module.exports = lib;
	} else {
		// Browser globals
		lib = factory(root);
		root[globalExport] = lib;
	}

}(typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this, function (global, require) {
'use strict';

var Module = {};
Module['isReady'] = false;
Module['onready'] = null;
Module['onRuntimeInitialized'] = function(){
	Module['isReady'] = true;
	if(Module['onready']) setTimeout(Module['onready'], 0);
};

if(global && global.OPUS_SCRIPT_LOCATION){
	Module['locateFile'] = function(fileName){
		var path = global.OPUS_SCRIPT_LOCATION || '';
		if(path[fileName]) return path[fileName];
		path += path && !/\/$/.test(path)? '/' : '';
		return path + fileName;
	};
}



// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = function(status, toThrow) {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;
ENVIRONMENT_IS_WEB = typeof window === 'object';
ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string';
ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;

var nodeFS;
var nodePath;

if (ENVIRONMENT_IS_NODE) {
  if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = require('path').dirname(scriptDirectory) + '/';
  } else {
    scriptDirectory = __dirname + '/';
  }

// include: node_shell_read.js


read_ = function shell_read(filename, binary) {
  var ret = tryParseAsDataURI(filename);
  if (ret) {
    return binary ? ret : ret.toString();
  }
  if (!nodeFS) nodeFS = require('fs');
  if (!nodePath) nodePath = require('path');
  filename = nodePath['normalize'](filename);
  return nodeFS['readFileSync'](filename, binary ? null : 'utf8');
};

readBinary = function readBinary(filename) {
  var ret = read_(filename, true);
  if (!ret.buffer) {
    ret = new Uint8Array(ret);
  }
  assert(ret.buffer);
  return ret;
};

// end include: node_shell_read.js
  if (process['argv'].length > 1) {
    thisProgram = process['argv'][1].replace(/\\/g, '/');
  }

  arguments_ = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });

  process['on']('unhandledRejection', abort);

  quit_ = function(status) {
    process['exit'](status);
  };

  Module['inspect'] = function () { return '[Emscripten Module object]'; };

} else
if (ENVIRONMENT_IS_SHELL) {

  if (typeof read != 'undefined') {
    read_ = function shell_read(f) {
      var data = tryParseAsDataURI(f);
      if (data) {
        return intArrayToString(data);
      }
      return read(f);
    };
  }

  readBinary = function readBinary(f) {
    var data;
    data = tryParseAsDataURI(f);
    if (data) {
      return data;
    }
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    arguments_ = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    arguments_ = arguments;
  }

  if (typeof quit === 'function') {
    quit_ = function(status) {
      quit(status);
    };
  }

  if (typeof print !== 'undefined') {
    // Prefer to use print/printErr where they exist, as they usually work better.
    if (typeof console === 'undefined') console = /** @type{!Console} */({});
    console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);
    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr !== 'undefined' ? printErr : print);
  }

} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document !== 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {

// include: web_or_worker_shell_read.js


  read_ = function(url) {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
    } catch (err) {
      var data = tryParseAsDataURI(url);
      if (data) {
        return intArrayToString(data);
      }
      throw err;
    }
  };

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = function(url) {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
      } catch (err) {
        var data = tryParseAsDataURI(url);
        if (data) {
          return data;
        }
        throw err;
      }
    };
  }

  readAsync = function(url, onload, onerror) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      var data = tryParseAsDataURI(url);
      if (data) {
        onload(data.buffer);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };

// end include: web_or_worker_shell_read.js
  }

  setWindowTitle = function(title) { document.title = title };
} else
{
}

// Set up the out() and err() hooks, which are how we can print to stdout or
// stderr, respectively.
var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];

if (Module['thisProgram']) thisProgram = Module['thisProgram'];

if (Module['quit']) quit_ = Module['quit'];

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message




var STACK_ALIGN = 16;

function alignMemory(size, factor) {
  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default
  return Math.ceil(size / factor) * factor;
}

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length-1] === '*') {
        return 4; // A pointer
      } else if (type[0] === 'i') {
        var bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}

// include: runtime_functions.js


// Wraps a JS function as a wasm function with a given signature.
function convertJsFunctionToWasm(func, sig) {
  return func;
}

var freeTableIndexes = [];

// Weak map of functions in the table to their indexes, created on first use.
var functionsInTableMap;

function getEmptyTableSlot() {
  // Reuse a free index if there is one, otherwise grow.
  if (freeTableIndexes.length) {
    return freeTableIndexes.pop();
  }
  // Grow the table
  try {
    wasmTable.grow(1);
  } catch (err) {
    if (!(err instanceof RangeError)) {
      throw err;
    }
    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
  }
  return wasmTable.length - 1;
}

// Add a wasm function to the table.
function addFunctionWasm(func, sig) {
  // Check if the function is already in the table, to ensure each function
  // gets a unique index. First, create the map if this is the first use.
  if (!functionsInTableMap) {
    functionsInTableMap = new WeakMap();
    for (var i = 0; i < wasmTable.length; i++) {
      var item = wasmTable.get(i);
      // Ignore null values.
      if (item) {
        functionsInTableMap.set(item, i);
      }
    }
  }
  if (functionsInTableMap.has(func)) {
    return functionsInTableMap.get(func);
  }

  // It's not in the table, add it now.

  var ret = getEmptyTableSlot();

  // Set the new value.
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    wasmTable.set(ret, func);
  } catch (err) {
    if (!(err instanceof TypeError)) {
      throw err;
    }
    var wrapped = convertJsFunctionToWasm(func, sig);
    wasmTable.set(ret, wrapped);
  }

  functionsInTableMap.set(func, ret);

  return ret;
}

function removeFunction(index) {
  functionsInTableMap.delete(wasmTable.get(index));
  freeTableIndexes.push(index);
}

// 'sig' parameter is required for the llvm backend but only when func is not
// already a WebAssembly function.
function addFunction(func, sig) {

  return addFunctionWasm(func, sig);
}

// end include: runtime_functions.js
// include: runtime_debug.js


// end include: runtime_debug.js
function makeBigInt(low, high, unsigned) {
  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));
}

var tempRet0 = 0;

var setTempRet0 = function(value) {
  tempRet0 = value;
};

var getTempRet0 = function() {
  return tempRet0;
};



// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary;
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
var noExitRuntime = Module['noExitRuntime'] || true;

// include: wasm2js.js


// wasm2js.js - enough of a polyfill for the WebAssembly object so that we can load
// wasm2js code that way.

// Emit "var WebAssembly" if definitely using wasm2js. Otherwise, in MAYBE_WASM2JS
// mode, we can't use a "var" since it would prevent normal wasm from working.
/** @suppress{duplicate, const} */
var
WebAssembly = {
  // Note that we do not use closure quoting (this['buffer'], etc.) on these
  // functions, as they are just meant for internal use. In other words, this is
  // not a fully general polyfill.
  Memory: function(opts) {
    this.buffer = new ArrayBuffer(opts['initial'] * 65536);
  },

  Module: function(binary) {
    // TODO: use the binary and info somehow - right now the wasm2js output is embedded in
    // the main JS
  },

  Instance: function(module, info) {
    // TODO: use the module and info somehow - right now the wasm2js output is embedded in
    // the main JS
    // This will be replaced by the actual wasm2js code.
    this.exports = (
// EMSCRIPTEN_START_ASM
function instantiate(asmLibraryArg) {
function Table(ret) {
  // grow method not included; table is not growable
  ret.set = function(i, func) {
    this[i] = func;
  };
  ret.get = function(i) {
    return this[i];
  };
  return ret;
}

  var bufferView;
  var base64ReverseLookup = new Uint8Array(123/*'z'+1*/);
  for (var i = 25; i >= 0; --i) {
    base64ReverseLookup[48+i] = 52+i; // '0-9'
    base64ReverseLookup[65+i] = i; // 'A-Z'
    base64ReverseLookup[97+i] = 26+i; // 'a-z'
  }
  base64ReverseLookup[43] = 62; // '+'
  base64ReverseLookup[47] = 63; // '/'
  /** @noinline Inlining this function would mean expanding the base64 string 4x times in the source code, which Closure seems to be happy to do. */
  function base64DecodeToExistingUint8Array(uint8Array, offset, b64) {
    var b1, b2, i = 0, j = offset, bLength = b64.length, end = offset + (bLength*3>>2) - (b64[bLength-2] == '=') - (b64[bLength-1] == '=');
    for (; i < bLength; i += 4) {
      b1 = base64ReverseLookup[b64.charCodeAt(i+1)];
      b2 = base64ReverseLookup[b64.charCodeAt(i+2)];
      uint8Array[j++] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;
      if (j < end) uint8Array[j++] = b1 << 4 | b2 >> 2;
      if (j < end) uint8Array[j++] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i+3)];
    }
  }
function initActiveSegments(imports) {
  base64DecodeToExistingUint8Array(bufferView, 1025, "QAAAbCIAAEIPAAASBgAATQIAANs=");
  base64DecodeToExistingUint8Array(bufferView, 1056, "7QAAAJkAAABJAAAAHgAAAAwAAAAH");
  base64DecodeToExistingUint8Array(bufferView, 1089, "QAAAk10AAL1wAADteQAAsn0AACR/AABIzQAALSsgICAwWDB4AChudWxsKQAAAAARAAoAERERAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABEADwoREREDCgcAAQAJCwsAAAkGCwAACwAGEQAAABEREQ==");
  base64DecodeToExistingUint8Array(bufferView, 1217, "CwAAAAAAAAAAEQAKChEREQAKAAACAAkLAAAACQALAAAL");
  base64DecodeToExistingUint8Array(bufferView, 1275, "DA==");
  base64DecodeToExistingUint8Array(bufferView, 1287, "DAAAAAAMAAAAAAkMAAAAAAAMAAAM");
  base64DecodeToExistingUint8Array(bufferView, 1333, "Dg==");
  base64DecodeToExistingUint8Array(bufferView, 1345, "DQAAAAQNAAAAAAkOAAAAAAAOAAAO");
  base64DecodeToExistingUint8Array(bufferView, 1391, "EA==");
  base64DecodeToExistingUint8Array(bufferView, 1403, "DwAAAAAPAAAAAAkQAAAAAAAQAAAQAAASAAAAEhIS");
  base64DecodeToExistingUint8Array(bufferView, 1458, "EgAAABISEgAAAAAAAAk=");
  base64DecodeToExistingUint8Array(bufferView, 1507, "Cw==");
  base64DecodeToExistingUint8Array(bufferView, 1519, "CgAAAAAKAAAAAAkLAAAAAAALAAAL");
  base64DecodeToExistingUint8Array(bufferView, 1565, "DA==");
  base64DecodeToExistingUint8Array(bufferView, 1577, "DAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAwMTIzNDU2Nzg5QUJDREVGRmF0YWwgKGludGVybmFsKSBlcnJvciBpbiAlcywgbGluZSAlZDogJXMKAGFzc2VydGlvbiBmYWlsZWQ6IDAAY2VsdC9jZWx0LmMAAAAAAAAAAJ0+AEBePgDABD4AgO0+AECJPgAAAAAAwEw/AADNPQ==");
  base64DecodeToExistingUint8Array(bufferView, 1745, "/wD/AP8A/wD/AP4BAAH/AP4A/QIAAf8A/gD9AwAB/2Fzc2VydGlvbiBmYWlsZWQ6IE1BWF9GUkFNRV9MRU5HVEggPj0gcHNFbmNDLT5mcmFtZV9sZW5ndGgAc2lsay9WQUQuYwBhc3NlcnRpb24gZmFpbGVkOiBwc0VuY0MtPmZyYW1lX2xlbmd0aCA9PSA4ICogc2lsa19SU0hJRlQoIHBzRW5jQy0+ZnJhbWVfbGVuZ3RoLCAzICkAAAAAAAAwdQAAcBcAACDR//8g0f//YXNzZXJ0aW9uIGZhaWxlZDogZW5jQ29udHJvbCAhPSBOVUxMAHNpbGsvY2hlY2tfY29udHJvbF9pbnB1dC5jAGFzc2VydGlvbiBmYWlsZWQ6IDA=");
  base64DecodeToExistingUint8Array(bufferView, 2048, "/fr06dS2loN4bmJVSDwxKCAZEw8NCwkIBwYFBAMCAQDS0M7Lx8G3qI5oSjQlGxQOCgYEAg==");
  base64DecodeToExistingUint8Array(bufferView, 2112, "38m3p5iKfG9iWE9GPjgyLCcjHxsYFRIQDgwKCAYEAwIBALywm4p3YUMrGgoApXdQPS8jGxQOCQQAcT8AAAAAAAwjPFNshJ20zuQPIDdNZX2Xr8nhEypCWXKJorjR5gwZMkhheJOsyN8aLEVacoeftM3hDRY1UGqCnLTN5A8ZLEBac46oxN4TGD5SZHiRqL7WFh8yT2d4l6rL4xUdLUFqfJarxOAeMUtheY6lutHlExk0Rl10j6bA2xoiPkthdpGnwtkZIThGW3GPpcTfFSIzSGF1kavE3hQdMkNadZCoxd0WHzBCX3WSqMTeGCEzTXSGnrTI4BUcRldqfJWqwtkaITVAU3WYrczhGyJBX2yBm67S4RQaSGNxg5qwyNsiKz1OXXKbsc3lFx02YXyKo7PR5R4mOFl2gZ6yyOcVHTE/VW+Oo8HeGzBNZ4Wes8TX6B0vSmN8l7DG3O0hKj1MXXmbrs/hHTVXcIiaqrzQ4xgeNFSDlqa6y+UlMEBUaHacscnmUQsKCQoJCgnvCO8ICgn8CBcJ7whICxQKWgk/CQoJ4gjiCOII4giSCLcJJAkkCQoJCgkKCSQJJAk/CTIJkAzOCiQJJAkKCeIIrQifCNUIkgicCaoJPwlaCVoJWglaCT8JZwkKCZcN8AtPCJ8I4gjiCOII7wgKCdUI0gxFDBQKWgnHCK0InwiSCJIIQggAEAUPrQg8CjwKZwkKCVoJPwkaCGoMrAw/Ca0I+QmCCSQJCgl3CK0ICg2gDaYKkgjVCJwJMgk/CZ8INQgyCXQJFwk/CVoJdAl0CXQJnAk/CcMOLQ6CCd8JPwniCOII/AifCAAItgyZDJkKHguPCRcJ/Aj8COIITwi/DOQMwQr2Co8J1QjVCMcITwg1CDkLpQtJCj8JZwkyCZIIxwjHCEIImQx9DEkKFAriCIUIxwitCK0IXQhqDO4MtApnCeII4gjiCO8IkghCCEUMyAycCQ0I7wjECT8JtwmCCYUIsw3SDAoJjApXCqoJPwlaCSQJTwhfDc8N3gvwC/wIngetCOII4gjiCEwNJg0nCH8KOQsyCXQJ4giqCewJsA6gDZ4HZApRC98JWgk/CZwJ1QjUC8gMtApIC7QKaghPCO8IugjHCG8OSQ7pB7EHZAqMChQKxAkXCT8JhwxVDTIJGghIC0gLJAm3CccIdwgKDSYNHgvcChcJagjiCO8IQggNCBcJ/AiFCHcIhQg/CUkKjAqMCvkJZwmCCa0I1QitCK0IJAl0CS8KjAreC6wM9gpIC6oJGgj8CAoJMglMCa0IaghPCO8IxAnpCukKPAoUCj8JXA6BDroILgeFCMEKpgpxCtEJnwjpClgMpgr5CR4L0QmFCFoJrQiFCNSylIFsYFVST009Ozk4MzEwLSopKCYkIh8eFQwKAwEA//X07Onh2cu+sK+hlYh9cmZbUUc8NCsjHBQTEgwLBQCzioyUl5WZl6N0Q1I7XEhkWVw=");
  base64DecodeToExistingUint8Array(bufferView, 3232, "EAAAAABjQiQkIiQiIiIiU0UkNCJ0ZkZERLBmREQiQVVEVCR0jZiLqoS7uNiJhPmouYtoZmRERLLaubmq9Ni7u6r0u7vbimebuLmJdLebmIiE2bi4qqTZq5uL9Km4uaqk2N/aitaPvNqo9I2Im6qoitzbi6TbytiJqLr2uYt0udu5imRkhmRmIkREZESoy93aqKeaiGhGpPariYuJm9rbi//+/e4OAwIBAP/+/NojAwIBAP/++tA7BAIBAP/+9sJHCgIBAP/87LdSCAIBAP/867RaEQIBAP/44KthHgQBAP/+7K1fJQcB");
  base64DecodeToExistingUint8Array(bufferView, 3472, "////gwaR///////sXQ9g///////CUxlH3f////+iSSJCov///9J+SSs5rf///8l9RzA6gv///6ZuSTk+aNL///t7QTdEZKv/AAAAAAAAAAD6AAMABgADAAMAAwAEAAMAAwADAM0BAAAgAAoAFC5kAYAIAADACQAAQAwAAIAMAACgDAAAQA0AAJANAADgDQAABxcmNkVVZHSDk6KywdDf7w0ZKTdFU2Jwf46dq7vL3OwPFSIzPU5can6ImKe5zeHwChUkMj9PX25+jZ2tvc3d7REUJTM7Tllre4aWpLjN4PAKDyAzQ1FgcIGOnq29zNzsCBUlM0FPYnF+ipuos8DR2gwPIjc/TldsdoOUp7nL2+wQEyAkOE9bbHaImqu6zNztCxwrOkpZaXiHlqW0xNPi8QYQIS48S1xre4mcqbnH1uELEx4sOUpZaXmHmKm6ytrqDBMdLjlHWGR4hJSltsfY6REXIy44TVxqe4aYp7nM3u0OES01P0tZa3OEl6u8zt3wCRAdKDhHWGd3iZqrvc3e7RATJDA5TFdpdoSWp7nK2uwMER02R1FeaH6IlaS2yd3tDxwvPk9hc4GOm6i0wtDf7ggOHi0+Tl5vf4+fr8DP3+8RHjE+T1xrd4SRoK6+zNzrDhMkLT1MW2x5ipqsvc3e7gwSHy08TFtre4qaq7vM3ewNER8rNUZTZ3KDlae5y9ztERYjKjpOXW59i5uqvM7g8AgPIjJDU2Nzg5KissHR4O8NEClCSVZfb4CJlqO3zuHxERklND9LXGZ3hJCgr7/U5xMfMUFTZHWFk6Guu8jV4/ISHzREWGd1foqVo7HAz9/vEB0vPUxaaneFk6GwwdHg8A8VIzI9SVZhbneBja/G2u1JDm0LbQttC20LbQttC20LbQttC20LbQuTC5MLbQseC5AMDQycC/AL8AvCC8ILwguTC5MLwgucC0gLHgseC6YKUA+uD6ULhwyHDHYL8AseCzIMrAxtCx4LPAr5CdwKbQu8DX0MwgsfDMsLSAttC20LbQttC0gLSAtIC0gLSAvBCr4TvhN2C/UNOQ3wCw0M6QpYDFgMnAseC9EJ7AnBCkgLTBE1EIwKwQqcC8ILbQseC6ULywttC20LbQttC0gLpgokDssLnAvwC/ALOQv2CvALkAznC6UL2wzbDKUL7gyvC2sUlhPsCQoNxg05DX0MFgwwDaULjApXCn8K6QoeC3EK2RM2FAcSTBGcCVEL5wuHDGEMfwq0CkgLHgvpCh4LjAoyDEgLkwttC20LbQttC5MLkwuTC5MLbQttC5MLkwuTC2oQhwylCx8MwgtIC0gLbQucCzkLZAvLC5wLwgt9DDkLsA6wDqwMHwylC0gLbQtIC5wLdgvpCukKHgtIC0gLZAoOD64PhwwyDKwMdgvnC5MLkwsNDB4L6QrpCukK6QoUCgUP8A8dDbwNFgy0CsILdgsyDA0MHgseC1cKVwoeC/YKGxQeE5kMBQ9xDWEMUQtVDXsNjAoUCnEKtAoeC/YKwQoNEM0O2wxYDG0LSAtIC20L6Qq0CukKtArpCh4LSAv2CtkTvhPnC9kNrAzwCw0MgAsfDFELtAq0CrQKHgvpCjwK1RDVECwL3wmHDDANMA0DDAMMMA3wCx4LVwoUCqYKwQrwC2QL9gpIC7QKfwpRCx8MTgxODJAMYQzwC8ILkwseCxcRKg9tC0gLHgtICx4LHgtIC0gLSAseC0gLbQtICx4LpQtkC2QLpQulC/ALMgyQDE4M8AvCC5wLnAucC20LtAqFEDUQ7gwTDW0LkwtIC6ULpQseC+kKtAoeCx4LHgvpCvAPrg8fDMILbQttC20LSAttC20LHgseCx4L6QpIC9wKBxLfEWEMcQ2HDKULUQveCzIMtAp/Cn8Kfwq0CukKjAo1EK0QzQ5JDqYK3ApIC0gLwgucC20LHgt/Cn8K6QpIC3cQ4g3BCh4LHgtIC0gLSAttC20LSAttC20LbQuTC0gLNhQ5E9UIaA3NDpcNEw0eC+4Mlw1ODFELnAm3CcEKbQt7DWUOMgx9DB0N5wuHDIcMpQuQDA0MbQttC38K7AmCCaULwgvpCukKtArpCh4LnAvwCx8MTgxODE4MHwzCC8ILgAs5C38KpgrcCsILaA3ZDR0NrAzwC8ILkwttC0gLHgvLC4ALUQvCC8ILnAvLCx8M8AvwC8ILSAseC20LbQtIC1APfw/CC30MHQ2QDNsM2wyXDXgOcQ2mCoUInAkUCi8K4czJuLevnpqZh3dzcW5tY2JfT0Q0MjAtKyAfGxIKAwD/++vm1MnEtqemo5eKfG5oWk5MRkU5LSIYFQsGBQQDAK+UoLCyra6ksa7EtsbAtkQ+QjxIdVVadoiXjqCOmw==");
  base64DecodeToExistingUint8Array(bufferView, 5255, "AWRmZkREJCJgpGueubS5i2ZAQiQiIgABINCLjb+YuZtoYKtopmZmZoQBAAAAABAQAFBtTmu5i2dl0NSNi62Ze2ckAAAAAAAAATAAAAAAAAAgRId7d3dnRWJEZ3h2dmZHYoaInbi2mYuG0Kj4S72PeWsgMSIiIgARAtLri3u5iWmGYodotmS3q4ZkRkRGQkIig0CmZkQkAgEAhqZmRCIiQoTU9p6La2tXZmTbfXqJdmeEcoeJaatqMiKk1o2PuZd5Z8AiAAAAAAAB0G1Ku4b5n4lmbpp2V2V3ZQACACQkQkQjYKRmZCQAAiGniq5mZFQCAmRreHckxRgA//799AwDAgEA//784CYDAgEA//770TkEAgEA//70w0UEAgEA//vouFQHAgEA//7wulYOAgEA//7vslseBQEA//jjsWQTAgE=");
  base64DecodeToExistingUint8Array(bufferView, 5584, "////nASa///////jZg9c///////VUxhI7P////+WTCE/1v///755TSs3uf////WJRys7i/////+DQjJCa8L//6Z0TDc1ff//AAAAAAAAAABkAAMAKAADAAMAAwAFAA4ADgAKAAsAAwAIAAkABwADAFsBAAAgABAAZiarASAOAAAgEAAAIBQAAGAUAACAFAAAgBUAANAVAAAgFgAAAAAAAFzKvti235rinOZ47Hr0zPw0A4YLiBNkGWYdSiBCJ6Q1+ff29fTq0srJyMWuUjs4NzYuFgwLCgkHAEAAy5YA18OmfW5SAAAAAKsWAACuFgAAeACAQADongoA5gDz3cC1AGQA8AAgAGQAzTwAMAAgq1UAwIBAAM2aZjMA1auAVSsA4MCggGBAIABkKBAHAwEAAApn8g5WzeQdCmfyDnVSggxZmgQZdVKCDEYRMQrtA2IURhExCtoC1wf5xq0P2gLXByK2UgXa+qQKIrZSBQAAAABG8y4eK+NLDh9mgBgcLB0K2mFIEu2c9AbsMBML45ClBO2kHQIK32sDAAAAAAAAAAAqr9XJz/9AABEAY/9hARD+owAnK71W2f8GAFsAVv+6ABcAgPzAGNhN7f/c/2YAp//o/0gBSfwICiU+AAAAAAAAh8c9yUAAgACG/yQANgEA/UgCMyRFRQwAgAASAHL/IAGL/5/8GxB7OAAAAAAAAAAAaAINyPb/JwA6ANL/rP94ALgAxf7j/QQFBBVAIwAAAADmPsbE8/8AABQAGgAFAOH/1f/8/0EAWgAHAGP/CP/U/1ECLwY0CscMAAAAAAAAAADkVwXFAwDy/+z/8f8CABkAJQAZAPD/uf+V/7H/MgAkAW8C1gMIBbgFAAAAAAAAAACUa2fEEQAMAAgAAQD2/+r/4v/g/+r/AwAsAGQAqADzAD0BfQGtAccBE/WV5lkS8ykfBlQg");
  base64DecodeToExistingUint8Array(bufferView, 6304, "vQCo/WkCZ3d1AGH/0vsIdDQA3QCo9nRu/P8RAury5WbQ//YCjPClXbD/iQN17wZTnf/MA4LvZkeV/8cDi/AnO5n/gANh8q4upf8FA8/0XiK5/2MCofeYFtL/qQGh+rQLYXNzZXJ0aW9uIGZhaWxlZDogMABzaWxrL3Jlc2FtcGxlcl9wcml2YXRlX2Rvd25fRklSLmMAYXNzZXJ0aW9uIGZhaWxlZDogMABzaWxrL3Jlc2FtcGxlci5jAAYAAwAHAwABCgACBhIKDAQAAgAAAAkEBwQAAwwHB2Fzc2VydGlvbiBmYWlsZWQ6IGluTGVuID49IFMtPkZzX2luX2tIegBhc3NlcnRpb24gZmFpbGVkOiBTLT5pbnB1dERlbGF5IDw9IFMtPkZzX2luX2tIegBhc3NlcnRpb24gZmFpbGVkOiBmc19rSHogPT0gOCB8fCBmc19rSHogPT0gMTIgfHwgZnNfa0h6ID09IDE2AHNpbGsvY29udHJvbF9jb2RlYy5jAGFzc2VydGlvbiBmYWlsZWQ6IHBzRW5jLT5zQ21uLm5iX3N1YmZyID09IDIgfHwgcHNFbmMtPnNDbW4ubmJfc3ViZnIgPT0gNABhc3NlcnRpb24gZmFpbGVkOiAoIHBzRW5jLT5zQ21uLnN1YmZyX2xlbmd0aCAqIHBzRW5jLT5zQ21uLm5iX3N1YmZyICkgPT0gcHNFbmMtPnNDbW4uZnJhbWVfbGVuZ3RoAGFzc2VydGlvbiBmYWlsZWQ6IENvbXBsZXhpdHkgPj0gMCAmJiBDb21wbGV4aXR5IDw9IDEwAGFzc2VydGlvbiBmYWlsZWQ6IHBzRW5jQy0+cGl0Y2hFc3RpbWF0aW9uTFBDT3JkZXIgPD0gTUFYX0ZJTkRfUElUQ0hfTFBDX09SREVSAGFzc2VydGlvbiBmYWlsZWQ6IF9mdD4xAGNlbHQvZW50ZW5jLmMAYXNzZXJ0aW9uIGZhaWxlZDogX2JpdHM+MABhc3NlcnRpb24gZmFpbGVkOiBfbmJpdHM8PUVDX1NZTV9CSVRTAGFzc2VydGlvbiBmYWlsZWQ6IF90aGlzLT5vZmZzK190aGlzLT5lbmRfb2Zmczw9X3NpemUAYXNzZXJ0aW9uIGZhaWxlZDogbiA8IDI1AHNpbGsvc3RlcmVvX2VuY29kZV9wcmVkLmMAYXNzZXJ0aW9uIGZhaWxlZDogaXhbIG4gXVsgMCBdIDwgMwBhc3NlcnRpb24gZmFpbGVkOiBpeFsgbiBdWyAxIF0gPCBTVEVSRU9fUVVBTlRfU1VCX1NURVBTAAAAAADgcCwPAwIBAP7twIRGFwQA//zimz0LAg==");
  base64DecodeToExistingUint8Array(bufferView, 7328, "+vXqy0cyKiYjIR8dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQCzYwBHOCseFQwG");
  base64DecodeToExistingUint8Array(bufferView, 7392, "x6WQfG1gVEc9MyogFw8IAPHh08e7r6SZjoR7cmlgWFBIQDkyLCYhHRgUEAwJBQIAzBwAAOAcAADwHAAAD4OKipubra0=");
  base64DecodeToExistingUint8Array(bufferView, 7472, "RV1zdoOKjYqWlpuWm6CmoIOAho2NjZGRkZabm5uboKCgoKamra22wLbAwMDNwM3gHB0AADAdAABAHQAAAAAAAAQGGAcFAAACAAAMHCkN/PcPKhkOAf4+Kff2JUH8A/oEQgf4EA4m/SEAAAAAAAAAAA0WJxcM/yRAG/r5CjcrEQEBCAEBBvVKNff0N0z0CP0DXRv8Gic7A/gCAE0LCfgWLPoHKAkaAwn5FGX5BAP4KhoA8SFEAhf+Ny7+DwP/FRAp+hs9JwX1KlgEAf48QQb8//tJOAH3E14d9wAMYwYECO1mLvMDAg0DAgnrVEju9S5o6ggSJjAXAPBGU+sLBfV1Fvj6F3X0AwP4XxwE9g9NPPH/BHwC/AMmVBjnAg0qDR8V/Dgu//8jT/MT+UFY9/IUBFEx4xQASwPvBfcsXPgB/RZFH/pfKfQFJ0MQ/AEA+ng33PMsegToUQULAwcCAAkKWHAdAACgHQAA8B0AAC4CWlddW1Ji");
  base64DecodeToExistingUint8Array(bufferView, 7856, "bXh2DHFzdXdjO1dvP29wUH58fXyBeX4XhH9/f35/eoWChmV2d5F+Vnx4e3eqrWttnB4AALAeAADAHgAACBAgYXNzZXJ0aW9uIGZhaWxlZDogdHlwZU9mZnNldCA+PSAwICYmIHR5cGVPZmZzZXQgPCA2AHNpbGsvZW5jb2RlX2luZGljZXMuYwBhc3NlcnRpb24gZmFpbGVkOiBlbmNvZGVfTEJSUiA9PSAwIHx8IHR5cGVPZmZzZXQgPj0gMgBhc3NlcnRpb24gZmFpbGVkOiBwc0VuY0MtPnBzTkxTRl9DQi0+b3JkZXIgPT0gcHNFbmNDLT5wcmVkaWN0TFBDT3JkZXIACAoMEAAAAAAAAAB9MxoSDwwLCgkIBwYFBAMCAQDGaS0WDwwLCgkIBwYFBAMCAQDVonRTOysgGBIPDAkHBgUDAgDvu3Q7HBALCgkIBwYFBAMCAQD65byHVjMeEw0KCAYFBAMCAQD569W5nIBnU0I1KiEaFRENCgD++evOpHZNLhsQCgcFBAMCAQD//fnv3L+cd1U5JRcPCgYEAgD//fv27d/Ls5h8Yks3KB0VDwD//v333KJqQyocEgwJBgQDAg==");
  base64DecodeToExistingUint8Array(bufferView, 8320, "HzlroM3N////////////////RS9Db6bN////////////////UkpPX22AkaCtzc3N4P//4P/gfUo7RWGNtv//////////////rXNVSUxcc5GtzeDg////////poZxZmVma3Z9ipGbprbAwM2W4LaGZVNPVWF4ka3N4P///////+DAlnhlXFldZnaGoLbA4ODg/+DgtpuGdm1oZmpvdoORoK2D");
  base64DecodeToExistingUint8Array(bufferView, 8496, "8b6yhFdKKQ4A38GdjGo5JxI=");
  base64DecodeToExistingUint8Array(bufferView, 8528, "g0qNT1CKX2iGX2NbfV1Me3N7");
  base64DecodeToExistingUint8Array(bufferView, 8560, "gADWKgDrgBUA9LhICwD41oAqBwD44apQGQUA++zGfjYSAwD67tOfUiMPBQD658uogFg1GQYA/O7YuZRsRygSBAD98+HHpoBaOR8NAwD+9unUt5NtSSwXCgIA//rw38amgFo6IRAGAQD/+/Tn0rWSbksuGQwFAQD//fju3cSkgFw8IxIIAwEA//358uXQtJJuTDAbDgcDAQ==");
  base64DecodeToExistingUint8Array(bufferView, 8720, "gQDPMgDsgRQA9blICgD51YEqBgD64qlXGwQA++nCgj4UBAD67M+gYy8RAwD/8Nm2g1EpCwEA//7pyZ9rPRQCAQD/+enOqoBWMhcHAQD/+u7ZupRsRicSBgEA//zz4simgFo4Hg0EAQD//PXn0bSSbkwvGQsEAQD//fjt28KjgF0+JRMIAwEA//768eLNsZFvTzMeDwYCAQ==");
  base64DecodeToExistingUint8Array(bufferView, 8880, "gQDLNgDqgRcA9bhJCgD614EpBQD86K1WGAMA/fDIgTgPAgD99NmkXiYKAQD99eK9hEcbBwEA/fbny59pOBcGAQD/+OvVs4VVLxMFAQD//vPdwp91RiUMAgEA//746tCrgFUwFggCAQD//vrw3L2Va0MkEAYCAQD//vvz48mmgFo3HQ0FAgEA//789urVt5NtSSsWCgQCAQ==");
  base64DecodeToExistingUint8Array(bufferView, 9040, "ggDIOgDnghoA9LhMDAD51oIrBgD86K1XGAMA/fHLgzgOAgD+9t2nXiMIAQD++ejBgkEXBQEA//vv06JjLQ8EAQD/+/PfuoNKIQsDAQD//PXmyp5pORgIAgEA//3369azhFQsEwcCAQD//vrw38SfcEUkDwYCAQD//v3159GwiF03GwsDAgEA//79/O/dwp51TCoSBAMCAQ==");
  base64DecodeToExistingUint8Array(bufferView, 9202, "AgUJDhQbIyw2QU1aaHeH");
  base64DecodeToExistingUint8Array(bufferView, 9232, "/jFDTVJdY8YLEhgfJC3/LkJOV15o0A4VICozQv9eaG1wc3b4NUVQWF9mYXNzZXJ0aW9uIGZhaWxlZDogX2Z0PjEAY2VsdC9lbnRkZWMuYwBhc3NlcnRpb24gZmFpbGVkOiBmcmFtZV9sZW5ndGggPT0gMTIgKiAxMABzaWxrL2VuY29kZV9wdWxzZXMuYwBhc3NlcnRpb24gZmFpbGVkOiB3aW5fdHlwZSA9PSAxIHx8IHdpbl90eXBlID09IDIAc2lsay9mbG9hdC9hcHBseV9zaW5lX3dpbmRvd19GTFAuYwBhc3NlcnRpb24gZmFpbGVkOiAoIGxlbmd0aCAmIDMgKSA9PSAwAGFzc2VydGlvbiBmYWlsZWQ6IG9yZGVyID49IDAgJiYgb3JkZXIgPD0gU0lMS19NQVhfT1JERVJfTFBDAHNpbGsvZmxvYXQvc2NodXJfRkxQLmMAYXNzZXJ0aW9uIGZhaWxlZDogT3JkZXIgPD0gbGVuZ3RoAHNpbGsvZmxvYXQvTFBDX2FuYWx5c2lzX2ZpbHRlcl9GTFAuYwBhc3NlcnRpb24gZmFpbGVkOiAwAGNlbHQvY2VsdF9scGMuYwBhc3NlcnRpb24gZmFpbGVkOiBuPjAAYXNzZXJ0aW9uIGZhaWxlZDogb3ZlcmxhcD49MABhc3NlcnRpb24gZmFpbGVkOiBtYXhfcGl0Y2g+MABjZWx0L3BpdGNoLmMAYXNzZXJ0aW9uIGZhaWxlZDogbGVuPjA=");
  base64DecodeToExistingUint8Array(bufferView, 9816, "AwAAAAIAAAADAAAAAgAAAAUAAAACAAAAAwAAAAIAAAADAAAAAgAAAAUAAAACAAAAAwAAAAIAAABhc3NlcnRpb24gZmFpbGVkOiBsZW4+PTMALi9jZWx0L3BpdGNoLmgAYXNzZXJ0aW9uIGZhaWxlZDogSyA+IDAAc2lsay9mbG9hdC9zb3J0X0ZMUC5jAGFzc2VydGlvbiBmYWlsZWQ6IEwgPiAwAGFzc2VydGlvbiBmYWlsZWQ6IEwgPj0gSwAAAQAAAAEAAAAAAAH/Af8C/gL+A/0AAQAB/wL/Av4D/gP9B/4HAAAAAAAC////AAABAQABAAEAAAAAAAEAAAAAAAEAAAABAAAAAAD/AgEAAQEAAP//AAAAAAAAAf8AAf8A/wH+Av7+Av0CA/38A/wEBPsF+vsG+QYFCPcAAAEAAAAAAAAA/wEAAAH/AAH//wH/AgH/Av7+Av4CAgP9AAEAAAAAAAABAAEAAAH/AQAAAgH/Av//Av8CAv8D/v7+AwABAAABAAH/Av8C/wID/gP+/gQE/QX9/Ab8BgX7CPr7+QkAAAAAAAAAAPsI/wb/BvwK+gr+Bv8G+wr3DP0H/gf5DRAYImFzc2VydGlvbiBmYWlsZWQ6IEZzX2tIeiA9PSA4IHx8IEZzX2tIeiA9PSAxMiB8fCBGc19rSHogPT0gMTYAc2lsay9mbG9hdC9waXRjaF9hbmFseXNpc19jb3JlX0ZMUC5jAGFzc2VydGlvbiBmYWlsZWQ6IGNvbXBsZXhpdHkgPj0gU0lMS19QRV9NSU5fQ09NUExFWABhc3NlcnRpb24gZmFpbGVkOiBjb21wbGV4aXR5IDw9IFNJTEtfUEVfTUFYX0NPTVBMRVgAYXNzZXJ0aW9uIGZhaWxlZDogRnNfa0h6ID09IDgAYXNzZXJ0aW9uIGZhaWxlZDogdGFyZ2V0X3B0ciArIHNmX2xlbmd0aF84a0h6IDw9IGZyYW1lXzRrSHogKyBmcmFtZV9sZW5ndGhfNGtIegBhc3NlcnRpb24gZmFpbGVkOiBiYXNpc19wdHIgPj0gZnJhbWVfNGtIegBhc3NlcnRpb24gZmFpbGVkOiBiYXNpc19wdHIgKyBzZl9sZW5ndGhfOGtIeiA8PSBmcmFtZV80a0h6ICsgZnJhbWVfbGVuZ3RoXzRrSHoAYXNzZXJ0aW9uIGZhaWxlZDogbGVuZ3RoX2Rfc3JjaCA+IDAAYXNzZXJ0aW9uIGZhaWxlZDogKmxhZ0luZGV4ID49IDAAYXNzZXJ0aW9uIGZhaWxlZDogbmJfc3ViZnIgPT0gUEVfTUFYX05CX1NVQkZSID4+IDEAYXNzZXJ0aW9uIGZhaWxlZDogYnVmX2xlbiA+PSBwc0VuYy0+c0Ntbi5waXRjaF9MUENfd2luX2xlbmd0aABzaWxrL2Zsb2F0L2ZpbmRfcGl0Y2hfbGFnc19GTFAuYw==");
  base64DecodeToExistingUint8Array(bufferView, 10934, "4D8AAAAAAADgv2Fzc2VydGlvbiBmYWlsZWQ6ICggb3JkZXIgJiAxICkgPT0gMABzaWxrL2Zsb2F0L3dhcnBlZF9hdXRvY29ycmVsYXRpb25fRkxQLmMAAAAAXT1/Zp6g5j8AAAAAAIg5PUQXdfpSsOY/AAAAAAAA2Dz+2Qt1EsDmPwAAAAAAeCi9v3bU3dzP5j8AAAAAAMAePSkaZTyy3+Y/AAAAAAAA2LzjOlmYku/mPwAAAAAAALy8hpNR+X3/5j8AAAAAANgvvaMt9GZ0D+c/AAAAAACILL3DX+zodR/nPwAAAAAAwBM9Bc/qhoIv5z8AAAAAADA4vVKBpUiaP+c/AAAAAADAAL38zNc1vU/nPwAAAAAAiC898WdCVutf5z8AAAAAAOADPUhtq7EkcOc/AAAAAADQJ704Xd5PaYDnPwAAAAAAAN28AB2sOLmQ5z8AAAAAAADjPHgB63MUoec/AAAAAAAA7bxg0HYJe7HnPwAAAAAAQCA9M8EwAe3B5z8AAAAAAACgPDaG/2Jq0uc/AAAAAACQJr07Ts828+LnPwAAAAAA4AK96MORhIfz5z8AAAAAAFgkvU4bPlQnBOg/AAAAAAAAMz0aB9Gt0hToPwAAAAAAAA89fs1MmYkl6D8AAAAAAMAhvdBCuR5MNug/AAAAAADQKT21yiNGGkfoPwAAAAAAEEc9vFufF/RX6D8AAAAAAGAiPa+RRJvZaOg/AAAAAADEMr2VozHZynnoPwAAAAAAACO9uGWK2ceK6D8AAAAAAIAqvQBYeKTQm+g/AAAAAAAA7bwjoipC5azoPwAAAAAAKDM9+hnWugW+6D8AAAAAALRCPYNDtRYyz+g/AAAAAADQLr1MZgheauDoPwAAAAAAUCC9B3gVma7x6D8AAAAAACgoPQ4sKND+Auk/AAAAAACwHL2W/5ELWxTpPwAAAAAA4AW9+S+qU8Ml6T8AAAAAAED1PErGzbA3N+k/AAAAAAAgFz2umF8ruEjpPwAAAAAAAAm9y1LIy0Ra6T8AAAAAAGglPSFvdprda+k/AAAAAADQNr0qTt6fgn3pPwAAAAAAAAG9oyN65DOP6T8AAAAAAAAtPQQGynDxoOk/AAAAAACkOL2J/1NNu7LpPwAAAAAAXDU9W/GjgpHE6T8AAAAAALgmPcW4Sxl01uk/AAAAAAAA7LyOI+MZY+jpPwAAAAAA0Bc9AvMHjV766T8AAAAAAEAWPU3lXXtmDOo/AAAAAAAA9bz2uI7teh7qPwAAAAAA4Ak9Jy5K7Jsw6j8AAAAAANgqPV0KRoDJQuo/AAAAAADwGr2bJT6yA1XqPwAAAAAAYAs9E2L0ikpn6j8AAAAAAIg4PaezMBOeeeo/AAAAAAAgET2NLsFT/ovqPwAAAAAAwAY90vx5VWue6j8AAAAAALgpvbhvNSHlsOo/AAAAAABwKz2B89O/a8PqPwAAAAAAANk8gCc8Ov/V6j8AAAAAAADkPKPSWpmf6Oo/AAAAAACQLL1n8yLmTPvqPwAAAAAAUBY9kLeNKQcO6z8AAAAAANQvPamJmmzOIOs/AAAAAABwEj1LGk+4ojPrPwAAAAAAR00950e3FYRG6z8AAAAAADg4vTpZ5Y1yWes/AAAAAAAAmDxqxfEpbmzrPwAAAAAA0Ao9UF778nZ/6z8AAAAAAIDePLJJJ/KMkus/AAAAAADABL0DBqEwsKXrPwAAAAAAcA29Zm+at+C46z8AAAAAAJANPf/BS5AezOs/AAAAAACgAj1vofPDad/rPwAAAAAAeB+9uB3XW8Ly6z8AAAAAAKAQvemyQWEoBuw/AAAAAABAEb3gUoXdmxnsPwAAAAAA4As97mT62Rwt7D8AAAAAAEAJvS/Q/1+rQOw/AAAAAADQDr0V/fp4R1TsPwAAAAAAZjk9y9BXLvFn7D8AAAAAABAavbbBiImoe+w/AAAAAIBFWL0z5waUbY/sPwAAAAAASBq938RRV0Cj7D8AAAAAAADLPJSQ79wgt+w/AAAAAABAAT2JFm0uD8vsPwAAAAAAIPA8EsRdVQvf7D8AAAAAAGDzPDurW1sV8+w/AAAAAACQBr28iQdKLQftPwAAAAAAoAk9+sgIK1Mb7T8AAAAAAOAVvYWKDQiHL+0/AAAAAAAoHT0DosrqyEPtPwAAAAAAoAE9kaT73BhY7T8AAAAAAADfPKHmYuh2bO0/AAAAAACgA71Og8kW44DtPwAAAAAA2Ay9kGD/cV2V7T8AAAAAAMD0PK4y2wPmqe0/AAAAAACQ/zwlgzrWfL7tPwAAAAAAgOk8RbQB8yHT7T8AAAAAACD1vL8FHGTV5+0/AAAAAABwHb3smnszl/ztPwAAAAAAFBa9Xn0Za2cR7j8AAAAAAEgLPeej9RRGJu4/AAAAAADOQD1c7hY7MzvuPwAAAAAAaAw9tD+L5y5Q7j8AAAAAADAJvWhtZyQ5Ze4/AAAAAAAA5bxETMf7UXruPwAAAAAA+Ae9JrfNd3mP7j8AAAAAAHDzvOiQpKKvpO4/AAAAAADQ5TzkynyG9LnuPwAAAAAAGhY9DWiOLUjP7j8AAAAAAFD1PBSFGKKq5O4/AAAAAABAxjwTWmHuG/ruPwAAAAAAgO68BkG2HJwP7z8AAAAAAIj6vGO5azcrJe8/AAAAAACQLL11ct1IyTrvPwAAAAAAAKo8JEVuW3ZQ7z8AAAAAAPD0vP1EiHkyZu8/AAAAAACAyjw4vpyt/XvvPwAAAAAAvPo8gjwkAtiR7z8AAAAAAGDUvI6QnoHBp+8/AAAAAAAMC70R1ZI2ur3vPwAAAAAA4MC8lHGPK8LT7z8AAAAAgN4Qve4jKmvZ6e8/AAAAAABD7jwAAAAAAADwPwAAAAAAAAAAvrxa+hoL8D8AAAAAAECzvAMz+6k9FvA/AAAAAAAXEr2CAjsUaCHwPwAAAAAAQLo8bIB3Ppos8D8AAAAAAJjvPMq7ES7UN/A/AAAAAABAx7yJf27oFUPwPwAAAAAAMNg8Z1T2cl9O8D8AAAAAAD8avVqFFdOwWfA/AAAAAACEAr2VHzwOCmXwPwAAAAAAYPE8GvfdKWtw8D8AAAAAACQVPS2ocivUe/A/AAAAAACg6bzQm3UYRYfwPwAAAAAAQOY8yAdm9r2S8D8AAAAAAHgAvYPzxso+nvA/AAAAAAAAmLwwOR+bx6nwPwAAAAAAoP88/Ij5bFi18D8AAAAAAMj6vIps5EXxwPA/AAAAAADA2TwWSHIrkszwPwAAAAAAIAU92F05IzvY8D8AAAAAAND6vPPR0zLs4/A/AAAAAACsGz2mqd9fpe/wPwAAAAAA6AS98NL+r2b78D8AAAAAADANvUsj1ygwB/E/AAAAAABQ8TxbWxLQARPxPwAAAAAAAOw8+Speq9se8T8AAAAAALwWPdUxbMC9KvE/AAAAAABA6Dx9BPIUqDbxPwAAAAAA0A696S2prppC8T8AAAAAAODoPDgxT5OVTvE/AAAAAABA6zxxjqXImFrxPwAAAAAAMAU938NxVKRm8T8AAAAAADgDPRFSfTy4cvE/AAAAAADUKD2fu5WG1H7xPwAAAAAA0AW9k42MOPmK8T8AAAAAAIgcvWZdN1gml/E/AAAAAADwET2ny2/rW6PxPwAAAAAASBA944cT+Jmv8T8AAAAAADlHvVRdBITgu/E/AAAAAADkJD1DHCiVL8jxPwAAAAAAIAq9srloMYfU8T8AAAAAAIDjPDFAtF7n4PE/AAAAAADA6jw42fwiUO3xPwAAAAAAkAE99804hMH58T8AAAAAAHgbvY+NYog7BvI/AAAAAACULT0eqHg1vhLyPwAAAAAAANg8Qd19kUkf8j8AAAAAADQrPSMTeaLdK/I/AAAAAAD4GT3nYXVuejjyPwAAAAAAyBm9JxSC+x9F8j8AAAAAADACPQKmsk/OUfI/AAAAAABIE72wzh5xhV7yPwAAAAAAcBI9Fn3iZUVr8j8AAAAAANARPQ/gHTQOePI/AAAAAADuMT0+Y/Xh34TyPwAAAAAAwBS9MLuRdbqR8j8AAAAAANgTvQnfH/WdnvI/AAAAAACwCD2bDtFmiqvyPwAAAAAAfCK9Otra0H+48j8AAAAAADQqPfkadzl+xfI/AAAAAACAEL3ZAuSmhdLyPwAAAAAA0A69eRVkH5bf8j8AAAAAACD0vM8uPqmv7PI/AAAAAACYJL0iiL1K0vnyPwAAAAAAMBa9JbYxCv4G8z8AAAAAADYyvQul7u0yFPM/AAAAAIDfcL2410z8cCHzPwAAAAAASCK9oumoO7gu8z8AAAAAAJglvWYXZLIIPPM/AAAAAADQHj0n+uNmYknzPwAAAAAAANy8D5+SX8VW8z8AAAAAANgwvbmI3qIxZPM/AAAAAADIIj05qjo3p3HzPwAAAAAAYCA9/nQeIyZ/8z8AAAAAAGAWvTjYBW2ujPM/AAAAAADgCr3DPnEbQJrzPwAAAAAAckS9IKDlNNun8z8AAAAAACAIPZVu7L9/tfM/AAAAAACAPj3yqBPDLcPzPwAAAAAAgO88IuHtROXQ8z8AAAAAAKAXvbs0Ekym3vM/AAAAAAAwJj3MThzfcOzzPwAAAAAApki9jH6sBEX68z8AAAAAANw8vbugZ8MiCPQ/AAAAAAC4JT2VLvchChb0PwAAAAAAwB49RkYJJ/sj9D8AAAAAAGATvSCpUNn1MfQ/AAAAAACYIz3ruYQ/+j/0PwAAAAAAAPo8GYlhYAhO9D8AAAAAAMD2vAHSp0IgXPQ/AAAAAADAC70WAB3tQWr0PwAAAAAAgBK9JjOLZm149D8AAAAAAOAwPQA8wbWihvQ/AAAAAABALb0Er5Lh4ZT0PwAAAAAAIAw9ctPX8Cqj9D8AAAAAAFAevQG4bep9sfQ/AAAAAACABz3hKTbV2r/0PwAAAAAAgBO9MsEXuEHO9D8AAAAAAIAAPdvd/Zmy3PQ/AAAAAABwLD2Wq9iBLev0PwAAAAAA4By9Ai2ddrL59D8AAAAAACAZPcExRX9BCPU/AAAAAADACL0qZs+i2hb1PwAAAAAAAPq86lE/6H0l9T8AAAAAAAhKPdpOnVYrNPU/AAAAAADYJr0arPb04kL1PwAAAAAARDK925RdyqRR9T8AAAAAADxIPWsR6d1wYPU/AAAAAACwJD3eKbU2R2/1PwAAAAAAWkE9DsTi2yd+9T8AAAAAAOApvW/Hl9QSjfU/AAAAAAAII71MC/8nCJz1PwAAAAAA7E09J1RI3Qer9T8AAAAAAADEvPR6qPsRuvU/AAAAAAAIMD0LRlmKJsn1PwAAAAAAyCa9P46ZkEXY9T8AAAAAAJpGPeEgrRVv5/U/AAAAAABAG73K69wgo/b1PwAAAAAAcBc9uNx2ueEF9j8AAAAAAPgmPRX3zeYqFfY/AAAAAAAAAT0xVTqwfiT2PwAAAAAA0BW9tSkZHd0z9j8AAAAAANASvRPDzDRGQ/Y/AAAAAACA6rz6jrz+uVL2PwAAAAAAYCi9lzNVgjhi9j8AAAAAAP5xPY4yCMfBcfY/AAAAAAAgN71+qUzUVYH2PwAAAAAAgOY8cZSesfSQ9j8AAAAAAHgpvQAg/h/2H+of2B/CH6gfiB9iHzofCh/YHqAeYh4iHtwdkB1CHe4clhw6HNgbchsKG5waKhq0GToZvBg8GLYXLhegFhAWfhXoFE4UsBMQE24SyBEeEXQQxg8WD2QOrg34DEAMhAvICgoKSgmKCMYHAgc+BngFsgTqAyIDWgKSAcoAAAA2/27+pv3e/Bb8TvuI+sL5/vg6+Hb3tvb29Tj1fPTA8wjzUvKc8erwOvCM7+LuOO6S7fDsUOyy6xjrgurw6WDp0uhK6MTnROfG5kzm1uVk5fbkjuQo5MbjauMS477icOIk4t7hnuFg4Sjh9uDG4J7geOBY4D7gKOAW4ArgAuAA4A==");
  base64DecodeToExistingUint8Array(bufferView, 15393, "DwgHBAsMAwINCgUGCQ4BAAkGAwQFCAECB2Fzc2VydGlvbiBmYWlsZWQ6IGQ9PTEwIHx8IGQ9PTE2AHNpbGsvTkxTRjJBLmMAYXNzZXJ0aW9uIGZhaWxlZDogRCA+IDAAc2lsay9OTFNGX1ZRX3dlaWdodHNfbGFyb2lhLmMAYXNzZXJ0aW9uIGZhaWxlZDogKCBEICYgMSApID09IDAAYXNzZXJ0aW9uIGZhaWxlZDogaWZhY3RfUTIgPj0gMABzaWxrL2ludGVycG9sYXRlLmMAYXNzZXJ0aW9uIGZhaWxlZDogaWZhY3RfUTIgPD0gNABhc3NlcnRpb24gZmFpbGVkOiBLID4gMABzaWxrL3NvcnQuYwBhc3NlcnRpb24gZmFpbGVkOiBMID4gMABhc3NlcnRpb24gZmFpbGVkOiBMID49IEsAYXNzZXJ0aW9uIGZhaWxlZDogKCBMUENfb3JkZXIgJiAxICkgPT0gMABzaWxrL05MU0ZfVlEuYwBhc3NlcnRpb24gZmFpbGVkOiBzaWduYWxUeXBlID49IDAgJiYgc2lnbmFsVHlwZSA8PSAyAHNpbGsvTkxTRl9lbmNvZGUuYwBhc3NlcnRpb24gZmFpbGVkOiBwc0VuY0MtPnVzZUludGVycG9sYXRlZE5MU0ZzID09IDEgfHwgcHNFbmNDLT5pbmRpY2VzLk5MU0ZJbnRlcnBDb2VmX1EyID09ICggMSA8PCAyICkAc2lsay9wcm9jZXNzX05MU0ZzLmMAYXNzZXJ0aW9uIGZhaWxlZDogTkxTRl9tdV9RMjAgPiAwAGFzc2VydGlvbiBmYWlsZWQ6IHBzRW5jQy0+cHJlZGljdExQQ09yZGVyIDw9IE1BWF9MUENfT1JERVIAYXNzZXJ0aW9uIGZhaWxlZDogZCA+PSA2AHNpbGsvTFBDX2FuYWx5c2lzX2ZpbHRlci5jAGFzc2VydGlvbiBmYWlsZWQ6IChkICYgMSkgPT0gMABhc3NlcnRpb24gZmFpbGVkOiBkIDw9IGxlbgBhc3NlcnRpb24gZmFpbGVkOiBzdGFydF9pZHggPiAwAHNpbGsvTlNRX2RlbF9kZWMuYwBhc3NlcnRpb24gZmFpbGVkOiBuU3RhdGVzRGVsYXllZERlY2lzaW9uID4gMABhc3NlcnRpb24gZmFpbGVkOiAoIHNoYXBpbmdMUENPcmRlciAmIDEgKSA9PSAwAGFzc2VydGlvbiBmYWlsZWQ6IHN0YXJ0X2lkeCA+IDAAc2lsay9OU1EuYwBhc3NlcnRpb24gZmFpbGVkOiAoIHNoYXBpbmdMUENPcmRlciAmIDEgKSA9PSAwAGFzc2VydGlvbiBmYWlsZWQ6IGxhZyA+IDAgfHwgc2lnbmFsVHlwZSAhPSBUWVBFX1ZPSUNFRABhc3NlcnRpb24gZmFpbGVkOiBzdWJmcl9sZW5ndGggKiBuYl9zdWJmciA8PSBNQVhfRlJBTUVfU0laRQBzaWxrL2Zsb2F0L2J1cmdfbW9kaWZpZWRfRkxQLmMAYXNzZXJ0aW9uIGZhaWxlZDogcHNFbmNDLT5pbmRpY2VzLk5MU0ZJbnRlcnBDb2VmX1EyID09IDQgfHwgKCBwc0VuY0MtPnVzZUludGVycG9sYXRlZE5MU0ZzICYmICFwc0VuY0MtPmZpcnN0X2ZyYW1lX2FmdGVyX3Jlc2V0ICYmIHBzRW5jQy0+bmJfc3ViZnIgPT0gTUFYX05CX1NVQkZSICkAc2lsay9mbG9hdC9maW5kX0xQQ19GTFAuYwBhc3NlcnRpb24gZmFpbGVkOiBwc0VuYy0+c0Ntbi5sdHBfbWVtX2xlbmd0aCAtIHBzRW5jLT5zQ21uLnByZWRpY3RMUENPcmRlciA+PSBwc0VuY0N0cmwtPnBpdGNoTFsgMCBdICsgTFRQX09SREVSIC8gMgBzaWxrL2Zsb2F0L2ZpbmRfcHJlZF9jb2Vmc19GTFAuYwBhc3NlcnRpb24gZmFpbGVkOiBzUmFuZ2VFbmNfY29weTIub2ZmcyA8PSAxMjc1AHNpbGsvZmxvYXQvZW5jb2RlX2ZyYW1lX0ZMUC5jAGFzc2VydGlvbiBmYWlsZWQ6IHBzUmFuZ2VFbmMtPm9mZnMgPD0gMTI3NQ==");
  base64DecodeToExistingUint8Array(bufferView, 17025, "Dyc0PURKT1RYXF9jZmlsb3J1d3p8foGDhYeJi46PkZOVl5mbnZ6goqOlp6iqq62usLGztLa3ubq7vb7AwcLExcfIycvMzc/Q0dPU1dfY2dvc3d/g4ePk5ufo6uvs7u/x8vP19vj5+vz9/wAAAAAAAAAcKzQ7QUZKTlFVV1pdX2JkZmlrbW9xc3R2eHp7fX+AgoOFhoiJioyNj5CRk5SVl5iZmpydnp+goqOkpaanqKmrrK2ur7CxsrO0tba3uLm6u7y8vb6/wMHCw8TFxsfIycrLy8zNzs/Q0dLT1NXW1tfY2drb3N3e3+Dg4eLj5OXm5+jp6uvs7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAAAAAAAAAAgdKTE4PkJGSk1QU1ZYW11fYWNlZ2lrbG5wcXN0dnd5ent9fn+BgoOEhoeIiYqMjY6PkJGSk5SVlpeYmZqcnZ6fn6ChoqOkpaanqKmqq6usra6vsLGxsrO0tbW2t7i5ubq7vL29vr/AwMHCw8PExcbGx8jIycrLy8zNzs7P0NHR0tPT1NXW1tfY2Nna29vc3d3e3+Dg4eLi4+Tl5ebn6Ojp6urr7O3t7u/w8PHy8/P09fb29/j5+fr7/P3/YXNzZXJ0aW9uIGZhaWxlZDogMABzaWxrL2VuY19BUEkuYwBhc3NlcnRpb24gZmFpbGVkOiAhcmV0AGFzc2VydGlvbiBmYWlsZWQ6IGVuY0NvbnRyb2wtPm5DaGFubmVsc0ludGVybmFsID09IDEgfHwgcHNFbmMtPnN0YXRlX0Z4eFsgMCBdLnNDbW4uZnNfa0h6ID09IHBzRW5jLT5zdGF0ZV9GeHhbIDEgXS5zQ21uLmZzX2tIegBhc3NlcnRpb24gZmFpbGVkOiBlbmNDb250cm9sLT5uQ2hhbm5lbHNBUEkgPT0gMSAmJiBlbmNDb250cm9sLT5uQ2hhbm5lbHNJbnRlcm5hbCA9PSAxAGFzc2VydGlvbiBmYWlsZWQ6IHBzRW5jLT5zdGF0ZV9GeHhbIDAgXS5zQ21uLmlucHV0QnVmSXggPT0gcHNFbmMtPnN0YXRlX0Z4eFsgMCBdLnNDbW4uZnJhbWVfbGVuZ3RoAGFzc2VydGlvbiBmYWlsZWQ6IGVuY0NvbnRyb2wtPm5DaGFubmVsc0ludGVybmFsID09IDEgfHwgcHNFbmMtPnN0YXRlX0Z4eFsgMSBdLnNDbW4uaW5wdXRCdWZJeCA9PSBwc0VuYy0+c3RhdGVfRnh4WyAxIF0uc0Ntbi5mcmFtZV9sZW5ndGgAAACAuwAAeAAAABUAAAAVAAAAAJpZPwAAAAAAAIA/AACAP8BGAAADAAAACAAAAHgAAAALAAAA8EYAAOBHAAAQSAAAgAcAAAMAAADwSQAAEH4AAEB/AAD4fwAAMEoAAIgBAABQZgAAMGcAAMBo");
  base64DecodeToExistingUint8Array(bufferView, 18114, "AQACAAMABAAFAAYABwAIAAoADAAOABAAFAAYABwAIgAoADAAPABOAGQ=");
  base64DecodeToExistingUint8Array(bufferView, 18181, "WlBLRT84MSgiHRQSCgAAAAAAAAAAbmRaVE5HQTozLScgGhQMAAAAAAAAdm5nXVZQS0ZBOzUvKB8XDwQAAAAAfndwaF9ZU05IQjw2LycgGREMAQAAhn94cmdhW1VOSEI8Ni8pIx0XEAoBkImCfHFrZV9YUkxGQDkzLSchGg8BmJGKhHt1b2liXFZQSkM9NzErJBQBopuUjoV/eXNsZmBaVE1HQTs1Lh4BrKWemI+Jg312cGpkXldRS0U/OC0UyMjIyMjIyMjGwby3sq2oo56ZlIFo");
  base64DecodeToExistingUint8Array(bufferView, 18416, "CAAIAAgACAAQABAAEAAVABUAGAAdACIAJAAAAAAAAABqHI04UrseOghp3DqC7Vc7iWOyOwMqBTww3Dk8tD53PByjnjzR8sU8/obxPJurED0FrSo9hMJGPVPmZD0RiYI9h5+TPcuypT3Rvrg9Or/MPVSv4T0Uivc9DiUHPtn0Ej5fMR8+aNcrPorjOD4wUkY+lB9UPr9HYj6OxnA+sJd/PlJbhz5gD48+mOWWPnnbnj5w7qY+2BuvPvtgtz4Ru78+RifIPrei0D54Ktk+lLvhPgxT6j7e7fI+Bon7Pr4QAj8fWgY/JJ8KP1DeDj8rFhM/QUUXPyVqGz9zgx8/zo8jP+aNJz90fCs/P1ovPxkmMz/n3jY/mYM6PzMTPj/FjEE/d+9EP386SD8nbUs/zoZOP+WGUT/xbFQ/jjhXP2npWT9Ff1w/+vleP3NZYT+vnWM/wcZlP8/UZz8RyGk/0qBrP25fbT9QBG8/9I9wP+YCcj+9XXM/H6F0P7/NdT9X5HY/sOV3P5fSeD/jq3k/c3J6Pycnez/nyns/nV58PzXjfD+cWX0/vcJ9P4Yffj/ecH4/q7d+P8/0fj8mKX8/hlV/P756fz+WmX8/zLJ/PxTHfz8c138/guN/P93sfz+2838/ivh/P8j7fz/W/X8/B/9/P6X/fz/o/38//f9/PwAAgD/gAQAAh4gIO/////8FAGAAAwAgAAQACAACAAQABAAB");
  base64DecodeToExistingUint8Array(bufferView, 18972, "cGkAADBt");
  base64DecodeToExistingUint8Array(bufferView, 18992, "//9/P47/fz9q/n8/k/x/Pwf6fz/I9n8/1vJ/PzDufz/W6H8/yOJ/Pwfcfz+T1H8/a8x/P4/Dfz8Aun8/va9/P8ekfz8dmX8/wIx/P7B/fz/scX8/dmN/P0tUfz9uRH8/3jN/P5oifz+jEH8/+v1+P53qfj+N1n4/y8F+P1asfj8uln4/U39+P8Znfj+GT34/lDZ+P+8cfj+YAn4/j+d9P9PLfT9mr30/RpJ9P3R0fT/xVX0/vDZ9P9UWfT889nw/8tR8P/ayfD9JkHw/62x8P9tIfD8bJHw/qf57P4fYez+0sXs/MIp7P/xhez8XOXs/gg97Pz3lej9Iuno/oo56P01iej9INXo/lAd6PzDZeT8dqnk/Wnp5P+lJeT/IGHk/+eZ4P3u0eD9OgXg/c014P+oYeD+y43c/za13Pzp3dz/5P3c/Cgh3P27Pdj8llnY/L1x2P4whdj885nU/QKp1P5dtdT9CMHU/QfJ0P5SzdD87dHQ/NzR0P4fzcz8ssnM/JnBzP3Ytcz8a6nI/FKZyP2Rhcj8KHHI/BdZxP1ePcT8ASHE///9wP1W3cD8CbnA/BiRwP2LZbz8Vjm8/IEJvP4T1bj8/qG4/U1puP8ALbj+GvG0/pWxtPx0cbT/vymw/G3lsP6EmbD+A02s/u39rP1Araz9A1mo/jIBqPzIqaj8102k/k3tpP00jaT9kymg/2HBoP6gWaD/Vu2c/YGBnP0gEZz+Pp2Y/M0pmPzbsZT+XjWU/Vy5lP3fOZD/1bWQ/1AxkPxKrYz+xSGM/sOViPxCCYj/RHWI/87hhP3dTYT9c7WA/pIZgP04fYD9bt18/y05fP57lXj/Ve14/cBFeP26mXT/SOl0/ms5cP8ZhXD9Z9Fs/UYZbP64XWz9yqFo/nThaPy7IWT8nV1k/h+VYP09zWD9/AFg/F41XPxgZVz+CpFY/Vi9WP5O5VT86Q1U/S8xUP8dUVD+u3FM/AWRTP7/qUj/pcFI/f/ZRP4J7UT/y/1A/z4NQPxoHUD/SiU8/+gtPP5CNTj+UDk4/CY9NP+0OTT9Bjkw/BQ1MPzuLSz/hCEs/+YVKP4MCSj9/fkk/7vlIP890SD8k70c/7WhHPyniRj/aWkY/ANNFP5tKRT+swUQ/MjhEPy+uQz+iI0M/jZhCP+8MQj/IgEE/GvRAP+VmQD8o2T8/5Uo/Pxu8Pj/MLD4/95w9P50MPT++ezw/XOo7P3VYOz8Kxjo/HTM6P62fOT+7Czk/R3c4P1HiNz/aTDc/47Y2P2sgNj90iTU//fE0PwdaND+TwTM/oCgzPzCPMj9C9TE/2FoxP/G/MD+OJDA/r4gvP1XsLj+BTy4/MrItP2kULT8ndiw/a9crPzc4Kz+LmCo/Z/gpP8xXKT+6tig/MhUoPzNzJz+/0CY/1i0mP3mKJT+n5iQ/YUIkP6mdIz99+CI/31IiP8+sIT9NBiE/W18gP/i3Hz8lEB8/4mcePzC/HT8QFh0/gWwcP4TCGz8aGBs/Q20aPwDCGT9RFhk/NmoYP7G9Fz/BEBc/Z2MWP6O1FT92BxU/4VgUP+SpEz9/+hI/s0oSP4CaET/n6RA/6DgQP4SHDz+71Q4/jiMOP/5wDT8Kvgw/swoMP/pWCz/fogo/Y+4JP4Y5CT9JhAg/rM4HP68YBz9UYgY/m6sFP4P0BD8PPQQ/PYUDPw/NAj+GFAI/oVsBP2GiAD+P0f8+p13+Pg7p/D7Cc/s+xv35PhuH+D7BD/c+upf1PgYf9D6opfI+nivxPuyw7z6RNe4+kLnsPug86z6av+k+qUHoPhXD5j7fQ+U+CMTjPpFD4j58wuA+yEDfPni+3T6MO9w+BrjaPuYz2T4ur9c+3ynWPvmj1D59HdM+bpbRPswO0D6Xhs4+0v3MPn10yz6Z6sk+J2DIPijVxj6fScU+ir3DPuwwwj7Go8A+GRa/PuaHvT4t+bs+8Wm6PjLauD7xSbc+L7m1Pu4ntD4vlrI+8gOxPjlxrz4E3q0+VkqsPi+2qj6QIak+eoynPu/2pT7vYKQ+fMqiPpczoT5AnJ8+egSePkRsnD6h05o+kTqZPhahlz4wB5Y+4WyUPinSkj4LN5E+h5uPPp7/jT5RY4w+osaKPpEpiT4gjIc+UO6FPiJQhD6XsYI+sBKBPt7mfj6pp3s+w2d4Pi8ndT7u5XE+BKRuPnNhaz48Hmg+YtpkPuiVYT7PUF4+GgtbPszEVz7mfVQ+azZRPl3uTT6/pUo+klxHPtoSRD6XyEA+zn09PoAyOj6u5jY+XZozPo1NMD5CAC0+fbIpPkJkJj6RFSM+bsYfPtt2HD7aJhk+bdYVPpiFEj5bNA8+uuILPreQCD5UPgU+lOsBPvAw/T0GivY9ceLvPTM66T1PkeI9z+fbPbU91T0Dk849wOfHPfI7wT2cj7o9w+KzPWw1rT2bh6Y9VdmfPZ8qmT1+e5I99suLPQschT2H13w9RnZvPV0UYj3WsVQ9uU5HPRDrOT3lhiw9QCIfPSy9ET2yVwQ9tePtPGAX0zx2Srg8C32dPDKvgjz6wU88/iQaPCoPyTuZpzs7Ln3WudJGcbur3uO7pownvIEpXbzhYom8oDCkvOz9vryzytm84Jb0vDGxB72TFhW9jHsivRPgL70eRD29padKvZ0KWL3+bGW9vs5yveoXgL0byIa97XeNvVwnlL1j1pq9/YShvSYzqL3Z4K69EY61vco6vL3+5sK9qpLJvcg90L1U6Na9SpLdvaQ75L1d5Oq9cozxvd0z+L2a2v69UsACvvwSBr5HZQm+MrcMvroIEL7dWRO+mKoWvur6Gb7QSh2+R5ogvk7pI77hNye+AIYqvqbTLb7TIDG+g200vrW5N75lBTu+k1A+vjqbQb5a5US+8C5Ivvl3S750wE6+XQhSvrNPVb5zlli+nNxbvioiX74bZ2K+batlvh/vaL4sMmy+lHRvvlS2cr5q93W+0zd5vo13fL6Wtn++dXqBvkUZg765t4S+0FWGvojzh77hkIm+2i2LvnDKjL6kZo6+dAKQvt+dkb7kOJO+gdOUvrZtlr6BB5i+4qCZvtc5m75f0py+eWqeviMCoL5emaG+JjCjvn3GpL5gXKa+zvGnvsaGqb5HG6u+UK+svuBCrr711a++j2ixvq36sr5NjLS+bh22vhCut74wPrm+z826vupcvL6C672+lHm/vh8Hwb4jlMK+nyDEvpGsxb74N8e+08LIviJNyr7i1su+E2DNvrXozr7FcNC+QvjRvi1/076DBdW+Q4vWvm0Q2L7/lNm++Rjbvlmc3L4dH96+RqHfvtMi4b7Bo+K+ECTkvr6j5b7MIue+OKHovgAf6r4knOu+ohjtvnqU7r6rD/C+M4rxvhIE875GffS+z/X1vqpt977Z5Pi+WFv6vijR+75HRv2+tbr+vjgXAL+70AC/5IkBv7JCAr8l+wK/O7MDv/ZqBL9TIgW/U9kFv/WPBr84Rge/HfwHv6KxCL/HZgm/jBsKv/DPCr/zgwu/kzcMv9HqDL+snQ2/JFAOvzgCD7/osw+/MmUQvxgWEb+XxhG/sHYSv2MmE7+u1RO/kYQUvw0zFb8f4RW/yI4Wvwg8F7/d6Be/SJUYv0hBGb/c7Bm/BJgav8BCG78P7Ru/8JYcv2NAHb9o6R2//pEevyU6H7/c4R+/I4kgv/ovIb9f1iG/Unwiv9QhI7/jxiO/f2skv6cPJb9csyW/nVYmv2j5Jr+/mye/oD0ovwvfKL//fym/fSAqv4PAKr8RYCu/J/8rv8SdLL/oOy2/ktktv8N2Lr95Ey+/tK8vv3NLML+35jC/f4Exv8sbMr+ZtTK/6k4zv73nM78SgDS/6Bc1vz+vNb8WRja/btw2v0VyN7+cBzi/cZw4v8UwOb+WxDm/5lc6v7LqOr/8fDu/wg48vwOgPL/BMD2/+sA9v61QPr/b3z6/g24/v6X8P79AikC/UxdBv+CjQb/kL0K/YLtCv1NGQ7++0EO/nlpEv/bjRL/CbEW/BfVFv7x8Rr/oA0e/iYpHv50QSL8llki/IBtJv46fSb9vI0q/waZKv4YpS7+8q0u/Yy1Mv3quTL8CL02/+q5Nv2IuTr85rU6/fitPvzOpT79VJlC/5qJQv+QeUb9QmlG/KBVSv22PUr8eCVO/O4JTv8P6U7+3clS/FupUv99gVb8S11W/sExWv7fBVr8nNle/AKpXv0IdWL/sj1i//gFZv3hzWb9Z5Fm/olRav1HEWr9mM1u/4qFbv8MPXL8KfVy/t+lcv8hVXb8+wV2/GCxev1eWXr/5/16//2hfv2jRX78zOWC/YqBgv/MGYb/lbGG/OtJhv/A2Yr8Im2K/gP5iv1lhY7+Sw2O/LCVkvyWGZL9+5mS/N0Zlv06lZb/FA2a/mmFmv82+Zr9eG2e/TXdnv5rSZ79ELWi/S4dov67gaL9vOWm/i5FpvwTpab/ZP2q/CZZqv5Trar97QGu/vJRrv1noa79PO2y/oI1sv0vfbL9PMG2/rYBtv2XQbb91H26/321uv6G7br+7CG+/LlVvv/igb78b7G+/lTZwv2eAcL+QyXC/DxJxv+ZZcb8ToXG/l+dxv3Etcr+gcnK/JrdyvwH7cr8yPnO/uIBzv5TCc7/EA3S/SUR0vyKEdL9Qw3S/0gF1v6g/db/SfHW/ULl1vyH1db9FMHa/vWp2v4ikdr+m3Xa/FhZ3v9lNd7/vhHe/V7t3vxHxd78dJni/elp4vyqOeL8rwXi/ffN4vyEleb8WVnm/XIZ5v/K1eb/a5Hm/EhN6v5pAer9zbXq/nZl6vxbFer/f73q/+Bl7v2FDe78abHu/IpR7v3q7e78g4nu/Fwh8v1wtfL/wUXy/03V8vwWZfL+Gu3y/Vd18v3P+fL/fHn2/mj59v6Ndfb/6e32/n5l9v5K2fb/T0n2/Yu59vz8Jfr9pI36/4Tx+v6dVfr+6bX6/G4V+v8mbfr/EsX6/Dcd+v6Lbfr+F736/tQJ/vzIVf7/8Jn+/Ezh/v3ZIf78nWH+/JGd/v251f78Fg3+/6I9/vxmcf7+Vp3+/X7J/v3S8f7/XxX+/hc5/v4HWf7/I3X+/XeR/vz3qf79q73+/4/N/v6n3f7+7+n+/Gf1/v8T+f7+7/3+/+v9/Pzn+fz+p+X8/S/J/Px7ofz8j238/Wct/P8G4fz9bo38/KIt/Pydwfz9aUn8/vzF/P1gOfz8l6H4/Jr9+P1yTfj/IZH4/aTN+P0H/fT9PyH0/lo59PxRSfT/LEn0/vNB8P+eLfD9NRHw/7/l7P82sez/pXHs/Qwp7P920ej+2XHo/0QF6Py6keT/OQ3k/suB4P9x6eD9MEng/BKd3PwQ5dz9PyHY/5FR2P8bedT/2ZXU/dep0P0RsdD9l63M/2mdzP6Phcj/CWHI/Oc1xPwk/cT80rnA/uxpwP6CEbz/k624/ilBuP5OybT8BEm0/1W5sPxHJaz+3IGs/yXVqP0nIaT85GGk/m2VoP2+wZz+6+GY/fD5mP7iBZT9vwmQ/pABkP1o8Yz+RdWI/TKxhP47gYD9ZEmA/rkFfP5FuXj8DmV0/CMFcP6DmWz/PCVs/mCpaP/tIWT/9ZFg/n35XP+WVVj/QqlU/Y71UP6HNUz+M21I/J+dRP3XwUD95908/NPxOP6v+TT/f/kw/1PxLP4z4Sj8K8kk/UulIP2XeRz9H0UY/+8FFP4SwRD/lnEM/IIdCPzpvQT80VUA/Ezk/P9gaPj+I+jw/Jtg7P7SzOj82jTk/r2Q4PyI6Nz+TDTY/Bd80P3yuMz/5ezI/gkcxPxkRMD/C2C4/f54tP1ZiLD9IJCs/WuQpP5CiKD/rXic/cRkmPyXSJD8JiSM/Iz4iP3XxID8Eox8/0lIeP+QAHT89rRs/4VcaP9MAGT8ZqBc/tE0WP6rxFD/9kxM/sjQSP8zTED9QcQ8/Qg0OP6SnDD98QAs/zdcJP5ptCD/pAQc/vZQFPxkmBD8DtgI/fkQBPxyj/z5uuvw++s75Psrg9j7k7/M+UfzwPhoG7j5HDes+4BHoPu0T5T53E+I+hxDfPiQL3D5YA9k+KvnVPqTs0j7N3c8+r8zMPlK5yT6/o8Y+/ovDPhhywD4WVr0+ADi6PuAXtz699bM+odGwPpWrrT6ig6o+z1mnPicupD6yAKE+edGdPoWgmj7fbZc+jzmUPqADkT4azI0+BZOKPmtYhz5WHIQ+zd6APrY/ez4Qv3Q+uztuPsm1Zz5NLWE+WaJaPv8UVD5RhU0+Y/NGPkZfQD4NyTk+yjAzPpCWLD5y+iU+glwfPtK8GD52GxI+f3gLPgHUBD4dXPw9cg3vPSm84T1maNQ9ThLHPQi6uT24X6w9hAOfPZKlkT0HRoQ9EsptPXoFUz2RPjg9pHUdPfyqAj3Kvc88ViOaPGEOSTzFp7s7PXpWuglG8bsS3WO8UIqnvEEk3bzjXQm9IygkvZbwPr3ytlm96np0vRqeh71C/ZS9yFqivYa2r71XEL29FmjKvZu9173DEOW9aWHyvWWv/71KfQa+aCENvvrDE77tZBq+LgQhvqyhJ75TPS6+ENc0vtJuO76GBEK+GZhIvnkpT76UuFW+VkVcvq7PYr6JV2m+1txvvoBfdr5433y+VK6BvoHrhL44J4i+cmGLviSajr5F0ZG+zQaVvrM6mL7ubJu+dJ2evj3Mob5A+aS+cySovs9Nq75Jda6+2pqxvni+tL4b4Le+uv+6vksdvr7HOMG+JVLEvltpx75hfsq+MJHNvryh0L4AsNO+8bvWvofF2b66zNy+gdHfvtPT4r6p0+W++tDovr3L677qw+6+eLnxvmCs9L6anPe+HIr6vt90/b5tLgC/A6EBvy0SA7/mgQS/LPAFv/pcB79MyAi/HjIKv2yaC78yAQ2/bGYOvxfKD78tLBG/rIwSv5DrE7/VSBW/dqQWv3H+F7/AVhm/Yq0av1ECHL+KVR2/Cacev8v2H7/MRCG/CZEiv3zbI78kJCW//WomvwKwJ78w8yi/hDQqv/pzK7+PsSy/P+0tvwcnL7/jXjC/0JQxv8rIMr/O+jO/2io1v+hYNr/3hDe/Aq84vwfXOb8D/Tq/8SA8v89CPb+aYj6/T4A/v+mbQL9otUG/xsxCvwHiQ78X9US/AwZGv8QUR79WIUi/titJv+EzSr/UOUu/jT1Mvwk/Tb9EPk6/PTtPv/A1UL9aLlG/eSRSv0oYU7/KCVS/9/hUv87lVb9N0Fa/cLhXvzeeWL+cgVm/oGJavz5BW791HVy/Qfdcv6LOXb+Uo16/FHZfvyJGYL+6E2G/2d5hv3+nYr+pbWO/VDFkv37yZL8msWW/SW1mv+UmZ7/43We/gJJov3tEab/o82m/w6BqvwxLa7/A8mu/3pdsv2Q6bb9Q2m2/oHduv1MSb79mqm+/2T9wv6nScL/VYnG/W/Bxvzp7cr9xA3O//Yhzv94LdL8RjHS/lgl1v2uEdb+P/HW/AHJ2v73kdr/GVHe/GMJ3v7IseL+TlHi/u/l4vyhceb/Zu3m/zRh6vwJzer95ynq/Lx97vyRxe79YwHu/yQx8v3ZWfL9fnXy/guF8v+Aifb93YX2/R519v0/Wfb+ODH6/BEB+v7Bwfr+Snn6/qcl+v/Xxfr91F3+/KTp/vxBaf78rd3+/eJF/v/iof7+qvX+/j89/v6Xef7/t6n+/ZvR/vxH7f7/t/n+/6v9/P+X4fz+m5n8/Lcl/P3ygfz+VbH8/eS1/Pyzjfj+xjX4/Cy1+Pz/BfT9SSn0/SMh8Pyg7fD/3ons/vf96P4BRej9ImHk/HtR4PwkFeD8TK3c/RkZ2P6xWdT9OXHQ/OFdzP3ZHcj8TLXE/HAhwP57Ybj+lnm0/QFpsP34Laz9rsmk/GU9oP5bhZj/yaWU/PuhjP4tcYj/qxmA/bSdfPyZ+XT8oy1s/hQ5aP1NIWD+jeFY/i59UPyC9Uj920VA/o9xOP73eTD/b10o/E8hIP3yvRj8ujkQ/QWRCP84xQD/s9j0/tLM7P0JoOT+tFDc/ELk0P4ZVMj8p6i8/FXctP2X8Kj81eig/ofAlP8ZfIz/AxyA/rCgeP6mCGz/U1Rg/SiIWPypoEz+TpxA/pOANP3sTCz85QAg//WYFP+eHAj8tRv8+W3H5PpeR8z4kp+0+RbLnPjyz4T5Mqts+upfVPsl7zz6+Vsk+3yjDPnDyvD63s7Y++2ywPoEeqj6SyKM+c2udPmwHlz7FnJA+xyuKPrm0gz7Hb3o+IWttPhFcYD4pQ1M+/SBGPiD2OD4mwys+pIgePi1HET5X/wM+bmPtPcK90j3aDrg93ledPfuZgj28rE89ZRwaPZkKyTwqpzs8wXjWui1EcbxX1+O8TIEnvZQPXb0VSom9WgakvW27vr0iaNm9Tgv0veNRB74vmBS+99chvqUQL76mQTy+ZGpJvk2KVr7NoGO+UK1wvkWvfb4NU4W+nsiLvg04kr4SoZi+ZgOfvr9epb7Ysqu+af+xvitEuL7YgL6+KrXEvtvgyr6lA9G+RR3XvnUt3b7xM+O+djDpvsAi776NCvW+m+f6vtNcAL84QAO/2x0Gv5v1CL9axwu/95IOv1RYEb9QFxS/zc8Wv6yBGb/QLBy/GtEev21uIb+rBCS/t5Mmv3QbKb/Hmyu/kxQuv7uFML8m7zK/t1A1v1WqN7/j+zm/SkU8v26GPr83v0C/i+9Cv1MXRb91Nke/2kxJv2taS78QX02/s1pPvz5NUb+aNlO/sxZVv3LtVr/Fuli/lX5av9A4XL9i6V2/OJBfv0AtYb9nwGK/nElkv87IZb/rPWe/46hov6cJar8nYGu/VKxsvx/ubb96JW+/WFJwv6t0cb9njHK/f5lzv+ebdL+Vk3W/foB2v5Zid7/UOXi/LwZ5v57Heb8Xfnq/lCl7vw3Ke796X3y/1el8vxhpfb8+3X2/QEZ+vxykfr/M9n6/TT5/v5x6f7+2q3+/mdF/v0Psf7+0+3+/pv9/P5Tjfz+cmn8/zCR/PziCfj/9sn0/P7d8PyqPez/zOno/1Lp4PxEPdz/2N3U/1TVzPwgJcT/xsW4/+TBsP5CGaT8vs2Y/U7djP4STYD9OSF0/RdZZPwM+Vj8rgFI/ZZ1OP16WSj/Ma0Y/ah5CP/muPT9AHjk/DW00PzKcLz+HrCo/654lPz90ID9tLRs/YcsVPw1PED9ouQo/awsFPy6M/j7d1PI+8fLmPn/o2j6mt84+iGLCPk7rtT4qVKk+UZ+cPv3Ojz5t5YI+zslrPmKfUT4wUDc+0+AcPvFVAj5iaM89fACaPST7SD0bpLs883dWu2Q98by7wGO9Z12nvRS93L0D+wi+c38jvjTnPb6kLVi+Jk5yvhIihr6JBZO+NM+fvtV8rL4zDLm+GnvFvlvH0b7N7t2+UO/pvsfG9b6QuQC/JnkGvyQhDL+NsBG/ZiYXv7qBHL+YwSG/FeUmv0rrK79W0zC/W5w1v4NFOr/9zT6//DRDv7x5R799m0u/hJlPvx9zU7+hJ1e/Y7Zav8YeXr8wYGG/D3pkv9hrZ78HNWq/H9Vsv6lLb783mHG/Yrpzv8mxdb8Wfne/9h55vyGUer9V3Xu/Wfp8v/rqfb8Or36/dEZ/vw+xf7/O7n+//////////////////////wAAAAAAAAAAKQApACkAUgBSAHsApADIAN4=");
  base64DecodeToExistingUint8Array(bufferView, 26250, "KQApACkAKQB7AHsAewCkAKQA8AAKARsBJwEpACkAKQApACkAKQApACkAewB7AHsAewDwAPAA8AAKAQoBMQE+AUgBUAF7AHsAewB7AHsAewB7AHsA8ADwAPAA8AAxATEBMQE+AT4BVwFfAWYBbAHwAPAA8ADwAPAA8ADwAPAAMQExATEBMQFXAVcBVwFfAV8BcgF4AX4BgwE=");
  base64DecodeToExistingUint8Array(bufferView, 26416, "KAcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcoDxccHyIkJicpKissLS4vLzEyMzQ1Njc3OTo7PD0+Pz9BQkNERUZHRygUISkwNTk9QEJFR0lLTE5QUlVXWVtcXmBiZWdpa2xucHJ1d3l7fH6AKBcnMzxDSU9TV1teYWRmaWtvc3Z5fH6Bg4eLjpGUlpmbn6OmqayusbMjHDFBTllja3J4foSIjZGVmZ+lq7C0ub3Ax83T2Nzh5ejv9fsVITpPYXB9iZSdpq62vcPJz9nj6/P7ESM/Vmp7i5ilsbvFztbe5u36GR83S1tpdYCKkpqhqK60ub7I0Nfe5evw9f8QJEFZboCQn625xM/Z4ury+gspSmeAl6y/0eHx/wkrT26Ko7rP4/YMJ0dje5CktsbW5PH9CSxRcY6owNbr/wcxWn+gv9z3BjNfhqrL6gcvV3ubuNTtBjRhia7Q8AU5apfA5wU7b57K8wU3Z5O74AU8caHO+ARBeq/gBEN/tuoAAAAAAAAAAODg4ODg4ODgoKCgoLm5ubKyqIY9JeDg4ODg4ODg8PDw8M/Pz8bGt5BCKKCgoKCgoKCgubm5ucHBwbe3rIpAJvDw8PDw8PDwz8/Pz8zMzMHBtI9CKLm5ubm5ubm5wcHBwcHBwbe3rIpBJ8/Pz8/Pz8/PzMzMzMnJyby8sI1CKMHBwcHBwcHBwcHBwcLCwri4rYtBJ8zMzMzMzMzMycnJycbGxru7r4xCKA==");
  base64DecodeToExistingUint8Array(bufferView, 26994, "YADAACABgAEgAIAA4ABAAaABQACgAAABYAHAAQgAaADIACgBiAEoAIgA6ABIAagBSACoAAgBaAHIARAAcADQADABkAEwAJAA8ABQAbABUACwABABcAHQARgAeADYADgBmAE4AJgA+ABYAbgBWAC4ABgBeAHYAQQAZADEACQBhAEkAIQA5ABEAaQBRACkAAQBZAHEAQwAbADMACwBjAEsAIwA7ABMAawBTACsAAwBbAHMARQAdADUADQBlAE0AJQA9ABUAbQBVAC0ABQBdAHUARwAfADcADwBnAE8AJwA/ABcAbwBXAC8ABwBfAHcAQEAYQDBACEBgQEhAIEA4QBBAaEBQQChAAEBYQHBAQkAaQDJACkBiQEpAIkA6QBJAakBSQCpAAkBaQHJAREAcQDRADEBkQExAJEA8QBRAbEBUQCxABEBcQHRARkAeQDZADkBmQE5AJkA+QBZAbkBWQC5ABkBeQHZAQUAZQDFACUBhQElAIUA5QBFAaUBRQClAAUBZQHFAQ0AbQDNAC0BjQEtAI0A7QBNAa0BTQCtAA0BbQHNARUAdQDVADUBlQE1AJUA9QBVAbUBVQC1ABUBdQHVAR0AfQDdAD0BnQE9AJ0A/QBdAb0BXQC9AB0BfQHdAQIAYgDCACIBggEiAIIA4gBCAaIBQgCiAAIBYgHCAQoAagDKACoBigEqAIoA6gBKAaoBSgCqAAoBagHKARIAcgDSADIBkgEyAJIA8gBSAbIBUgCyABIBcgHSARoAegDaADoBmgE6AJoA+gBaAboBWgC6ABoBegHaAQYAZgDGACYBhgEmAIYA5gBGAaYBRgCmAAYBZgHGAQ4AbgDOAC4BjgEuAI4A7gBOAa4BTgCuAA4BbgHOARYAdgDWADYBlgE2AJYA9gBWAbYBVgC2ABYBdgHWAR4AfgDeAD4BngE+AJ4A/gBeAb4BXgC+AB4BfgHeAQMAYwDDACMBgwEjAIMA4wBDAaMBQwCjAAMBYwHDAQsAawDLACsBiwErAIsA6wBLAasBSwCrAAsBawHLARMAcwDTADMBkwEzAJMA8wBTAbMBUwCzABMBcwHTARsAewDbADsBmwE7AJsA+wBbAbsBWwC7ABsBewHbAQcAZwDHACcBhwEnAIcA5wBHAacBRwCnAAcBZwHHAQ8AbwDPAC8BjwEvAI8A7wBPAa8BTwCvAA8BbwHPARcAdwDXADcBlwE3AJcA9wBXAbcBVwC3ABcBdwHXAR8AfwDfAD8BnwE/AJ8A/wBfAb8BXwC/AB8BfwHfAQAAgD8AAACAY/p/P791VryL6X8/CnHWvHnNfz/nziC9L6Z/PzpeVr2vc38/E/KFvfk1fz8qr6C9Eu1+PzNlu739mH4/BBPWvbw5fj9zt/C9Vc99P6ioBb7LWX0/u+8SviXZfD9cMCC+Z018P/VpLb6Ytns/85s6vr4Uez/CxUe+4md6P83mVL4JsHk/gv5hvjzteD9NDG++hB94P5wPfL7qRnc/7oOEvndjdj8++oq+NnV1P3Vqkb4wfHQ/TNSXvnF4cz96N56+A2pyP7eTpL70UHE/vOiqvk8tcD9BNrG+If9uPwF8t752xm0/tLm9vl6DbD8V78O+5zVrP94byr4e3mk/yT/QvhJ8aD+SWta+1A9nP/Nr3L50mWU/qnPivgEZZD9xcei+jY5iPwdl7r4o+mA/J070vuZbXz+QLPq+17NdPwAAAL8PAlw/G+QCv6BGWj93wgW/noFYP/aaCL8ds1Y/d20LvzHbVD/aOQ6/7/lSPwAAEb9sD1E/yr8Tv70bTz8YeRa/+B5NP80rGb80GUs/ytcbv4gKST/xfB6/CvNGPyQbIb/R0kQ/RrIjv/epQj86Qia/k3hAP+PKKL+9Pj4/JUwrv4/8Oz/jxS2/IrI5PwE4ML+QXzc/ZaIyv/MENT/zBDW/ZaIyP5BfN78BODA/IrI5v+PFLT+P/Du/JUwrP70+Pr/jyig/k3hAvzpCJj/3qUK/RrIjP9HSRL8kGyE/CvNGv/F8Hj+ICkm/ytcbPzQZS7/NKxk/+B5Nvxh5Fj+9G0+/yr8TP2wPUb8AABE/7/lSv9o5Dj8x21S/d20LPx2zVr/2mgg/noFYv3fCBT+gRlq/G+QCPw8CXL8AAAA/17Ndv5As+j7mW1+/J070Pij6YL8HZe4+jY5iv3Fx6D4BGWS/qnPiPnSZZb/za9w+1A9nv5Ja1j4SfGi/yT/QPh7eab/eG8o+5zVrvxXvwz5eg2y/tLm9PnbGbb8BfLc+If9uv0E2sT5PLXC/vOiqPvRQcb+3k6Q+A2pyv3o3nj5xeHO/TNSXPjB8dL91apE+NnV1vz76ij53Y3a/7oOEPupGd7+cD3w+hB94v00Mbz487Xi/gv5hPgmweb/N5lQ+4md6v8LFRz6+FHu/85s6Ppi2e7/1aS0+Z018v1wwID4l2Xy/u+8SPstZfb+oqAU+Vc99v3O38D28OX6/BBPWPf2Yfr8zZbs9Eu1+vyqvoD35NX+/E/KFPa9zf786XlY9L6Z/v+fOID15zX+/CnHWPIvpf7+/dVY8Y/p/vwAwjSQAAIC/v3VWvGP6f78Kcda8i+l/v+fOIL15zX+/Ol5WvS+mf78T8oW9r3N/vyqvoL35NX+/M2W7vRLtfr8EE9a9/Zh+v3O38L28OX6/qKgFvlXPfb+77xK+y1l9v1wwIL4l2Xy/9WktvmdNfL/zmzq+mLZ7v8LFR76+FHu/zeZUvuJner+C/mG+CbB5v00Mb7487Xi/nA98voQfeL/ug4S+6kZ3vz76ir53Y3a/dWqRvjZ1db9M1Je+MHx0v3o3nr5xeHO/t5OkvgNqcr+86Kq+9FBxv0E2sb5PLXC/AXy3viH/br+0ub2+dsZtvxXvw75eg2y/3hvKvuc1a7/JP9C+Ht5pv5Ja1r4SfGi/82vcvtQPZ7+qc+K+dJllv3Fx6L4BGWS/B2Xuvo2OYr8nTvS+KPpgv5As+r7mW1+/AAAAv9ezXb8b5AK/DwJcv3fCBb+gRlq/9poIv56BWL93bQu/HbNWv9o5Dr8x21S/AAARv+/5Ur/KvxO/bA9Rvxh5Fr+9G0+/zSsZv/geTb/K1xu/NBlLv/F8Hr+ICkm/JBshvwrzRr9GsiO/0dJEvzpCJr/3qUK/48oov5N4QL8lTCu/vT4+v+PFLb+P/Du/ATgwvyKyOb9lojK/kF83v/MENb/zBDW/kF83v2WiMr8isjm/ATgwv4/8O7/jxS2/vT4+vyVMK7+TeEC/48oov/epQr86Qia/0dJEv0ayI78K80a/JBshv4gKSb/xfB6/NBlLv8rXG7/4Hk2/zSsZv70bT78YeRa/bA9Rv8q/E7/v+VK/AAARvzHbVL/aOQ6/HbNWv3dtC7+egVi/9poIv6BGWr93wgW/DwJcvxvkAr/Xs12/AAAAv+ZbX7+QLPq+KPpgvydO9L6NjmK/B2XuvgEZZL9xcei+dJllv6pz4r7UD2e/82vcvhJ8aL+SWta+Ht5pv8k/0L7nNWu/3hvKvl6DbL8V78O+dsZtv7S5vb4h/26/AXy3vk8tcL9BNrG+9FBxv7zoqr4DanK/t5OkvnF4c796N56+MHx0v0zUl742dXW/dWqRvndjdr8++oq+6kZ3v+6DhL6EH3i/nA98vjzteL9NDG++CbB5v4L+Yb7iZ3q/zeZUvr4Ue7/CxUe+mLZ7v/ObOr5nTXy/9WktviXZfL9cMCC+y1l9v7vvEr5Vz32/qKgFvrw5fr9zt/C9/Zh+vwQT1r0S7X6/M2W7vfk1f78qr6C9r3N/vxPyhb0vpn+/Ol5WvXnNf7/nziC9i+l/vwpx1rxj+n+/v3VWvAAAgL8AMA2lY/p/v791VjyL6X+/CnHWPHnNf7/nziA9L6Z/vzpeVj2vc3+/E/KFPfk1f78qr6A9Eu1+vzNluz39mH6/BBPWPbw5fr9zt/A9Vc99v6ioBT7LWX2/u+8SPiXZfL9cMCA+Z018v/VpLT6Ytnu/85s6Pr4Ue7/CxUc+4md6v83mVD4JsHm/gv5hPjzteL9NDG8+hB94v5wPfD7qRne/7oOEPndjdr8++oo+NnV1v3VqkT4wfHS/TNSXPnF4c796N54+A2pyv7eTpD70UHG/vOiqPk8tcL9BNrE+If9uvwF8tz52xm2/tLm9Pl6DbL8V78M+5zVrv94byj4e3mm/yT/QPhJ8aL+SWtY+1A9nv/Nr3D50mWW/qnPiPgEZZL9xceg+jY5ivwdl7j4o+mC/J070PuZbX7+QLPo+17NdvwAAAD8PAly/G+QCP6BGWr93wgU/noFYv/aaCD8ds1a/d20LPzHbVL/aOQ4/7/lSvwAAET9sD1G/yr8TP70bT78YeRY/+B5Nv80rGT80GUu/ytcbP4gKSb/xfB4/CvNGvyQbIT/R0kS/RrIjP/epQr86QiY/k3hAv+PKKD+9Pj6/JUwrP4/8O7/jxS0/IrI5vwE4MD+QXze/ZaIyP/MENb/zBDU/ZaIyv5BfNz8BODC/IrI5P+PFLb+P/Ds/JUwrv70+Pj/jyii/k3hAPzpCJr/3qUI/RrIjv9HSRD8kGyG/CvNGP/F8Hr+ICkk/ytcbvzQZSz/NKxm/+B5NPxh5Fr+9G08/yr8Tv2wPUT8AABG/7/lSP9o5Dr8x21Q/d20Lvx2zVj/2mgi/noFYP3fCBb+gRlo/G+QCvw8CXD8AAAC/17NdP5As+r7mW18/J070vij6YD8HZe6+jY5iP3Fx6L4BGWQ/qnPivnSZZT/za9y+1A9nP5Ja1r4SfGg/yT/Qvh7eaT/eG8q+5zVrPxXvw75eg2w/tLm9vnbGbT8BfLe+If9uP0E2sb5PLXA/vOiqvvRQcT+3k6S+A2pyP3o3nr5xeHM/TNSXvjB8dD91apG+NnV1Pz76ir53Y3Y/7oOEvupGdz+cD3y+hB94P00Mb7487Xg/gv5hvgmweT/N5lS+4md6P8LFR76+FHs/85s6vpi2ez/1aS2+Z018P1wwIL4l2Xw/u+8SvstZfT+oqAW+Vc99P3O38L28OX4/BBPWvf2Yfj8zZbu9Eu1+PyqvoL35NX8/E/KFva9zfz86Xla9L6Z/P+fOIL15zX8/CnHWvIvpfz+/dVa8Y/p/PwDIU6UAAIA/v3VWPGP6fz8KcdY8i+l/P+fOID15zX8/Ol5WPS+mfz8T8oU9r3N/PyqvoD35NX8/M2W7PRLtfj8EE9Y9/Zh+P3O38D28OX4/qKgFPlXPfT+77xI+y1l9P1wwID4l2Xw/9WktPmdNfD/zmzo+mLZ7P8LFRz6+FHs/zeZUPuJnej+C/mE+CbB5P00Mbz487Xg/nA98PoQfeD/ug4Q+6kZ3Pz76ij53Y3Y/dWqRPjZ1dT9M1Jc+MHx0P3o3nj5xeHM/t5OkPgNqcj+86Ko+9FBxP0E2sT5PLXA/AXy3PiH/bj+0ub0+dsZtPxXvwz5eg2w/3hvKPuc1az/JP9A+Ht5pP5Ja1j4SfGg/82vcPtQPZz+qc+I+dJllP3Fx6D4BGWQ/B2XuPo2OYj8nTvQ+KPpgP5As+j7mW18/AAAAP9ezXT8b5AI/DwJcP3fCBT+gRlo/9poIP56BWD93bQs/HbNWP9o5Dj8x21Q/AAARP+/5Uj/KvxM/bA9RPxh5Fj+9G08/zSsZP/geTT/K1xs/NBlLP/F8Hj+ICkk/JBshPwrzRj9GsiM/0dJEPzpCJj/3qUI/48ooP5N4QD8lTCs/vT4+P+PFLT+P/Ds/ATgwPyKyOT9lojI/kF83P/MENT/zBDU/kF83P2WiMj8isjk/ATgwP4/8Oz/jxS0/vT4+PyVMKz+TeEA/48ooP/epQj86QiY/0dJEP0ayIz8K80Y/JBshP4gKST/xfB4/NBlLP8rXGz/4Hk0/zSsZP70bTz8YeRY/bA9RP8q/Ez/v+VI/AAARPzHbVD/aOQ4/HbNWP3dtCz+egVg/9poIP6BGWj93wgU/DwJcPxvkAj/Xs10/AAAAP+ZbXz+QLPo+KPpgPydO9D6NjmI/B2XuPgEZZD9xceg+dJllP6pz4j7UD2c/82vcPhJ8aD+SWtY+Ht5pP8k/0D7nNWs/3hvKPl6DbD8V78M+dsZtP7S5vT4h/24/AXy3Pk8tcD9BNrE+9FBxP7zoqj4DanI/t5OkPnF4cz96N54+MHx0P0zUlz42dXU/dWqRPndjdj8++oo+6kZ3P+6DhD6EH3g/nA98PjzteD9NDG8+CbB5P4L+YT7iZ3o/zeZUPr4Uez/CxUc+mLZ7P/ObOj5nTXw/9WktPiXZfD9cMCA+y1l9P7vvEj5Vz30/qKgFPrw5fj9zt/A9/Zh+PwQT1j0S7X4/M2W7Pfk1fz8qr6A9r3N/PxPyhT0vpn8/Ol5WPXnNfz/nziA9i+l/Pwpx1jxj+n8/v3VWPAAAMABgAJAAwAAQAEAAcACgANAAIABQAIAAsADgAAQANABkAJQAxAAUAEQAdACkANQAJABUAIQAtADkAAgAOABoAJgAyAAYAEgAeACoANgAKABYAIgAuADoAAwAPABsAJwAzAAcAEwAfACsANwALABcAIwAvADsAAEAMQBhAJEAwQARAEEAcQChANEAIQBRAIEAsQDhAAUANQBlAJUAxQAVAEUAdQClANUAJQBVAIUAtQDlAAkAOQBpAJkAyQAZAEkAeQCpANkAKQBZAIkAuQDpAA0APQBtAJ0AzQAdAE0AfQCtAN0ALQBdAI0AvQDtAAIAMgBiAJIAwgASAEIAcgCiANIAIgBSAIIAsgDiAAYANgBmAJYAxgAWAEYAdgCmANYAJgBWAIYAtgDmAAoAOgBqAJoAygAaAEoAegCqANoAKgBaAIoAugDqAA4APgBuAJ4AzgAeAE4AfgCuAN4ALgBeAI4AvgDuAAMAMwBjAJMAwwATAEMAcwCjANMAIwBTAIMAswDjAAcANwBnAJcAxwAXAEcAdwCnANcAJwBXAIcAtwDnAAsAOwBrAJsAywAbAEsAewCrANsAKwBbAIsAuwDrAA8APwBvAJ8AzwAfAE8AfwCvAN8ALwBfAI8AvwDvAPAAAACJiIg7AQAAAAUAMAADABAABAAEAAQAAQ==");
  base64DecodeToExistingUint8Array(bufferView, 32316, "MHwAADBt");
  base64DecodeToExistingUint8Array(bufferView, 32338, "GAAwAEgAYAAIACAAOABQAGgAEAAoAEAAWABwAAQAHAA0AEwAZAAMACQAPABUAGwAFAAsAEQAXAB0AAEAGQAxAEkAYQAJACEAOQBRAGkAEQApAEEAWQBxAAUAHQA1AE0AZQANACUAPQBVAG0AFQAtAEUAXQB1AAIAGgAyAEoAYgAKACIAOgBSAGoAEgAqAEIAWgByAAYAHgA2AE4AZgAOACYAPgBWAG4AFgAuAEYAXgB2AAMAGwAzAEsAYwALACMAOwBTAGsAEwArAEMAWwBzAAcAHwA3AE8AZwAPACcAPwBXAG8AFwAvAEcAXwB3AHgAAACIiAg8AgAAAAUAGAADAAgAAgAEAAQAAQ==");
  base64DecodeToExistingUint8Array(bufferView, 32620, "UH4AADBt");
  base64DecodeToExistingUint8Array(bufferView, 32642, "DAAYACQAMAAEABAAHAAoADQACAAUACAALAA4AAEADQAZACUAMQAFABEAHQApADUACQAVACEALQA5AAIADgAaACYAMgAGABIAHgAqADYACgAWACIALgA6AAMADwAbACcAMwAHABMAHwArADcACwAXACMALwA7ADwAAACJiIg8AwAAAAUADAADAAQABAAB");
  base64DecodeToExistingUint8Array(bufferView, 32804, "gH8AADBtAAAAAAAAlYsAADeYAAD/pQAABLUAAGfFAABF1wAAweoAAP//AABhc3NlcnRpb24gZmFpbGVkOiBmbCtmczw9MzI3NjgAY2VsdC9sYXBsYWNlLmMAYXNzZXJ0aW9uIGZhaWxlZDogZnM+MA==");
  base64DecodeToExistingUint8Array(bufferView, 32930, "zkAAAMhAAAC4QAAAqkAAAKJAAACaQAAAkEAAAIxAAACcQAAAlkAAAJJAAACOQAAAnEAAAJRAAACKQAAAkEAAAIxAAACUQAAAmEAAAI5AAABwQAAAcEAAAHBAAABwQAAAcEA=");
  base64DecodeToExistingUint8Array(bufferView, 33040, "SH9BgUKAQYBAgD6AQIBAgFxOXE9cTlpPdClzKHIohBqEGpERoQywCrELGLMwijaHNoQ1hjiFN4Q3hD1yRmBKWEtYV0pZQltDZDtsMngoeiVhK04yU05UUVhLVkpXR1pJXUpdSm0ociR1InUijxGREpITogylCrIHvQa+CLEJF7I2cz9mQmJFY0pZR1tJW05ZVlBcQl1AZjtnPGg8dTR7LIojhR9hJk0tPVpdPGkqayluLXQmcSZwJnwahBuIE4wUmw6fEJ4Sqg2xCrsIwAavCZ8KFbI7bkdWS1VUU1tCWElXSFxLYkhpOms2czRyN3A4gTOEKJYhjB1iI00qKnlgQmwrbyh1LHsgeCR3IX8hhiKLFZMXmBSeGZoaphWtELgNuAqWDYsPFrI/ckpSVFNcUmc+YEhgQ2VJa0hxN3Y0fTR2NHU3hzGJJ50gkR1hIU0oAABmPwAATD8AACY/AAAAPwCGaz8AFC4/AHC9PgDQTD4CAQ==");
  base64DecodeToExistingUint8Array(bufferView, 33424, "AwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAABnERwDNZ8MACejcAFmDKgCLdsQAphyWAESv3QAZV9EApT4FAAUH/wAzfj8AwjLoAJhP3gC7fTIAJj3DAB5r7wCf+F4ANR86AH/yygDxhx0AfJAhAGokfADVbvoAMC13ABU7QwC1FMYAwxmdAK3EwgAsTUEADABdAIZ9RgDjcS0Am8aaADNiAAC00nwAtKeXADdV1QDXPvYAoxAYAE12/ABknSoAcNerAGN8+AB6sFcAFxXnAMBJVgA71tkAp4Q4ACQjywDWincAWlQjAAAfuQDxChsAGc7fAJ8x/wBmHmoAmVdhAKz7RwB+f9gAImW3ADLoiQDmv2AA78TNAGw2CQBdP9QAFt7XAFg73gDem5IA0iIoACiG6ADiWE0AxsoyAAjjFgDgfcsAF8BQAPMdpwAY4FsALhM0AIMSYgCDSAEA9Y5bAK2wfwAe6fIASEpDABBn0wCq3dgArl9CAGphzgAKKKQA05m0AAam8gBcd38Ao8KDAGE8iACKc3gAr4xaAG/XvQAtpmMA9L/LAI2B7wAmwWcAVcpFAMrZNgAoqNIAwmGNABLJdwAEJhQAEkabAMRZxADIxUQATbKRAAAX8wDUQ60AKUnlAP3VEAAAvvwAHpTMAHDO7gATPvUA7PGAALPnwwDH+CgAkwWUAMFxPgAuCbMAC0XzAIgSnACrIHsALrWfAEeSwgB7Mi8ADFVtAHKnkABr5x8AMcuWAHkWSgBBeeIA9N+JAOiUlwDi5oQAmTGXAIjtawBfXzYAu/0OAEiatABnpGwAcXJCAI1dMgCfFbgAvOUJAI0xJQD3dDkAMAUcAA0MAQBLCGgALO5YAEeqkAB05wIAvdYkAPd9pgBuSHIAnxbvAI6UpgC0kfYA0VNRAM8K8gAgmDMA9Ut+ALJjaADdPl8AQF0DAIWJfwBVUikAN2TAAG3YEAAySDIAW0x1AE5x1ABFVG4ACwnBACr1aQAUZtUAJwedAF0EUAC0O9sA6nbFAIf5FwBJa30AHSe6AJZpKQDGzKwArRRUAJDiagCI2YkALHJQAASkvgB3B5QA8zBwAAD8JwDqcagAZsJJAGTgPQCX3YMAoz+XAEOU/QANhowAMUHeAJI5nQDdcIwAF7fnAAjfOwAVNysAXICgAFqAkwAQEZIAD+jYAGyArwDb/0sAOJAPAFkYdgBipRUAYcu7AMeJuQAQQL0A0vIEAEl1JwDrtvYA2yK7AAoUqgCJJi8AZIN2AAk7MwAOlBoAUTqqAB2jwgCv7a4AXCYSAG3CTQAtepwAwFaXAAM/gwAJ8PYAK0CMAG0xmQA5tAcADCAVANjDWwD1ksQAxq1LAE7KpQCnN80A5qk2AKuSlADdQmgAGWPeAHaM7wBoi1IA/Ns3AK6hqwDfFTEAAK6hAAz72gBkTWYA7QW3ACllMABXVr8AR/86AGr5uQB1vvMAKJPfAKuAMABmjPYABMsVAPoiBgDZ5B0APbOkAFcbjwA2zQkATkLpABO+pAAzI7UA8KoaAE9lqADSwaUACz8PAFt4zQAj+XYAe4sEAIkXcgDGplMAb27iAO/rAACbSlgAxNq3AKpmugB2z88A0QIdALHxLQCMmcEAw613AIZI2gD3XaAAxoD0AKzwLwDd7JoAP1y8ANDebQCQxx8AKtu2AKMlOgAAr5oArVOTALZXBAApLbQAS4B+ANoHpwB2qg4Ae1mhABYSKgDcty0A+uX9AInb/gCJvv0A5HZsAAap/AA+gHAAhW4VAP2H/wAoPgcAYWczACoYhgBNveoAs+evAI9tbgCVZzkAMb9bAITXSAAw3xYAxy1DACVhNQDJcM4AMMu4AL9s/QCkAKIABWzkAFrdoAAhb0cAYhLSALlchABwYUkAa1bgAJlSAQBQVTcAHtW3ADPxxAATbl8AXTDkAIUuqQAdssMAoTI2AAi3pADqsdQAFvchAI9p5AAn/3cADAOAAI1ALQBPzaAAIKWZALOi0wAvXQoAtPlCABHaywB9vtAAm9vBAKsXvQDKooEACGpcAC5VFwAnAFUAfxTwAOEHhgAUC2QAlkGNAIe+3gDa/SoAayW2AHuJNAAF8/4Aub+eAGhqTwBKKqgAT8RaAC34vADXWpgA9MeVAA1NjQAgOqYApFdfABQ/sQCAOJUAzCABAHHdhgDJ3rYAv2D1AE1lEQABB2sAjLCsALLA0ABRVUgAHvsOAJVywwCjBjsAwEA1AAbcewDgRcwATin6ANbKyADo80EAfGTeAJtk2ADZvjEApJfDAHdY1ABp48UA8NoTALo6PABGGEYAVXVfANK99QBuksYArC5dAA5E7QAcPkIAYcSHACn96QDn1vMAInzKAG+RNQAI4MUA/9eNAG5q4gCw/cYAkwjBAHxddABrrbIAzW6dAD5yewDGEWoA98+pAClz3wC1yboAtwBRAOKyDQB0uiQA5X1gAHTYigANFSwAgRgMAH5mlAABKRYAn3p2AP39vgBWRe8A2X42AOzZEwCLurkAxJf8ADGoJwDxbsMAlMU2ANioVgC0qLUAz8wOABKJLQBvVzQALFaJAJnO4wDWILkAa16qAD4qnAARX8wA/QtKAOH0+wCOO20A4oYsAOnUhAD8tKkA7+7RAC41yQAvOWEAOCFEABvZyACB/AoA+0pqAC8c2ABTtIQATpmMAFQizAAqVdwAwMbWAAsZlgAacLgAaZVkACZaYAA/Uu4AfxEPAPS1EQD8y/UANLwtADS87gDoXcwA3V5gAGeOmwCSM+8AyRe4AGFYmwDhV7wAUYPGANg+EADdcUgALRzdAK8YoQAhLEYAWfPXANl6mACeVMAAT4b6AFYG/ADlea4AiSI2ADitIgBnk9wAVeiqAIImOADK55sAUQ2kAJkzsQCp1w4AaQVIAGWy8AB/iKcAiEyXAPnRNgAhkrMAe4JKAJjPIQBAn9wA3EdVAOF0OgBn60IA/p3fAF7UXwB7Z6QAuqx6AFX2ogAriCMAQbpVAFluCAAhKoYAOUeDAInj5gDlntQASftAAP9W6QAcD8oAxVmKAJT6KwDTwcUAD8XPANtargBHxYYAhUNiACGGOwAseZQAEGGHACpMewCALBoAQ78SAIgmkAB4PIkAqMTkAOXbewDEOsIAJvTqAPdnigANkr8AZaMrAD2TsQC9fAsApFHcACfdYwBp4d0AmpQZAKgplQBozigACe20AESfIABOmMoAcIJjAH58IwAPuTIAp/WOABRW5wAh8QgAtZ0qAG9+TQClGVEAtfmrAILf1gCW3WEAFjYCAMQ6nwCDoqEAcu1tADmNegCCuKkAazJcAEYnWwAANO0A0gB3APz0VQABWU0A4HGA");
  base64DecodeToExistingUint8Array(bufferView, 36211, "QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNWFzc2VydGlvbiBmYWlsZWQ6IF9rPjAAY2VsdC9jd3JzLmM=");
  base64DecodeToExistingUint8Array(bufferView, 36320, "QI4AAACRAAC8kwAAdJYAACiZAADYmwAAhJ4AAOyfAACooAAAHKEAAGihAACgoQAAwKEAANihAADkoQAAYXNzZXJ0aW9uIGZhaWxlZDogX24+PTI=");
  base64DecodeToExistingUint8Array(bufferView, 36416, "AQ==");
  base64DecodeToExistingUint8Array(bufferView, 37124, "AQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAADAAAABQAAAAcAAAAJAAAACwAAAA0AAAAPAAAAEQAAABMAAAAVAAAAFwAAABkAAAAbAAAAHQAAAB8AAAAhAAAAIwAAACUAAAAnAAAAKQAAACsAAAAtAAAALwAAADEAAAAzAAAANQAAADcAAAA5AAAAOwAAAD0AAAA/AAAAQQAAAEMAAABFAAAARwAAAEkAAABLAAAATQAAAE8AAABRAAAAUwAAAFUAAABXAAAAWQAAAFsAAABdAAAAXwAAAGEAAABjAAAAZQAAAGcAAABpAAAAawAAAG0AAABvAAAAcQAAAHMAAAB1AAAAdwAAAHkAAAB7AAAAfQAAAH8AAACBAAAAgwAAAIUAAACHAAAAiQAAAIsAAACNAAAAjwAAAJEAAACTAAAAlQAAAJcAAACZAAAAmwAAAJ0AAACfAAAAoQAAAKMAAAClAAAApwAAAKkAAACrAAAArQAAAK8AAACxAAAAswAAALUAAAC3AAAAuQAAALsAAAC9AAAAvwAAAMEAAADDAAAAxQAAAMcAAADJAAAAywAAAM0AAADPAAAA0QAAANMAAADVAAAA1wAAANkAAADbAAAA3QAAAN8AAADhAAAA4wAAAOUAAADnAAAA6QAAAOsAAADtAAAA7wAAAPEAAADzAAAA9QAAAPcAAAD5AAAA+wAAAP0AAAD/AAAAAQEAAAMBAAAFAQAABwEAAAkBAAALAQAADQEAAA8BAAARAQAAEwEAABUBAAAXAQAAGQEAABsBAAAdAQAAHwEAACEBAAAjAQAAJQEAACcBAAApAQAAKwEAAC0BAAAvAQAAMQEAADMBAAA1AQAANwEAADkBAAA7AQAAPQEAAD8BAABBAQAAQwEAAEUBAABHAQAASQEAAEsBAABNAQAATwEAAFEBAABTAQAAVQEAAFcBAABZAQAAWwEAAF0BAABfAQAADQAAABkAAAApAAAAPQAAAFUAAABxAAAAkQAAALUAAADdAAAACQEAADkBAABtAQAApQEAAOEBAAAhAgAAZQIAAK0CAAD5AgAASQMAAJ0DAAD1AwAAUQQAALEEAAAVBQAAfQUAAOkFAABZBgAAzQYAAEUHAADBBwAAQQgAAMUIAABNCQAA2QkAAGkKAAD9CgAAlQsAADEMAADRDAAAdQ0AAB0OAADJDgAAeQ8AAC0QAADlEAAAoREAAGESAAAlEwAA7RMAALkUAACJFQAAXRYAADUXAAARGAAA8RgAANUZAAC9GgAAqRsAAJkcAACNHQAAhR4AAIEfAACBIAAAhSEAAI0iAACZIwAAqSQAAL0lAADVJgAA8ScAABEpAAA1KgAAXSsAAIksAAC5LQAA7S4AACUwAABhMQAAoTIAAOUzAAAtNQAAeTYAAMk3AAAdOQAAdToAANE7AAAxPQAAlT4AAP0/AABpQQAA2UIAAE1EAADFRQAAQUcAAMFIAABFSgAAzUsAAFlNAADpTgAAfVAAABVSAACxUwAAUVUAAPVWAACdWAAASVoAAPlbAACtXQAAZV8AACFhAADhYgAApWQAAG1mAAA5aAAACWoAAN1rAAC1bQAAkW8AAHFxAABVcwAAPXUAACl3AAAZeQAADXsAAAV9AAABfwAAAYEAAAWDAAANhQAAGYcAACmJAAA9iwAAVY0AAHGPAACRkQAAtZMAAN2VAAAJmAAAOZoAAG2cAAClngAA4aAAACGjAABlpQAAracAAPmpAABJrAAAna4AAPWwAABRswAAsbUAABW4AAB9ugAA6bwAAFm/AADNwQAARcQAAMHGAABByQAAxcsAAE3OAADZ0AAAadMAAP3VAACV2AAAMdsAANHdAAB14AAAHeMAAMnlAAB56AAALesAAOXtAACh8AAAPwAAAIEAAADnAAAAeQEAAD8CAABBAwAAhwQAABkGAAD/BwAAQQoAAOcMAAD5DwAAfxMAAIEXAAAHHAAAGSEAAL8mAAABLQAA5zMAAHk7AAC/QwAAwUwAAIdWAAAZYQAAf2wAAMF4AADnhQAA+ZMAAP+iAAABswAAB8QAABnWAAA/6QAAgf0AAOcSAQB5KQEAP0EBAEFaAQCHdAEAGZABAP+sAQBBywEA5+oBAPkLAgB/LgIAgVICAAd4AgAZnwIAv8cCAAHyAgDnHQMAeUsDAL96AwDBqwMAh94DABkTBAB/SQQAwYEEAOe7BAD59wQA/zUFAAF2BQAHuAUAGfwFAD9CBgCBigYA59QGAHkhBwA/cAcAQcEHAIcUCAAZaggA/8EIAEEcCQDneAkA+dcJAH85CgCBnQoABwQLABltCwC/2AsAAUcMAOe3DAB5Kw0Av6ENAMEaDgCHlg4AGRUPAH+WDwDBGhAA56EQAPkrEQD/uBEAAUkSAAfcEgAZchMAPwsUAIGnFADnRhUAeekVAD+PFgBBOBcAh+QXABmUGAD/RhkAQf0ZAOe2GgD5cxsAfzQcAIH4HAAHwB0AGYseAL9ZHwABLCAA5wEhAHnbIQC/uCIAwZkjAId+JAAZZyUAf1MmAMFDJwDnNygA+S8pAP8rKgABLCsABzAsABk4LQA/RC4AgVQvAOdoMAB5gTEAP54yAEG/MwCH5DQAGQ42AP87NwBBbjgA56Q5APnfOgB/HzwAgWM9AAesPgAZ+T8Av0pBAAGhQgDn+0MAeVtFAL+/RgDBKEgAh5ZJABkJSwB/gEwAwfxNAOd9TwD5A1EA/45SAAEfVAAHtFUAGU5XAD/tWACBkVoA5zpcAHnpXQA/nV8AQVZhAIcUYwAZ2GQA/6BmAEFvaADnQmoA+RtsAH/6bQBBAQAAqQIAAAkFAADBCAAAQQ4AAAkWAACpIAAAwS4AAAFBAAApWAAACXUAAIGYAACBwwAACfcAACk0AQABfAEAwc8BAKkwAgAJoAIAQR8DAMGvAwAJUwQAqQoFAEHYBQCBvQYAKbwHAAnWCAABDQoAAWMLAAnaDAApdA4AgTMQAEEaEgCpKhQACWcWAMHRGABBbRsACTweAKlAIQDBfSQAAfYnACmsKwAJoy8Agd0zAIFeOAAJKT0AKUBCAAGnRwDBYE0AqXBTAAnaWQBBoGAAwcZnAAlRbwCpQncAQZ9/AIFqiAApqJEACVybAAGKpQABNrAACWS7ACkYxwCBVtMAQSPgAKmC7QAJefsAwQoKAUE8GQEJEikBqZA5AcG8SgEBm1wBKTBvAQmBggGBkpYBgWmrAQkLwQEpfNcBAcLuAcHhBgKp4B8CCcQ5AkGRVALBTXACCf+MAqmqqgJBVskCgQfpAinECQMJkisDAXdOAwF5cgMJnpcDKey9A4Fp5QNBHA4EqQo4BAk7YwTBs48EQXu9BAmY7ASpEB0FwetOBQEwggUp5LYFCQ/tBYG3JAaB5F0GCZ2YBino1AYBzRIHwVJSB6mAkwcJXtYHQfIaCMFEYQgJXakIqULzCEH9PgmBlIwJKRDcCQl4LQoB1IAKASzWCgmILQsp8IYLgWziC0EFQAypwp8MCa0BDcHMZQ1BKswNCc40DqnAnw7BCg0PAbV8DynI7g8JTWMQgUzaEIHPUxEJ388RKYROEgHIzxLBs1MTqVDaEwmoYxRBw+8Uwat+FQlrEBapCqUWQZQ8F4ER1xcpjHQYCQ4VGQGhuBkBT18aCSIJGykkthuBX2YcQd4ZHamq0B0Jz4oewVVIH0FJCSAJtM0gqaCVIcEZYSIBKjAjKdwCJAk72SSBUbMlkwYAAEUOAAAPHAAAETMAAFtXAAANjgAAd90AADlNAQBj5gEAlbMCAB/BAwAhHQUAq9cGAN0CCQAHswsAyf4OADP/EgDlzxcAL48dADFeJAD7YCwArb41AJehQABZN00AA7FbADVDbAA/Jn8AQZaUAEvTrAB9IcgAJ8nmAOkWCQHTWy8Bhe1ZAU8miQFRZb0Bmw73AU2LNgK3SXwCeb3IAqNfHAPVrncDXy/bA2FrRwTr8rwEHVw8BUdDxgUJS1sGcxz8BiVnqQdv4WMIcUgsCTtgAwrt8+kK19XgC5nf6AxD8gIOdfYvD3/ccBCBnMYRizYyE72ytBRnIU8WKZsCGBNB0BnFPLkbj8C+HZEH4h/bVSQijfiGJPdFCye5nbIp42h+LBUacC+fLYkyoSnLNSueNzldJdA8h2OWQEkHjESzybJIZW4MTa/DmlGxol9We+9cWy2ZlGAXmghm2fe6a4PDrXG1GeN3vyJdfh0jAABxTQAAkZwAAP0mAQBlDAIA6XcDAJmiBQA11ggALXANAOHkEwAhwxwA7bcoAHWSOABZSE0AKfpnACX4iQA9x7QAUSbqALETLAHd0nwBhfLeAclSVQK5K+MCFRSMA00IVATBcT8FQS5TBs2XlAeVjAkJOXe4CklXqAwFyuAOXRNqETEnTRTRspMXvSZIG6XAdR+plSgk2ZxtKfW5Ui9tyOY1oaY5PWFBXEWtn2BOte5ZWBmOXGNpHH5v5YPVfP+9AAABqAEAj2sDAPGeBgA/IwwAwT0VAI+2IwDx/DkA/1FbAAH6iwAPddEAcb8yAT+auAHB3G0CD89fA3GOngT/ez0GAbZTCI+c/ArxYVgOP6eMEsElxRePZTQe8YEUJv/7py8BnDo7D2IiSXGGwFk/ioJtwVjjhAEOBACRIQkAESwTAEHuJQBBT0cAkUOAABH33QABRnMBAZJaAhEBuAORNbwFQY+nCEEGzgwRspsSkQ+aGgEadiUBTAc0kZ5XRxGdrGBBppGBI1EWAMWeMgAXuWsAmfbYAGuJoAENxP4CHwFQBSHZHQkzbDAP1aKkGKdnCCcp/X08e7XnWx13HYmvoC3JrY57AInmGQE5ll4CPRbYBLVjdwnhKMYRIQM0IHVIgjh9V1dgv1uvAoHYJwb3hF4N6f6tG3+L6zaBt+VoFwOcwcEM/w45aoUiGe6RS4F4K54z4QlUYXNzZXJ0aW9uIGZhaWxlZDogX24+MQAADwAAAAoAAAAFAAAAYXNzZXJ0aW9uIGZhaWxlZDogSz4wCmFsZ19xdWFudCgpIG5lZWRzIGF0IGxlYXN0IG9uZSBwdWxzZQBjZWx0L3ZxLmMAYXNzZXJ0aW9uIGZhaWxlZDogTj4xCmFsZ19xdWFudCgpIG5lZWRzIGF0IGxlYXN0IHR3byBkaW1lbnNpb25zAGFzc2VydGlvbiBmYWlsZWQ6IEs+MAphbGdfdW5xdWFudCgpIG5lZWRzIGF0IGxlYXN0IG9uZSBwdWxzZQBhc3NlcnRpb24gZmFpbGVkOiBOPjEKYWxnX3VucXVhbnQoKSBuZWVkcyBhdCBsZWFzdCB0d28gZGltZW5zaW9ucwBjZWx0L2JhbmRzLmMAYXNzZXJ0aW9uIGZhaWxlZDogZW5kPjAAYXNzZXJ0aW9uIGZhaWxlZDogbmJCYW5kcz4wAGFzc2VydGlvbiBmYWlsZWQ6IHN1bT49MABhc3NlcnRpb24gZmFpbGVkOiBOID4gMAAAAAAAAAAAAQEBAgMDAwIDAwMCAwMDAAMMDzAzPD/Aw8zP8PP8/2Fzc2VydGlvbiBmYWlsZWQ6IHN0cmlkZT4wAAAAAAAAAQAAAAAAAAADAAAAAAAAAAIAAAABAAAABwAAAAAAAAAEAAAAAwAAAAYAAAABAAAABQAAAAIAAAAPAAAAAAAAAAgAAAAHAAAADAAAAAMAAAALAAAABAAAAA4AAAABAAAACQAAAAYAAAANAAAAAgAAAAoAAAAFAAAAYXNzZXJ0aW9uIGZhaWxlZDogaXRoZXRhPj0w");
  base64DecodeToExistingUint8Array(bufferView, 42145, "QMpFG0z/UoJas2Kia2B1YXNzZXJ0aW9uIGZhaWxlZDogcW4gPD0gMjU2AAAAAAAACA0QExUXGBobHB0eHyAgISIiIyQkJSVhc3NlcnRpb24gZmFpbGVkOiBjb2RlZEJhbmRzID4gc3RhcnQAY2VsdC9yYXRlLmMAYXNzZXJ0aW9uIGZhaWxlZDogYml0c1tqXSA+PSAwAGFzc2VydGlvbiBmYWlsZWQ6IGViaXRzW2pdID49IDAAYXNzZXJ0aW9uIGZhaWxlZDogQyplYml0c1tqXTw8QklUUkVTID09IGJpdHNbal0AYXNzZXJ0aW9uIGZhaWxlZDogZmluICE9IGZvdXQKSW4tcGxhY2UgRkZUIG5vdCBzdXBwb3J0ZWQAY2VsdC9raXNzX2ZmdC5jAGFzc2VydGlvbiBmYWlsZWQ6IG09PTQAYXNzZXJ0aW9uIGZhaWxlZDogc3QtPnNpZ25hbGxpbmc9PTAAY2VsdC9jZWx0X2VuY29kZXIuYwACAQBhc3NlcnRpb24gZmFpbGVkOiAhY2VsdF9pc25hbihmcmVxWzBdKSAmJiAoQz09MSB8fCAhY2VsdF9pc25hbihmcmVxW05dKSkAYXNzZXJ0aW9uIGZhaWxlZDogY291bnQ+MAAZFwI=");
  base64DecodeToExistingUint8Array(bufferView, 42642, "gD8AAABAAABAQAAAgEAAAKBAAADAQAAA4EAAAABBAACAQQAAwEEAABBCAAAwQgAASEIAAGBCAAB4QgAAhkIAAJBCAACeQgAAsEIAANRCAAAGQw==");
  base64DecodeToExistingUint8Array(bufferView, 42738, "gD8AAIA/AACAPwAAgD8AAIA/AACAPwAAgD8AAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAABAQAAAQEAAAIBAAACgQAAAwEAAAABBAAAAQX58d21XKRMJBAIAAP//nG5WRjszLSglIR8cGhkXFhUUExIREBAPDw4NDQwMDAwLCwsKCgoJCQkJCQkICAgICAcHBwcHBwYGBgYGBgYGBgYGBgYGBgYFBQUFBQUFBQUFBQUEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAwMDAwMDAwMDAwMDAwMDAwMCYXNzZXJ0aW9uIGZhaWxlZDogIWNlbHRfaXNuYW4odG1wWzBdKQBhc3NlcnRpb24gZmFpbGVkOiAhY2VsdF9pc25hbihub3JtKQAAAAAAAAAz8AEN+/rw+Qv6ahoc8hXjBxLu7xXv9xTn/d4wC/Ph7OL3AvQF/wgJCQjzEu/e+xH1APwKAgoP+AL/AAUN/fAB+wMH5PMGJP0TxO/kB/Xi+QLW6/0G6iH3B+IV8hj17O779AzPzs8QCdv/CSLz4eEMECzWAvcI7voJJBMLDQzrA+T0AyEZ8gsBotkS9PXx+TE0CtUJOQgV+g7xLPgH4vP+9xn+gRL1zBrlGwr2BysG6CkK7uUKEQkK7/YU+hY3I7AkGejcDwntWBNAzd0RAPkp8BsED/8S8C/ZyvgN5+xm7vssC+RHAs37BQKt9+MIFcs62/kNJgki/9cVBOjc3+sgS/4BvP8v4yAUDL+pBRD0GCgPBxPm7xEG/tvi9yCB2QDh5QTqF/qzI8Mg2+gN9f/Y/RH5DQs77QoG7gANA/rpEwvvDf+wKMtF48oA/CHn/iYjJPEuAvPw+PgM6PfJ+/cgCwcM7vaq2jYl5xLVB+Xlyg0JFkYGI/kX8dT6B76rICjt9/kM8QcCBt0LHAAaDgEBBAwSIxbu/Q7/Bw748v0E/e35/+flGeb+Ierl5wT3BxUa4gr37AsbCgXuDvwC7/v59/MPHQH28PYjJPnq1BEeFhX/FvUg+PkF9gUe7B3s3gz8+gbzCvu8/xgJE+jAHxMb5kvTKSfWCAYX4hDnHiII2v0SEOEW/PcBFAkm4ADTAPrzC+fg6h/o9fX8/BTeFhQJ5xv7HOMdBhX67jYE0hcV8uEk1+gEFgoLByTg88zvGBzb3P8YCdojMBIC/y0KJxjaDQjwCBkLB+P1BxTi2tMO7uT3QT0Wy9rwJC4U2SDD+vrc3+7kOGUtC+Tp48MU0QIwG+8BKAEDzQ8jHBYjNcPjDPrrCgPsAucB+h8L/QH2zAZ+l3p/gH9/gH9sDH8wgNyAf3+AgH9ZgH+AgIB/f4CAo64UfUGufya2UVioTzPRkeYOU6iQGCObYp3Q0y5TxLEt7NcJBDQ2XfYEDQN7Bl6Ru/LhCgw1sfXr/tS4XEHHONp/yIB/f4BWdbWAf+2dkH+Af9BydoCAde/6eYB/gFI2ln9/32TZ6RKy3uP/4n/mf4B+gBvpsYiBf0hCHQe+yIuAIKgAAECoAAAZAAAAIA==");
  base64DecodeToExistingUint8Array(bufferView, 43904, "1hQQAGk8AZ8YPBINPhl/Ik83dn9fH/xXFQwC8hIXCBH/+AUEGCUVDSQNERIlHiEBCPD1++H9+wAGAzr5//AF8xAK/vIL/AP1AAAAAAAAAAAW//kHHeXh7/MhLPgLIRhODxMe/ugFMQUkHfL10N8V1tr0N9s2+AEkEQAzHzsH9DUEIPIwBfbw+AHwyOj6Ev4XBi769hQj1PHPJBAF+bG9DEb9scqr6C/qIRVF/wsWDvDw6uT1C9cf5t/t/BsgzgX22ur4I+EB1/H1LBzv1+kRAunm8/PvBg7h5wntJ/gEH//T9eSk0vEVduotzQvs7PEN65/j4OnWXgEX+D/90hPmINi25hr88x7s4ufy4dPVBMTQ9N4CAgMNDwsQBS73yfDHHQ4mzv7U9fg05dr5FC8RxQAvLsEj7xMhRO0CD/Ac8Jka3S/ZxB4f6czzdC/nHige6gIM5e4f9hv4vgwOBObk8wMN5s0lBQLrLwMNGdfl+PwFtN8cCgnSthMcGR82yUQm6OACBEQL/2MFEP62KBrmIR//vA76GQkdPD0H+QDoB00E/xD5DfHtHOHo8CUYDR4K4gsL9hY8HC392ML7mgng5coVD/sl1fUl7S/AgOWOFb47Lv30qfcEE4/cTjnm2rP2Bga1GZ/1IdIBDevf7BD6/fX85SYI1/7fEhPmAePq/PLJ9bD9CyJaMwsRKyR/4B1nCRsNQDhG8gP0CiUDDOr2LhwKFBroEgkHDiL7+R/yyAvu+O/59tgK3+DVBQkL/Aoy9PsuCQcBCw9b7wfOFwbinQDvDgj25+K7wh9/cull+8r66gfIJxLjAC4IsQTrEuA+9Pj0xh/gEQboGRgJ/O0tBhHyBeUQ/NcZ3AUPDDIbGRfUu/ft0PgEDPoN7eLcGiX//eLW8vbsGsrl1ARJ5logu+PwA2cP7yUY6eEh28AZDa/k4BsF3ekP6hP5CR4T6RvzKx3j+gnY39/gCQvQ+OnMLhHq1iPx1xAiH9bt9TcH2Vn13xTyFiAD7/oOIgE366b4EhsN4xUP38339QTw7hf8/DABBx3y9PARIwgA+f4JCBH6NeDrzgVjxPvLCuEM+wdQJBLhCWIkwd0E8+ToHPMSEP/u3goUBwQdCxn5JA4tGAHwHgYj+vXoDf8bJxQw9fzzHAvh7h/jFv7s8AUe9OT9XfAXEuMGytsc/f3R/dzJ/Sn2L/4XKvm55VPAB+gIGu8PDB/i2vPfyATvFBIB4vv64fLbABYK4iXvEgYFF9zgDhLzw8y7LOIQEvznDlEa+OnFNJgRd+AaEQEXLR3Ax/JJFfPzCbz5zAMY2SzxGw4T9+T1BQPe/gIW+ukEAw3q8/buHQYs8+j4Ah4OKwYRt/r5FLD5+eQPu9r7nN0PsRcd7uUVvtsI6tkwBPMB9wvjFgbPIPIv7vwszLYrHhfyBQDlBPkK/AoB8Avu/vsC9QDs/CZKOydA9hr92LwD4s0I7eXSMzQ2JFpcDg37ABDCEAvR2/r7FTbHICr6PvcQFRgJ9vwhMg3xAd3QEvXvvfMVJtQk8B0RBfYSEeACCBbI8eAoKxMu+ZygEzUYFebQm649Jqvk3v8/+/snJ9og9OQUKPgCHwzd8xTnHggD8/fsAvMYJfYhBhTw6Pr67fsWFQoL/Nn/BjEp8ccVwk278wC2Afna+AY/HAQazFI/DS3fLMy/69LPQO8gGETZ8PvmHAXD5AIYC/TfCdv95Bbb9BMA7v4OAQQI9/4r7/6+4TjYqdz+/NbT/x/V8Rs/9SD23xvtBA/m3h382b8O7Ovv3A07L9rfDdv42/n6tOH00gcY6+LyCQ/08y/l5//ZABT3BgcEAwcnMhb5DuwBRuQd1wrw++T+2yDuET717M4kFcL0yDQyEQMwLNfnAxD9ACH6Dxsi5xYJEfUkEP4MFcwt/vYuFe5D5PMeJSoQ9wtLB8DY9h056QU1swPv+y/J3dzzNMu5NJHp5uQd1TftK+029N/U2e324fYVJsfsAucI+jIMDxnnD+L6CRklE/wf6gIEAiQHA96wJPb++x/cMboU3BUYGdLNJMbQ2PY3Ry8K/wEC0rwQDQC240nM7vUH1K7guuT/2bz61wzq8Cj15zP3FQQE3geyEAba4v7UIAAWQAW4/vL28PjnDGbGJfbpDzEH+QLs4C36MBweIf8W+h5B7x1KJeb2D+gTvhb24f/u9wsl/C0FKREBARjGKQXNDggrEPb/LSDAA9/n/eW8DBf189vYBOv0IOntTCnp6NS///EBRz8FFP0V6R/gEv4bHy772fvdEu7Y9gMMAv7qKAX6PCQDHeUKGcoFGicj6NsepRz86+XZ+gUMgCbwHaHjUv4jAgwI6gpQ0QLnt7EQ4uC+MBXT9dEO5e/5D9Ty1ObgGukR+eQa+hwG5gIN8unyEy4QAt/rHO/WLNsB2RxU0g8KDdRI5hog5PStAgri1PbkNS1BAOc5JN8GHSzLCxP+5SMgMQQXJiQYCjPZBPkaJd0L0e4cEN0qEevXHA70C9MH1fES+ybYzuLrCZ4NDBdLyPn9/P/eDM8LGu7k7yEN8igYuNsKEfoWEBD69OLyCijpDA/98Q3I/OIB/e8bMvtA3O0HHRYZCfDGu9jDufIqXRoL+sb1RswTCeLfC9vR6+rYCi8E6REwKdAOCg8i6f7RF+Dz9ubm/BAm8gD0+fkULP/g5fAE+u4OBQTjHAf5D/Xs09wQVCLF4hZ+CERP7xW8JQUPPzF/plUrBxAJBtPH1TkL6fXjPOYAByroChfnCPnYE+8jBBvZpRvcIgIQ6BkH6wURCuriCe/D5iEVOs3yRdoUB1D8v/rlNfQv//EBPGax/AwJFiX4/CUC/fHw9fsT+tUU5+4K5QDk5fUK7v788BoO+gf6ATX+4xcJ4vr8+jhGAN/s7/foLvuXL9LNFBTLr//5S/vrvwzMFs70MTZMrwot18US7RkO4cv7DB9U6QIHAgrgJ/70AfcA9vUJD/j+Av8KDvvYE/n5GvwCAeUjIBXhGiv3BOAowswkFiYWJKAG9unPD9/u/QApFe0VF9np+gYvOARKAJ4d0fLcFeoWEA0MEPsNEfPxAd7mGgwgGw29GwIIChIQFO/vOcAFDhMf7tTS8ATnEYLoJwQIN+feJ/ADCUdI4ckGCucgq+sS+A8M5fkB6/77MPASAermEA7hG/rx6wTyEtwUQ50MKecx1CNRbi8ivvIOxCIdtwopI1kH3RYHG+z6OBpCBiHJNQHrDhFENzsAEvcF1wb7jvQdKukKUeUUy+LCKF8Z/AMS+PHjrgLH/cPj4zECyQW7nc/NBucMWSzfBSkBF9vb5NADBNfix93Z//PI+zIxKfz8Ier/ISISKNYMAfr+EhEnLAtBxNMKWxUJwvUIRSUY4hUa5QHkGEL4BrkiGCw6su05EcQBDP3/2BYL+xkMAUhPB84XEg0V9ewFTaIYDznNAyQ1/wQOHuEWKCD13tzFOhkVyukoLhIADDagncUFd9oyNwzwQwAiIycj/0UYG+Ld/LoC1Pn6E/c8LOv2JSvw/R7xvx/JEp5MQBkY7vm89iYbxCQhEB4i2dsfDDXKDubPgPP76vWrN/jN9d/24bTXFyzYyoGbE+nxDxs6xAgO3wEw9/WFAzUXBOQWAuO9JAwHN+tYFP/r7wMpIPby+8dDORUX/uW36HgVEt0q+QPT50zeMgvKpQOP7PsvD9ERG/3m+QoHSthA+fvoz+j99hvv+P0O5SENJxz52h0QLBM3/QnzxysrHwCj7xPIBPTnJavziiHvOEew/Ab17i/MGQkwlQEVFP0K8PwYER/D7s4Y9gxHGgv9BAEA+dgSJt4mEQjeAhV74OYrDt7/9yXwBu/CRBYRC7UhsD73tUwk1/jY9bko2T7PrxD3zDQ9EZnl9vjKxxUX8MwkEgr7CA/jBe3bCMsGE9sm7zAKAFEuRuNlCyzU/RgLAw73Cw7TDS79x0QsP2IZ5OkPIPY1+v73+hCV9fXkOznqJipTGwUd4gzr8x8m6zr29vH++wsMt+TaFgLnScz0ySDBFTMhNOY35uY54PzMwxXfpc1Fpsva1Ay07E3T+VYrk9+X2If2ALgtzbXP2v/CEv8e1PL2vSj23i7A4B3zIQPg+xzl510YRNg5F/3rxhHZ7+qnCxLSGxgufz1XH3/cL+kvf+hueh5kAGD0BjIs80kEN/XxMSr6FN06EiYqSBPrCwnbBx0fEO8NzhMF6TPw+wToTArL5Pm/Sijw4yDwz939O6DO1dXD8fjc3t/yC/3ZBI6F9c/rDsgBK8EaKBL25vLx3d31INS9AhYHA/fizeQcBuoQIufMyvj6BQgU8O/UGwMf+9D//XQLR+HRbTLq9McgQgjno8r2E7TeYTDc7uLZ5vQcDgz04SYCCgTYFBDDAkAnBQ8hKMPPXfYhHPXl7ifC+vo+C/gmvQwbJ+V77vq/U8AUE/UhGBE4TgfxNpv3c6AyMyMiGyXY9QjcKtMC6QBD+PfzMvLlBAD48h73HQ8J2iX4MtI2KfX49eYnLQ7m7+VFJidiQgAqe5vtrXXgOAoMqE/LOD9fwgkk87HwJdIj3g4RygUV+Qc/OA8btOcE5sEcvcwr0boo9Ci+2wAjJcsE780LFQ7e/BjWHRYHHAwlJ9ntQcTO/gFSJxPp1eq93d4gZlF/JEPTAb3M/CMUHEdW3fet3gwJ6QIOHOkH5y0HEdsA7R8aKOXwEQXrFxhgyTTt8voBMt5WyyYCzNzzPKuIIAf0Fkb5oia04ewP5AcGKDVYAyYS+OrpMyX3DeAZ6xsfFBL38wEV6PMnD/Xj3BIPCBsVov/qMUL/Bv3Y7gYcDCHFPjzQWv9sCRL+G02/UtDa7fV/MkIS8+o82ijy5vMmQzkeIRokJu8b5BQMwBIF3+UN5iAj+9DyXCvR8igLM0IWwfDDBOQbFN/i6+PLH9gYK/ztFUMUZPCjTvruzNv3QuH4GhIEGOoR/vMbAAju5wXr6PkSoxUHArVFMvvx7zzWNwH8AwouEPMt+fbUlDEC8cD0uCDa0wrKDfPl3MA6wptYqrnZ94AgD/w28Nnm3C4wwPYTHvMi+DI86vr14gUyIDgAGQZEC+Mt9/QEARLPANrtWh0jMwjQYP/09+DBv/kmWRyr5OnngDhP3GP62wfzu9LjGUDrEQEqvgFQGuAVDw8GBvYPfwUmG1fH5wtI6/sL875OJP0p6wjfF0kcOef7BOrRDwTHuCEBEgI1uZ3r/ZFsR/JSGT3QBQnN7Of9Dt8O/d4WDO3a8AIVEBrhSyzhEBpCEffq6hbUFhsCOvIKt9Y358NI/x7G5z8a0Nga4jwI7//u7Cvs/OR/lh1GQOUn3/uo2MwaLO8XAs8W9/hWMdXEAQotJMv8ISYwuAETFb8E+8Ib5xH6BtPZ0gQaf/cS3+79IQL7D+bqi8HvxT22B9HGgL0P8IAMAhQJ0NgrA9jw2vrq5PDF6gb7C/S+2BvC1O0m/Sf4KOgNFTLE6jXj+gEWxQAR2XOAqwAA0KsAANC0AAAgAAAAGAAAAA51");
  base64DecodeToExistingUint8Array(bufferView, 48048, "j6gfgILDVd12gMN/gO+Af2j3gCEtfwVTVICrgNMwy4Auf+99ddeLpYG8/6ewIGoHpLsAALC7AAAYAAAAAgAAAAE=");
  base64DecodeToExistingUint8Array(bufferView, 48132, "BcEjPel9oz0llvQ94nQiPqwcSj7dJXE+NLqLPrR3nj7kv7A+rYjCPiXJ0z4YeuQ+GJX0PsgKAj8cfAk/SZ0QP8ptFz/A7R0/nx0kP1T+KT8ukS8/4Nc0P2PUOT/wiD4/0/dCP6sjRz8XD0s/2LxOP60vUj9qalU/zm9YP5pCWz+O5V0/S1tgP26mYj9kyWQ/m8ZmP2+gaD/3WGo/gPJrP99ubT8L0G4/yhdwP+BHcT/hYXI/TWdzP5ZZdD8MOnU//wl2P4rKdj+7fHc/wCF4P2K6eD+dR3k/S8p5PyRDej/ysno/Oxp7P8h5ez8g0ns/yCN8PzdvfD/ytHw/XvV8P+AwfT/sZ30/t5p9P7TJfT8G9X0/ER1+PxhCfj9OZH4/04N+P/2gfj/tu34/w9R+P7Prfj/vAH8/hxR/P40mfz9DN38/qkZ/P+NUfz8PYn8/L25/P2R5fz++g38/P41/PxiWfz84nn8/wqV/P6Osfz8Qs38/9bh/P3e+fz9yw38/Gch/P2zMfz9b0H8/BtR/P2/Xfz+D2n8/Zt1/PxXgfz+C4n8/zeR/P+bmfz/N6H8/kup/P0bsfz/I7X8/KO9/P3jwfz+m8X8/w/J/P7/zfz+69H8/lPV/P172fz8n938/z/d/P3f4fz/9+H8/lPl/Pwn6fz9/+n8/9Pp/P1n7fz+t+38/Afx/P1T8fz+Y/H8/2/x/Px79fz9Q/X8/gv1/P7X9fz/n/X8/Cf5/Pzv+fz9d/n8/fv5/P4/+fz+w/n8/0v5/P+P+fz/0/n8/Ff9/Pyb/fz83/38/R/9/P1j/fz9Y/38/af9/P3r/fz96/38/i/9/P5v/fz+b/38/m/9/P6z/fz+s/38/vf9/P73/fz+9/38/zv9/P87/fz/O/38/zv9/P87/fz/e/38/3v9/P97/fz/e/38/3v9/P97/fz/v/38/7/9/P+//fz/v/38/7/9/P+//fz/v/38/7/9/P+//fz/v/38/7/9/P+//fz/v/38/AACAPwAAgD8AAIA/AACAPwAAgD8AAIA/AACAPwAAgD8AAIA/AACAPwAAgD8=");
  base64DecodeToExistingUint8Array(bufferView, 48944, "5lo0OHdOMznT2ck5kpEzOsxgjDph+8k6mX4JO8uAMzvVJWM7dy6MO6iKqTtFuMk7h6bsO+guCTyuZh089wIzPJP/STxPWGI8XhF8PC6Rizy9x5k8XKyoPPM8uDyBecg87l/ZPDnw6jxjKv08NQcIPRDMET3N5Bs9YVAmPcsOMT0AHzw9/oBHPcY0Uz0/OF89aYtrPUUueD1pkII9ezCJPeD3jz2K5ZY9e/mdPbEzpT0hk6w9UBi0PTPCuz1PkcM9EoTLPQKb0z0f1ts91zPkPa+07D0hWPU9qB3+PaGCAz7yBgg+x5sMPt1AET409hU+RbsaPhGQHz5UdCQ+y2cpPjNqLj6NezM+Ups4PsXJPT4cBkM+WVBIPnqoTT63DVM+UoBYPggAXj5UjGM+8iRpPiXKbj4ke3Q+rDd6PgAAgD6r6YI++diFPoXNiD5Qx4s+N8aOPvfJkT6z0pQ+JuCXPg/ymj5sCJ4+HCOhPv9BpD7QZKc+sYuqPhy2rT5U5LA+0xW0PrpKtz7ogro++b29Pg38wD7iPMQ+VoDHPkfGyj6VDs4++1jRPnql1D7x89c+HETbPtmV3j4I6eE+pz3lPlOT6D4M6us+r0HvPhya8j4O8/U+iEz5PiKm/D4AAAA/76wBP7xZAz95BgU/8rIGPylfCD/6Cgo/VrYLPyxhDT98Cw8/E7UQP/JdEj8IBhQ/Q60VP4JTFz+2+Bg/3JwaP9U/HD+P4R0/+YEfPwQhIT+MviI/o1okPxf1JT/WjSc/8iQpPyi6Kj+YTSw/Ad8tP3JuLz/K+zA/+YYyP+0PND+nljU/BBs3P+WcOD9YHDo/PZk7P4MTPT8qiz4/AABAPxVyQT834UI/d01EP8O2RT/rHEc//n9IP+zfST+SPEs/4ZVMP+rrTT95Pk8/j41QPyvZUT8dIVM/c2VUPw2mVT/r4lY//BtYPy9RWT9zglo/ya9bPw7ZXD9D/l0/WB9fP0s8YD/8VGE/amliP4V5Yz88hWQ/oIxlP36PZj/WjWc/uodoP/Z8aT+cbWo/illrP9FAbD9PI20/BAFuP/HZbj/zrW8/HH1wP0lHcT98DHI/tMxyP/CHcz8QPnQ/E+90P/qadT+zQXY/P+N2P41/dz+tFng/fqh4PwE1eT80vHk/GD56P526ej/CMXs/d6N7P7sPfD+fdnw/Ath8P/QzfT9lin0/RNt9P7Mmfj+PbH4/66x+P6Pnfj/aHH8/f0x/P4F2fz8Cm38/0Ll/PxzTfz/F5n8/y/R/Py/9fz8AAIA/BAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAoAAAAMAAAADgAAABAAAAAUAAAAGAAAABwAAAAiAAAAKAAAADAAAAA8A==");
  base64DecodeToExistingUint8Array(bufferView, 49986, "gD4AAIA+AACAPgAAgD4AAIA+AACAPgAAgD4AAIA+AACAPgAAgD4AAIA+AACAPgAAgD4AAIA+AACAPgAAgD7QJbQ+lzmtPgmlnz767Ys+zaxlPvipKj40MNI9WvENPVrxDb00MNK9+Kkqvs2sZb767Yu+CaWfvpc5rb7QJbS+h4qxPhuDlj5gI0k+xEKNPcRCjb1gI0m+G4OWvoeKsb6HirG+G4OWvmAjSb7EQo29xEKNPWAjST4bg5Y+h4qxPpc5rT7NrGU+WvENPfipKr4JpZ++0CW0vvrti740MNK9NDDSPfrtiz7QJbQ+CaWfPvipKj5a8Q29zaxlvpc5rb59Pac+0osKPtKLCr59Pae+fT2nvtKLCr7Siwo+fT2nPn09pz7Siwo+0osKvn09p759Pae+0osKvtKLCj59Pac+CaWfPlrxDT367Yu+lzmtvjQw0r3NrGU+0CW0PvipKj74qSq+0CW0vs2sZb40MNI9lzmtPvrtiz5a8Q29CaWfvhuDlj7EQo29h4qxvmAjSb5gI0k+h4qxPsRCjT0bg5a+G4OWvsRCjT2HirE+YCNJPmAjSb6HirG+xEKNvRuDlj767Ys++Kkqvpc5rb5a8Q090CW0PjQw0j0JpZ++zaxlvs2sZT4JpZ8+NDDSvdAltL5a8Q29lzmtPvipKj767Yu+YXNzZXJ0aW9uIGZhaWxlZDogc3QtPm1vZGUgPT0gTU9ERV9IWUJSSUQgfHwgY3Vycl9iYW5kd2lkdGggPT0gT1BVU19CQU5EV0lEVEhfV0lERUJBTkQAc3JjL29wdXNfZW5jb2Rlci5jAGFzc2VydGlvbiBmYWlsZWQ6IHN0LT5zaWxrX21vZGUuaW50ZXJuYWxTYW1wbGVSYXRlID09IDE2MDAw");
  base64DecodeToExistingUint8Array(bufferView, 50672, "4C4AAOgDAACwNgAA6AMAAIA+AADoAwAAIE4AAOgDAADwVQAA6AM=");
  base64DecodeToExistingUint8Array(bufferView, 50740, "4C4AABAnAAAQJwAA+CoAAPgqAACAPgAAvDQAALw0AACYOgAAmDoAACBOAACAPgAAgD4AAFBGAABQRgAAwF0AAFBGAABQRgAACFIAAAhSAAAAfQAA8FUAAPBVAABgbQAAYG0AAAD6AABwlAAAcJQAAFDDAABQwwAADQAAABEAAAARAAAAEwAAAAAAAAAIAAAABAAAAOF6VD/2KFw/nMcAABAAAAAEAAAAmplZP65HYT+cxwAAIAAAAAQAAADBymE/w/VoP5zHAAAwAAAACAAAALgeZT+DwGo/pMcAAEAAAAAIAAAAqMZrP9ejcD+kxwAAUAAAABAAAAAxCGw/16NwP6zHAABgAAAAEAAAANejcD+F63E/rMcAAIAAAAAQAAAAMzNzPzMzcz+sxwAAoAAAABAAAACPwnU/j8J1P6zHAADAAAAAIAAAANnOdz/Zznc/tMcAAAABAAAgAAAAmpl5P5qZeT+0xwAAwMcAACAAAADgyAAAIAAAAADKAAAgAAAAIMsAAEAAAAAAAAAAJZHguiDq7z8AAAAAAADwPyWR4Log6u8/3ksrz82o7z9aH/+a5jzvP1XPF7Xap+4/vqBk9qLr7T/XkG46uArtP4voz2UHCOw/td5vtOPm6j9YAHQU96rpPyJyVTQxWOg/UMWuabXy5j9Y5LYByH7lP5RFJ2y7AOQ/RytKS9184j+po+NqZPfgP6qpl6W+6N4/FsR6gkjv2z9LZsyPhQnZPz/p4VfuPdY/wmpufT+S0z+gvqdqaQvRPytyXzkIW80/J5liL5D3yD+hB8qvF/HEP8pirICMSsE/IsW+bFQKvD9hhQCFH0G2P4/ecB+5NbE/Q4TJnk7DqT8he3vfEXiiP/NHKOi855g/We0O5+l1jj8hAg6hSs1+PwAAAAAAAAAAwVNMzh7i7z8AAAAAAADwP8FTTM4e4u8/z0LImg2J7z8MbeeYf/buP4gSLXk8Le4/mk30twwx7T+1sMC6ngbsP8yZDhlms+o/3Hksx3U96T9RqyK7VqvnP5U2yU3cA+Y/davnpPdN5D93AJvei5DiPxOB6h9E0uA/xgDD0dky3j9TPgRVo9faP9kIYcE/ndc/qGoG4Z+M1D9uJH0YKa3RP1rvefZDCc4/GwBgK1cuyT9RlmsbkM7EP4vsWq3Z68A/6dYpXn4Kuz/fF/rUby61PwYNgUwAOLA/yr1E5fQvqD+mFfjtmHihP0v1U9J5Q5g/lM+f9I0BkD8Abjc9/6iDP95pGUbNmXU/4IWMy+EoYz/8qfHSTWJAPwAAAAAAAAAAuaajkCLa7z8AAAAAAADwP7mmo5Ai2u8/hQsW2ntp7z9ERs1417DuPyZTw4bAtO0/M9ouXVZ77D+pzhc5EwzrP6nqcSGHb+k/cuaRHgqv5z/W0WnEadTlP8CnpBSV6eM/OaAA5Ur44T/qgxvfzQngP1Vq1TJCTdw/Q13e+5+s2D8PWvbBhT7VPx8F28pDDdI/oGc3IxhBzj+Mi3rz4frIP/CuSIb7TMQ/dOMnH8w3wD/uYYrNIm+5PztOVcoAirM/6GEuyuhXrT8kM80qInmlP7tpbfnMgp4/Iix0b4/vlD8+Ed0W2YyLP13CX5umMoE/UAiy2AUHdD+ByCq+BBtlP9zuq5Ov21I/G8qaom1GNz8=");
  base64DecodeToExistingUint8Array(bufferView, 52000, "yFEM0oT07z8AAAAAAADwP8hRDNKE9O8/9pUH6SnS7z/a08TxMpnvP9T9ENkPSu8/fp+7blvl7j9hwT+d2WvuPx3X8SV13u0/an9v7Dw+7T/J6jXBYIzsP3ckRQEuyus/Hrx+2gv56j860L80dxrqP/UlI4D+L+k/8kBDgz076D8OB1Pe2D3nP/fyr6N5OeY/TMjFIMkv5T/OuHiRbCLkP/+ZWhkBE+M/L5wx7RcD4j9j2QbNMvTgP01ahnKBz98/zY9k+zW+3T8VxjeQBbfbP+AHrag9vNk/YDMKk/PP1z/zHfzEAfTVP0qFZ/gFKtQ/5808FGBz0j+NyjQ3MtHQP9jRevDBiM4/ryd4Eiqbyz/ISJPeedrIP7XPWyMfR8Y/PVdCFB/hwz+1zQFAHajBP026kLvGNr8/LgwmONRzuz9mkgUKxAS4P4BUFsd55rQ/YkhOJm4Vsj+kFYSXhRuvP+yy6yCnlqo/l6hBRZOTpj8+eC/vWAmjP9XnrEfI3Z8/bM9NFzl2mj/08djo/8mVPw8LtaZ5x5E/VRds+h67jD/+pLEosveGPzy3lup+JYI/pfu1zFROfD9nH1R3n8J1PwXEfxU7dXA/dH+znJ1vaD/T8PMAksBhP/dS2/qnI1k/P8Gs7XlAUT/xQgCR+sJGP3uyzVM+gDw/JlGSIvCPMD/HVG5gehQhP32Jfzcgqws/8WjjiLX45D4=");
  base64DecodeToExistingUint8Array(bufferView, 52545, "0VAAAAAAAAU=");
  base64DecodeToExistingUint8Array(bufferView, 52564, "AQ==");
  base64DecodeToExistingUint8Array(bufferView, 52588, "AgAAAAMAAAC40A==");
  base64DecodeToExistingUint8Array(bufferView, 52612, "Ag==");
  base64DecodeToExistingUint8Array(bufferView, 52627, "//////8=");
  base64DecodeToExistingUint8Array(bufferView, 52868, "4NA=");
}

  var scratchBuffer = new ArrayBuffer(16);
  var i32ScratchView = new Int32Array(scratchBuffer);
  var f32ScratchView = new Float32Array(scratchBuffer);
  var f64ScratchView = new Float64Array(scratchBuffer);
  
  function wasm2js_scratch_load_i32(index) {
    return i32ScratchView[index];
  }
      
  function wasm2js_scratch_store_i32(index, value) {
    i32ScratchView[index] = value;
  }
      
  function wasm2js_scratch_load_f64() {
    return f64ScratchView[0];
  }
      
  function wasm2js_scratch_store_f64(value) {
    f64ScratchView[0] = value;
  }
      
  function wasm2js_scratch_store_f32(value) {
    f32ScratchView[2] = value;
  }
      
  function wasm2js_scratch_load_f32() {
    return f32ScratchView[2];
  }
      
function asmFunc(env) {
 var memory = env.memory;
 var buffer = memory.buffer;
 var HEAP8 = new Int8Array(buffer);
 var HEAP16 = new Int16Array(buffer);
 var HEAP32 = new Int32Array(buffer);
 var HEAPU8 = new Uint8Array(buffer);
 var HEAPU16 = new Uint16Array(buffer);
 var HEAPU32 = new Uint32Array(buffer);
 var HEAPF32 = new Float32Array(buffer);
 var HEAPF64 = new Float64Array(buffer);
 var Math_imul = Math.imul;
 var Math_fround = Math.fround;
 var Math_abs = Math.abs;
 var Math_clz32 = Math.clz32;
 var Math_min = Math.min;
 var Math_max = Math.max;
 var Math_floor = Math.floor;
 var Math_ceil = Math.ceil;
 var Math_trunc = Math.trunc;
 var Math_sqrt = Math.sqrt;
 var abort = env.abort;
 var nan = NaN;
 var infinity = Infinity;
 var emscripten_resize_heap = env.emscripten_resize_heap;
 var emscripten_memcpy_big = env.emscripten_memcpy_big;
 var __wasi_fd_close = env.fd_close;
 var __wasi_fd_write = env.fd_write;
 var abort = env.abort;
 var setTempRet0 = env.setTempRet0;
 var legalimport$__wasi_fd_seek = env.fd_seek;
 var __stack_pointer = 5296384;
 var i64toi32_i32$HIGH_BITS = 0;
 // EMSCRIPTEN_START_FUNCS
function opus_encode_native($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12) {
 var $13 = 0, $14 = 0, $15 = 0, $16 = Math_fround(0), $17 = Math_fround(0), $18 = 0, $19 = 0, $20 = 0, $21 = Math_fround(0), $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = Math_fround(0), $27 = 0, $28 = Math_fround(0), $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = Math_fround(0), $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = Math_fround(0), $48 = Math_fround(0), $49 = Math_fround(0), $50 = 0, $51 = 0, $52 = 0;
 $15 = __stack_pointer - 624 | 0;
 __stack_pointer = $15;
 $14 = $15;
 HEAP32[$14 + 616 >> 2] = 0;
 HEAP32[$0 + 18136 >> 2] = 0;
 $13 = -1;
 label$1 : {
  if (($2 | 0) < 1) {
   break label$1;
  }
  $23 = ($4 | 0) < 1276 ? $4 : 1276;
  if (($23 | 0) < 1) {
   break label$1;
  }
  if (($23 | 0) == 1) {
   $13 = -2;
   if (HEAP32[$0 + 144 >> 2] == (Math_imul($2, 10) | 0)) {
    break label$1;
   }
  }
  $19 = HEAP32[$0 >> 2] + $0 | 0;
  $22 = HEAP32[$0 + 4 >> 2];
  $38 = HEAP32[$0 + 108 >> 2] != 2051 ? HEAP32[$0 + 116 >> 2] : $38;
  $13 = HEAP32[$0 + 168 >> 2];
  HEAP32[$14 + 416 >> 2] = $14 + 612;
  opus_custom_encoder_ctl($19, 10015, $14 + 416 | 0);
  HEAP32[$14 + 544 >> 2] = 0;
  $20 = ($5 | 0) < ($13 | 0) ? $5 : $13;
  label$4 : {
   label$5 : {
    label$6 : {
     label$7 : {
      label$8 : {
       label$9 : {
        if (HEAP32[$0 + 44 >> 2] < 7) {
         break label$9;
        }
        $29 = HEAP32[$0 + 144 >> 2];
        if (($29 | 0) < 16e3) {
         break label$9;
        }
        $41 = 1;
        $5 = Math_imul(HEAP32[$0 + 112 >> 2], $2);
        if (($5 | 0) >= 1) {
         $13 = 0;
         while (1) {
          $16 = HEAPF32[($13 << 2) + $1 >> 2];
          $21 = $16 > $21 ? $21 : $16;
          $17 = $16 < $17 ? $17 : $16;
          $13 = $13 + 1 | 0;
          if (($13 | 0) != ($5 | 0)) {
           continue;
          }
          break;
         }
        }
        $24 = HEAP32[$0 + 7640 >> 2];
        $30 = HEAP32[$0 + 7636 >> 2];
        run_analysis($0 + 188 | 0, HEAP32[$14 + 612 >> 2], $6, $7, $2, $8, $9, $10, $29, $20, $11, $14 + 544 | 0);
        $16 = Math_fround(-$21);
        $5 = 0;
        if (Math_fround(Math_fround(1) / Math_fround(1 << $20)) >= ($16 < $17 ? $17 : $16)) {
         break label$4;
        }
        if (HEAPF32[$14 + 580 >> 2] > Math_fround(.10000000149011612) ^ 1) {
         break label$5;
        }
        $21 = Math_fround(HEAPF32[$0 + 18128 >> 2] * Math_fround(.9990000128746033));
        $5 = Math_imul(HEAP32[$0 + 112 >> 2], $2);
        if (($5 | 0) < 1) {
         break label$8;
        }
        $13 = 0;
        $16 = Math_fround(0);
        while (1) {
         $17 = HEAPF32[($13 << 2) + $1 >> 2];
         $16 = Math_fround($16 + Math_fround($17 * $17));
         $13 = $13 + 1 | 0;
         if (($13 | 0) != ($5 | 0)) {
          continue;
         }
         break;
        }
        $26 = Math_fround($5 | 0);
        if (Math_fround($16 / $26) < $21) {
         break label$6;
        }
        $13 = 0;
        $16 = Math_fround(0);
        while (1) {
         $17 = HEAPF32[($13 << 2) + $1 >> 2];
         $16 = Math_fround($16 + Math_fround($17 * $17));
         $13 = $13 + 1 | 0;
         if (($13 | 0) != ($5 | 0)) {
          continue;
         }
         break;
        }
        break label$7;
       }
       $24 = -1;
       if (HEAP32[$0 + 7648 >> 2]) {
        tonality_analysis_reset($0 + 188 | 0);
       }
       $30 = -1;
       break label$5;
      }
      $16 = Math_fround(0);
      $26 = Math_fround($5 | 0);
      if (Math_fround(Math_fround(0) / $26) < $21) {
       break label$6;
      }
     }
     $21 = Math_fround($16 / $26);
    }
    HEAPF32[$0 + 18128 >> 2] = $21;
   }
   HEAP32[$0 + 140 >> 2] = -1;
   $41 = 0;
   $5 = 1;
  }
  $51 = $5;
  HEAP32[$0 + 18120 >> 2] = 0;
  if (HEAP32[$14 + 544 >> 2]) {
   if (HEAP32[$0 + 124 >> 2] == -1e3) {
    $5 = $0;
    label$19 : {
     label$20 : {
      $13 = HEAP32[$0 + 14228 >> 2];
      if (($13 | 0) != 1002) {
       if ($13) {
        break label$20;
       }
       $13 = $14 + 564 | 0;
       break label$19;
      }
      $13 = $14 + 572 | 0;
      break label$19;
     }
     $13 = $14 + 568 | 0;
    }
    $46 = Math_floor(+Math_fround(Math_fround(Math_fround(1) - HEAPF32[$13 >> 2]) * Math_fround(100)) + .5);
    label$18 : {
     if (Math_abs($46) < 2147483648) {
      $13 = ~~$46;
      break label$18;
     }
     $13 = -2147483648;
    }
    HEAP32[$5 + 140 >> 2] = $13;
   }
   $6 = $0;
   $5 = HEAP32[$14 + 576 >> 2];
   $13 = 1101;
   label$23 : {
    if (($5 | 0) < 13) {
     break label$23;
    }
    $13 = 1102;
    if (($5 | 0) < 15) {
     break label$23;
    }
    $13 = 1103;
    if (($5 | 0) < 17) {
     break label$23;
    }
    $13 = ($5 | 0) < 19 ? 1104 : 1105;
   }
   HEAP32[$6 + 18120 >> 2] = $13;
  }
  $16 = Math_fround(0);
  if (!(HEAP32[$0 + 120 >> 2] == 1 | HEAP32[$0 + 112 >> 2] != 2)) {
   $16 = compute_stereo_width($1, $2, HEAP32[$0 + 144 >> 2], $0 + 14260 | 0);
  }
  $5 = $2 ? $2 : HEAP32[$0 + 144 >> 2] / 400 | 0;
  label$26 : {
   label$27 : {
    $13 = HEAP32[$0 + 164 >> 2];
    if (($13 | 0) != -1e3) {
     if (($13 | 0) == -1) {
      break label$27;
     }
     $6 = HEAP32[$0 + 144 >> 2];
     break label$26;
    }
    $6 = HEAP32[$0 + 144 >> 2];
    $13 = Math_imul($6, HEAP32[$0 + 112 >> 2]) + ((Math_imul($6, 60) | 0) / ($5 | 0) | 0) | 0;
    break label$26;
   }
   $6 = HEAP32[$0 + 144 >> 2];
   $13 = (Math_imul($23, $6) << 3) / ($5 | 0) | 0;
  }
  HEAP32[$0 + 160 >> 2] = $13;
  $5 = ($6 | 0) / ($2 | 0) | 0;
  label$29 : {
   label$30 : {
    label$31 : {
     $7 = HEAP32[$0 + 148 >> 2];
     label$32 : {
      if (!$7) {
       $8 = (Math_imul($6, 12) | 0) / ($2 | 0) | 0;
       $13 = ((($8 | 0) / 2 | 0) + ((Math_imul($13, 12) | 0) / 8 | 0) | 0) / ($8 | 0) | 0;
       $23 = ($13 | 0) < ($23 | 0) ? $13 : $23;
       $13 = (Math_imul($8, $23) << 3) / 12 | 0;
       HEAP32[$0 + 160 >> 2] = $13;
       $8 = 1;
       if (($23 | 0) < 2) {
        break label$32;
       }
      }
      label$34 : {
       if (($23 | 0) < 3 | (Math_imul($5, 24) | 0) > ($13 | 0)) {
        break label$34;
       }
       $29 = Math_imul($5, $23);
       if (($5 | 0) > 49) {
        break label$31;
       }
       if (($29 | 0) < 300) {
        break label$34;
       }
       if (($13 | 0) >= 2400) {
        break label$30;
       }
      }
      $8 = $23;
     }
     $13 = HEAP32[$0 + 14240 >> 2];
     $13 = $13 ? $13 : 1101;
     $6 = 0;
     $2 = HEAP32[$0 + 14224 >> 2];
     $15 = ($5 | 0) > 100 ? 1002 : $2 ? $2 : 1e3;
     $1 = ($5 | 0) == 25 & ($15 | 0) != 1e3;
     $23 = $1 ? 50 : $5;
     label$35 : {
      if (($23 | 0) > 16) {
       $2 = $23;
       break label$35;
      }
      if (!(($23 | 0) == 10 | ($15 | 0) != 1e3 ? ($4 | 0) != 1 : 0)) {
       $1 = ($23 | 0) < 13;
       $15 = 1e3;
       $2 = ($23 | 0) == 12 ? 25 : 16;
       break label$35;
      }
      $6 = 50 / ($23 | 0) | 0;
      $1 = 3;
      $2 = 50;
     }
     label$39 : {
      if (($13 | 0) >= 1104) {
       $4 = 1103;
       if (($15 | 0) == 1e3) {
        break label$39;
       }
      }
      if (($13 | 0) == 1102) {
       $4 = 1101;
       if (($15 | 0) == 1002) {
        break label$39;
       }
      }
      $4 = ($13 | 0) < 1105 ? ($15 | 0) == 1001 ? 1104 : $13 : $13;
     }
     $23 = HEAP32[$0 + 14192 >> 2];
     $13 = 0;
     if (($2 | 0) <= 399) {
      while (1) {
       $13 = $13 + 1 | 0;
       $2 = $2 << 1;
       if (($2 | 0) < 400) {
        continue;
       }
       break;
      }
      $13 = $13 << 3;
     }
     $2 = $3;
     label$44 : {
      label$45 : {
       switch ($15 - 1e3 | 0) {
       case 0:
        $13 = $13 - 16 | ($4 << 5) + 96 & 224;
        break label$44;
       case 2:
        $13 = ((($4 | 0) > 1102 ? $4 : 1102) << 5) - -64 & 96 | $13 | 128;
        break label$44;
       default:
        break label$45;
       }
      }
      $13 = $13 + 240 | $4 << 4 | 96;
     }
     HEAP8[$2 | 0] = $13 | ((($23 | 0) == 2) << 2 | $1);
     $13 = $1 >>> 0 < 2;
     if (($1 | 0) == 3) {
      HEAP8[$3 + 1 | 0] = $6;
     }
     $13 = $13 ? 1 : 2;
     if (HEAP32[$0 + 148 >> 2]) {
      break label$1;
     }
     $0 = ($8 | 0) > ($13 | 0) ? $8 : $13;
     $13 = opus_packet_pad($3, $13, $0) ? -3 : $0;
     break label$1;
    }
    $42 = $29 << 3;
    $9 = HEAP32[$0 + 40 >> 2];
    $34 = HEAP32[$0 + 44 >> 2];
    $8 = HEAP32[$0 + 112 >> 2];
    $10 = $13;
    if (($5 | 0) == 50) {
     break label$29;
    }
    $44 = 1;
    $10 = Math_imul(Math_imul($8, -40) - 20 | 0, $5 - 50 | 0) + $13 | 0;
    break label$29;
   }
   $42 = $29 << 3;
   $9 = HEAP32[$0 + 40 >> 2];
   $34 = HEAP32[$0 + 44 >> 2];
   $8 = HEAP32[$0 + 112 >> 2];
   $10 = $13;
  }
  $10 = $7 ? $10 : (($10 | 0) / -12 | 0) + $10 | 0;
  $32 = $34 + 90 | 0;
  $25 = (Math_imul($10, $32) | 0) / 100 | 0;
  $36 = Math_imul($9, 12) + 20 | 0;
  $18 = (Math_imul($25, $9) | 0) / ($36 | 0) | 0;
  $10 = 127;
  label$49 : {
   label$50 : {
    switch (HEAP32[$0 + 124 >> 2] - 3001 | 0) {
    case 1:
     $10 = 0;
     break label$49;
    case 0:
     break label$49;
    default:
     break label$50;
    }
   }
   $10 = HEAP32[$0 + 140 >> 2];
   if (($10 | 0) >= 0) {
    $10 = Math_imul($10, 327) >> 8;
    if (HEAP32[$0 + 108 >> 2] != 2049) {
     break label$49;
    }
    $10 = ($10 | 0) < 115 ? $10 : 115;
    break label$49;
   }
   $10 = HEAP32[$0 + 108 >> 2] == 2048 ? 115 : 48;
  }
  $11 = HEAP32[$0 + 120 >> 2];
  label$53 : {
   label$54 : {
    if (($11 | 0) != -1e3) {
     if (($8 | 0) != 2) {
      break label$54;
     }
     HEAP32[$0 + 14192 >> 2] = $11;
     $8 = $11;
     break label$53;
    }
    if (($8 | 0) != 2) {
     break label$54;
    }
    $8 = ((Math_imul(Math_imul($10, $10), 2e3) >>> 14 | 0) + (HEAP32[$0 + 14192 >> 2] == 2 ? 16e3 : 18e3) | 0) < ($25 - $18 | 0) ? 2 : 1;
   }
   HEAP32[$0 + 14192 >> 2] = $8;
  }
  $25 = !(HEAP32[$14 + 544 >> 2] | $41) & HEAP32[$0 + 184 >> 2] != 0;
  HEAP32[$0 + 56 >> 2] = $25;
  $11 = $44 ? Math_imul(Math_imul($8, -40) - 20 | 0, $5 - 50 | 0) + $13 | 0 : $13;
  $11 = $7 ? $11 : (($11 | 0) / -12 | 0) + $11 | 0;
  $11 = (Math_imul($32, $11) | 0) / 100 | 0;
  $27 = (Math_imul($11, $9) | 0) / ($36 | 0) | 0;
  $33 = HEAP32[$0 + 108 >> 2];
  label$57 : {
   if (($33 | 0) == 2051) {
    $11 = 1002;
    HEAP32[$0 + 14224 >> 2] = 1002;
    $25 = $0 + 14224 | 0;
    $33 = (($6 | 0) / 100 | 0) > ($2 | 0);
    break label$57;
   }
   $18 = HEAP32[$0 + 136 >> 2];
   label$59 : {
    if (($18 | 0) == -1e3) {
     $31 = $0;
     $27 = $11 - $27 | 0;
     $17 = Math_fround(Math_fround(1) - $16);
     $21 = Math_fround(Math_fround($16 * Math_fround(1e4)) + Math_fround($17 * Math_fround(1e4)));
     label$61 : {
      if (Math_fround(Math_abs($21)) < Math_fround(2147483648)) {
       $18 = ~~$21;
       break label$61;
      }
      $18 = -2147483648;
     }
     $39 = $18;
     $16 = Math_fround(Math_fround($16 * Math_fround(44e3)) + Math_fround($17 * Math_fround(64e3)));
     label$63 : {
      if (Math_fround(Math_abs($16)) < Math_fround(2147483648)) {
       $11 = ~~$16;
       break label$63;
      }
      $11 = -2147483648;
     }
     $11 = $39 + (Math_imul($11 - $18 | 0, Math_imul($10, $10)) >> 14) | 0;
     $11 = ($33 | 0) == 2048 ? $11 + 8e3 | 0 : $11;
     $18 = HEAP32[$0 + 14228 >> 2];
     $18 = ($27 | 0) < ((($18 | 0) == 1002 ? $11 - 4e3 | 0 : ($18 | 0) > 0 ? $11 + 4e3 | 0 : $11) | 0) ? 1e3 : 1002;
     HEAP32[$31 + 14224 >> 2] = $18;
     if (!(!HEAP32[$0 + 48 >> 2] | 128 - $10 >> 4 >= ($9 | 0))) {
      HEAP32[$0 + 14224 >> 2] = 1e3;
      $18 = 1e3;
     }
     $11 = (Math_imul($44 ? 9e3 : 6e3, $2) | 0) / ($6 << 3) | 0;
     if (($23 | 0) >= ($11 | 0) ? !(($10 | 0) > 100 & $25) : 0) {
      break label$59;
     }
     $18 = ($11 | 0) > ($23 | 0) ? 1002 : 1e3;
    }
    HEAP32[$0 + 14224 >> 2] = $18;
   }
   $25 = $0 + 14224 | 0;
   $6 = ($6 | 0) / 100 | 0;
   $33 = ($6 | 0) > ($2 | 0);
   if (($2 | 0) >= ($6 | 0)) {
    $11 = $18;
    break label$57;
   }
   $11 = 1002;
   if (($18 | 0) == 1002) {
    $11 = $18;
    break label$57;
   }
   HEAP32[$25 >> 2] = 1002;
  }
  if (HEAP32[$0 + 176 >> 2]) {
   HEAP32[$25 >> 2] = 1002;
   $11 = 1002;
  }
  $27 = 0;
  label$69 : {
   label$70 : {
    label$71 : {
     $18 = HEAP32[$0 + 14228 >> 2];
     if (($18 | 0) < 1) {
      break label$71;
     }
     if (!(($11 | 0) != 1002 ? ($18 | 0) == 1002 : 0)) {
      if (($11 | 0) != 1002) {
       break label$71;
      }
      $6 = 1002;
      if (($18 | 0) == 1002) {
       break label$70;
      }
     }
     $6 = 1002;
     $45 = 1;
     label$73 : {
      if (($11 | 0) != 1002) {
       $43 = 1;
       $6 = $11;
       break label$73;
      }
      $31 = 0;
      if ($33) {
       break label$69;
      }
      HEAP32[$25 >> 2] = $18;
      $45 = 0;
      $27 = 1;
      $6 = $18;
     }
     $31 = 1;
     break label$69;
    }
    $6 = $11;
   }
   $45 = 1;
   $31 = 0;
  }
  label$75 : {
   label$76 : {
    if (($8 | 0) != 1 | HEAP32[$0 + 14232 >> 2] != 2 | (HEAP32[$0 + 68 >> 2] | ($18 | 0) == 1002)) {
     break label$76;
    }
    if (($6 | 0) == 1002) {
     break label$76;
    }
    $8 = 2;
    HEAP32[$0 + 14192 >> 2] = 2;
    HEAP32[$0 + 68 >> 2] = 1;
    break label$75;
   }
   HEAP32[$0 + 68 >> 2] = 0;
  }
  $33 = $0 + $22 | 0;
  $13 = $44 ? Math_imul(Math_imul($8, -40) - 20 | 0, $5 - 50 | 0) + $13 | 0 : $13;
  $13 = $7 ? $13 : (($13 | 0) / -12 | 0) + $13 | 0;
  $8 = (Math_imul($32, $13) | 0) / 100 | 0;
  $39 = $0;
  label$78 : {
   label$79 : {
    label$80 : {
     label$81 : {
      label$82 : {
       label$83 : {
        label$84 : {
         if (($6 & -2) == 1e3) {
          $7 = 1;
          $11 = 1002;
          $32 = 0;
          $8 = ($34 | 0) <= 1 ? ($8 << 2) / 5 | 0 : $8;
          $8 = $8 - ((Math_imul($8, $9) | 0) / (Math_imul($9, 6) + 10 | 0) | 0) | 0;
          $9 = $8;
          if (($6 | 0) != 1002) {
           break label$84;
          }
          break label$83;
         }
         $11 = 1002;
         if (($6 | 0) == 1002) {
          $32 = 0;
          $7 = 1;
          if (($34 | 0) > 4) {
           break label$83;
          }
          $8 = (Math_imul($8, 9) | 0) / 10 | 0;
          break label$83;
         }
         $9 = $8 - ((Math_imul($8, $9) | 0) / ($36 | 0) | 0) | 0;
        }
        $8 = $9;
        $32 = 0;
        if (($18 | 0) == 1002) {
         silk_InitEncoder($33, HEAP32[$0 + 180 >> 2], $14 + 440 | 0);
         $32 = 1;
         $6 = HEAP32[$0 + 14224 >> 2];
        }
        $7 = 1;
        if (($6 | 0) == 1002) {
         break label$83;
        }
        $7 = 0;
        if (HEAP32[$0 + 84 >> 2] ? 0 : !HEAP32[$0 + 14252 >> 2]) {
         break label$82;
        }
        $11 = $6;
       }
       $13 = Math_imul($10, $10);
       $9 = (Math_imul($13, 2e3) >> 14) + 12e3 | 0;
       $10 = (Math_imul($13, 2500) >> 14) + 11e3 | 0;
       label$89 : {
        label$90 : {
         $6 = HEAP32[$0 + 14252 >> 2];
         if (!$6) {
          $13 = 1105;
          $22 = 1;
          if (((HEAP32[$0 + 14244 >> 2] < 1105 ? 2e3 : -2e3) + $9 | 0) <= ($8 | 0)) {
           break label$80;
          }
          if ($6) {
           break label$89;
          }
          if (HEAP32[$0 + 14244 >> 2] < 1104) {
           break label$90;
          }
          $10 = $10 - 1e3 | 0;
          break label$89;
         }
         if (($8 | 0) < ($9 | 0)) {
          break label$89;
         }
         HEAP32[$0 + 14240 >> 2] = 1105;
         HEAP32[$0 + 14244 >> 2] = 1105;
         $13 = 1105;
         break label$79;
        }
        $10 = $10 + 1e3 | 0;
       }
       if (($8 | 0) >= ($10 | 0)) {
        $13 = 1104;
        $22 = 1;
        break label$80;
       }
       if (!$6) {
        $13 = 1103;
        $22 = 0;
        if (((HEAP32[$0 + 14244 >> 2] < 1103 ? 9700 : 8300) | 0) <= ($8 | 0)) {
         break label$80;
        }
        $13 = 9e3;
        if ($6) {
         break label$81;
        }
        $13 = HEAP32[$0 + 14244 >> 2] < 1102 ? 9700 : 8300;
        break label$81;
       }
       $13 = 9e3;
       if (($8 | 0) < 9e3) {
        break label$81;
       }
       HEAP32[$0 + 14240 >> 2] = 1103;
       HEAP32[$0 + 14244 >> 2] = 1103;
       $13 = 1103;
       break label$79;
      }
      $13 = HEAP32[$0 + 14240 >> 2];
      break label$78;
     }
     $13 = ($8 | 0) < ($13 | 0) ? 1101 : 1103;
     $22 = 0;
    }
    HEAP32[$39 + 14240 >> 2] = $13;
    HEAP32[$0 + 14244 >> 2] = $13;
    if ($6 | $7 | (HEAP32[$0 + 88 >> 2] | $22 ^ 1)) {
     break label$79;
    }
    $13 = 1103;
    HEAP32[$0 + 14240 >> 2] = 1103;
   }
   $6 = $11;
  }
  $9 = HEAP32[$0 + 132 >> 2];
  if (($13 | 0) > ($9 | 0)) {
   HEAP32[$0 + 14240 >> 2] = $9;
   $13 = $9;
  }
  $9 = HEAP32[$0 + 128 >> 2];
  if (($9 | 0) != -1e3) {
   HEAP32[$0 + 14240 >> 2] = $9;
   $13 = $9;
  }
  if (!(($6 | 0) == 1002 | ($29 | 0) > 1874)) {
   $13 = ($13 | 0) < 1103 ? $13 : 1103;
   HEAP32[$0 + 14240 >> 2] = $13;
  }
  $6 = HEAP32[$0 + 144 >> 2];
  label$97 : {
   if (($6 | 0) > 24e3) {
    $22 = $13;
    break label$97;
   }
   $22 = 1104;
   label$99 : {
    label$100 : {
     label$101 : {
      label$102 : {
       if (($13 | 0) <= 1104) {
        if (($6 | 0) >= 16001) {
         $22 = $13;
         break label$97;
        }
        if (($13 | 0) > 1103) {
         break label$102;
        }
        if (($6 | 0) < 12001) {
         break label$101;
        }
        $22 = $13;
        break label$97;
       }
       HEAP32[$0 + 14240 >> 2] = 1104;
       if (($6 | 0) >= 16001) {
        break label$97;
       }
      }
      $22 = 1103;
      HEAP32[$0 + 14240 >> 2] = 1103;
      if (($6 | 0) >= 12001) {
       break label$97;
      }
      break label$100;
     }
     if (($13 | 0) > 1102) {
      break label$100;
     }
     if (($6 | 0) > 8e3) {
      $22 = $13;
      break label$97;
     }
     $22 = $13;
     if (($13 | 0) != 1102) {
      break label$97;
     }
     break label$99;
    }
    $22 = 1102;
    HEAP32[$0 + 14240 >> 2] = 1102;
    if (($6 | 0) > 8e3) {
     break label$97;
    }
   }
   $22 = 1101;
   HEAP32[$0 + 14240 >> 2] = 1101;
  }
  $13 = HEAP32[$0 + 18120 >> 2];
  if (!(!$13 | ($9 | 0) != -1e3)) {
   $11 = $0;
   $18 = $13;
   $9 = HEAP32[$0 + 14192 >> 2];
   label$107 : {
    label$108 : {
     if ((Math_imul($9, 18e3) | 0) >= ($8 | 0)) {
      $10 = 0;
      if (!$7) {
       break label$108;
      }
      $7 = 1;
      $6 = 1101;
      break label$107;
     }
     if ((Math_imul($9, 24e3) | 0) < ($8 | 0)) {
      $10 = $7;
      break label$108;
     }
     $10 = $7;
     $6 = 1102;
     if (!($7 ^ 1)) {
      break label$107;
     }
    }
    $7 = $10;
    $6 = (Math_imul($9, 3e4) | 0) < ($8 | 0) ? (Math_imul($9, 44e3) | 0) < ($8 | 0) ? 1105 : 1104 : 1103;
   }
   $13 = ($6 | 0) < ($13 | 0) ? $18 : $6;
   HEAP32[$11 + 18120 >> 2] = $13;
   $22 = ($13 | 0) > ($22 | 0) ? $22 : $13;
   HEAP32[$0 + 14240 >> 2] = $22;
  }
  $13 = 0;
  label$113 : {
   if (!HEAP32[$0 + 48 >> 2] | $7) {
    break label$113;
   }
   $6 = HEAP32[$0 + 40 >> 2];
   if (!$6) {
    break label$113;
   }
   $7 = 125 - (($6 | 0) < 25 ? $6 : 25) | 0;
   $9 = HEAP32[$0 + 52 >> 2];
   $10 = ($9 | 0) == 1;
   $11 = ($6 | 0) < 6;
   $13 = $22;
   label$114 : {
    while (1) {
     $6 = $13 << 3;
     $18 = HEAP32[$6 + 41864 >> 2];
     $6 = HEAP32[$6 + 41868 >> 2];
     $6 = Math_imul(($18 - ($10 ? $6 : 0) | 0) + ($9 ? 0 : $6) | 0, $7);
     $6 = (Math_imul($6 & 65535, 655) >>> 16 | 0) + Math_imul($6 >> 16, 655) | 0;
     if (($8 | 0) > ($6 | 0) | $11) {
      break label$114;
     }
     if (($13 | 0) > 1101) {
      $13 = $13 - 1 | 0;
      HEAP32[$0 + 14240 >> 2] = $13;
      continue;
     }
     break;
    }
    HEAP32[$0 + 14240 >> 2] = $22;
    $13 = 0;
    break label$113;
   }
   $13 = ($6 | 0) < ($8 | 0);
  }
  HEAP32[$0 + 52 >> 2] = $13;
  HEAP32[$14 + 400 >> 2] = $20;
  opus_custom_encoder_ctl($19, 4036, $14 + 400 | 0);
  $13 = HEAP32[$0 + 14224 >> 2];
  if (!(($13 | 0) != 1002 | HEAP32[$0 + 14240 >> 2] != 1102)) {
   HEAP32[$0 + 14240 >> 2] = 1103;
  }
  label$118 : {
   label$119 : {
    label$120 : {
     label$121 : {
      label$122 : {
       label$123 : {
        if (HEAP32[$0 + 176 >> 2]) {
         $11 = 1101;
         HEAP32[$0 + 14240 >> 2] = 1101;
         break label$123;
        }
        $11 = HEAP32[$0 + 14240 >> 2];
        if (($13 | 0) != 1e3) {
         break label$123;
        }
        if (($11 | 0) > 1103) {
         break label$122;
        }
       }
       if (!(($13 | 0) != 1001 | ($11 | 0) > 1103)) {
        HEAP32[$25 >> 2] = 1e3;
        $13 = 1e3;
       }
       $7 = HEAP32[$0 + 144 >> 2];
       $6 = ($7 | 0) / 50 | 0;
       if (($6 | 0) < ($2 | 0)) {
        break label$121;
       }
       $9 = $13;
       break label$120;
      }
      $9 = 1001;
      HEAP32[$0 + 14224 >> 2] = 1001;
      $7 = HEAP32[$0 + 144 >> 2];
      $6 = ($7 | 0) / 50 | 0;
      if (($6 | 0) < ($2 | 0) | ((Math_imul($7, 3) | 0) / 50 | 0) < ($2 | 0)) {
       break label$119;
      }
      break label$118;
     }
     $9 = 1e3;
     if (($13 | 0) != 1e3) {
      break label$119;
     }
    }
    $13 = Math_imul($7, 3);
    $10 = ($13 | 0) / 50 | 0;
    if (($10 | 0) >= ($2 | 0)) {
     break label$118;
    }
    if (($9 | 0) != 1e3) {
     break label$119;
    }
    if ((($7 << 1) / 25 | 0) == ($2 | 0)) {
     $6 = ($7 | 0) / 25 | 0;
     break label$119;
    }
    $6 = (($13 | 0) / 25 | 0) == ($2 | 0) ? $10 : $6;
   }
   $13 = ($2 | 0) / ($6 | 0) | 0;
   if (($30 | 0) != -1) {
    HEAP32[$0 + 7640 >> 2] = $24;
    HEAP32[$0 + 7636 >> 2] = $30;
   }
   $13 = encode_multiframe_packet($0, $1, $13, $6, $3, $4, $27, $20, $12);
   break label$1;
  }
  if (HEAP32[$0 + 14248 >> 2]) {
   HEAP32[$0 + 14248 >> 2] = 0;
   $43 = 1;
   $31 = 1;
   $32 = 2;
  }
  $13 = HEAP32[$0 + 160 >> 2];
  $30 = 0;
  label$129 : {
   if (!$31) {
    $18 = 0;
    $4 = 0;
    break label$129;
   }
   $18 = 0;
   $4 = 0;
   if (($9 | 0) == 1002) {
    break label$129;
   }
   $6 = HEAP32[$0 + 14192 >> 2];
   $4 = Math_imul($6, 40) + 20 | 0;
   $9 = (Math_imul(Math_imul($4, 200 - $5 | 0) + $13 | 0, 3) | 0) / 3200 | 0;
   $4 = (((Math_imul(($23 << 3) - ($4 << 1) | 0, 240) | 0) / ((48e3 / ($5 | 0) | 0) + 240 | 0) | 0) + $4 | 0) / 8 | 0;
   $4 = ($4 | 0) > ($9 | 0) ? $9 : $4;
   $30 = ($6 << 3 | 4) < ($4 | 0) ? ($4 | 0) < 257 ? $4 : 257 : 0;
   $18 = ($30 | 0) != 0;
   $4 = $18;
  }
  $39 = $4;
  $40 = $3 + 1 | 0;
  $22 = $23 - 1 | 0;
  ec_enc_init($14 + 440 | 0, $40, $22);
  $34 = $2 + $38 | 0;
  $4 = $15 - ((Math_imul($34, HEAP32[$0 + 112 >> 2]) << 2) + 15 & -16) | 0;
  $20 = $4;
  __stack_pointer = $4;
  $31 = $0 + 14280 | 0;
  $15 = HEAP32[$0 + 112 >> 2];
  $9 = memcpy($4, $31 + (Math_imul($15, HEAP32[$0 + 172 >> 2] - $38 | 0) << 2) | 0, Math_imul($15, $38) << 2);
  $27 = (Math_imul($2, $13) | 0) / ($7 << 3) | 0;
  $6 = $0;
  label$131 : {
   if (HEAP32[$0 + 14224 >> 2] == 1002) {
    $13 = silk_lin2log(60) << 8;
    break label$131;
   }
   $13 = HEAP32[$33 + 8 >> 2];
  }
  $4 = HEAP32[$0 + 14200 >> 2];
  $13 = $13 - $4 | 0;
  $13 = Math_imul($13 >> 16, 983) + $4 + (Math_imul($13 & 65535, 983) >>> 16) | 0;
  HEAP32[$6 + 14200 >> 2] = $13;
  $24 = $0 + 14208 | 0;
  $15 = silk_log2lin($13 >> 8);
  $6 = HEAP32[$0 + 112 >> 2];
  $13 = (Math_imul($38, $6) << 2) + $9 | 0;
  $4 = HEAP32[$0 + 144 >> 2];
  label$133 : {
   if (HEAP32[$0 + 108 >> 2] == 2048) {
    $4 = (Math_imul($15 << 16 >> 16, 2471) | 0) / (($4 | 0) / 1e3 | 0) | 0;
    if (($2 | 0) < 1) {
     break label$133;
    }
    $15 = $4 << 16 >> 16;
    $7 = ((Math_imul($15, $4 >> 16) + (Math_imul($4 & 65535, $15) >> 16) | 0) + Math_imul(($4 >> 15) + 1 >> 1, $4) | 0) - 8388608 | 0;
    $10 = $7 << 16 >> 16;
    $15 = Math_imul($4, -471) + 268435456 | 0;
    $4 = $15 >> 6;
    $37 = $4 & 65535;
    $36 = $15 >> 22;
    $35 = Math_fround(Math_fround(((Math_imul($10, $37) >> 16) + Math_imul($36, $10) | 0) + Math_imul(($7 >> 15) + 1 >> 1, $4) | 0) * Math_fround(3.725290298461914e-9));
    $7 = Math_imul(($15 >> 21) + 1 >> 1, $4);
    $4 = $4 << 16 >> 16;
    $47 = Math_fround(Math_fround(($7 + Math_imul($36, $4) | 0) + (Math_imul($4, $37) >> 16) | 0) * Math_fround(3.725290298461914e-9));
    $48 = Math_fround(Math_fround($15 | 0) * Math_fround(3.725290298461914e-9));
    $4 = 0;
    $49 = Math_fround(Math_fround(0 - ($15 << 1) | 0) * Math_fround(3.725290298461914e-9));
    $17 = HEAPF32[$0 + 14212 >> 2];
    $21 = HEAPF32[$0 + 14208 >> 2];
    while (1) {
     $15 = Math_imul($4, $6) << 2;
     $26 = HEAPF32[$15 + $1 >> 2];
     $16 = Math_fround($48 * $26);
     $28 = $16;
     $16 = Math_fround($21 + $16);
     $28 = Math_fround(Math_fround($28 - Math_fround($47 * $16)) + Math_fround(1.0000000031710769e-30));
     HEAPF32[$0 + 14212 >> 2] = $28;
     $21 = Math_fround(Math_fround($49 * $26) + Math_fround($17 - Math_fround($35 * $16)));
     HEAPF32[$0 + 14208 >> 2] = $21;
     HEAPF32[$13 + $15 >> 2] = $16;
     $17 = $28;
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
    if (($6 | 0) != 2) {
     break label$133;
    }
    $7 = $13 + 4 | 0;
    $10 = $1 + 4 | 0;
    $17 = HEAPF32[$0 + 14220 >> 2];
    $21 = HEAPF32[$0 + 14216 >> 2];
    $4 = 0;
    while (1) {
     $15 = $4 << 3;
     $26 = HEAPF32[$15 + $10 >> 2];
     $16 = Math_fround($48 * $26);
     $28 = $16;
     $16 = Math_fround($21 + $16);
     $28 = Math_fround(Math_fround($28 - Math_fround($47 * $16)) + Math_fround(1.0000000031710769e-30));
     HEAPF32[$0 + 14220 >> 2] = $28;
     $21 = Math_fround(Math_fround($49 * $26) + Math_fround($17 - Math_fround($35 * $16)));
     HEAPF32[$0 + 14216 >> 2] = $21;
     HEAPF32[$7 + $15 >> 2] = $16;
     $17 = $28;
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
    break label$133;
   }
   $17 = Math_fround(Math_fround(18.900001525878906) / Math_fround($4 | 0));
   $21 = Math_fround(Math_fround(1) - $17);
   $16 = HEAPF32[$24 >> 2];
   if (($6 | 0) != 2) {
    $4 = 0;
    if (($2 | 0) > 0) {
     while (1) {
      $15 = $4 << 2;
      $26 = HEAPF32[$15 + $1 >> 2];
      HEAPF32[$13 + $15 >> 2] = $26 - $16;
      $16 = Math_fround(Math_fround($21 * $16) + Math_fround(Math_fround($17 * $26) + Math_fround(1.0000000031710769e-30)));
      $4 = $4 + 1 | 0;
      if (($4 | 0) != ($2 | 0)) {
       continue;
      }
      break;
     }
    }
    HEAPF32[$24 >> 2] = $16;
    break label$133;
   }
   $26 = HEAPF32[$0 + 14216 >> 2];
   if (($2 | 0) >= 1) {
    $4 = 0;
    while (1) {
     $15 = $4 << 3;
     $7 = $15 | 4;
     $28 = HEAPF32[$7 + $1 >> 2];
     $35 = HEAPF32[$1 + $15 >> 2];
     HEAPF32[$13 + $15 >> 2] = $35 - $16;
     HEAPF32[$7 + $13 >> 2] = $28 - $26;
     $16 = Math_fround(Math_fround($21 * $16) + Math_fround(Math_fround($17 * $35) + Math_fround(1.0000000031710769e-30)));
     $26 = Math_fround(Math_fround($21 * $26) + Math_fround(Math_fround($17 * $28) + Math_fround(1.0000000031710769e-30)));
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   HEAPF32[$0 + 14216 >> 2] = $26;
   HEAPF32[$0 + 14208 >> 2] = $16;
  }
  label$142 : {
   if (!$12) {
    break label$142;
   }
   $16 = Math_fround(0);
   $15 = Math_imul($2, $6);
   if (($15 | 0) >= 1) {
    $4 = 0;
    while (1) {
     $17 = HEAPF32[($4 << 2) + $13 >> 2];
     $16 = Math_fround($16 + Math_fround($17 * $17));
     $4 = $4 + 1 | 0;
     if (($15 | 0) != ($4 | 0)) {
      continue;
     }
     break;
    }
   }
   if ($16 == $16 ? !($16 < Math_fround(1e9) ^ 1) : 0) {
    break label$142;
   }
   memset($13, 0, $15 << 2);
   HEAP32[$24 + 8 >> 2] = 0;
   HEAP32[$24 + 12 >> 2] = 0;
   HEAP32[$24 >> 2] = 0;
   HEAP32[$24 + 4 >> 2] = 0;
  }
  $21 = Math_fround(1);
  label$145 : {
   if (HEAP32[$25 >> 2] != 1002) {
    $4 = 1;
    $36 = $20;
    $10 = $20 - ((Math_imul($2, $6) << 1) + 15 & -16) | 0;
    __stack_pointer = $10;
    $26 = HEAPF32[$14 + 580 >> 2];
    $52 = HEAP32[$14 + 544 >> 2];
    $13 = $23 - $30 | 0;
    $27 = Math_imul(((($13 | 0) < ($27 | 0) ? $13 : $27) << 3) - 8 | 0, $5);
    label$147 : {
     label$148 : {
      label$149 : {
       label$150 : {
        label$151 : {
         label$152 : {
          $24 = HEAP32[$25 >> 2];
          if (($24 | 0) == 1001) {
           $6 = (HEAP32[$0 + 52 >> 2] << 1) + (HEAP32[$0 + 144 >> 2] == (Math_imul($2, 50) | 0) ? 2 : 1) | 0;
           $12 = HEAP32[$0 + 148 >> 2];
           $15 = HEAP32[$0 + 14192 >> 2];
           $13 = ($27 | 0) / ($15 | 0) | 0;
           if (($13 | 0) < 12e3) {
            break label$152;
           }
           $4 = 2;
           if (($13 | 0) < 16e3) {
            break label$152;
           }
           $4 = 3;
           if (($13 | 0) < 2e4) {
            break label$152;
           }
           $4 = 4;
           if (($13 | 0) < 24e3) {
            break label$152;
           }
           $4 = 5;
           if (($13 | 0) < 32e3) {
            break label$152;
           }
           $4 = 6;
           if (($13 | 0) < 64e3) {
            break label$152;
           }
           $4 = HEAP32[($6 << 2) + 50840 >> 2] + (($13 - 64e3 | 0) / 2 | 0) | 0;
           break label$151;
          }
          HEAP32[$0 + 36 >> 2] = $27;
          $12 = HEAP32[$0 + 14256 >> 2];
          if ($12) {
           break label$150;
          }
          $6 = $27;
          break label$147;
         }
         $4 = Math_imul($4, 20);
         $7 = $4 + 50720 | 0;
         $20 = HEAP32[$7 >> 2];
         $4 = $4 + 50700 | 0;
         $6 = $6 << 2;
         $37 = Math_imul($20 - $13 | 0, HEAP32[$4 + $6 >> 2]);
         $4 = HEAP32[$4 >> 2];
         $4 = ($37 + Math_imul(HEAP32[$6 + $7 >> 2], $13 - $4 | 0) | 0) / ($20 - $4 | 0) | 0;
        }
        $4 = $12 ? $4 : $4 + 100 | 0;
        $4 = Math_imul(($11 | 0) == 1104 ? $4 + 300 | 0 : $4, $15);
        $6 = ($15 | 0) == 2 ? ($13 | 0) > 11999 ? $4 - 1e3 | 0 : $4 : $4;
        HEAP32[$0 + 36 >> 2] = $6;
        $12 = HEAP32[$0 + 14256 >> 2];
        if (!$12) {
         break label$149;
        }
        $27 = $6;
       }
       if (HEAP32[$0 + 148 >> 2]) {
        break label$148;
       }
       $6 = $27;
       break label$147;
      }
      $21 = Math_fround(Math_fround(1) - Math_fround(exp(+Math_fround(Math_fround($6 - $27 | 0) * Math_fround(.0009765625)) * .6931471805599453)));
      break label$147;
     }
     if (HEAP32[$0 + 176 >> 2]) {
      $6 = $27;
      break label$147;
     }
     $28 = Math_fround(8e3);
     $7 = 13;
     label$155 : {
      label$156 : {
       label$157 : {
        $50 = HEAP32[$0 + 14240 >> 2];
        switch ($50 - 1101 | 0) {
        case 0:
         break label$155;
        case 1:
         break label$157;
        default:
         break label$156;
        }
       }
       $28 = Math_fround(12e3);
       $7 = 15;
       break label$155;
      }
      $28 = Math_fround(16e3);
      $7 = 17;
     }
     $17 = Math_fround(0);
     $37 = HEAP32[$0 + 112 >> 2];
     if (($37 | 0) >= 1) {
      $20 = 0;
      while (1) {
       $6 = Math_imul($20, 21);
       $13 = 0;
       while (1) {
        $16 = HEAPF32[($6 + $13 << 2) + $12 >> 2];
        $35 = $16;
        $4 = $16 < Math_fround(.5);
        $15 = ($4 ? $16 : Math_fround(.5)) > Math_fround(-2);
        $16 = $15 ? Math_fround(.5) : Math_fround(-2);
        $16 = $15 ? $4 ? $35 : $16 : $16;
        $17 = Math_fround($17 + ($16 > Math_fround(0) ? Math_fround($16 * Math_fround(.5)) : $16));
        $13 = $13 + 1 | 0;
        if (($13 | 0) != ($7 | 0)) {
         continue;
        }
        break;
       }
       $20 = $20 + 1 | 0;
       if (($37 | 0) != ($20 | 0)) {
        continue;
       }
       break;
      }
     }
     $13 = (0 - ($27 << 1) | 0) / 3 | 0;
     $16 = Math_fround($28 * Math_fround(Math_fround(Math_fround($17 / Math_fround($7 | 0)) * Math_fround($37 | 0)) + Math_fround(.20000000298023224)));
     label$161 : {
      if (Math_fround(Math_abs($16)) < Math_fround(2147483648)) {
       $4 = ~~$16;
       break label$161;
      }
      $4 = -2147483648;
     }
     $13 = ($4 | 0) > ($13 | 0) ? $4 : $13;
     $13 = ($50 & -2) == 1104 ? (Math_imul($13, 3) | 0) / 5 | 0 : $13;
     $6 = $27 + $13 | 0;
     HEAP32[$0 + 36 >> 2] = $6;
    }
    $15 = HEAP32[$0 + 112 >> 2];
    HEAP32[$0 + 8 >> 2] = $15;
    $7 = HEAP32[$0 + 14192 >> 2];
    HEAP32[$0 + 12 >> 2] = $7;
    $4 = HEAP32[$0 + 144 >> 2];
    HEAP32[$0 + 32 >> 2] = (Math_imul($2, 1e3) | 0) / ($4 | 0);
    $13 = 8e3;
    $12 = 8e3;
    label$164 : {
     label$165 : {
      switch ($11 - 1101 | 0) {
      default:
       $12 = 12e3;
       $13 = 16e3;
       if (($11 | 0) == 1103 | ($24 | 0) == 1001) {
        break label$164;
       }
       celt_fatal(50496, 50583, 1755);
       abort();
      case 0:
       break label$164;
      case 1:
       break label$165;
      }
     }
     $13 = 12e3;
     $12 = 12e3;
    }
    HEAP32[$0 + 28 >> 2] = $13;
    HEAP32[$0 + 20 >> 2] = 16e3;
    HEAP32[$0 + 24 >> 2] = ($24 | 0) == 1001 ? 16e3 : 8e3;
    label$167 : {
     if (($24 | 0) != 1e3) {
      break label$167;
     }
     $42 = $44 ? ($29 << 4) / 3 | 0 : $42;
     if (($42 | 0) > 7999) {
      break label$167;
     }
     HEAP32[$0 + 20 >> 2] = 12e3;
     HEAP32[$0 + 28 >> 2] = $12;
     if (($42 | 0) > 6999) {
      break label$167;
     }
     HEAP32[$0 + 28 >> 2] = 8e3;
     HEAP32[$0 + 20 >> 2] = 8e3;
    }
    $12 = $26 >= Math_fround(.10000000149011612);
    $13 = $22 << 3;
    HEAP32[$0 - -64 >> 2] = $13;
    $20 = HEAP32[$0 + 148 >> 2];
    HEAP32[$0 + 60 >> 2] = !$20;
    label$168 : {
     label$169 : {
      label$170 : {
       label$171 : {
        if (!($18 ^ 1 | ($30 | 0) < 2)) {
         $13 = ($30 << 3 ^ -1) + $13 | 0;
         HEAP32[$0 + 64 >> 2] = $13;
         if (($24 | 0) != 1001) {
          break label$168;
         }
         $13 = $13 - 20 | 0;
         HEAP32[$0 + 64 >> 2] = $13;
         if (!$20) {
          break label$169;
         }
         break label$171;
        }
        if (!$20) {
         break label$170;
        }
        if (($24 | 0) != 1001) {
         break label$168;
        }
       }
       $6 = 1;
       $20 = (HEAP32[$0 + 52 >> 2] << 1) + ((Math_imul($2, 50) | 0) == ($4 | 0) ? 2 : 1) | 0;
       $18 = $0;
       label$173 : {
        label$174 : {
         $13 = ((Math_imul($4, $13) | 0) / ($2 | 0) | 0) / ($7 | 0) | 0;
         if (($13 | 0) < 12e3) {
          break label$174;
         }
         $6 = 2;
         if (($13 | 0) < 16e3) {
          break label$174;
         }
         $6 = 3;
         if (($13 | 0) < 2e4) {
          break label$174;
         }
         $6 = 4;
         if (($13 | 0) < 24e3) {
          break label$174;
         }
         $6 = 5;
         if (($13 | 0) < 32e3) {
          break label$174;
         }
         $6 = 6;
         if (($13 | 0) < 64e3) {
          break label$174;
         }
         $6 = HEAP32[($20 << 2) + 50840 >> 2] + (($13 - 64e3 | 0) / 2 | 0) | 0;
         break label$173;
        }
        $6 = Math_imul($6, 20);
        $29 = $6 + 50720 | 0;
        $24 = HEAP32[$29 >> 2];
        $6 = $6 + 50700 | 0;
        $20 = $20 << 2;
        $27 = Math_imul($24 - $13 | 0, HEAP32[$6 + $20 >> 2]);
        $6 = HEAP32[$6 >> 2];
        $6 = ($27 + Math_imul(HEAP32[$20 + $29 >> 2], $13 - $6 | 0) | 0) / ($24 - $6 | 0) | 0;
       }
       $6 = Math_imul(($11 | 0) == 1104 ? $6 + 300 | 0 : $6, $7);
       HEAP32[$18 + 64 >> 2] = (Math_imul(($7 | 0) == 2 ? ($13 | 0) > 11999 ? $6 - 1e3 | 0 : $6 : $6, $2) | 0) / ($4 | 0);
       break label$168;
      }
      if (($24 | 0) != 1001) {
       break label$168;
      }
     }
     $6 = (Math_imul($2, $6) | 0) / ($4 | 0) | 0;
     HEAP32[$0 + 64 >> 2] = ($6 | 0) > ($13 | 0) ? $13 : $6;
    }
    $6 = $0 + 8 | 0;
    $12 = $52 ? $12 : -1;
    if ($32) {
     $13 = 0;
     HEAP32[$14 + 432 >> 2] = 0;
     $7 = ($4 | 0) / 400 | 0;
     $20 = Math_imul((HEAP32[$0 + 172 >> 2] - $7 | 0) - HEAP32[$0 + 116 >> 2] | 0, $15) << 2;
     $29 = ($20 + $0 | 0) + 14280 | 0;
     $24 = HEAP32[$14 + 612 >> 2];
     gain_fade($29, $29, Math_fround(0), Math_fround(1), HEAP32[$24 + 4 >> 2], $7, $15, HEAP32[$24 + 60 >> 2], $4);
     memset($31, 0, $20);
     $15 = HEAP32[$0 + 172 >> 2];
     $4 = Math_imul($15, HEAP32[$0 + 112 >> 2]);
     if (($4 | 0) >= 1) {
      while (1) {
       $16 = Math_fround(HEAPF32[(($13 << 2) + $0 | 0) + 14280 >> 2] * Math_fround(32768));
       $16 = $16 > Math_fround(-32768) ? $16 : Math_fround(-32768);
       HEAP16[($13 << 1) + $10 >> 1] = lrintf($16 < Math_fround(32767) ? $16 : Math_fround(32767));
       $13 = $13 + 1 | 0;
       if (($13 | 0) != ($4 | 0)) {
        continue;
       }
       break;
      }
     }
     silk_Encode($33, $6, $10, $15, 0, $14 + 432 | 0, $32, $12);
     HEAP32[$0 + 72 >> 2] = 0;
     $15 = HEAP32[$0 + 112 >> 2];
    }
    $4 = Math_imul($2, $15);
    if (($4 | 0) >= 1) {
     $15 = Math_imul($15, $38);
     $13 = 0;
     while (1) {
      $16 = Math_fround(HEAPF32[($13 + $15 << 2) + $9 >> 2] * Math_fround(32768));
      $16 = $16 > Math_fround(-32768) ? $16 : Math_fround(-32768);
      HEAP16[($13 << 1) + $10 >> 1] = lrintf($16 < Math_fround(32767) ? $16 : Math_fround(32767));
      $13 = $13 + 1 | 0;
      if (($13 | 0) != ($4 | 0)) {
       continue;
      }
      break;
     }
    }
    $13 = -3;
    label$181 : {
     if (!silk_Encode($33, $6, $10, $2, $14 + 440 | 0, $14 + 620 | 0, 0, $12)) {
      $13 = HEAP32[$0 + 80 >> 2];
      label$183 : {
       label$184 : {
        $4 = HEAP32[$0 + 14224 >> 2];
        if (($4 | 0) == 1e3) {
         if (($13 | 0) == 8e3) {
          $11 = 1101;
          break label$183;
         }
         if (($13 | 0) == 16e3) {
          break label$184;
         }
         if (($13 | 0) != 12e3) {
          break label$183;
         }
         $11 = 1102;
         break label$183;
        }
        if (($13 | 0) == 16e3) {
         break label$183;
        }
        celt_fatal(50602, 50583, 1863);
        abort();
       }
       $11 = 1103;
      }
      label$187 : {
       if (HEAP32[$0 + 96 >> 2]) {
        $13 = HEAP32[$0 + 18132 >> 2];
        HEAP32[$0 + 72 >> 2] = !$13;
        if (!HEAP32[$14 + 620 >> 2]) {
         break label$187;
        }
        if ($13) {
         break label$181;
        }
        HEAP32[$0 + 14248 >> 2] = 1;
        $43 = 0;
        $4 = HEAP32[$0 + 14192 >> 2];
        $13 = Math_imul($4, 40) + 20 | 0;
        $15 = (Math_imul(HEAP32[$0 + 160 >> 2] + Math_imul($13, 200 - $5 | 0) | 0, 3) | 0) / 3200 | 0;
        $13 = (((Math_imul(($23 << 3) - ($13 << 1) | 0, 240) | 0) / ((48e3 / ($5 | 0) | 0) + 240 | 0) | 0) + $13 | 0) / 8 | 0;
        $13 = ($13 | 0) > ($15 | 0) ? $15 : $13;
        $30 = ($4 << 3 | 4) < ($13 | 0) ? ($13 | 0) < 257 ? $13 : 257 : 0;
        $39 = ($30 | 0) != 0;
        break label$181;
       }
       HEAP32[$0 + 72 >> 2] = 0;
       if (HEAP32[$14 + 620 >> 2]) {
        break label$181;
       }
      }
      $13 = 0;
      HEAP32[$0 + 18136 >> 2] = 0;
      $1 = HEAP32[$0 + 14192 >> 2];
      $0 = HEAP32[$0 + 144 >> 2] / ($2 | 0) | 0;
      if (($0 | 0) <= 399) {
       while (1) {
        $13 = $13 + 1 | 0;
        $0 = $0 << 1;
        if (($0 | 0) < 400) {
         continue;
        }
        break;
       }
       $13 = $13 << 3;
      }
      label$191 : {
       label$192 : {
        switch ($4 - 1e3 | 0) {
        case 0:
         $0 = $13 - 16 | ($11 << 5) + 96 & 224;
         break label$191;
        case 2:
         $0 = ((($11 | 0) > 1102 ? $11 : 1102) << 5) - -64 & 96 | $13 | 128;
         break label$191;
        default:
         break label$192;
        }
       }
       $0 = $13 + 240 | $11 << 4 | 96;
      }
      HEAP8[$3 | 0] = $0 | (($1 | 0) == 2) << 2;
      $13 = 1;
     }
     break label$145;
    }
    $20 = $36;
   }
   $13 = 21;
   $4 = $11 - 1101 | 0;
   if ($4 >>> 0 <= 3) {
    $13 = HEAP32[($4 << 2) + 50860 >> 2];
   }
   HEAP32[$14 + 384 >> 2] = $13;
   opus_custom_encoder_ctl($19, 10012, $14 + 384 | 0);
   HEAP32[$14 + 368 >> 2] = HEAP32[$0 + 14192 >> 2];
   opus_custom_encoder_ctl($19, 10008, $14 + 368 | 0);
   HEAP32[$14 + 352 >> 2] = -1;
   opus_custom_encoder_ctl($19, 4002, $14 + 352 | 0);
   label$196 : {
    if (HEAP32[$0 + 14224 >> 2] == 1e3) {
     $13 = HEAP32[$0 + 112 >> 2];
     $10 = $20 - (((Math_imul($13, HEAP32[$0 + 144 >> 2]) | 0) / 400 << 2) + 15 & -16) | 0;
     __stack_pointer = $10;
     break label$196;
    }
    HEAP32[$14 + 336 >> 2] = 0;
    opus_custom_encoder_ctl($19, 4006, $14 + 336 | 0);
    HEAP32[$14 + 320 >> 2] = !HEAP32[$0 + 76 >> 2] << 1;
    opus_custom_encoder_ctl($19, 10002, $14 + 320 | 0);
    $13 = HEAP32[$0 + 148 >> 2];
    $4 = HEAP32[$0 + 14224 >> 2];
    label$198 : {
     label$199 : {
      label$200 : {
       if (($4 | 0) == 1001) {
        if (!$13) {
         $13 = HEAP32[$0 + 112 >> 2];
         $15 = HEAP32[$0 + 144 >> 2];
         $5 = (Math_imul($13, $15) | 0) / 400 | 0;
         $10 = $20 - (($5 << 2) + 15 & -16) | 0;
         __stack_pointer = $10;
         $4 = 1001;
         break label$198;
        }
        HEAP32[$14 + 256 >> 2] = HEAP32[$0 + 160 >> 2] - HEAP32[$0 + 36 >> 2];
        opus_custom_encoder_ctl($19, 4002, $14 + 256 | 0);
        HEAP32[$14 + 240 >> 2] = 0;
        opus_custom_encoder_ctl($19, 4020, $14 + 240 | 0);
        break label$200;
       }
       if (!$13) {
        break label$199;
       }
       HEAP32[$14 + 304 >> 2] = 1;
       opus_custom_encoder_ctl($19, 4006, $14 + 304 | 0);
       HEAP32[$14 + 288 >> 2] = HEAP32[$0 + 152 >> 2];
       opus_custom_encoder_ctl($19, 4020, $14 + 288 | 0);
       HEAP32[$14 + 272 >> 2] = HEAP32[$0 + 160 >> 2];
       opus_custom_encoder_ctl($19, 4002, $14 + 272 | 0);
      }
      $4 = HEAP32[$25 >> 2];
     }
     $13 = HEAP32[$0 + 112 >> 2];
     $15 = HEAP32[$0 + 144 >> 2];
     $5 = (Math_imul($13, $15) | 0) / 400 | 0;
     $10 = $20 - (($5 << 2) + 15 & -16) | 0;
     __stack_pointer = $10;
     if (($4 | 0) == 1e3) {
      break label$196;
     }
    }
    $6 = HEAP32[$0 + 14228 >> 2];
    if (($6 | 0) == ($4 | 0) | ($6 | 0) < 1) {
     break label$196;
    }
    memcpy($10, ((Math_imul(HEAP32[$0 + 172 >> 2] + ((($15 | 0) / -400 | 0) - $38 | 0) | 0, $13) << 2) + $0 | 0) + 14280 | 0, $5 << 2);
   }
   $4 = HEAP32[$0 + 172 >> 2];
   $15 = Math_imul($4 - $34 | 0, $13);
   label$203 : {
    if (($15 | 0) >= 1) {
     $4 = $0 + 14280 | 0;
     $15 = $15 << 2;
     memmove($31, $4 + (Math_imul($2, $13) << 2) | 0, $15);
     memcpy($4 + $15 | 0, $9, Math_imul($13, $34) << 2);
     break label$203;
    }
    memcpy($31, (Math_imul($34 - $4 | 0, $13) << 2) + $9 | 0, Math_imul($4, $13) << 2);
   }
   $16 = HEAPF32[$0 + 14204 >> 2];
   if (!($16 < Math_fround(1) ^ 1 ? !($21 < Math_fround(1)) : 0)) {
    $13 = HEAP32[$14 + 612 >> 2];
    gain_fade($9, $9, $16, $21, HEAP32[$13 + 4 >> 2], $2, HEAP32[$0 + 112 >> 2], HEAP32[$13 + 60 >> 2], HEAP32[$0 + 144 >> 2]);
   }
   HEAPF32[$0 + 14204 >> 2] = $21;
   $5 = HEAP32[$0 + 14224 >> 2];
   if (!(HEAP32[$0 + 14192 >> 2] != 1 ? ($5 | 0) == 1001 : 0)) {
    $4 = $0;
    $13 = 16384;
    label$208 : {
     if (($8 | 0) > 32e3) {
      break label$208;
     }
     $13 = 0;
     if (($8 | 0) < 16e3) {
      break label$208;
     }
     $13 = 16384 - ((65536e3 - ($8 << 11) | 0) / ($8 - 14e3 | 0) | 0) | 0;
    }
    HEAP32[$4 + 92 >> 2] = $13;
   }
   label$209 : {
    if (HEAP32[$0 + 14256 >> 2] | HEAP32[$0 + 112 >> 2] != 2) {
     break label$209;
    }
    $4 = HEAP16[$0 + 14196 >> 1];
    $8 = HEAP32[$0 + 92 >> 2];
    if (($8 | 0) > 16383 ? ($4 | 0) >= 16384 : 0) {
     break label$209;
    }
    $21 = Math_fround(Math_fround(1) - Math_fround(Math_fround($8 | 0) * Math_fround(6103515625e-14)));
    $13 = 0;
    $15 = HEAP32[$14 + 612 >> 2];
    $12 = 48e3 / HEAP32[$0 + 144 >> 2] | 0;
    $6 = HEAP32[$15 + 4 >> 2] / ($12 | 0) | 0;
    if (($6 | 0) > 0) {
     $26 = Math_fround(Math_fround(1) - Math_fround(Math_fround($4 | 0) * Math_fround(6103515625e-14)));
     $7 = HEAP32[$15 + 60 >> 2];
     while (1) {
      $4 = $13 << 3;
      $15 = $9 + $4 | 0;
      $16 = HEAPF32[$15 >> 2];
      $28 = $16;
      $17 = HEAPF32[(Math_imul($12, $13) << 2) + $7 >> 2];
      $17 = Math_fround($17 * $17);
      $35 = Math_fround(Math_fround($21 * $17) + Math_fround($26 * Math_fround(Math_fround(1) - $17)));
      $4 = ($4 | 4) + $9 | 0;
      $17 = HEAPF32[$4 >> 2];
      $16 = Math_fround($35 * Math_fround(Math_fround($16 - $17) * Math_fround(.5)));
      HEAPF32[$15 >> 2] = $28 - $16;
      HEAPF32[$4 >> 2] = $17 + $16;
      $13 = $13 + 1 | 0;
      if (($13 | 0) != ($6 | 0)) {
       continue;
      }
      break;
     }
     $13 = $6;
    }
    if (($2 | 0) > ($13 | 0)) {
     while (1) {
      $4 = $13 << 3;
      $15 = $9 + $4 | 0;
      $16 = HEAPF32[$15 >> 2];
      $28 = $16;
      $4 = ($4 | 4) + $9 | 0;
      $17 = HEAPF32[$4 >> 2];
      $16 = Math_fround($21 * Math_fround(Math_fround($16 - $17) * Math_fround(.5)));
      HEAPF32[$15 >> 2] = $28 - $16;
      HEAPF32[$4 >> 2] = $17 + $16;
      $13 = $13 + 1 | 0;
      if (($13 | 0) != ($2 | 0)) {
       continue;
      }
      break;
     }
    }
    HEAP16[$0 + 14196 >> 1] = $8;
   }
   label$215 : {
    label$216 : {
     if (($5 | 0) == 1002 | (Math_clz32(HEAP32[$14 + 468 >> 2]) + (HEAP32[$14 + 460 >> 2] + (($5 | 0) == 1001 ? 5 : -15) | 0) | 0) > $22 << 3) {
      break label$216;
     }
     if (($5 | 0) == 1001) {
      ec_enc_bit_logp($14 + 440 | 0, $39, 12);
     }
     if (!$39) {
      break label$216;
     }
     $6 = 1;
     ec_enc_bit_logp($14 + 440 | 0, $43, 1);
     $13 = HEAP32[$14 + 460 >> 2] + Math_clz32(HEAP32[$14 + 468 >> 2]) | 0;
     $4 = $13 - 21 | 0;
     $5 = $13 - 32 | 0;
     $13 = HEAP32[$25 >> 2];
     $4 = $22 - ((($13 | 0) == 1001 ? $4 : $5) + 7 >> 3) | 0;
     $4 = ($4 | 0) < ($30 | 0) ? $4 : $30;
     $4 = ($4 | 0) > 2 ? $4 : 2;
     $5 = ($4 | 0) < 257 ? $4 : 257;
     $7 = 0;
     if (($13 | 0) != 1001) {
      break label$215;
     }
     ec_enc_uint($14 + 440 | 0, $5 - 2 | 0, 256);
     break label$215;
    }
    $6 = 0;
    HEAP32[$0 + 14248 >> 2] = 0;
    $7 = 1;
    $5 = 0;
   }
   $12 = HEAP32[$25 >> 2];
   label$218 : {
    if (($12 | 0) == 1e3) {
     $13 = HEAP32[$14 + 468 >> 2];
     $4 = HEAP32[$14 + 460 >> 2];
     ec_enc_done($14 + 440 | 0);
     $13 = (Math_clz32($13) + $4 | 0) - 25 >> 3;
     $15 = $13;
     break label$218;
    }
    $13 = $22 - $5 | 0;
    ec_enc_shrink($14 + 440 | 0, $13);
    $15 = 0;
   }
   label$220 : {
    if (!(HEAP32[$25 >> 2] != 1e3 | $6)) {
     $4 = $43;
     $8 = 0;
     break label$220;
    }
    HEAP32[$14 + 224 >> 2] = $14 + 544;
    opus_custom_encoder_ctl($19, 10022, $14 + 224 | 0);
    if (HEAP32[$25 >> 2] == 1001) {
     HEAP32[$14 + 432 >> 2] = HEAP32[$0 + 100 >> 2];
     HEAP32[$14 + 436 >> 2] = HEAP32[$0 + 104 >> 2];
     HEAP32[$14 + 208 >> 2] = $14 + 432;
     opus_custom_encoder_ctl($19, 10028, $14 + 208 | 0);
    }
    $4 = $43;
    $8 = 0;
    if (!($6 & $4)) {
     break label$220;
    }
    HEAP32[$14 + 192 >> 2] = 0;
    opus_custom_encoder_ctl($19, 10010, $14 + 192 | 0);
    HEAP32[$14 + 176 >> 2] = 0;
    opus_custom_encoder_ctl($19, 4006, $14 + 176 | 0);
    HEAP32[$14 + 160 >> 2] = -1;
    opus_custom_encoder_ctl($19, 4002, $14 + 160 | 0);
    if ((celt_encode_with_ec($19, $9, HEAP32[$0 + 144 >> 2] / 200 | 0, $13 + $40 | 0, $5, 0) | 0) < 0) {
     $13 = -3;
     break label$145;
    }
    HEAP32[$14 + 144 >> 2] = $14 + 616;
    opus_custom_encoder_ctl($19, 4031, $14 + 144 | 0);
    opus_custom_encoder_ctl($19, 4028, 0);
    $4 = 1;
    $8 = 1;
   }
   HEAP32[$14 + 128 >> 2] = ($12 | 0) == 1002 ? 0 : 17;
   opus_custom_encoder_ctl($19, 10010, $14 + 128 | 0);
   $12 = HEAP32[$25 >> 2];
   label$224 : {
    if (($12 | 0) == 1e3) {
     break label$224;
    }
    $20 = HEAP32[$0 + 14228 >> 2];
    if (!(($20 | 0) == ($12 | 0) | ($20 | 0) < 1)) {
     opus_custom_encoder_ctl($19, 4028, 0);
     celt_encode_with_ec($19, $10, HEAP32[$0 + 144 >> 2] / 400 | 0, $14 + 432 | 0, 2, 0);
     HEAP32[$14 + 112 >> 2] = 0;
     opus_custom_encoder_ctl($19, 10002, $14 + 112 | 0);
    }
    if (((HEAP32[$14 + 460 >> 2] + Math_clz32(HEAP32[$14 + 468 >> 2]) | 0) - 32 | 0) > $13 << 3) {
     break label$224;
    }
    if (!(!HEAP32[$0 + 148 >> 2] | (!$8 | HEAP32[$25 >> 2] != 1001))) {
     HEAP32[$14 + 96 >> 2] = HEAP32[$0 + 160 >> 2] - HEAP32[$0 + 36 >> 2];
     opus_custom_encoder_ctl($19, 4002, $14 + 96 | 0);
    }
    HEAP32[$14 + 80 >> 2] = HEAP32[$0 + 148 >> 2];
    opus_custom_encoder_ctl($19, 4006, $14 + 80 | 0);
    $15 = celt_encode_with_ec($19, $9, $2, 0, $13, $14 + 440 | 0);
    if (($15 | 0) < 0) {
     $13 = -3;
     break label$145;
    }
    if (!HEAP32[$0 + 148 >> 2] | (!$8 | HEAP32[$25 >> 2] != 1001)) {
     break label$224;
    }
    memmove($15 + $40 | 0, $13 + $40 | 0, $5);
    $13 = $5 + $13 | 0;
   }
   label$228 : {
    if (!($4 | $7)) {
     $4 = HEAP32[$0 + 144 >> 2];
     opus_custom_encoder_ctl($19, 4028, 0);
     HEAP32[$14 + 64 >> 2] = 0;
     opus_custom_encoder_ctl($19, 10010, $14 - -64 | 0);
     HEAP32[$14 + 48 >> 2] = 0;
     opus_custom_encoder_ctl($19, 10002, $14 + 48 | 0);
     HEAP32[$14 + 32 >> 2] = 0;
     opus_custom_encoder_ctl($19, 4006, $14 + 32 | 0);
     HEAP32[$14 + 16 >> 2] = -1;
     opus_custom_encoder_ctl($19, 4002, $14 + 16 | 0);
     $12 = ($4 | 0) / 400 | 0;
     $4 = ($4 | 0) / 200 | 0;
     if (HEAP32[$0 + 14224 >> 2] == 1001) {
      ec_enc_shrink($14 + 440 | 0, $15);
      $13 = $15;
     }
     $7 = $2 - $4 | 0;
     celt_encode_with_ec($19, (Math_imul(HEAP32[$0 + 112 >> 2], $7 - $12 | 0) << 2) + $9 | 0, $12, $14 + 432 | 0, 2, 0);
     if ((celt_encode_with_ec($19, (Math_imul(HEAP32[$0 + 112 >> 2], $7) << 2) + $9 | 0, $4, $13 + $40 | 0, $5, 0) | 0) < 0) {
      break label$228;
     }
     HEAP32[$14 >> 2] = $14 + 616;
     opus_custom_encoder_ctl($19, 4031, $14);
    }
    $12 = HEAP32[$0 + 14192 >> 2];
    $7 = HEAP32[$0 + 14224 >> 2];
    $13 = 0;
    $4 = HEAP32[$0 + 144 >> 2] / ($2 | 0) | 0;
    if (($4 | 0) <= 399) {
     while (1) {
      $13 = $13 + 1 | 0;
      $4 = $4 << 1;
      if (($4 | 0) < 400) {
       continue;
      }
      break;
     }
     $13 = $13 << 3;
    }
    $4 = $3;
    label$233 : {
     label$234 : {
      switch ($7 - 1e3 | 0) {
      case 0:
       $13 = $13 - 16 | ($11 << 5) + 96 & 224;
       break label$233;
      case 2:
       $13 = ((($11 | 0) > 1102 ? $11 : 1102) << 5) - -64 & 96 | $13 | 128;
       break label$233;
      default:
       break label$234;
      }
     }
     $13 = $13 + 240 | $11 << 4 | 96;
    }
    HEAP8[$4 | 0] = $13 | (($12 | 0) == 2) << 2;
    $12 = HEAP32[$14 + 468 >> 2];
    HEAP32[$0 + 18136 >> 2] = $12 ^ HEAP32[$14 + 616 >> 2];
    $13 = 1002;
    $13 = $45 ? HEAP32[$25 >> 2] : $13;
    HEAP32[$0 + 14228 >> 2] = $13;
    HEAP32[$0 + 14252 >> 2] = 0;
    HEAP32[$0 + 14236 >> 2] = $2;
    $7 = HEAP32[$0 + 14192 >> 2];
    HEAP32[$0 + 14232 >> 2] = $7;
    label$238 : {
     if (!(!HEAP32[$0 + 184 >> 2] | !(HEAP32[$14 + 544 >> 2] | $41))) {
      label$240 : {
       if (!($51 ^ 1 | HEAPF32[$14 + 580 >> 2] < Math_fround(.10000000149011612) ^ 1)) {
        $21 = HEAPF32[$0 + 18128 >> 2];
        $16 = Math_fround(0);
        $4 = Math_imul(HEAP32[$0 + 112 >> 2], $2);
        if (($4 | 0) >= 1) {
         $13 = 0;
         while (1) {
          $17 = HEAPF32[($13 << 2) + $1 >> 2];
          $16 = Math_fround($16 + Math_fround($17 * $17));
          $13 = $13 + 1 | 0;
          if (($13 | 0) != ($4 | 0)) {
           continue;
          }
          break;
         }
        }
        $41 = Math_fround(Math_fround($16 / Math_fround($4 | 0)) * Math_fround(316.2300109863281)) <= $21;
       }
       if ($41) {
        $13 = HEAP32[$0 + 18124 >> 2];
        HEAP32[$0 + 18124 >> 2] = $13 + 1;
        if (($13 | 0) < 10) {
         break label$238;
        }
        if (($13 | 0) < 30) {
         break label$240;
        }
        HEAP32[$0 + 18124 >> 2] = 10;
        break label$238;
       }
       HEAP32[$0 + 18124 >> 2] = 0;
       break label$238;
      }
      $13 = 0;
      HEAP32[$0 + 18136 >> 2] = 0;
      $1 = HEAP32[$0 + 14224 >> 2];
      $0 = HEAP32[$0 + 144 >> 2] / ($2 | 0) | 0;
      if (($0 | 0) <= 399) {
       while (1) {
        $13 = $13 + 1 | 0;
        $0 = $0 << 1;
        if (($0 | 0) < 400) {
         continue;
        }
        break;
       }
       $13 = $13 << 3;
      }
      label$248 : {
       label$249 : {
        switch ($1 - 1e3 | 0) {
        case 0:
         $0 = $13 - 16 | ($11 << 5) + 96 & 224;
         break label$248;
        case 2:
         $0 = ((($11 | 0) > 1102 ? $11 : 1102) << 5) - -64 & 96 | $13 | 128;
         break label$248;
        default:
         break label$249;
        }
       }
       $0 = $13 + 240 | $11 << 4 | 96;
      }
      HEAP8[$3 | 0] = $0 | (($7 | 0) == 2) << 2;
      $13 = 1;
      break label$145;
     }
     HEAP32[$0 + 18124 >> 2] = 0;
    }
    label$252 : {
     if (((HEAP32[$14 + 460 >> 2] + Math_clz32($12) | 0) - 32 | 0) > $22 << 3) {
      HEAP8[$40 | 0] = 0;
      HEAP32[$0 + 18136 >> 2] = 0;
      $15 = 1;
      break label$252;
     }
     if (HEAP32[$25 >> 2] != 1e3 | $6 | ($15 | 0) < 3) {
      break label$252;
     }
     while (1) {
      if (HEAPU8[$3 + $15 | 0]) {
       break label$252;
      }
      $13 = ($15 | 0) > 3;
      $15 = $15 - 1 | 0;
      if ($13) {
       continue;
      }
      break;
     }
     $15 = 2;
    }
    $2 = ($5 + $15 | 0) + 1 | 0;
    label$255 : {
     if (HEAP32[$0 + 148 >> 2]) {
      $23 = $2;
      break label$255;
     }
     $13 = -3;
     if (opus_packet_pad($3, $2, $23)) {
      break label$145;
     }
    }
    $13 = $23;
    break label$145;
   }
   $13 = -3;
  }
 }
 __stack_pointer = $14 + 624 | 0;
 return $13;
}
function celt_encode_with_ec($0, $1, $2, $3, $4, $5) {
 var $6 = Math_fround(0), $7 = 0, $8 = Math_fround(0), $9 = 0, $10 = Math_fround(0), $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = Math_fround(0), $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = Math_fround(0), $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = Math_fround(0), $64 = 0, $65 = 0, $66 = Math_fround(0), $67 = 0, $68 = Math_fround(0), $69 = Math_fround(0), $70 = 0, $71 = Math_fround(0), $72 = Math_fround(0);
 $39 = __stack_pointer - 192 | 0;
 __stack_pointer = $39;
 $13 = HEAP32[$0 + 8 >> 2];
 $11 = HEAP32[$0 + 4 >> 2];
 $16 = $39;
 HEAP32[$16 + 28 >> 2] = 15;
 HEAP32[$16 + 24 >> 2] = 0;
 HEAP32[$16 + 20 >> 2] = 0;
 HEAP32[$16 + 16 >> 2] = 0;
 HEAP32[$16 + 4 >> 2] = 0;
 $14 = HEAP32[$0 + 36 >> 2];
 $20 = HEAP32[$0 + 32 >> 2];
 $19 = HEAP32[$0 >> 2];
 $18 = HEAP32[$19 + 32 >> 2];
 $24 = HEAP32[$19 + 4 >> 2];
 $30 = HEAP32[$19 + 8 >> 2];
 HEAP32[$16 + 12 >> 2] = 0;
 $7 = -1;
 label$1 : {
  if (!$1 | ($4 | 0) < 2) {
   break label$1;
  }
  $21 = HEAP32[$19 + 36 >> 2];
  if (($21 | 0) < 0) {
   break label$1;
  }
  $37 = Math_imul(HEAP32[$0 + 28 >> 2], $2);
  $28 = HEAP32[$19 + 44 >> 2];
  while (1) {
   if ($28 << $15 != ($37 | 0)) {
    $2 = ($15 | 0) < ($21 | 0);
    $15 = $15 + 1 | 0;
    if ($2) {
     continue;
    }
    break label$1;
   }
   break;
  }
  label$4 : {
   if (!$5) {
    $57 = 1;
    $9 = 1;
    $17 = 0;
    break label$4;
   }
   $57 = ec_tell_frac($5);
   $2 = HEAP32[$5 + 20 >> 2] + Math_clz32(HEAP32[$5 + 28 >> 2]) | 0;
   $9 = $2 - 32 | 0;
   $17 = $2 - 28 >> 3;
  }
  label$6 : {
   label$7 : {
    if (!HEAP32[$0 + 48 >> 2]) {
     $21 = $24 + 1024 | 0;
     $26 = ($4 | 0) < 1275 ? $4 : 1275;
     $29 = $26 - $17 | 0;
     $2 = HEAP32[$0 + 40 >> 2];
     label$9 : {
      if (HEAP32[$0 + 44 >> 2]) {
       if (($2 | 0) == -1) {
        break label$7;
       }
       $28 = HEAP32[$19 >> 2];
       $42 = (Math_imul($2, $37) + ($28 >> 4) | 0) / ($28 >> 3) | 0;
       $35 = $42 >> 6;
       break label$9;
      }
      if (($2 | 0) == -1) {
       break label$7;
      }
      $28 = HEAP32[$19 >> 2];
      $28 = ((Math_imul($2, $37) + (($9 | 0) > 1 ? $9 : 0) | 0) + ($28 << 2) | 0) / ($28 << 3) | 0;
      $28 = ($28 | 0) > ($26 | 0) ? $26 : $28;
      $26 = ($28 | 0) > 2 ? $28 : 2;
      $35 = $26 - $17 | 0;
     }
     $7 = $2;
     break label$6;
    }
    celt_fatal(42472, 42508, 1547);
    abort();
   }
   $35 = $29;
  }
  $2 = Math_imul($11, $21);
  $48 = 3 - $15 | 0;
  $21 = Math_imul($26, 400);
  if (!$5) {
   ec_enc_init($16 + 32 | 0, $3, $26);
   $5 = $16 + 32 | 0;
  }
  $53 = $0 + 244 | 0;
  $2 = $2 << 2;
  $50 = Math_imul($11, $30);
  $3 = $21 >> $48;
  label$12 : {
   if (!HEAP32[$0 + 52 >> 2] | ($42 | 0) < 1) {
    break label$12;
   }
   $21 = (($9 | 0) == 1) << 1;
   $28 = ($42 << 1) - HEAP32[$0 + 208 >> 2] >> 6;
   $21 = ($21 | 0) > ($28 | 0) ? $21 : $28;
   if (($29 | 0) <= ($21 | 0)) {
    break label$12;
   }
   $26 = $17 + $21 | 0;
   ec_enc_shrink($5, $26);
   $29 = $21;
  }
  $21 = $2 + $53 | 0;
  $27 = $50 << 2;
  $12 = ($3 | 0) < ($7 | 0);
  $31 = Math_imul($13, 40);
  $32 = 400 >>> $15 | 0;
  $23 = HEAP32[$19 + 12 >> 2];
  $4 = $24 + $37 | 0;
  $33 = $39 - ((Math_imul($11, $4) << 2) + 15 & -16) | 0;
  $38 = $33;
  __stack_pointer = $33;
  $34 = HEAPF32[$0 + 224 >> 2];
  $54 = HEAP32[$0 + 28 >> 2];
  $39 = (Math_imul($37 - $24 | 0, $13) | 0) / ($54 | 0) | 0;
  label$13 : {
   label$14 : {
    if (($39 | 0) >= 1) {
     $2 = 0;
     while (1) {
      $6 = HEAPF32[($2 << 2) + $1 >> 2];
      $10 = $6 > $10 ? $10 : $6;
      $8 = $6 < $8 ? $8 : $6;
      $2 = $2 + 1 | 0;
      if (($39 | 0) != ($2 | 0)) {
       continue;
      }
      break;
     }
     $6 = Math_fround(-$10);
     if (($6 < $8 ? $8 : $6) < $34) {
      break label$13;
     }
     $2 = 0;
     $10 = Math_fround(0);
     $8 = Math_fround(0);
     while (1) {
      $6 = HEAPF32[($2 << 2) + $1 >> 2];
      $10 = $6 > $10 ? $10 : $6;
      $8 = $6 < $8 ? $8 : $6;
      $2 = $2 + 1 | 0;
      if (($39 | 0) != ($2 | 0)) {
       continue;
      }
      break;
     }
     break label$14;
    }
    if ($34 > Math_fround(0)) {
     break label$13;
    }
   }
   $6 = Math_fround(-$10);
   $34 = $6 < $8 ? $8 : $6;
  }
  $22 = Math_imul($11, $24);
  $28 = $21 + $27 | 0;
  $12 = $12 ? $3 : $7;
  $25 = ($7 | 0) == -1;
  $58 = $31 + 20 | 0;
  $31 = $32 - 50 | 0;
  $51 = 1;
  $10 = Math_fround(0);
  $7 = (Math_imul($13, $24) | 0) / ($54 | 0) | 0;
  label$18 : {
   if (($7 | 0) < 1) {
    $8 = Math_fround(0);
    break label$18;
   }
   $39 = ($39 << 2) + $1 | 0;
   $2 = 0;
   $8 = Math_fround(0);
   while (1) {
    $6 = HEAPF32[($2 << 2) + $39 >> 2];
    $10 = $6 > $10 ? $10 : $6;
    $8 = $6 < $8 ? $8 : $6;
    $2 = $2 + 1 | 0;
    if (($7 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  $2 = $22 << 2;
  $39 = $27 + $28 | 0;
  $7 = $25 ? $3 : $12;
  $3 = Math_imul($31, $58);
  $12 = ($14 | 0) > ($23 | 0);
  $22 = $26 << 3;
  $6 = Math_fround(-$10);
  $6 = $6 < $8 ? $8 : $6;
  HEAPF32[$0 + 224 >> 2] = $6;
  $6 = $6 < $34 ? $34 : $6;
  label$21 : {
   if (($9 | 0) != 1) {
    $31 = 0;
    break label$21;
   }
   $9 = Math_fround(Math_fround(1) / Math_fround(1 << HEAP32[$0 + 60 >> 2])) >= $6;
   ec_enc_bit_logp($5, $9, 15);
   if ($9 ^ 1) {
    $31 = 0;
    $9 = 1;
    break label$21;
   }
   $31 = 1;
   label$24 : {
    if (($42 | 0) < 1) {
     $9 = $22;
     break label$24;
    }
    $29 = 2;
    $9 = $17 + 2 | 0;
    $35 = ($9 | 0) > ($26 | 0) ? $26 : $9;
    ec_enc_shrink($5, $35);
    $26 = $35;
    $9 = $26 << 3;
    $22 = $9;
   }
   HEAP32[$5 + 20 >> 2] = ($9 - Math_clz32(HEAP32[$5 + 28 >> 2]) | 0) + 32;
   $51 = 0;
  }
  $17 = $2 + $53 | 0;
  $53 = $27 + $39 | 0;
  $43 = 1 << $15;
  $46 = $7 - $3 | 0;
  $25 = $12 ? $23 : $14;
  $54 = ($11 | 0) > 1 ? $11 : 1;
  $3 = $19 + 16 | 0;
  $24 = ($24 << 2) + $33 | 0;
  $2 = 0;
  while (1) {
   $7 = $2 << 2;
   celt_preemphasis($7 + $1 | 0, (Math_imul($2, $4) << 2) + $24 | 0, $37, $11, HEAP32[$0 + 28 >> 2], $3, ($0 + $7 | 0) + 192 | 0, HEAP32[$0 + 16 >> 2] != 0 & $6 > Math_fround(65536));
   $2 = $2 + 1 | 0;
   if (($54 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
  $2 = 0;
  if (!(HEAP32[$0 + 20 >> 2] | (!(HEAP32[$0 + 64 >> 2] != 0 & ($29 | 0) > 3 | (Math_imul($13, 12) | 0) < ($29 | 0)) | ($20 | $31)))) {
   $2 = HEAP32[$0 + 24 >> 2] > 4;
  }
  $64 = HEAP32[$0 + 100 >> 2];
  $52 = $0 + 120 | 0;
  $59 = run_prefilter($0, $33, $17, $11, $37, $64, $16 + 28 | 0, $16 + 24 | 0, $16 + 80 | 0, $2, $29, $52);
  $66 = HEAPF32[$16 + 24 >> 2];
  label$28 : {
   if (!($66 > Math_fround(.4000000059604645))) {
    $1 = 0;
    if (HEAPF32[$0 + 108 >> 2] > Math_fround(.4000000059604645) ^ 1) {
     break label$28;
    }
   }
   if (HEAP32[$52 >> 2]) {
    $1 = 0;
    if (+HEAPF32[$0 + 124 >> 2] > .3 ^ 1) {
     break label$28;
    }
   }
   $60 = +HEAP32[$16 + 28 >> 2];
   $61 = +HEAP32[$0 + 104 >> 2];
   $1 = $60 > $61 * 1.26 | $61 * .79 > $60;
  }
  $65 = $1;
  label$31 : {
   if (!$59) {
    if (($9 + 16 | 0) > ($22 | 0) | $20) {
     break label$31;
    }
    ec_enc_bit_logp($5, 0, 1);
    break label$31;
   }
   ec_enc_bit_logp($5, 1, 1);
   $2 = HEAP32[$16 + 28 >> 2];
   $1 = $2 + 1 | 0;
   $7 = Math_clz32($1);
   $3 = 27 - $7 | 0;
   ec_enc_uint($5, $3, 6);
   ec_enc_bits($5, (-16 << $3) + $1 | 0, 31 - $7 | 0);
   HEAP32[$16 + 28 >> 2] = $2;
   ec_enc_bits($5, HEAP32[$16 + 80 >> 2], 3);
   ec_enc_icdf($5, $64, 42528, 2);
  }
  $62 = 1;
  if (!(HEAP32[$0 + 64 >> 2] | HEAP32[$0 + 24 >> 2] < 1)) {
   $2 = 0;
   $2 = !$20 | ($35 | 0) > 14 ? $2 : HEAP32[$0 + 184 >> 2] != 2;
   $36 = transient_analysis($33, $4, $11, $16 + 12 | 0, $16 + 16 | 0, $2, $16 + 4 | 0);
  }
  $3 = $19;
  label$35 : {
   label$36 : {
    if (!(!$15 | ((HEAP32[$5 + 20 >> 2] + Math_clz32(HEAP32[$5 + 28 >> 2]) | 0) - 29 | 0) > ($22 | 0))) {
     if ($36) {
      break label$36;
     }
     $62 = 0;
    }
    $32 = $38 - ((Math_imul($11, $37) << 2) + 15 & -16) | 0;
    $2 = $32;
    __stack_pointer = $2;
    $1 = ($50 << 2) + 15 & -16;
    $38 = $2 - $1 | 0;
    $2 = $38;
    __stack_pointer = $2;
    $4 = $2 - $1 | 0;
    $2 = $4;
    __stack_pointer = $2;
    $40 = Math_imul($13, $30);
    $31 = $2 - (($40 << 2) + 15 & -16) | 0;
    $7 = $31;
    __stack_pointer = $7;
    $55 = 1;
    $36 = 0;
    $56 = 0;
    break label$35;
   }
   $32 = $38 - ((Math_imul($11, $37) << 2) + 15 & -16) | 0;
   $2 = $32;
   __stack_pointer = $2;
   $1 = ($50 << 2) + 15 & -16;
   $38 = $2 - $1 | 0;
   $2 = $38;
   __stack_pointer = $2;
   $4 = $2 - $1 | 0;
   $2 = $4;
   __stack_pointer = $2;
   $40 = Math_imul($13, $30);
   $31 = $2 - (($40 << 2) + 15 & -16) | 0;
   $7 = $31;
   __stack_pointer = $7;
   $1 = HEAP32[$0 + 24 >> 2];
   label$38 : {
    if (($1 | 0) < 8) {
     $62 = 0;
     break label$38;
    }
    $62 = 0;
    compute_mdcts($19, 0, $33, $32, $13, $11, $15, HEAP32[$0 + 28 >> 2], HEAP32[$0 + 72 >> 2]);
    compute_band_energies($19, $32, $38, $25, $13, $15, HEAP32[$0 + 72 >> 2]);
    amp2Log2($19, $25, $14, $38, $31, $13);
    $49 = 1;
    if (($40 | 0) < 1) {
     break label$38;
    }
    $6 = Math_fround(Math_fround($15 | 0) * Math_fround(.5));
    $2 = 0;
    while (1) {
     $1 = ($2 << 2) + $31 | 0;
     HEAPF32[$1 >> 2] = $6 + HEAPF32[$1 >> 2];
     $2 = $2 + 1 | 0;
     if (($40 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   $56 = $43;
  }
  compute_mdcts($3, $56, $33, $32, $13, $11, $15, HEAP32[$0 + 28 >> 2], HEAP32[$0 + 72 >> 2]);
  label$41 : {
   label$42 : {
    $6 = HEAPF32[$32 >> 2];
    if ($6 == $6) {
     if (($13 | 0) == 1) {
      break label$42;
     }
     $6 = HEAPF32[($37 << 2) + $32 >> 2];
     $1 = 0;
     if ($6 == $6) {
      break label$41;
     }
    }
    celt_fatal(42531, 42508, 1729);
    abort();
   }
   $1 = 0;
   if (($11 | 0) != 2) {
    break label$41;
   }
   HEAP32[$16 + 16 >> 2] = 0;
   $1 = 1;
  }
  $70 = $1;
  compute_band_energies($19, $32, $38, $25, $13, $15, HEAP32[$0 + 72 >> 2]);
  if (!(!HEAP32[$0 + 64 >> 2] | ($14 | 0) < 3)) {
   $2 = 2;
   while (1) {
    $1 = ($2 << 2) + $38 | 0;
    $6 = HEAPF32[$1 >> 2];
    $8 = Math_fround(HEAPF32[$38 >> 2] * Math_fround(9999999747378752e-20));
    $6 = $6 < $8 ? $6 : $8;
    HEAPF32[$1 >> 2] = $6 > Math_fround(1.0000000036274937e-15) ? $6 : Math_fround(1.0000000036274937e-15);
    $2 = $2 + 1 | 0;
    if (($14 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  amp2Log2($19, $25, $14, $38, $4, $13);
  $2 = $7 - (($40 << 2) + 15 & -16) | 0;
  $44 = $2;
  __stack_pointer = $2;
  $67 = $14 << 2;
  $45 = memset($2, 0, $67);
  $6 = Math_fround(0);
  label$46 : {
   label$47 : {
    if ($20) {
     break label$47;
    }
    $9 = HEAP32[$0 + 236 >> 2];
    $6 = Math_fround(0);
    if (!$9) {
     break label$47;
    }
    $1 = HEAP32[$0 + 64 >> 2];
    if ($1) {
     break label$46;
    }
    label$48 : {
     label$49 : {
      label$50 : {
       if (($13 | 0) < 1) {
        break label$50;
       }
       $2 = HEAP32[$0 + 92 >> 2];
       $1 = ($2 | 0) > 2 ? $2 : 2;
       $47 = HEAPU16[$18 >> 1];
       $12 = 0;
       $3 = 0;
       $8 = Math_fround(0);
       $10 = Math_fround(0);
       while (1) {
        $17 = Math_imul($12, $30);
        $7 = $47;
        $2 = 0;
        while (1) {
         $6 = HEAPF32[($2 + $17 << 2) + $9 >> 2];
         $41 = $6;
         $24 = $6 < Math_fround(.25);
         $27 = ($24 ? $6 : Math_fround(.25)) > Math_fround(-2);
         $6 = $27 ? Math_fround(.25) : Math_fround(-2);
         $6 = $27 ? $24 ? $41 : $6 : $6;
         $6 = $6 > Math_fround(0) ? Math_fround($6 * Math_fround(.5)) : $6;
         $8 = Math_fround($8 + Math_fround($6 * Math_fround(($2 << 1 | 1) - $1 | 0)));
         $24 = $7 << 16;
         $2 = $2 + 1 | 0;
         $7 = HEAP16[($2 << 1) + $18 >> 1];
         $24 = $7 - ($24 >> 16) | 0;
         $10 = Math_fround($10 + Math_fround($6 * Math_fround($24 | 0)));
         $3 = $3 + $24 | 0;
         if (($1 | 0) != ($2 | 0)) {
          continue;
         }
         break;
        }
        $12 = $12 + 1 | 0;
        if (($12 | 0) != ($13 | 0)) {
         continue;
        }
        break;
       }
       $2 = 0;
       if (($3 | 0) <= 0) {
        break label$50;
       }
       $6 = Math_fround(Math_fround(Math_fround($8 * Math_fround(6)) / Math_fround(Math_imul($1 + 1 | 0, Math_imul($1 - 1 | 0, Math_imul($1, $13))) | 0)) * Math_fround(.5));
       $6 = $6 < Math_fround(.03099999949336052) ? $6 : Math_fround(.03099999949336052);
       $8 = Math_fround($10 / Math_fround($3 | 0));
       $3 = HEAP16[($1 << 1) + $18 >> 1] / 2 << 16 >> 16;
       while (1) {
        $7 = $2;
        $2 = $2 + 1 | 0;
        if (HEAP16[($2 << 1) + $18 >> 1] < ($3 | 0)) {
         continue;
        }
        break;
       }
       $34 = $6 > Math_fround(-.03099999949336052) ? $6 : Math_fround(-.03099999949336052);
       $10 = Math_fround($8 + Math_fround(.20000000298023224));
       $2 = 0;
       $24 = 0;
       while (1) {
        $8 = Math_fround($10 + Math_fround($34 * Math_fround($2 - $7 | 0)));
        $3 = $2 << 2;
        $6 = HEAPF32[$9 + $3 >> 2];
        if (($13 | 0) == 2) {
         $63 = HEAPF32[($2 + $30 << 2) + $9 >> 2];
         $6 = $6 > $63 ? $6 : $63;
        }
        $6 = Math_fround(($6 < Math_fround(0) ? $6 : Math_fround(0)) - $8);
        if (!($6 > Math_fround(.25) ^ 1)) {
         HEAPF32[$3 + $45 >> 2] = $6 + Math_fround(-.25);
         $24 = $24 + 1 | 0;
        }
        $2 = $2 + 1 | 0;
        if (($2 | 0) != ($1 | 0)) {
         continue;
        }
        break;
       }
       if (($24 | 0) < 3) {
        break label$48;
       }
       $6 = Math_fround($10 + Math_fround(.25));
       $10 = Math_fround(0);
       if (!($6 > Math_fround(0) ^ 1)) {
        break label$49;
       }
       $2 = 0;
       while (1) {
        $7 = ($2 << 2) + $45 | 0;
        HEAPF32[$7 >> 2] = Math_max(Math_fround(HEAPF32[$7 >> 2] + Math_fround(-.25)), Math_fround(0));
        $2 = $2 + 1 | 0;
        if (($2 | 0) != ($1 | 0)) {
         continue;
        }
        break;
       }
       $10 = $6;
       break label$48;
      }
      celt_fatal(42604, 42508, 1770);
      abort();
     }
     memset($45, 0, $1 << 2);
     $34 = Math_fround(0);
    }
    $71 = Math_fround($34 * Math_fround(64));
    $6 = Math_fround($10 + Math_fround(.20000000298023224));
   }
   $63 = $6;
   $1 = HEAP32[$0 + 64 >> 2];
   if ($1) {
    break label$46;
   }
   $8 = Math_fround(0);
   if (($14 | 0) > ($20 | 0)) {
    $34 = $55 ? Math_fround(0) : Math_fround(Math_fround($15 | 0) * Math_fround(.5));
    $6 = Math_fround(-10);
    $2 = $20;
    while (1) {
     $6 = Math_fround($6 + Math_fround(-1));
     $10 = Math_fround(HEAPF32[($2 << 2) + $4 >> 2] - $34);
     $6 = $6 > $10 ? $6 : $10;
     if (($13 | 0) == 2) {
      $10 = Math_fround(HEAPF32[($2 + $30 << 2) + $4 >> 2] - $34);
      $6 = $6 > $10 ? $6 : $10;
     }
     $8 = Math_fround($8 + $6);
     $2 = $2 + 1 | 0;
     if (($14 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   $6 = HEAPF32[$0 + 240 >> 2];
   $68 = Math_fround(Math_min(Math_fround(Math_max(Math_fround(Math_fround($8 / Math_fround($14 - $20 | 0)) - $6), Math_fround(-1.5))), Math_fround(3)));
   HEAPF32[$0 + 240 >> 2] = $6 + Math_fround($68 * Math_fround(.019999999552965164));
   $1 = 0;
  }
  if (!$49) {
   memcpy($31, $4, $40 << 2);
  }
  label$64 : {
   if (!$15) {
    break label$64;
   }
   $2 = (HEAP32[$5 + 20 >> 2] + Math_clz32(HEAP32[$5 + 28 >> 2]) | 0) - 29 | 0;
   label$65 : {
    if (($22 | 0) < ($2 | 0) | $36) {
     break label$65;
    }
    $36 = 0;
    if ($1 | $20 | HEAP32[$0 + 24 >> 2] < 5) {
     break label$65;
    }
    $2 = 1;
    $6 = HEAPF32[$21 >> 2];
    label$66 : {
     label$67 : {
      if (($13 | 0) == 1) {
       HEAPF32[$16 + 80 >> 2] = $6;
       if (($14 | 0) < 2) {
        break label$66;
       }
       while (1) {
        $6 = Math_fround($6 + Math_fround(-1));
        $1 = $2 << 2;
        $8 = HEAPF32[$21 + $1 >> 2];
        $6 = $6 > $8 ? $6 : $8;
        HEAPF32[($16 + 80 | 0) + $1 >> 2] = $6;
        $2 = $2 + 1 | 0;
        if (($14 | 0) != ($2 | 0)) {
         continue;
        }
        break;
       }
       break label$67;
      }
      $8 = HEAPF32[($30 << 2) + $21 >> 2];
      $6 = $6 > $8 ? $6 : $8;
      HEAPF32[$16 + 80 >> 2] = $6;
      if (($14 | 0) < 2) {
       break label$66;
      }
      while (1) {
       $6 = Math_fround($6 + Math_fround(-1));
       $1 = $2 << 2;
       $8 = HEAPF32[$21 + $1 >> 2];
       $10 = HEAPF32[($2 + $30 << 2) + $21 >> 2];
       $8 = $8 > $10 ? $8 : $10;
       $6 = $6 > $8 ? $6 : $8;
       HEAPF32[($16 + 80 | 0) + $1 >> 2] = $6;
       $2 = $2 + 1 | 0;
       if (($14 | 0) != ($2 | 0)) {
        continue;
       }
       break;
      }
     }
     if (($14 | 0) < 2) {
      break label$66;
     }
     $2 = $14 - 2 | 0;
     while (1) {
      $1 = ($16 + 80 | 0) + ($2 << 2) | 0;
      $6 = HEAPF32[$1 >> 2];
      $8 = Math_fround(HEAPF32[$1 + 4 >> 2] + Math_fround(-1));
      HEAPF32[$1 >> 2] = $6 > $8 ? $6 : $8;
      $1 = ($2 | 0) > 0;
      $2 = $2 - 1 | 0;
      if ($1) {
       continue;
      }
      break;
     }
    }
    $24 = ($13 | 0) > 1 ? $13 : 1;
    $7 = $14 - 1 | 0;
    $3 = 0;
    $27 = ($14 | 0) < 4;
    $6 = Math_fround(0);
    while (1) {
     if (!$27) {
      $1 = Math_imul($3, $30);
      $2 = 2;
      while (1) {
       $6 = Math_fround($6 + Math_fround(Math_max(Math_fround(Math_fround(Math_max(HEAPF32[($1 + $2 << 2) + $4 >> 2], Math_fround(0))) - Math_fround(Math_max(HEAPF32[($16 + 80 | 0) + ($2 << 2) >> 2], Math_fround(0)))), Math_fround(0))));
       $2 = $2 + 1 | 0;
       if (($7 | 0) != ($2 | 0)) {
        continue;
       }
       break;
      }
     }
     $3 = $3 + 1 | 0;
     if (($24 | 0) != ($3 | 0)) {
      continue;
     }
     break;
    }
    if (!(Math_fround($6 / Math_fround(Math_imul($14 - 3 | 0, $13) | 0)) > Math_fround(1) ^ 1)) {
     compute_mdcts($19, $43, $33, $32, $13, $11, $15, HEAP32[$0 + 28 >> 2], HEAP32[$0 + 72 >> 2]);
     compute_band_energies($19, $32, $38, $25, $13, $15, HEAP32[$0 + 72 >> 2]);
     amp2Log2($19, $25, $14, $38, $4, $13);
     if (($40 | 0) >= 1) {
      $6 = Math_fround(Math_fround($15 | 0) * Math_fround(.5));
      $2 = 0;
      while (1) {
       $1 = ($2 << 2) + $31 | 0;
       HEAPF32[$1 >> 2] = $6 + HEAPF32[$1 >> 2];
       $2 = $2 + 1 | 0;
       if (($40 | 0) != ($2 | 0)) {
        continue;
       }
       break;
      }
     }
     HEAP32[$16 + 12 >> 2] = 1045220557;
     $56 = $43;
     $36 = 1;
    }
    $2 = (HEAP32[$5 + 20 >> 2] + Math_clz32(HEAP32[$5 + 28 >> 2]) | 0) - 29 | 0;
   }
   if (($2 | 0) > ($22 | 0)) {
    break label$64;
   }
   ec_enc_bit_logp($5, $36, 3);
  }
  $27 = $44 - ((Math_imul($13, $37) << 2) + 15 & -16) | 0;
  $1 = $27;
  __stack_pointer = $1;
  normalise_bands($19, $32, $1, $38, $25, $13, $43);
  $7 = 0;
  if (!((Math_imul($13, 15) | 0) > ($35 | 0) | $20 | HEAP32[$0 + 24 >> 2] < 2)) {
   $7 = !HEAP32[$0 + 64 >> 2];
  }
  $2 = ($30 << 2) + 15 & -16;
  $49 = $1 - $2 | 0;
  $1 = $49;
  __stack_pointer = $1;
  $1 = $1 - $2 | 0;
  __stack_pointer = $1;
  $12 = $1 - $2 | 0;
  $3 = $12;
  __stack_pointer = $3;
  $72 = dynalloc_analysis($4, $31, $30, $20, $14, $13, $49, HEAP32[$0 + 60 >> 2], HEAP32[$19 + 56 >> 2], $36, HEAP32[$0 + 44 >> 2], HEAP32[$0 + 52 >> 2], $18, $15, $35, $16 + 8 | 0, HEAP32[$0 + 64 >> 2], $45, $52, $1, $3);
  $33 = $3 - $2 | 0;
  $3 = $33;
  __stack_pointer = $3;
  label$79 : {
   if ($7) {
    $2 = 20480 / ($35 | 0) | 0;
    $44 = tf_analysis($19, $25, $36, $33, ($2 | 0) < 78 ? 80 : $2 + 2 | 0, $27, $37, $15, HEAPF32[$16 + 12 >> 2], HEAP32[$16 + 16 >> 2], $1);
    if (($14 | 0) <= ($23 | 0)) {
     break label$79;
    }
    $2 = (($25 << 2) + $33 | 0) - 4 | 0;
    while (1) {
     HEAP32[($23 << 2) + $33 >> 2] = HEAP32[$2 >> 2];
     $23 = $23 + 1 | 0;
     if (($23 | 0) != ($14 | 0)) {
      continue;
     }
     break;
    }
    break label$79;
   }
   if (!(!$20 | !HEAP32[$16 + 4 >> 2])) {
    $44 = 0;
    if (($14 | 0) < 1) {
     break label$79;
    }
    $2 = 0;
    while (1) {
     HEAP32[($2 << 2) + $33 >> 2] = 1;
     $2 = $2 + 1 | 0;
     if (($14 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
    break label$79;
   }
   if (!(!$20 | ($35 | 0) > 14 | HEAP32[$0 + 184 >> 2] == 2)) {
    $44 = $36;
    if (($14 | 0) < 1) {
     break label$79;
    }
    memset($33, 0, $67);
    break label$79;
   }
   $44 = 0;
   if (($14 | 0) < 1) {
    break label$79;
   }
   $2 = 0;
   while (1) {
    HEAP32[($2 << 2) + $33 >> 2] = $36;
    $2 = $2 + 1 | 0;
    if (($14 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  $55 = $0 + 100 | 0;
  $31 = ($13 | 0) > 1 ? $13 : 1;
  $24 = $3 - (($40 << 2) + 15 & -16) | 0;
  $45 = $24;
  __stack_pointer = $24;
  $9 = 0;
  while (1) {
   $32 = ($14 | 0) <= ($20 | 0);
   if (!$32) {
    $3 = Math_imul($9, $30);
    $2 = $20;
    while (1) {
     $1 = $2 + $3 << 2;
     $7 = $4 + $1 | 0;
     $6 = HEAPF32[$7 >> 2];
     if (!(Math_fround(Math_abs(Math_fround($6 - HEAPF32[$1 + $21 >> 2]))) < Math_fround(2) ^ 1)) {
      HEAPF32[$7 >> 2] = $6 + Math_fround(HEAPF32[$1 + $53 >> 2] * Math_fround(-.25));
     }
     $2 = $2 + 1 | 0;
     if (($14 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   $9 = $9 + 1 | 0;
   if (($31 | 0) != ($9 | 0)) {
    continue;
   }
   break;
  }
  quant_coarse_energy($19, $20, $14, $25, $4, $21, $22, $24, $5, $13, $15, $29, HEAP32[$0 + 12 >> 2], $0 + 84 | 0, HEAP32[$0 + 24 >> 2] > 3, HEAP32[$0 + 56 >> 2], HEAP32[$0 + 64 >> 2]);
  $47 = 0;
  $1 = HEAP32[$5 + 4 >> 2] << 3;
  $7 = (HEAP32[$5 + 20 >> 2] + Math_clz32(HEAP32[$5 + 28 >> 2]) | 0) - 32 | 0;
  $2 = $36 ? 2 : 4;
  $23 = ($15 | 0) != 0 & $1 >>> 0 >= $7 + ($2 | 1) >>> 0;
  $17 = 0;
  label$90 : {
   if ($32) {
    break label$90;
   }
   $3 = ($20 << 2) + $33 | 0;
   $11 = $1 - $23 | 0;
   label$91 : {
    if ($11 >>> 0 >= $2 + $7 >>> 0) {
     ec_enc_bit_logp($5, HEAP32[$3 >> 2], $2);
     $7 = (HEAP32[$5 + 20 >> 2] + Math_clz32(HEAP32[$5 + 28 >> 2]) | 0) - 32 | 0;
     $17 = HEAP32[$3 >> 2];
     break label$91;
    }
    HEAP32[$3 >> 2] = 0;
    $17 = 0;
   }
   $2 = $20 + 1 | 0;
   if (($14 | 0) == ($2 | 0)) {
    break label$90;
   }
   $3 = $36 ? 4 : 5;
   $9 = $17;
   while (1) {
    $1 = ($2 << 2) + $33 | 0;
    label$94 : {
     if ($3 + $7 >>> 0 <= $11 >>> 0) {
      ec_enc_bit_logp($5, HEAP32[$1 >> 2] ^ $9, $3);
      $9 = HEAP32[$1 >> 2];
      $17 = $17 | $9;
      $7 = (HEAP32[$5 + 20 >> 2] + Math_clz32(HEAP32[$5 + 28 >> 2]) | 0) - 32 | 0;
      break label$94;
     }
     HEAP32[$1 >> 2] = $9;
    }
    $2 = $2 + 1 | 0;
    if (($14 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  label$96 : {
   if (!$23) {
    break label$96;
   }
   $2 = ($15 << 3) + 1744 | 0;
   $1 = $36 << 2;
   if (HEAPU8[$2 + ($17 + $1 | 0) | 0] == HEAPU8[(($1 | 2) + $17 | 0) + $2 | 0]) {
    break label$96;
   }
   ec_enc_bit_logp($5, $44, 1);
   $47 = $44 << 1;
  }
  if (!$32) {
   $7 = ($36 << 2) + $47 | 0;
   $3 = $15 << 3;
   $2 = $20;
   while (1) {
    $1 = ($2 << 2) + $33 | 0;
    HEAP32[$1 >> 2] = HEAP8[((HEAP32[$1 >> 2] + $7 | 0) + $3 | 0) + 1744 | 0];
    $2 = $2 + 1 | 0;
    if (($14 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  if (((HEAP32[$5 + 20 >> 2] + Math_clz32(HEAP32[$5 + 28 >> 2]) | 0) - 28 | 0) <= ($22 | 0)) {
   label$100 : {
    if (HEAP32[$0 + 64 >> 2]) {
     $2 = 2;
     HEAP32[$0 + 80 >> 2] = 2;
     HEAP32[$0 + 100 >> 2] = 0;
     break label$100;
    }
    $1 = $0;
    label$102 : {
     label$103 : {
      label$104 : {
       if ($20) {
        if (!HEAP32[$0 + 24 >> 2]) {
         break label$103;
        }
        if ($36) {
         break label$104;
        }
        $2 = 3;
        break label$102;
       }
       $2 = HEAP32[$0 + 24 >> 2];
       if (!(($2 | 0) > 2 ? !((Math_imul($13, 10) | 0) > ($29 | 0) | $56) : 0)) {
        if (!$2) {
         break label$103;
        }
        break label$104;
       }
       $2 = spreading_decision($19, $27, $0 + 88 | 0, HEAP32[$0 + 80 >> 2], $0 + 96 | 0, $55, ($59 | 0) != 0, $25, $13, $43, $12);
       break label$102;
      }
      $2 = 2;
      break label$102;
     }
     $2 = 0;
    }
    HEAP32[$1 + 80 >> 2] = $2;
   }
   ec_enc_icdf($5, $2, 42630, 5);
  }
  if (HEAP32[$0 + 64 >> 2]) {
   HEAP32[$49 >> 2] = ($35 | 0) > 26 ? 8 : ($35 | 0) / 3 | 0;
  }
  $35 = $45 - (($30 << 2) + 15 & -16) | 0;
  $45 = $35;
  __stack_pointer = $35;
  init_caps($19, $35, $15, $13);
  $12 = $22 << 3;
  $3 = 0;
  $7 = ec_tell_frac($5);
  if (!$32) {
   $29 = 6;
   $25 = $20;
   while (1) {
    $2 = $25;
    $25 = $2 + 1 | 0;
    $9 = $2 << 2;
    $23 = $49 + $9 | 0;
    $1 = 0;
    label$111 : {
     if ((($29 << 3) + $7 | 0) >= ($12 - $3 | 0)) {
      break label$111;
     }
     label$112 : {
      $22 = $9 + $35 | 0;
      if (HEAP32[$22 >> 2] <= 0) {
       $9 = 0;
       break label$112;
      }
      $2 = Math_imul(HEAP16[($25 << 1) + $18 >> 1] - HEAP16[($2 << 1) + $18 >> 1] | 0, $13) << $15;
      $7 = $2 << 3;
      $2 = ($2 | 0) > 48 ? $2 : 48;
      $17 = ($2 | 0) > ($7 | 0) ? $7 : $2;
      $9 = $29;
      $2 = 0;
      while (1) {
       $11 = HEAP32[$23 >> 2];
       ec_enc_bit_logp($5, ($11 | 0) > ($2 | 0), $9);
       $7 = ec_tell_frac($5);
       if (($2 | 0) >= ($11 | 0)) {
        $9 = $2;
        break label$112;
       }
       $1 = $1 + $17 | 0;
       $3 = $3 + $17 | 0;
       if (($7 + 8 | 0) < ($12 - $3 | 0)) {
        $9 = 1;
        $2 = $2 + 1 | 0;
        if (HEAP32[$22 >> 2] <= ($1 | 0)) {
         break label$112;
        }
        continue;
       }
       break;
      }
      $29 = ($29 | 0) > 2 ? $29 - 1 | 0 : 2;
      break label$111;
     }
     if (!$9) {
      break label$111;
     }
     $29 = ($29 | 0) > 2 ? $29 - 1 | 0 : 2;
    }
    HEAP32[$23 >> 2] = $1;
    if (($14 | 0) != ($25 | 0)) {
     continue;
    }
    break;
   }
  }
  if (($13 | 0) == 2) {
   if ($15) {
    $18 = HEAP32[$19 + 32 >> 2];
    $17 = HEAPU16[$18 >> 1];
    $10 = Math_fround(1.0000000036274937e-15);
    $9 = 0;
    $34 = Math_fround(1.0000000036274937e-15);
    while (1) {
     $2 = $17 << 16 >> 16 << $15;
     $9 = $9 + 1 | 0;
     $17 = HEAP16[($9 << 1) + $18 >> 1];
     $1 = $17 << $15;
     if (($2 | 0) < ($1 | 0)) {
      while (1) {
       $6 = HEAPF32[($2 << 2) + $27 >> 2];
       $8 = HEAPF32[($2 + $37 << 2) + $27 >> 2];
       $34 = Math_fround($34 + Math_fround(Math_fround(Math_abs(Math_fround($6 + $8))) + Math_fround(Math_abs(Math_fround($6 - $8)))));
       $10 = Math_fround($10 + Math_fround(Math_fround(Math_abs($6)) + Math_fround(Math_abs($8))));
       $2 = $2 + 1 | 0;
       if (($2 | 0) != ($1 | 0)) {
        continue;
       }
       break;
      }
     }
     if (($9 | 0) != 13) {
      continue;
     }
     break;
    }
    $2 = HEAP16[$18 + 26 >> 1] << $15 + 1;
    HEAP32[$16 + 20 >> 2] = Math_fround(Math_fround($34 * Math_fround(.7071070075035095)) * Math_fround($2 + ($15 >>> 0 < 2 ? 5 : 13) | 0)) > Math_fround($10 * Math_fround($2 | 0));
   }
   $2 = hysteresis_decision(Math_fround(($46 | 0) / 1e3 | 0), 42640, 42736, 21, HEAP32[$0 + 232 >> 2]);
   $2 = ($2 | 0) < ($20 | 0) ? $20 : $2;
   HEAP32[$0 + 232 >> 2] = ($2 | 0) > ($14 | 0) ? $14 : $2;
  }
  $9 = 5;
  if (($7 + 48 | 0) <= ($12 - $3 | 0)) {
   $22 = $5;
   label$123 : {
    if (!(HEAP32[$0 + 64 >> 2] ? 0 : ($20 | 0) <= 0)) {
     HEAP32[$0 + 228 >> 2] = 0;
     $9 = 5;
     break label$123;
    }
    $12 = HEAP32[$0 + 232 >> 2];
    $34 = HEAPF32[$16 + 12 >> 2];
    $10 = Math_fround(4);
    label$126 : {
     if (($46 | 0) < 64e3) {
      break label$126;
     }
     $10 = Math_fround(5);
     if (($46 | 0) > 79999) {
      break label$126;
     }
     $10 = Math_fround(Math_fround(Math_fround($46 - 64e3 >> 10) * Math_fround(.0625)) + Math_fround(4));
    }
    if (($13 | 0) == 2) {
     $23 = HEAP32[$19 + 32 >> 2];
     $11 = HEAPU16[$23 >> 1];
     $8 = Math_fround(0);
     $18 = 0;
     while (1) {
      $2 = $11 << 16;
      $6 = Math_fround(0);
      $18 = $18 + 1 | 0;
      $11 = HEAP16[($18 << 1) + $23 >> 1];
      $2 = $2 >> 16;
      $7 = $11 - $2 << $15;
      if (($7 | 0) >= 1) {
       $2 = $2 << $15;
       $9 = ($2 << 2) + $27 | 0;
       $17 = ($2 + $37 << 2) + $27 | 0;
       $2 = 0;
       while (1) {
        $1 = $2 << 2;
        $6 = Math_fround($6 + Math_fround(HEAPF32[$9 + $1 >> 2] * HEAPF32[$1 + $17 >> 2]));
        $2 = $2 + 1 | 0;
        if (($7 | 0) != ($2 | 0)) {
         continue;
        }
        break;
       }
      }
      $8 = Math_fround($8 + $6);
      if (($18 | 0) != 8) {
       continue;
      }
      break;
     }
     $41 = Math_fround(Math_min(Math_fround(Math_abs(Math_fround($8 * Math_fround(.125)))), Math_fround(1)));
     $8 = $41;
     if (($12 | 0) >= 9) {
      $11 = HEAPU16[$23 + 16 >> 1];
      $18 = 8;
      $8 = $41;
      while (1) {
       $2 = $11 << 16;
       $6 = Math_fround(0);
       $18 = $18 + 1 | 0;
       $11 = HEAP16[($18 << 1) + $23 >> 1];
       $2 = $2 >> 16;
       $7 = $11 - $2 << $15;
       if (($7 | 0) >= 1) {
        $2 = $2 << $15;
        $9 = ($2 << 2) + $27 | 0;
        $17 = ($2 + $37 << 2) + $27 | 0;
        $2 = 0;
        while (1) {
         $1 = $2 << 2;
         $6 = Math_fround($6 + Math_fround(HEAPF32[$9 + $1 >> 2] * HEAPF32[$1 + $17 >> 2]));
         $2 = $2 + 1 | 0;
         if (($7 | 0) != ($2 | 0)) {
          continue;
         }
         break;
        }
       }
       $6 = Math_fround(Math_abs($6));
       $8 = $6 > $8 ? $8 : $6;
       if (($12 | 0) != ($18 | 0)) {
        continue;
       }
       break;
      }
     }
     $61 = log(+Math_fround(Math_fround(1.0010000467300415) - Math_fround($41 * $41)));
     $6 = Math_fround(Math_min(Math_fround(Math_abs($8)), Math_fround(1)));
     $60 = log(+Math_fround(Math_fround(1.0010000467300415) - Math_fround($6 * $6)));
     $6 = Math_fround(HEAPF32[$0 + 228 >> 2] + Math_fround(.25));
     $8 = Math_fround($61 * 1.4426950408889634);
     $41 = Math_fround($8 * Math_fround(.5));
     $69 = Math_fround($60 * 1.4426950408889634);
     $41 = Math_fround(($41 > $69 ? $41 : $69) * Math_fround(-.5));
     HEAPF32[$0 + 228 >> 2] = $6 < $41 ? $6 : $41;
     $10 = Math_fround($10 + Math_fround(Math_max(Math_fround($8 * Math_fround(.75)), Math_fround(-4))));
    }
    $7 = $14 - 1 | 0;
    $9 = 2 - $14 | 0;
    $6 = Math_fround(0);
    $17 = 0;
    while (1) {
     if (($14 | 0) >= 2) {
      $1 = Math_imul(HEAP32[$19 + 8 >> 2], $17);
      $2 = 0;
      while (1) {
       $6 = Math_fround($6 + Math_fround(HEAPF32[($1 + $2 << 2) + $4 >> 2] * Math_fround(($2 << 1) + $9 | 0)));
       $2 = $2 + 1 | 0;
       if (($7 | 0) != ($2 | 0)) {
        continue;
       }
       break;
      }
     }
     $17 = $17 + 1 | 0;
     if (($31 | 0) != ($17 | 0)) {
      continue;
     }
     break;
    }
    $6 = Math_fround(Math_fround(Math_fround($6 / Math_fround(Math_imul($7, $13) | 0)) + Math_fround(1)) / Math_fround(6));
    $2 = $6 > Math_fround(2);
    $1 = $6 < Math_fround(-2);
    $8 = $1 ? $2 ? Math_fround(2) : Math_fround(-2) : Math_fround(2);
    $6 = Math_fround(Math_fround(Math_fround($10 - ($1 ? $8 : $2 ? $8 : $6)) - $71) - Math_fround($34 + $34));
    if (HEAP32[$52 >> 2]) {
     $8 = Math_fround(HEAPF32[$0 + 128 >> 2] + Math_fround(.05000000074505806));
     $8 = Math_fround($8 + $8);
     $2 = $8 > Math_fround(2);
     $1 = $8 < Math_fround(-2);
     $10 = $1 ? $2 ? Math_fround(2) : Math_fround(-2) : Math_fround(2);
     $6 = Math_fround($6 - ($1 ? $10 : $2 ? $10 : $8));
    }
    $6 = Math_fround(Math_floor(Math_fround($6 + Math_fround(.5))));
    label$138 : {
     if (Math_fround(Math_abs($6)) < Math_fround(2147483648)) {
      $2 = ~~$6;
      break label$138;
     }
     $2 = -2147483648;
    }
    $2 = ($2 | 0) < 10 ? $2 : 10;
    $9 = ($2 | 0) > 0 ? $2 : 0;
   }
   ec_enc_icdf($22, $9, 42820, 7);
   $7 = ec_tell_frac($5);
  }
  if (($42 | 0) >= 1) {
   $2 = 1275 >>> $48 | 0;
   $4 = HEAP32[$19 + 36 >> 2];
   if ($20) {
    $1 = (Math_imul($13, -72) + $42 | 0) - 32 | 0;
    $1 = ($1 | 0) > 0 ? $1 : 0;
   } else {
    $1 = $42 - ($58 << 3) | 0;
   }
   $11 = ($2 | 0) > ($26 | 0);
   $18 = $4 - $15 | 0;
   $17 = HEAP32[$0 + 52 >> 2];
   $1 = $17 ? (HEAP32[$0 + 216 >> 2] >> $18) + $1 | 0 : $1;
   $2 = $11 ? $26 : $2;
   $44 = $2;
   label$146 : {
    label$147 : {
     label$148 : {
      if (!$20) {
       $23 = HEAP32[$19 + 32 >> 2];
       $4 = HEAP32[$0 + 92 >> 2];
       $26 = HEAP32[$19 + 8 >> 2];
       $12 = $4 ? $4 : $26;
       $11 = HEAP16[$23 + ($12 << 1) >> 1] << $15;
       $29 = HEAP32[$0 + 236 >> 2];
       $25 = HEAP32[$0 + 64 >> 2];
       $8 = HEAPF32[$0 + 228 >> 2];
       $22 = HEAP32[$0 + 232 >> 2];
       $6 = HEAPF32[$16 + 12 >> 2];
       $48 = HEAP32[$16 + 8 >> 2];
       $11 = ($13 | 0) == 2 ? (HEAP16[((($12 | 0) > ($22 | 0) ? $22 : $12) << 1) + $23 >> 1] << $15) + $11 | 0 : $11;
       $47 = HEAP32[$52 >> 2];
       $4 = $1;
       label$151 : {
        if (!$47) {
         break label$151;
        }
        $10 = HEAPF32[$0 + 136 >> 2];
        $4 = $1;
        if (+$10 < .4 ^ 1) {
         break label$151;
        }
        $43 = $1;
        $10 = Math_fround(Math_fround(Math_fround(.4000000059604645) - $10) * Math_fround($11 << 3));
        label$152 : {
         if (Math_fround(Math_abs($10)) < Math_fround(2147483648)) {
          $4 = ~~$10;
          break label$152;
         }
         $4 = -2147483648;
        }
        $4 = $43 - $4 | 0;
       }
       if (($13 | 0) == 2) {
        $43 = $4;
        $12 = ($12 | 0) > ($22 | 0) ? $22 : $12;
        $12 = (HEAP16[($12 << 1) + $23 >> 1] << $15) - $12 | 0;
        $10 = Math_fround(Math_fround(Math_fround(Math_fround($12 | 0) * Math_fround(.800000011920929)) / Math_fround($11 | 0)) * Math_fround($4 | 0));
        $8 = Math_fround(Math_fround(($8 < Math_fround(1) ? $8 : Math_fround(1)) + Math_fround(-.10000000149011612)) * Math_fround($12 << 3));
        $8 = $8 > $10 ? $10 : $8;
        label$157 : {
         if (Math_fround(Math_abs($8)) < Math_fround(2147483648)) {
          $12 = ~~$8;
          break label$157;
         }
         $12 = -2147483648;
        }
        $4 = $43 - $12 | 0;
       }
       $4 = ((-19 << $15) + $48 | 0) + $4 | 0;
       $8 = Math_fround(Math_fround($6 + Math_fround(-.04399999976158142)) * Math_fround($4 | 0));
       label$154 : {
        if (Math_fround(Math_abs($8)) < Math_fround(2147483648)) {
         $12 = ~~$8;
         break label$154;
        }
        $12 = -2147483648;
       }
       $4 = $12 + $4 | 0;
       if (!(!$47 | $25)) {
        $8 = Math_fround($11 << 3);
        $10 = Math_fround(HEAPF32[$0 + 124 >> 2] + Math_fround(-.15000000596046448));
        $10 = Math_fround(Math_fround($8 * Math_fround(1.2000000476837158)) * ($10 < Math_fround(0) ? Math_fround(-.11999999731779099) : Math_fround($10 + Math_fround(-.11999999731779099))));
        label$161 : {
         if (Math_fround(Math_abs($10)) < Math_fround(2147483648)) {
          $12 = ~~$10;
          break label$161;
         }
         $12 = -2147483648;
        }
        $8 = Math_fround($8 * Math_fround(.800000011920929));
        label$163 : {
         if (Math_fround(Math_abs($8)) < Math_fround(2147483648)) {
          $22 = ~~$8;
          break label$163;
         }
         $22 = -2147483648;
        }
        $4 = $12 + (($65 ? $22 : 0) + $4 | 0) | 0;
       }
       $12 = !$29 | ($25 | 0) != 0;
       if (!$12) {
        $22 = ($4 | 0) / 4 | 0;
        $25 = $22;
        $8 = Math_fround($63 * Math_fround($11 << 3));
        label$166 : {
         if (Math_fround(Math_abs($8)) < Math_fround(2147483648)) {
          $11 = ~~$8;
          break label$166;
         }
         $11 = -2147483648;
        }
        $4 = $11 + $4 | 0;
        $4 = ($4 | 0) < ($22 | 0) ? $25 : $4;
       }
       $11 = $4 >> 2;
       $22 = $4;
       $8 = Math_fround($72 * Math_fround(Math_imul(HEAP16[(($26 << 1) + $23 | 0) - 4 >> 1] << $15, $13) << 3));
       label$168 : {
        if (Math_fround(Math_abs($8)) < Math_fround(2147483648)) {
         $23 = ~~$8;
         break label$168;
        }
        $23 = -2147483648;
       }
       $11 = ($11 | 0) < ($23 | 0) ? $23 : $11;
       $4 = ($4 | 0) < ($11 | 0) ? $22 : $11;
       if (!(!$17 | $12 ^ 1)) {
        $8 = Math_fround(Math_fround($4 - $1 | 0) * Math_fround(.6700000166893005));
        label$171 : {
         if (Math_fround(Math_abs($8)) < Math_fround(2147483648)) {
          $4 = ~~$8;
          break label$171;
         }
         $4 = -2147483648;
        }
        $4 = $4 + $1 | 0;
       }
       $12 = $4;
       if ($29 | $6 < Math_fround(.20000000298023224) ^ 1) {
        break label$147;
       }
       $11 = 96e3 - $46 | 0;
       $11 = ($11 | 0) < 32e3 ? $11 : 32e3;
       $6 = Math_fround(Math_fround((($11 | 0) < 0 ? Math_fround(0) : Math_fround(Math_fround($11 | 0) * Math_fround(3099999958067201e-21))) * $68) * Math_fround($4 | 0));
       if (!(Math_fround(Math_abs($6)) < Math_fround(2147483648))) {
        break label$148;
       }
       $12 = ~~$6 + $4 | 0;
       break label$147;
      }
      $4 = HEAP32[$0 + 188 >> 2];
      $1 = ((($4 | 0) < 100 ? 96 >>> $48 | 0 : 0) + $1 | 0) - (($4 | 0) > 100 ? 144 >>> $48 | 0 : 0) | 0;
      $6 = HEAPF32[$16 + 12 >> 2];
      $8 = Math_fround(Math_fround($6 + Math_fround(-.25)) * Math_fround(400));
      label$173 : {
       if (Math_fround(Math_abs($8)) < Math_fround(2147483648)) {
        $4 = ~~$8;
        break label$173;
       }
       $4 = -2147483648;
      }
      $1 = $1 + $4 | 0;
      $4 = $6 > Math_fround(.699999988079071) ? ($1 | 0) > 400 ? $1 : 400 : $1;
      $1 = (($3 + $7 | 0) + 63 >> 6) + 2 | 0;
      $3 = ($3 + $57 | 0) + 359 >> 6;
      $1 = ($1 | 0) > ($3 | 0) ? $1 : $3;
      break label$146;
     }
     $12 = $4 - -2147483648 | 0;
    }
    $4 = $12;
    $1 = $1 << 1;
    $4 = ($1 | 0) < ($4 | 0) ? $1 : $4;
    $1 = (($3 + $7 | 0) + 63 >> 6) + 2 | 0;
   }
   $4 = $4 + $7 | 0;
   $7 = $4 + 32 >> 6;
   $1 = ($1 | 0) > ($7 | 0) ? $1 : $7;
   $7 = ($1 | 0) > ($2 | 0) ? $44 : $1;
   $6 = Math_fround(.0010000000474974513);
   $1 = HEAP32[$0 + 220 >> 2];
   if (($1 | 0) <= 969) {
    HEAP32[$0 + 220 >> 2] = $1 + 1;
    $6 = Math_fround(Math_fround(1) / Math_fround($1 + 21 | 0));
   }
   $1 = $51 ? $7 : 2;
   label$176 : {
    if (!$17) {
     break label$176;
    }
    $7 = HEAP32[$0 + 208 >> 2] + (($51 ? $7 << 6 : 128) - $42 | 0) | 0;
    HEAP32[$0 + 208 >> 2] = $7;
    $12 = $0;
    $3 = (($51 ? $4 - $42 | 0 : 0) << $18) - HEAP32[$0 + 216 >> 2] | 0;
    $4 = HEAP32[$0 + 212 >> 2];
    $6 = Math_fround($6 * Math_fround($3 - $4 | 0));
    label$177 : {
     if (Math_fround(Math_abs($6)) < Math_fround(2147483648)) {
      $3 = ~~$6;
      break label$177;
     }
     $3 = -2147483648;
    }
    $4 = $3 + $4 | 0;
    HEAP32[$12 + 212 >> 2] = $4;
    HEAP32[$0 + 216 >> 2] = 0 - $4;
    if (($7 | 0) > -1) {
     break label$176;
    }
    HEAP32[$0 + 208 >> 2] = 0;
    $1 = ($51 ? ($7 | 0) / -64 | 0 : 0) + $1 | 0;
   }
   $26 = ($1 | 0) > ($2 | 0) ? $2 : $1;
   ec_enc_shrink($5, $26);
  }
  $1 = ($30 << 2) + 15 & -16;
  $2 = $45 - $1 | 0;
  __stack_pointer = $2;
  $4 = $2 - $1 | 0;
  $7 = $4;
  __stack_pointer = $7;
  $3 = $7 - $1 | 0;
  $11 = $3;
  __stack_pointer = $3;
  $23 = $26 << 6;
  $7 = $23 + (ec_tell_frac($5) ^ -1) | 0;
  $17 = 0;
  $22 = $19;
  $29 = $20;
  $25 = $14;
  $55 = $0 + 232 | 0;
  $57 = $16 + 20 | 0;
  $12 = $7;
  $1 = 0;
  label$179 : {
   if ($15 >>> 0 < 2) {
    break label$179;
   }
   $1 = 0;
   if (!$36) {
    break label$179;
   }
   $17 = (($15 << 3) + 16 | 0) <= ($7 | 0);
   $1 = $17 << 3;
  }
  $18 = $12 - $1 | 0;
  $58 = $16 + 80 | 0;
  $45 = $4;
  $44 = $2;
  $43 = $3;
  $47 = $13;
  $65 = $15;
  $42 = $5;
  $59 = HEAP32[$0 + 92 >> 2];
  if (HEAP32[$52 >> 2]) {
   $12 = HEAP32[$0 + 152 >> 2];
   $48 = $12;
   $7 = 13;
   label$181 : {
    if ((Math_imul($13, 32e3) | 0) > ($46 | 0)) {
     break label$181;
    }
    $7 = 16;
    if ((Math_imul($13, 48e3) | 0) > ($46 | 0)) {
     break label$181;
    }
    $7 = 18;
    if ((Math_imul($13, 6e4) | 0) > ($46 | 0)) {
     break label$181;
    }
    $7 = (Math_imul($13, 8e4) | 0) > ($46 | 0) ? 19 : 20;
   }
   $7 = ($7 | 0) < ($12 | 0) ? $48 : $7;
  } else {
   $7 = $14 - 1 | 0;
  }
  $7 = clt_compute_allocation($22, $29, $25, $49, $35, $9, $55, $57, $18, $58, $45, $44, $43, $47, $65, $42, 1, $59, HEAP32[$0 + 64 >> 2] ? 1 : $7);
  $9 = $7;
  $18 = HEAP32[$0 + 92 >> 2];
  if ($18) {
   $9 = $18 + 1 | 0;
   $18 = $18 - 1 | 0;
   $18 = ($7 | 0) < ($18 | 0) ? $18 : $7;
   $9 = ($9 | 0) < ($18 | 0) ? $9 : $18;
  }
  $18 = $26 << 3;
  HEAP32[$0 + 92 >> 2] = $9;
  quant_fine_energy($19, $20, $14, $21, $24, $2, $5, $13);
  $9 = 0;
  $11 = $11 - ($40 + 15 & -16) | 0;
  __stack_pointer = $11;
  quant_all_bands(1, $19, $20, $14, $27, ($13 | 0) == 2 ? ($37 << 2) + $27 | 0 : 0, $11, $38, $4, $56, HEAP32[$0 + 80 >> 2], HEAP32[$16 + 20 >> 2], HEAP32[$0 + 232 >> 2], $33, $23 - $1 | 0, HEAP32[$16 + 80 >> 2], $5, $15, $7, $0 + 76 | 0, HEAP32[$0 + 24 >> 2], HEAP32[$0 + 72 >> 2], HEAP32[$0 + 68 >> 2]);
  if ($17) {
   ec_enc_bits($5, HEAP32[$0 + 116 >> 2] < 2, 1);
  }
  quant_energy_finalise($19, $20, $14, $21, $24, $2, $3, (($18 - HEAP32[$5 + 20 >> 2] | 0) - Math_clz32(HEAP32[$5 + 28 >> 2]) | 0) + 32 | 0, $5, $13);
  $27 = $50 << 2;
  $3 = memset($53, 0, $27);
  while (1) {
   if (!$32) {
    $4 = Math_imul($9, $30);
    $2 = $20;
    while (1) {
     $1 = $2 + $4 << 2;
     $12 = $3 + $1 | 0;
     $6 = HEAPF32[$1 + $24 >> 2];
     $1 = $6 > Math_fround(.5);
     $7 = ($1 ? Math_fround(.5) : $6) < Math_fround(-.5);
     $8 = $7 ? Math_fround(-.5) : Math_fround(.5);
     HEAPF32[$12 >> 2] = $1 ? $8 : $7 ? $8 : $6;
     $2 = $2 + 1 | 0;
     if (($14 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   $9 = $9 + 1 | 0;
   if (($31 | 0) != ($9 | 0)) {
    continue;
   }
   break;
  }
  if (!(!($51 ^ 1) | ($40 | 0) < 1)) {
   $2 = 0;
   while (1) {
    HEAP32[($2 << 2) + $21 >> 2] = -1042284544;
    $2 = $2 + 1 | 0;
    if (($40 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  $2 = HEAP32[$16 + 28 >> 2];
  HEAP32[$0 + 112 >> 2] = $64;
  HEAPF32[$0 + 108 >> 2] = $66;
  HEAP32[$0 + 104 >> 2] = $2;
  if ($70) {
   $2 = $30 << 2;
   memcpy($21 + $2 | 0, $21, $2);
  }
  label$190 : {
   if ($36) {
    $2 = 0;
    if (($50 | 0) <= 0) {
     break label$190;
    }
    while (1) {
     $1 = $2 << 2;
     $7 = $28 + $1 | 0;
     $6 = HEAPF32[$7 >> 2];
     $8 = HEAPF32[$1 + $21 >> 2];
     HEAPF32[$7 >> 2] = $6 < $8 ? $6 : $8;
     $2 = $2 + 1 | 0;
     if (($50 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
    break label$190;
   }
   memcpy($39, $28, $27);
   memcpy($28, $21, $27);
  }
  $3 = ($20 | 0) < 1;
  $4 = 0;
  while (1) {
   if (!$3) {
    $7 = Math_imul($4, $30);
    $2 = 0;
    while (1) {
     $1 = $2 + $7 << 2;
     HEAP32[$21 + $1 >> 2] = 0;
     HEAP32[$1 + $39 >> 2] = -1042284544;
     HEAP32[$1 + $28 >> 2] = -1042284544;
     $2 = $2 + 1 | 0;
     if (($20 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   if (($14 | 0) < ($30 | 0)) {
    $7 = Math_imul($4, $30);
    $2 = $14;
    while (1) {
     $1 = $2 + $7 << 2;
     HEAP32[$21 + $1 >> 2] = 0;
     HEAP32[$1 + $39 >> 2] = -1042284544;
     HEAP32[$1 + $28 >> 2] = -1042284544;
     $2 = $2 + 1 | 0;
     if (($30 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   $4 = $4 + 1 | 0;
   if (($54 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
  $2 = 0;
  $2 = !$36 & ($62 ^ -1) ? $2 : HEAP32[$0 + 116 >> 2] + 1 | 0;
  HEAP32[$0 + 116 >> 2] = $2;
  HEAP32[$0 + 76 >> 2] = HEAP32[$5 + 28 >> 2];
  ec_enc_done($5);
  $7 = HEAP32[$5 + 44 >> 2] ? -3 : $26;
 }
 __stack_pointer = $16 + 192 | 0;
 return $7;
}
function run_analysis($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) {
 var $12 = Math_fround(0), $13 = Math_fround(0), $14 = 0, $15 = 0, $16 = 0, $17 = Math_fround(0), $18 = Math_fround(0), $19 = Math_fround(0), $20 = Math_fround(0), $21 = Math_fround(0), $22 = 0, $23 = Math_fround(0), $24 = Math_fround(0), $25 = Math_fround(0), $26 = Math_fround(0), $27 = 0, $28 = 0, $29 = Math_fround(0), $30 = Math_fround(0), $31 = Math_fround(0), $32 = 0, $33 = Math_fround(0), $34 = 0, $35 = Math_fround(0), $36 = 0, $37 = Math_fround(0), $38 = Math_fround(0), $39 = Math_fround(0), $40 = Math_fround(0), $41 = Math_fround(0), $42 = Math_fround(0), $43 = Math_fround(0), $44 = Math_fround(0), $45 = Math_fround(0), $46 = Math_fround(0), $47 = Math_fround(0), $48 = 0, $49 = Math_fround(0), $50 = 0, $51 = 0, $52 = Math_fround(0), $53 = 0, $54 = Math_fround(0), $55 = 0, $56 = Math_fround(0), $57 = Math_fround(0), $58 = 0, $59 = Math_fround(0), $60 = Math_fround(0), $61 = Math_fround(0), $62 = Math_fround(0), $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = Math_fround(0), $68 = Math_fround(0), $69 = Math_fround(0), $70 = Math_fround(0), $71 = 0, $72 = 0, $73 = Math_fround(0);
 $14 = __stack_pointer - 11360 | 0;
 __stack_pointer = $14;
 if ($2) {
  $15 = (Math_imul($8, 95) | 0) / 50 | 0;
  $3 = $3 & -2;
  $63 = ($3 | 0) > ($15 | 0) ? $15 : $3;
  $50 = HEAP32[$0 + 7440 >> 2];
  $51 = $63 - $50 | 0;
  if (($51 | 0) >= 1) {
   $64 = $0 + 7464 | 0;
   $71 = $0 + 3852 | 0;
   $72 = $0 + 4812 | 0;
   $65 = $0 + 7592 | 0;
   $53 = $0 + 2892 | 0;
   $55 = ($8 | 0) / 50 | 0;
   $12 = Math_fround(Math_fround(.0005699999746866524) / Math_fround(1 << (($9 | 0) > 8 ? $9 : 8) - 8));
   $56 = Math_fround($12 * $12);
   $73 = Math_fround($56 * Math_fround(3));
   while (1) {
    $8 = ($51 | 0) > ($55 | 0);
    if (!HEAP32[$0 + 7460 >> 2]) {
     HEAP32[$0 + 7460 >> 2] = 1;
     HEAP32[$0 + 5772 >> 2] = 240;
    }
    $22 = $8 ? $55 : $51;
    $48 = HEAP32[$0 + 7436 >> 2];
    $8 = HEAP32[$0 + 8 >> 2];
    label$5 : {
     if (($8 | 0) != 16e3) {
      $16 = $50;
      if (($8 | 0) != 48e3) {
       break label$5;
      }
      $22 = ($22 | 0) / 2 | 0;
      $16 = ($50 | 0) / 2 | 0;
      break label$5;
     }
     $22 = (Math_imul($22, 3) | 0) / 2 | 0;
     $16 = (Math_imul($50, 3) | 0) / 2 | 0;
    }
    $28 = HEAP32[$1 + 72 >> 2];
    $3 = HEAP32[$0 + 5772 >> 2];
    $15 = (($3 << 2) + $0 | 0) + 2892 | 0;
    $3 = 720 - $3 | 0;
    $45 = Math_fround(downmix_and_resample($10, $2, $15, $65, ($3 | 0) > ($22 | 0) ? $22 : $3, $16, $5, $6, $7, $8) + HEAPF32[$0 + 7456 >> 2]);
    HEAPF32[$0 + 7456 >> 2] = $45;
    $8 = HEAP32[$0 + 5772 >> 2] + $22 | 0;
    label$7 : {
     if (($8 | 0) <= 719) {
      HEAP32[$0 + 5772 >> 2] = $8;
      break label$7;
     }
     $8 = $48 + 1 | 0;
     $57 = Math_fround(Math_fround(1) / Math_fround((($48 | 0) < 100 ? $8 : 100) | 0));
     $46 = Math_fround(Math_fround(1) / Math_fround((($48 | 0) < 25 ? $8 : 25) | 0));
     $29 = Math_fround(Math_fround(1) / Math_fround((($48 | 0) < 10 ? $8 : 10) | 0));
     $32 = HEAP32[$0 + 7444 >> 2];
     HEAP32[$0 + 7444 >> 2] = $32 + (($32 | 0) > 98 ? -99 : 1);
     $27 = is_digital_silence($53, 720, 1, $9);
     $8 = 0;
     while (1) {
      $3 = ($14 + 5760 | 0) + ($8 << 3) | 0;
      $15 = $8 << 2;
      $12 = HEAPF32[$15 + 48944 >> 2];
      $15 = $15 + $53 | 0;
      HEAPF32[$3 >> 2] = $12 * HEAPF32[$15 >> 2];
      HEAPF32[$3 + 4 >> 2] = $12 * HEAPF32[$15 + 960 >> 2];
      $3 = 479 - $8 | 0;
      $15 = ($14 + 5760 | 0) + ($3 << 3) | 0;
      HEAPF32[$15 >> 2] = $12 * HEAPF32[($3 << 2) + $53 >> 2];
      HEAPF32[$15 + 4 >> 2] = $12 * HEAPF32[(719 - $8 << 2) + $53 >> 2];
      $8 = $8 + 1 | 0;
      if (($8 | 0) != 240) {
       continue;
      }
      break;
     }
     memcpy($53, $72, 960);
     $8 = HEAP32[$0 + 5772 >> 2];
     $3 = $22 + $8 | 0;
     $12 = downmix_and_resample($10, $2, $71, $65, $3 - 720 | 0, ($16 - $8 | 0) + 720 | 0, $5, $6, $7, HEAP32[$0 + 8 >> 2]);
     HEAP32[$0 + 5772 >> 2] = $3 - 480;
     HEAPF32[$0 + 7456 >> 2] = $12;
     $36 = ($32 << 6) + $0 | 0;
     $34 = $36 + 7604 | 0;
     if ($27) {
      $8 = HEAP32[$0 + 7444 >> 2];
      $8 = ($8 + (($8 | 0) < 2 ? 98 : -2) << 6) + $0 | 0;
      $16 = $8 + 7660 | 0;
      $15 = HEAP32[$16 >> 2];
      $3 = HEAP32[$16 + 4 >> 2];
      $16 = $15;
      $15 = $34;
      HEAP32[$15 + 56 >> 2] = $16;
      HEAP32[$15 + 60 >> 2] = $3;
      $16 = $8 + 7652 | 0;
      $3 = HEAP32[$16 >> 2];
      $15 = HEAP32[$16 + 4 >> 2];
      $16 = $3;
      $3 = $34;
      HEAP32[$3 + 48 >> 2] = $16;
      HEAP32[$3 + 52 >> 2] = $15;
      $16 = $8 + 7644 | 0;
      $15 = HEAP32[$16 >> 2];
      $3 = HEAP32[$16 + 4 >> 2];
      $16 = $15;
      $15 = $34;
      HEAP32[$15 + 40 >> 2] = $16;
      HEAP32[$15 + 44 >> 2] = $3;
      $16 = $8 + 7636 | 0;
      $3 = HEAP32[$16 >> 2];
      $15 = HEAP32[$16 + 4 >> 2];
      $16 = $3;
      $3 = $34;
      HEAP32[$3 + 32 >> 2] = $16;
      HEAP32[$3 + 36 >> 2] = $15;
      $16 = $8 + 7628 | 0;
      $15 = HEAP32[$16 >> 2];
      $3 = HEAP32[$16 + 4 >> 2];
      $16 = $15;
      $15 = $34;
      HEAP32[$15 + 24 >> 2] = $16;
      HEAP32[$15 + 28 >> 2] = $3;
      $16 = $8 + 7620 | 0;
      $3 = HEAP32[$16 >> 2];
      $15 = HEAP32[$16 + 4 >> 2];
      $16 = $3;
      $3 = $34;
      HEAP32[$3 + 16 >> 2] = $16;
      HEAP32[$3 + 20 >> 2] = $15;
      $16 = $8 + 7612 | 0;
      $15 = HEAP32[$16 >> 2];
      $3 = HEAP32[$16 + 4 >> 2];
      $16 = $15;
      $15 = $34;
      HEAP32[$15 + 8 >> 2] = $16;
      HEAP32[$15 + 12 >> 2] = $3;
      $16 = $8 + 7604 | 0;
      $3 = HEAP32[$16 >> 2];
      $15 = HEAP32[$16 + 4 >> 2];
      $8 = $3;
      $3 = $34;
      HEAP32[$3 >> 2] = $8;
      HEAP32[$3 + 4 >> 2] = $15;
      break label$7;
     }
     opus_fft_c($28, $14 + 5760 | 0, $14 + 1920 | 0);
     $8 = 1;
     $25 = HEAPF32[$14 + 1920 >> 2];
     if ($25 != $25) {
      HEAP32[$34 >> 2] = 0;
      break label$7;
     }
     while (1) {
      $3 = ((0 - $8 << 3) + $14 | 0) + 5760 | 0;
      $19 = HEAPF32[$3 >> 2];
      $15 = ($14 + 1920 | 0) + ($8 << 3) | 0;
      $18 = HEAPF32[$15 >> 2];
      $12 = Math_fround($19 - $18);
      $17 = HEAPF32[$15 + 4 >> 2];
      $26 = HEAPF32[$3 + 4 >> 2];
      $13 = Math_fround($17 + $26);
      $20 = Math_fround(0);
      $3 = $8 << 2;
      $15 = $3 + $0 | 0;
      $28 = $15;
      $27 = $15;
      $23 = Math_fround($18 + $19);
      $19 = Math_fround($23 * $23);
      $18 = Math_fround($17 - $26);
      $17 = Math_fround($18 * $18);
      $24 = Math_fround(0);
      label$13 : {
       if (Math_fround($19 + $17) < Math_fround(1.000000045813705e-18)) {
        break label$13;
       }
       $24 = Math_fround(($18 < Math_fround(0) ? Math_fround(-1.5707963705062866) : Math_fround(1.5707963705062866)) - Math_fround(Math_fround(Math_fround($18 * $23) * Math_fround(Math_fround($19 * Math_fround(.43157973885536194)) + $17)) / Math_fround(Math_fround(Math_fround($19 * Math_fround(.6784840226173401)) + $17) * Math_fround(Math_fround($19 * Math_fround(.0859554186463356)) + $17))));
       if (!($19 < $17 ^ 1)) {
        break label$13;
       }
       $24 = $18 < Math_fround(0) ? Math_fround(-1.5707963705062866) : Math_fround(1.5707963705062866);
       $18 = Math_fround($23 * $18);
       $24 = Math_fround(Math_fround($24 + Math_fround(Math_fround($18 * Math_fround($19 + Math_fround($17 * Math_fround(.43157973885536194)))) / Math_fround(Math_fround($19 + Math_fround($17 * Math_fround(.6784840226173401))) * Math_fround($19 + Math_fround($17 * Math_fround(.0859554186463356)))))) - ($18 < Math_fround(0) ? Math_fround(-1.5707963705062866) : Math_fround(1.5707963705062866)));
      }
      $24 = Math_fround($24 * Math_fround(.15915493667125702));
      $22 = $15 + 12 | 0;
      $23 = Math_fround($24 - HEAPF32[$22 >> 2]);
      $16 = $15 + 972 | 0;
      $19 = Math_fround($23 - HEAPF32[$16 >> 2]);
      $18 = Math_fround($12 * $12);
      $17 = Math_fround($13 * $13);
      label$14 : {
       if (Math_fround($18 + $17) < Math_fround(1.000000045813705e-18)) {
        break label$14;
       }
       if (!($18 > $17 ^ 1)) {
        $20 = Math_fround(($12 < Math_fround(0) ? Math_fround(-1.5707963705062866) : Math_fround(1.5707963705062866)) - Math_fround(Math_fround(Math_fround($12 * $13) * Math_fround($18 + Math_fround($17 * Math_fround(.43157973885536194)))) / Math_fround(Math_fround($18 + Math_fround($17 * Math_fround(.6784840226173401))) * Math_fround($18 + Math_fround($17 * Math_fround(.0859554186463356))))));
        break label$14;
       }
       $20 = $12 < Math_fround(0) ? Math_fround(-1.5707963705062866) : Math_fround(1.5707963705062866);
       $12 = Math_fround($12 * $13);
       $20 = Math_fround(Math_fround($20 + Math_fround(Math_fround($12 * Math_fround(Math_fround($18 * Math_fround(.43157973885536194)) + $17)) / Math_fround(Math_fround(Math_fround($18 * Math_fround(.6784840226173401)) + $17) * Math_fround(Math_fround($18 * Math_fround(.0859554186463356)) + $17)))) - ($12 < Math_fround(0) ? Math_fround(-1.5707963705062866) : Math_fround(1.5707963705062866)));
      }
      $18 = Math_fround($20 * Math_fround(.15915493667125702));
      $17 = Math_fround($18 - $24);
      $12 = Math_fround($17 - $23);
      $32 = lrintf($12);
      $16 = $3 + $14 | 0;
      $13 = Math_fround($19 - Math_fround(lrintf($19) | 0));
      $12 = Math_fround($12 - Math_fround($32 | 0));
      HEAPF32[$16 >> 2] = Math_fround(Math_abs($13)) + Math_fround(Math_abs($12));
      $15 = $15 + 1932 | 0;
      $19 = HEAPF32[$15 >> 2];
      $12 = Math_fround($12 * $12);
      $12 = Math_fround($12 * $12);
      HEAPF32[($14 + 1e4 | 0) + $3 >> 2] = Math_fround(Math_fround(1) / Math_fround(Math_fround($12 * Math_fround(62341.81640625)) + Math_fround(1))) + Math_fround(-.014999999664723873);
      $13 = Math_fround($13 * $13);
      HEAPF32[($14 + 960 | 0) + $3 >> 2] = Math_fround(Math_fround(1) / Math_fround(Math_fround(Math_fround(Math_fround(Math_fround($19 + Math_fround($13 * $13)) + Math_fround($12 + $12)) * Math_fround(.25)) * Math_fround(62341.81640625)) + Math_fround(1))) + Math_fround(-.014999999664723873);
      HEAPF32[$28 + 12 >> 2] = $18;
      HEAPF32[$27 + 972 >> 2] = $17;
      HEAPF32[$15 >> 2] = $12;
      $8 = $8 + 1 | 0;
      if (($8 | 0) != 240) {
       continue;
      }
      break;
     }
     $8 = 2;
     $12 = HEAPF32[$14 + 10008 >> 2];
     while (1) {
      $3 = $8 << 2;
      $15 = $3 + ($14 + 960 | 0) | 0;
      $19 = HEAPF32[$15 >> 2];
      $18 = HEAPF32[($3 + $14 | 0) + 9996 >> 2];
      $3 = $8 + 1 | 0;
      $13 = HEAPF32[($14 + 1e4 | 0) + ($3 << 2) >> 2];
      $18 = $13 < $18 ? $18 : $13;
      $12 = Math_fround(($12 < $18 ? $12 : $18) + Math_fround(-.10000000149011612));
      HEAPF32[$15 >> 2] = ($12 < $19 ? $19 : $12) * Math_fround(.8999999761581421);
      $12 = $13;
      $8 = $3;
      if (($8 | 0) != 239) {
       continue;
      }
      break;
     }
     $58 = $36 + 7620 | 0;
     HEAP32[$58 >> 2] = 0;
     $27 = HEAP32[$0 + 7436 >> 2];
     if (!$27) {
      HEAP32[$0 + 7008 >> 2] = 1343554297;
      HEAP32[$0 + 7012 >> 2] = 1343554297;
      HEAP32[$0 + 7080 >> 2] = -803929351;
      HEAP32[$0 + 7084 >> 2] = -803929351;
      HEAP32[$0 + 7088 >> 2] = -803929351;
      HEAP32[$0 + 7092 >> 2] = -803929351;
      HEAP32[$0 + 7016 >> 2] = 1343554297;
      HEAP32[$0 + 7020 >> 2] = 1343554297;
      HEAP32[$0 + 7096 >> 2] = -803929351;
      HEAP32[$0 + 7100 >> 2] = -803929351;
      HEAP32[$0 + 7024 >> 2] = 1343554297;
      HEAP32[$0 + 7028 >> 2] = 1343554297;
      HEAP32[$0 + 7104 >> 2] = -803929351;
      HEAP32[$0 + 7108 >> 2] = -803929351;
      HEAP32[$0 + 7032 >> 2] = 1343554297;
      HEAP32[$0 + 7036 >> 2] = 1343554297;
      HEAP32[$0 + 7112 >> 2] = -803929351;
      HEAP32[$0 + 7116 >> 2] = -803929351;
      HEAP32[$0 + 7040 >> 2] = 1343554297;
      HEAP32[$0 + 7044 >> 2] = 1343554297;
      HEAP32[$0 + 7048 >> 2] = 1343554297;
      HEAP32[$0 + 7052 >> 2] = 1343554297;
      HEAP32[$0 + 7120 >> 2] = -803929351;
      HEAP32[$0 + 7124 >> 2] = -803929351;
      HEAP32[$0 + 7056 >> 2] = 1343554297;
      HEAP32[$0 + 7060 >> 2] = 1343554297;
      HEAP32[$0 + 7136 >> 2] = -803929351;
      HEAP32[$0 + 7140 >> 2] = -803929351;
      HEAP32[$0 + 7128 >> 2] = -803929351;
      HEAP32[$0 + 7132 >> 2] = -803929351;
      HEAP32[$0 + 7064 >> 2] = 1343554297;
      HEAP32[$0 + 7068 >> 2] = 1343554297;
      HEAP32[$0 + 7072 >> 2] = 1343554297;
      HEAP32[$0 + 7144 >> 2] = -803929351;
      HEAP32[$0 + 7148 >> 2] = -803929351;
      HEAP32[$0 + 7076 >> 2] = 1343554297;
     }
     $12 = Math_fround($25 + $25);
     $17 = Math_fround($12 * $12);
     $12 = HEAPF32[$14 + 1924 >> 2];
     $12 = Math_fround($12 + $12);
     $17 = Math_fround($17 + Math_fround($12 * $12));
     $12 = HEAPF32[$14 + 1928 >> 2];
     $20 = Math_fround($12 * $12);
     $12 = HEAPF32[$14 + 5752 >> 2];
     $20 = Math_fround($20 + Math_fround($12 * $12));
     $12 = HEAPF32[$14 + 1932 >> 2];
     $20 = Math_fround($20 + Math_fround($12 * $12));
     $12 = HEAPF32[$14 + 5756 >> 2];
     $17 = Math_fround($17 + Math_fround($20 + Math_fround($12 * $12)));
     $12 = HEAPF32[$14 + 1936 >> 2];
     $20 = Math_fround($12 * $12);
     $12 = HEAPF32[$14 + 5744 >> 2];
     $20 = Math_fround($20 + Math_fround($12 * $12));
     $12 = HEAPF32[$14 + 1940 >> 2];
     $20 = Math_fround($20 + Math_fround($12 * $12));
     $12 = HEAPF32[$14 + 5748 >> 2];
     $17 = Math_fround($17 + Math_fround($20 + Math_fround($12 * $12)));
     $12 = HEAPF32[$14 + 1944 >> 2];
     $20 = Math_fround($12 * $12);
     $12 = HEAPF32[$14 + 5736 >> 2];
     $20 = Math_fround($20 + Math_fround($12 * $12));
     $12 = HEAPF32[$14 + 1948 >> 2];
     $20 = Math_fround($20 + Math_fround($12 * $12));
     $12 = HEAPF32[$14 + 5740 >> 2];
     $23 = Math_fround(Math_fround(log(+Math_fround(Math_fround($17 + Math_fround($20 + Math_fround($12 * $12))) + Math_fround(1.000000013351432e-10)))) * Math_fround(.7213475108146667));
     HEAPF32[$14 + 9888 >> 2] = $23;
     $24 = Math_fround(0);
     $16 = 0;
     $8 = 4;
     $35 = Math_fround(0);
     $30 = Math_fround(0);
     $31 = Math_fround(0);
     $49 = Math_fround(0);
     $37 = Math_fround(0);
     $38 = Math_fround(0);
     while (1) {
      $19 = Math_fround(0);
      $18 = Math_fround(0);
      $13 = Math_fround(0);
      $32 = $16 + 1 | 0;
      $28 = $32 << 2;
      $22 = HEAP32[$28 + 49904 >> 2];
      if (($22 | 0) > ($8 | 0)) {
       while (1) {
        $3 = ($14 + 1920 | 0) + ($8 << 3) | 0;
        $12 = HEAPF32[$3 >> 2];
        $17 = Math_fround($12 * $12);
        $15 = ((0 - $8 << 3) + $14 | 0) + 5760 | 0;
        $12 = HEAPF32[$15 >> 2];
        $17 = Math_fround($17 + Math_fround($12 * $12));
        $12 = HEAPF32[$3 + 4 >> 2];
        $17 = Math_fround($17 + Math_fround($12 * $12));
        $12 = HEAPF32[$15 + 4 >> 2];
        $12 = Math_fround($17 + Math_fround($12 * $12));
        $13 = Math_fround($13 + $12);
        $3 = $8 << 2;
        $18 = Math_fround($18 + Math_fround($12 * Math_fround(Math_max(HEAPF32[$3 + ($14 + 960 | 0) >> 2], Math_fround(0)))));
        $19 = Math_fround($19 + Math_fround(Math_fround($12 + $12) * Math_fround(Math_fround(.5) - HEAPF32[$3 + $14 >> 2])));
        $8 = $8 + 1 | 0;
        if (($22 | 0) != ($8 | 0)) {
         continue;
        }
        break;
       }
      }
      if (!($13 == $13 ? !($13 < Math_fround(1e9) ^ 1) : 0)) {
       HEAP32[$34 >> 2] = 0;
       break label$7;
      }
      $3 = $16 << 2;
      $8 = $3 + (Math_imul(HEAP32[$0 + 7432 >> 2], 72) + $0 | 0) | 0;
      HEAPF32[$8 + 5856 >> 2] = $13;
      $15 = ($14 + 9888 | 0) + $28 | 0;
      $26 = Math_fround($13 + Math_fround(1.000000013351432e-10));
      $12 = Math_fround(log(+$26));
      HEAPF32[$15 >> 2] = $12 * Math_fround(.7213475108146667);
      HEAPF32[($14 + 11200 | 0) + $3 >> 2] = $12;
      HEAPF32[$8 + 6432 >> 2] = $12;
      label$22 : {
       if ($27) {
        $8 = $0 + $3 | 0;
        $17 = HEAPF32[$8 + 7008 >> 2];
        $20 = HEAPF32[$8 + 7080 >> 2];
        break label$22;
       }
       $8 = $0 + $3 | 0;
       HEAPF32[$8 + 7080 >> 2] = $12;
       HEAPF32[$8 + 7008 >> 2] = $12;
       $17 = $12;
       $20 = $12;
      }
      $8 = $0 + $3 | 0;
      $15 = $8 + 7008 | 0;
      $28 = $8 + 7080 | 0;
      label$24 : {
       if (+$20 > +$17 + 7.5 ^ 1) {
        break label$24;
       }
       if (!(Math_fround($20 - $12) > Math_fround($12 - $17) ^ 1)) {
        $20 = Math_fround($20 + Math_fround(-.009999999776482582));
        HEAPF32[$28 >> 2] = $20;
        break label$24;
       }
       $17 = Math_fround($17 + Math_fround(.009999999776482582));
       HEAPF32[$15 >> 2] = $17;
      }
      $13 = Math_fround($13 + Math_fround(1.0000000036274937e-15));
      label$26 : {
       if (!($12 > $20 ^ 1)) {
        HEAPF32[$28 >> 2] = $12;
        $20 = Math_fround($12 + Math_fround(-15));
        $17 = $17 < $20 ? $20 : $17;
        HEAPF32[$15 >> 2] = $17;
        $20 = $12;
        break label$26;
       }
       if ($12 < $17 ^ 1) {
        break label$26;
       }
       HEAPF32[$15 >> 2] = $12;
       $17 = Math_fround($12 + Math_fround(15));
       $20 = $17 < $20 ? $17 : $20;
       HEAPF32[$28 >> 2] = $20;
       $17 = $12;
      }
      $26 = Math_fround(Math_sqrt($26));
      $19 = Math_fround($19 / $13);
      $13 = Math_fround($18 / $13);
      $15 = $8 + 5776 | 0;
      $18 = HEAPF32[$8 + 5856 >> 2];
      $25 = HEAPF32[$8 + 5928 >> 2];
      $33 = HEAPF32[$8 + 6e3 >> 2];
      $39 = HEAPF32[$8 + 6072 >> 2];
      $40 = HEAPF32[$8 + 6144 >> 2];
      $41 = HEAPF32[$8 + 6216 >> 2];
      $42 = HEAPF32[$8 + 6288 >> 2];
      $43 = HEAPF32[$8 + 6360 >> 2];
      $18 = Math_fround(Math_min(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_sqrt($18)) + Math_fround(0)) + Math_fround(Math_sqrt($25))) + Math_fround(Math_sqrt($33))) + Math_fround(Math_sqrt($39))) + Math_fround(Math_sqrt($40))) + Math_fround(Math_sqrt($41))) + Math_fround(Math_sqrt($42))) + Math_fround(Math_sqrt($43))) / Math_fround(Math_sqrt(+Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround($18 + Math_fround(0)) + $25) + $33) + $39) + $40) + $41) + $42) + $43) * Math_fround(8)) + 1e-15))), Math_fround(.9900000095367432)));
      $18 = Math_fround($18 * $18);
      $18 = Math_fround($18 * $18);
      $25 = Math_fround(HEAPF32[$15 >> 2] * $18);
      $13 = $13 > $25 ? $13 : $25;
      HEAPF32[($14 + 11280 | 0) + $3 >> 2] = $13;
      $24 = Math_fround($24 + $13);
      $12 = Math_fround(Math_fround($12 - $17) / Math_fround(Math_fround($20 - $17) + Math_fround(9999999747378752e-21)));
      $24 = $16 >>> 0 >= 9 ? Math_fround($24 - HEAPF32[($3 + $14 | 0) + 11244 >> 2]) : $24;
      $38 = Math_fround($38 + $26);
      $30 = Math_fround($30 + $19);
      $49 = Math_fround($49 + $18);
      $37 = Math_fround($37 + $12);
      HEAPF32[$15 >> 2] = $13;
      $12 = Math_fround(Math_fround(Math_fround(Math_fround($16 - 18 | 0) * Math_fround(.029999999329447746)) + Math_fround(1)) * $24);
      $35 = $12 < $35 ? $35 : $12;
      $31 = Math_fround($31 + Math_fround($13 * Math_fround($16 - 8 | 0)));
      $8 = $22;
      $16 = $32;
      if (($16 | 0) != 18) {
       continue;
      }
      break;
     }
     HEAPF32[$14 + 9808 >> 2] = $23;
     $13 = Math_fround($23 + Math_fround(-2.5));
     HEAPF32[$14 + 9728 >> 2] = $13;
     $3 = 1;
     $15 = 4;
     $19 = $23;
     while (1) {
      $8 = $3 << 2;
      $22 = HEAP32[$8 + 49904 >> 2];
      $12 = Math_fround($22 - $15 | 0);
      $18 = Math_fround(Math_fround($12 + $12) * Math_fround(.25));
      $19 = Math_fround($19 + $18);
      $12 = HEAPF32[($14 + 9888 | 0) + $8 >> 2];
      $19 = $12 > $19 ? $19 : $12;
      HEAPF32[($14 + 9808 | 0) + $8 >> 2] = $19;
      $13 = Math_fround($13 - $18);
      $12 = Math_fround($12 + Math_fround(-2.5));
      $13 = $12 < $13 ? $13 : $12;
      HEAPF32[($14 + 9728 | 0) + $8 >> 2] = $13;
      $15 = $22;
      $3 = $3 + 1 | 0;
      if (($3 | 0) != 19) {
       continue;
      }
      break;
     }
     $3 = 16;
     $15 = 192;
     $12 = HEAPF32[$14 + 9796 >> 2];
     $13 = HEAPF32[$14 + 9876 >> 2];
     while (1) {
      $8 = $3;
      $3 = $8 << 2;
      $22 = $3 + ($14 + 9808 | 0) | 0;
      $16 = HEAP32[$3 + 49904 >> 2];
      $19 = Math_fround($15 - $16 | 0);
      $19 = Math_fround(Math_fround($19 + $19) * Math_fround(.25));
      $13 = Math_fround($13 + $19);
      $18 = HEAPF32[$22 >> 2];
      $13 = $13 < $18 ? $13 : $18;
      HEAPF32[$22 >> 2] = $13;
      $12 = Math_fround($12 - $19);
      $3 = ($14 + 9728 | 0) + $3 | 0;
      $19 = HEAPF32[$3 >> 2];
      $12 = $12 > $19 ? $12 : $19;
      HEAPF32[$3 >> 2] = $12;
      $3 = $8 - 1 | 0;
      $15 = $16;
      if ($8) {
       continue;
      }
      break;
     }
     $8 = 0;
     while (1) {
      $44 = Math_fround(0);
      $15 = ($8 + $36 | 0) + 7648 | 0;
      $3 = $8 << 2;
      $66 = Math_floor(+Math_fround(Math_fround(Math_fround(Math_max(Math_fround(HEAPF32[$3 + ($14 + 9728 | 0) >> 2] - $23), Math_fround(0))) + Math_fround(Math_max(Math_fround($23 - Math_fround(HEAPF32[($14 + 9808 | 0) + $3 >> 2] + Math_fround(2.5))), Math_fround(0)))) * Math_fround(64)) + .5);
      label$32 : {
       if (Math_abs($66) < 2147483648) {
        $3 = ~~$66;
        break label$32;
       }
       $3 = -2147483648;
      }
      HEAP8[$15 | 0] = ($3 | 0) < 255 ? $3 : 255;
      $15 = 0;
      $8 = $8 + 1 | 0;
      if (($8 | 0) != 19) {
       $23 = HEAPF32[($14 + 9888 | 0) + ($8 << 2) >> 2];
       continue;
      }
      break;
     }
     while (1) {
      $8 = Math_imul($15, 72) + $0 | 0;
      $19 = HEAPF32[$8 + 6500 >> 2];
      $18 = HEAPF32[$8 + 6496 >> 2];
      $17 = HEAPF32[$8 + 6448 >> 2];
      $20 = HEAPF32[$8 + 6444 >> 2];
      $24 = HEAPF32[$8 + 6440 >> 2];
      $23 = HEAPF32[$8 + 6436 >> 2];
      $26 = HEAPF32[$8 + 6432 >> 2];
      $25 = HEAPF32[$8 + 6492 >> 2];
      $33 = HEAPF32[$8 + 6488 >> 2];
      $39 = HEAPF32[$8 + 6484 >> 2];
      $40 = HEAPF32[$8 + 6480 >> 2];
      $41 = HEAPF32[$8 + 6476 >> 2];
      $42 = HEAPF32[$8 + 6472 >> 2];
      $43 = HEAPF32[$8 + 6468 >> 2];
      $54 = HEAPF32[$8 + 6464 >> 2];
      $47 = HEAPF32[$8 + 6460 >> 2];
      $59 = HEAPF32[$8 + 6456 >> 2];
      $52 = HEAPF32[$8 + 6452 >> 2];
      $12 = Math_fround(999999986991104);
      $3 = 0;
      while (1) {
       $8 = Math_imul($3, 72) + $0 | 0;
       $13 = Math_fround($26 - HEAPF32[$8 + 6432 >> 2]);
       $21 = Math_fround(Math_fround($13 * $13) + Math_fround(0));
       $13 = Math_fround($23 - HEAPF32[$8 + 6436 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($24 - HEAPF32[$8 + 6440 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($20 - HEAPF32[$8 + 6444 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($17 - HEAPF32[$8 + 6448 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($52 - HEAPF32[$8 + 6452 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($59 - HEAPF32[$8 + 6456 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($47 - HEAPF32[$8 + 6460 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($54 - HEAPF32[$8 + 6464 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($43 - HEAPF32[$8 + 6468 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($42 - HEAPF32[$8 + 6472 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($41 - HEAPF32[$8 + 6476 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($40 - HEAPF32[$8 + 6480 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($39 - HEAPF32[$8 + 6484 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($33 - HEAPF32[$8 + 6488 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($25 - HEAPF32[$8 + 6492 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($18 - HEAPF32[$8 + 6496 >> 2]);
       $21 = Math_fround($21 + Math_fround($13 * $13));
       $13 = Math_fround($19 - HEAPF32[$8 + 6500 >> 2]);
       $13 = Math_fround($21 + Math_fround($13 * $13));
       $12 = ($3 | 0) == ($15 | 0) ? $12 : $12 < $13 ? $12 : $13;
       $3 = $3 + 1 | 0;
       if (($3 | 0) != 8) {
        continue;
       }
       break;
      }
      $44 = Math_fround($44 + $12);
      $15 = $15 + 1 | 0;
      if (($15 | 0) != 8) {
       continue;
      }
      break;
     }
     $17 = Math_fround(0);
     $26 = ($48 | 0) < 2 ? Math_fround(0) : Math_fround(Math_fround(1) - $57);
     $25 = Math_fround($44 * Math_fround(.125));
     $48 = HEAP32[$0 + 5852 >> 2];
     $16 = 0;
     $28 = 4;
     $27 = 0;
     $20 = Math_fround(0);
     $18 = Math_fround(0);
     $19 = Math_fround(0);
     while (1) {
      $12 = Math_fround(0);
      $8 = $28;
      $32 = $16 + 1 | 0;
      $22 = HEAP32[($32 << 2) + 49904 >> 2];
      if (($8 | 0) < ($22 | 0)) {
       while (1) {
        $3 = ($14 + 1920 | 0) + ($8 << 3) | 0;
        $13 = HEAPF32[$3 >> 2];
        $23 = Math_fround($13 * $13);
        $15 = ((0 - $8 << 3) + $14 | 0) + 5760 | 0;
        $13 = HEAPF32[$15 >> 2];
        $23 = Math_fround($23 + Math_fround($13 * $13));
        $13 = HEAPF32[$3 + 4 >> 2];
        $23 = Math_fround($23 + Math_fround($13 * $13));
        $13 = HEAPF32[$15 + 4 >> 2];
        $12 = Math_fround($12 + Math_fround($23 + Math_fround($13 * $13)));
        $8 = $8 + 1 | 0;
        if (($22 | 0) != ($8 | 0)) {
         continue;
        }
        break;
       }
      }
      $3 = $16 << 2;
      $8 = ($3 + $0 | 0) + 7152 | 0;
      $13 = Math_fround($26 * HEAPF32[$8 >> 2]);
      $13 = $12 < $13 ? $13 : $12;
      HEAPF32[$8 >> 2] = $13;
      $8 = $16 >>> 0 < 11;
      $24 = Math_fround($18 + $12);
      $23 = Math_fround($19 + $12);
      $20 = $12 < $20 ? $20 : $12;
      if (!($20 < Math_fround($12 * Math_fround(1e9)) ^ 1)) {
       $33 = $12 > $13 ? $12 : $13;
       $13 = Math_fround($22 - $28 | 0);
       $27 = Math_fround($56 * $13) < $12 ? $32 : $33 > Math_fround($73 * $13) ? $32 : $27;
      }
      $18 = $8 ? $24 : $18;
      $19 = $8 ? $19 : $23;
      HEAP32[($14 + 10960 | 0) + $3 >> 2] = Math_fround($17 * (($16 | 0) < ($48 | 0) ? Math_fround(.009999999776482582) : Math_fround(.05000000074505806))) > $12;
      $13 = Math_fround($17 * Math_fround(.05000000074505806));
      $17 = $12 < $13 ? $13 : $12;
      $28 = $22;
      $16 = $32;
      if (($16 | 0) != 18) {
       continue;
      }
      break;
     }
     if (HEAP32[$0 + 8 >> 2] == 48e3) {
      $13 = Math_fround($26 * HEAPF32[$0 + 7224 >> 2]);
      $12 = Math_fround($45 * Math_fround(.00027777778450399637));
      $13 = $12 < $13 ? $13 : $12;
      HEAPF32[$0 + 7224 >> 2] = $13;
      $20 = $12 > $13 ? $12 : $13;
      $8 = ($48 | 0) == 20;
      $13 = $8 ? Math_fround(10) : Math_fround(30);
      $27 = (Math_fround(Math_fround($56 * $13) * Math_fround(160)) < $12 ^ 1 ? !($20 > Math_fround(Math_fround($56 * Math_fround($13 * Math_fround(3))) * Math_fround(160))) : 0) ? $27 : 20;
      HEAP32[$14 + 11032 >> 2] = Math_fround(($8 ? Math_fround(.009999999776482582) : Math_fround(.05000000074505806)) * $17) > $12;
      $19 = Math_fround($12 + $19);
     }
     $12 = Math_fround($25 / Math_fround(18));
     HEAPF32[$36 + 7644 >> 2] = $19 > $18 ? Math_fround($18 / $19) : Math_fround(1);
     label$44 : {
      if (($27 | 0) == 20) {
       $27 = HEAP32[$14 + 11032 >> 2] ? 18 : 20;
       break label$44;
      }
      $8 = $27 - 1 | 0;
      if ($8 >>> 0 > 17) {
       break label$44;
      }
      $27 = HEAP32[($14 + 10960 | 0) + ($8 << 2) >> 2] ? $8 : $27;
     }
     $59 = Math_fround(Math_sqrt($12));
     $13 = Math_fround(HEAPF32[$0 + 7424 >> 2] + Math_fround(-.003000000026077032));
     $12 = Math_fround(Math_fround(log10(+$38)) * Math_fround(20));
     $13 = $12 < $13 ? $13 : $12;
     HEAPF32[$0 + 7424 >> 2] = $13;
     $19 = Math_fround(Math_fround(Math_fround(1) - $46) * HEAPF32[$0 + 7428 >> 2]);
     HEAPF32[$0 + 7428 >> 2] = Math_fround($13 + Math_fround(-30)) > $12 ? Math_fround($46 + $19) : $19;
     $16 = HEAP32[$0 + 7436 >> 2];
     $3 = 0;
     $12 = HEAPF32[$14 + 11204 >> 2];
     $13 = HEAPF32[$14 + 11200 >> 2];
     $19 = HEAPF32[$14 + 11260 >> 2];
     $18 = HEAPF32[$14 + 11256 >> 2];
     $17 = HEAPF32[$14 + 11252 >> 2];
     $20 = HEAPF32[$14 + 11248 >> 2];
     $24 = HEAPF32[$14 + 11244 >> 2];
     $23 = HEAPF32[$14 + 11240 >> 2];
     $26 = HEAPF32[$14 + 11236 >> 2];
     $25 = HEAPF32[$14 + 11232 >> 2];
     $33 = HEAPF32[$14 + 11228 >> 2];
     $39 = HEAPF32[$14 + 11224 >> 2];
     $40 = HEAPF32[$14 + 11220 >> 2];
     $41 = HEAPF32[$14 + 11216 >> 2];
     $42 = HEAPF32[$14 + 11212 >> 2];
     $43 = HEAPF32[$14 + 11208 >> 2];
     while (1) {
      $8 = $3 << 6;
      HEAPF32[($14 + 11168 | 0) + ($3 << 2) >> 2] = Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround($13 * HEAPF32[$8 + 49984 >> 2]) + Math_fround(0)) + Math_fround($12 * HEAPF32[($8 | 4) + 49984 >> 2])) + Math_fround($43 * HEAPF32[($8 | 8) + 49984 >> 2])) + Math_fround($42 * HEAPF32[($8 | 12) + 49984 >> 2])) + Math_fround($41 * HEAPF32[($8 | 16) + 49984 >> 2])) + Math_fround($40 * HEAPF32[($8 | 20) + 49984 >> 2])) + Math_fround($39 * HEAPF32[($8 | 24) + 49984 >> 2])) + Math_fround($33 * HEAPF32[($8 | 28) + 49984 >> 2])) + Math_fround($25 * HEAPF32[($8 | 32) + 49984 >> 2])) + Math_fround($26 * HEAPF32[($8 | 36) + 49984 >> 2])) + Math_fround($23 * HEAPF32[($8 | 40) + 49984 >> 2])) + Math_fround($24 * HEAPF32[($8 | 44) + 49984 >> 2])) + Math_fround($20 * HEAPF32[($8 | 48) + 49984 >> 2])) + Math_fround($17 * HEAPF32[($8 | 52) + 49984 >> 2])) + Math_fround($18 * HEAPF32[($8 | 56) + 49984 >> 2])) + Math_fround($19 * HEAPF32[($8 | 60) + 49984 >> 2]);
      $3 = $3 + 1 | 0;
      if (($3 | 0) != 8) {
       continue;
      }
      break;
     }
     $22 = 0;
     while (1) {
      $15 = $22 << 4;
      $12 = Math_fround(0);
      $8 = 0;
      while (1) {
       $3 = ($8 << 2) + $0 | 0;
       $12 = Math_fround($12 + Math_fround(Math_fround(HEAPF32[($8 + $15 << 2) + 49984 >> 2] * Math_fround(.5)) * Math_fround(HEAPF32[$3 + 7080 >> 2] + HEAPF32[$3 + 7008 >> 2])));
       $8 = $8 + 1 | 0;
       if (($8 | 0) != 16) {
        continue;
       }
       break;
      }
      HEAPF32[($14 + 9968 | 0) + ($22 << 2) >> 2] = $12;
      $22 = $22 + 1 | 0;
      if (($22 | 0) != 8) {
       continue;
      }
      break;
     }
     $20 = Math_fround($30 / Math_fround(18));
     HEAPF32[$58 >> 2] = $20 + Math_fround(Math_fround(Math_fround(1) - $20) * (($16 | 0) < 10 ? Math_fround(.5) : Math_fround($37 / Math_fround(18))));
     $12 = Math_fround($35 / Math_fround(9));
     $13 = Math_fround(HEAPF32[$0 + 5848 >> 2] * Math_fround(.800000011920929));
     $12 = $12 > $13 ? $12 : $13;
     HEAPF32[$0 + 5848 >> 2] = $12;
     $3 = $36 + 7612 | 0;
     HEAPF32[$3 >> 2] = $31 * Math_fround(.015625);
     $15 = ($16 | 0) < 9999 ? $16 + 1 | 0 : 1e4;
     HEAP32[$0 + 7436 >> 2] = $15;
     HEAP32[$0 + 7432 >> 2] = (HEAP32[$0 + 7432 >> 2] + 1 | 0) % 8;
     $22 = $36 + 7608 | 0;
     HEAPF32[$22 >> 2] = $12;
     $24 = HEAPF32[$0 + 7260 >> 2];
     $23 = HEAPF32[$0 + 7228 >> 2];
     $26 = HEAPF32[$0 + 7292 >> 2];
     $47 = Math_fround($23 + $26);
     $13 = HEAPF32[$14 + 11168 >> 2];
     $52 = HEAPF32[$0 + 7324 >> 2];
     $35 = Math_fround($13 + $52);
     $44 = HEAPF32[$0 + 7356 >> 2];
     $21 = Math_fround(Math_fround(Math_fround($24 * Math_fround(.6969299912452698)) + Math_fround(Math_fround($47 * Math_fround(.49195000529289246)) - Math_fround($35 * Math_fround(.12298999726772308)))) - Math_fround($44 * Math_fround(1.4349000453948975)));
     HEAPF32[$14 + 11056 >> 2] = $21;
     $25 = HEAPF32[$0 + 7264 >> 2];
     $33 = HEAPF32[$0 + 7232 >> 2];
     $39 = HEAPF32[$0 + 7296 >> 2];
     $30 = Math_fround($33 + $39);
     $19 = HEAPF32[$14 + 11172 >> 2];
     $31 = HEAPF32[$0 + 7328 >> 2];
     $37 = Math_fround($19 + $31);
     $38 = HEAPF32[$0 + 7360 >> 2];
     $60 = Math_fround(Math_fround(Math_fround($25 * Math_fround(.6969299912452698)) + Math_fround(Math_fround($30 * Math_fround(.49195000529289246)) - Math_fround($37 * Math_fround(.12298999726772308)))) - Math_fround($38 * Math_fround(1.4349000453948975)));
     HEAPF32[$14 + 11060 >> 2] = $60;
     $40 = HEAPF32[$0 + 7268 >> 2];
     $41 = HEAPF32[$0 + 7236 >> 2];
     $42 = HEAPF32[$0 + 7300 >> 2];
     $45 = Math_fround($41 + $42);
     $18 = HEAPF32[$14 + 11176 >> 2];
     $46 = HEAPF32[$0 + 7332 >> 2];
     $57 = Math_fround($18 + $46);
     $67 = HEAPF32[$0 + 7364 >> 2];
     $61 = Math_fround(Math_fround(Math_fround($40 * Math_fround(.6969299912452698)) + Math_fround(Math_fround($45 * Math_fround(.49195000529289246)) - Math_fround($57 * Math_fround(.12298999726772308)))) - Math_fround($67 * Math_fround(1.4349000453948975)));
     HEAPF32[$14 + 11064 >> 2] = $61;
     $68 = HEAPF32[$0 + 7272 >> 2];
     $43 = HEAPF32[$0 + 7240 >> 2];
     $54 = HEAPF32[$0 + 7304 >> 2];
     $17 = HEAPF32[$14 + 11180 >> 2];
     $69 = HEAPF32[$0 + 7336 >> 2];
     $70 = HEAPF32[$0 + 7368 >> 2];
     $62 = Math_fround(Math_fround(Math_fround($68 * Math_fround(.6969299912452698)) + Math_fround(Math_fround(Math_fround($43 + $54) * Math_fround(.49195000529289246)) - Math_fround(Math_fround($17 + $69) * Math_fround(.12298999726772308)))) - Math_fround($70 * Math_fround(1.4349000453948975)));
     HEAPF32[$14 + 11068 >> 2] = $62;
     $12 = Math_fround(Math_fround(1) - $29);
     HEAPF32[$0 + 7368 >> 2] = Math_fround($29 * $17) + Math_fround($70 * $12);
     HEAPF32[$0 + 7364 >> 2] = Math_fround($29 * $18) + Math_fround($12 * $67);
     HEAPF32[$0 + 7360 >> 2] = Math_fround($29 * $19) + Math_fround($12 * $38);
     HEAPF32[$0 + 7356 >> 2] = Math_fround($29 * $13) + Math_fround($12 * $44);
     HEAPF32[$14 + 11096 >> 2] = Math_fround(Math_fround($57 * Math_fround(.5345199704170227)) - Math_fround($45 * Math_fround(.26725998520851135))) - Math_fround($40 * Math_fround(.5345199704170227));
     HEAPF32[$14 + 11092 >> 2] = Math_fround(Math_fround($37 * Math_fround(.5345199704170227)) - Math_fround($30 * Math_fround(.26725998520851135))) - Math_fround($25 * Math_fround(.5345199704170227));
     $35 = Math_fround(Math_fround(Math_fround($35 * Math_fround(.5345199704170227)) - Math_fround($47 * Math_fround(.26725998520851135))) - Math_fround($24 * Math_fround(.5345199704170227)));
     HEAPF32[$14 + 11088 >> 2] = $35;
     $44 = Math_fround(Math_fround(Math_fround($17 - $69) * Math_fround(.6324599981307983)) + Math_fround(Math_fround($43 - $54) * Math_fround(.31622999906539917)));
     HEAPF32[$14 + 11084 >> 2] = $44;
     $30 = Math_fround(Math_fround(Math_fround($18 - $46) * Math_fround(.6324599981307983)) + Math_fround(Math_fround($41 - $42) * Math_fround(.31622999906539917)));
     HEAPF32[$14 + 11080 >> 2] = $30;
     $31 = Math_fround(Math_fround(Math_fround($19 - $31) * Math_fround(.6324599981307983)) + Math_fround(Math_fround($33 - $39) * Math_fround(.31622999906539917)));
     HEAPF32[$14 + 11076 >> 2] = $31;
     $37 = Math_fround(Math_fround(Math_fround($13 - $52) * Math_fround(.6324599981307983)) + Math_fround(Math_fround($23 - $26) * Math_fround(.31622999906539917)));
     HEAPF32[$14 + 11072 >> 2] = $37;
     $8 = ($16 | 0) < 3 ? 20 : $27;
     $52 = Math_fround($49 / Math_fround(18));
     $47 = HEAPF32[$0 + 7388 >> 2];
     label$49 : {
      if (($15 | 0) <= 5) {
       $12 = HEAPF32[$0 + 7420 >> 2];
       $30 = HEAPF32[$0 + 7412 >> 2];
       $31 = HEAPF32[$0 + 7408 >> 2];
       $49 = HEAPF32[$0 + 7404 >> 2];
       $38 = HEAPF32[$0 + 7400 >> 2];
       $45 = HEAPF32[$0 + 7396 >> 2];
       $46 = HEAPF32[$0 + 7392 >> 2];
       break label$49;
      }
      $47 = Math_fround(Math_fround($21 * Math_fround($29 * $21)) + Math_fround($12 * $47));
      HEAPF32[$0 + 7388 >> 2] = $47;
      $46 = Math_fround(Math_fround($60 * Math_fround($29 * $60)) + Math_fround($12 * HEAPF32[$0 + 7392 >> 2]));
      HEAPF32[$0 + 7392 >> 2] = $46;
      $45 = Math_fround(Math_fround($61 * Math_fround($29 * $61)) + Math_fround($12 * HEAPF32[$0 + 7396 >> 2]));
      HEAPF32[$0 + 7396 >> 2] = $45;
      $38 = Math_fround(Math_fround($62 * Math_fround($29 * $62)) + Math_fround($12 * HEAPF32[$0 + 7400 >> 2]));
      HEAPF32[$0 + 7400 >> 2] = $38;
      $49 = Math_fround(Math_fround($37 * Math_fround($29 * $37)) + Math_fround($12 * HEAPF32[$0 + 7404 >> 2]));
      HEAPF32[$0 + 7404 >> 2] = $49;
      $31 = Math_fround(Math_fround($31 * Math_fround($29 * $31)) + Math_fround($12 * HEAPF32[$0 + 7408 >> 2]));
      HEAPF32[$0 + 7408 >> 2] = $31;
      $30 = Math_fround(Math_fround($30 * Math_fround($29 * $30)) + Math_fround($12 * HEAPF32[$0 + 7412 >> 2]));
      HEAPF32[$0 + 7412 >> 2] = $30;
      HEAPF32[$0 + 7416 >> 2] = Math_fround($44 * Math_fround($29 * $44)) + Math_fround($12 * HEAPF32[$0 + 7416 >> 2]);
      $12 = Math_fround(Math_fround($35 * Math_fround($29 * $35)) + Math_fround($12 * HEAPF32[$0 + 7420 >> 2]));
      HEAPF32[$0 + 7420 >> 2] = $12;
     }
     HEAPF32[$14 + 11056 >> 2] = $13 - HEAPF32[$14 + 9968 >> 2];
     HEAPF32[$14 + 11060 >> 2] = $19 - HEAPF32[$14 + 9972 >> 2];
     HEAPF32[$14 + 11064 >> 2] = $18 - HEAPF32[$14 + 9976 >> 2];
     HEAPF32[$14 + 11068 >> 2] = $17 - HEAPF32[$14 + 9980 >> 2];
     HEAPF32[$0 + 7260 >> 2] = $23;
     HEAPF32[$0 + 7328 >> 2] = $39;
     HEAPF32[$0 + 7228 >> 2] = $13;
     HEAPF32[$0 + 7296 >> 2] = $25;
     HEAPF32[$0 + 7264 >> 2] = $33;
     HEAPF32[$0 + 7332 >> 2] = $42;
     HEAPF32[$0 + 7232 >> 2] = $19;
     HEAPF32[$0 + 7300 >> 2] = $40;
     HEAPF32[$0 + 7268 >> 2] = $41;
     HEAPF32[$0 + 7336 >> 2] = $54;
     HEAPF32[$0 + 7236 >> 2] = $18;
     HEAPF32[$0 + 7304 >> 2] = $68;
     HEAPF32[$0 + 7272 >> 2] = $43;
     HEAPF32[$0 + 7240 >> 2] = $17;
     HEAPF32[$0 + 7324 >> 2] = $26;
     HEAPF32[$0 + 7292 >> 2] = $24;
     $15 = HEAP32[$0 + 7308 >> 2];
     HEAP32[$0 + 7308 >> 2] = HEAP32[$0 + 7276 >> 2];
     HEAP32[$0 + 7340 >> 2] = $15;
     HEAP32[$0 + 7276 >> 2] = HEAP32[$0 + 7244 >> 2];
     HEAP32[$0 + 7244 >> 2] = HEAP32[$14 + 11184 >> 2];
     HEAP32[$0 + 7344 >> 2] = HEAP32[$0 + 7312 >> 2];
     HEAP32[$0 + 7312 >> 2] = HEAP32[$0 + 7280 >> 2];
     HEAP32[$0 + 7280 >> 2] = HEAP32[$0 + 7248 >> 2];
     HEAP32[$0 + 7248 >> 2] = HEAP32[$14 + 11188 >> 2];
     HEAP32[$0 + 7348 >> 2] = HEAP32[$0 + 7316 >> 2];
     HEAP32[$0 + 7316 >> 2] = HEAP32[$0 + 7284 >> 2];
     HEAP32[$0 + 7284 >> 2] = HEAP32[$0 + 7252 >> 2];
     HEAP32[$0 + 7252 >> 2] = HEAP32[$14 + 11192 >> 2];
     HEAP32[$0 + 7352 >> 2] = HEAP32[$0 + 7320 >> 2];
     HEAP32[$0 + 7320 >> 2] = HEAP32[$0 + 7288 >> 2];
     HEAP32[$0 + 7288 >> 2] = HEAP32[$0 + 7256 >> 2];
     HEAP32[$0 + 7256 >> 2] = HEAP32[$14 + 11196 >> 2];
     HEAPF32[$14 + 11132 >> 2] = Math_fround(Math_sqrt($12)) + Math_fround(-1.9187949895858765);
     HEAPF32[$14 + 11124 >> 2] = Math_fround(Math_sqrt($30)) + Math_fround(-1.260756015777588);
     HEAPF32[$14 + 11120 >> 2] = Math_fround(Math_sqrt($31)) + Math_fround(-2.1633129119873047);
     HEAPF32[$14 + 11116 >> 2] = Math_fround(Math_sqrt($49)) + Math_fround(-3.7732150554656982);
     HEAPF32[$14 + 11112 >> 2] = Math_fround(Math_sqrt($38)) + Math_fround(-1.599784016609192);
     HEAPF32[$14 + 11108 >> 2] = Math_fround(Math_sqrt($45)) + Math_fround(-1.7706340551376343);
     HEAPF32[$14 + 11104 >> 2] = Math_fround(Math_sqrt($46)) + Math_fround(-3.475287914276123);
     HEAPF32[$14 + 11100 >> 2] = Math_fround(Math_sqrt($47)) + Math_fround(-5.6849470138549805);
     HEAPF32[$14 + 11128 >> 2] = $59 + Math_fround(-.7799999713897705);
     HEAPF32[$14 + 11136 >> 2] = HEAPF32[$22 >> 2] + Math_fround(-.15472300350666046);
     $12 = HEAPF32[$58 >> 2];
     HEAPF32[$14 + 11144 >> 2] = $52 + Math_fround(-.7437170147895813);
     HEAPF32[$14 + 11140 >> 2] = $12 + Math_fround(-.7246429920196533);
     HEAPF32[$14 + 11148 >> 2] = HEAPF32[$3 >> 2] + Math_fround(.06921599805355072);
     HEAPF32[$14 + 11152 >> 2] = HEAPF32[$0 + 7428 >> 2] + Math_fround(-.06792999804019928);
     compute_dense(43872, $14 + 9600 | 0, $14 + 11056 | 0);
     compute_gru(48016, $64, $14 + 9600 | 0);
     compute_dense(48096, $14 + 11048 | 0, $64);
     HEAP32[$36 + 7640 >> 2] = HEAP32[$14 + 11052 >> 2];
     $3 = HEAP32[$14 + 11048 >> 2];
     HEAP32[$36 + 7636 >> 2] = $8;
     HEAP32[$36 + 7624 >> 2] = $3;
     HEAP32[$0 + 5852 >> 2] = $8;
     HEAPF32[$36 + 7616 >> 2] = $20;
     HEAP32[$34 >> 2] = 1;
    }
    $50 = $50 + $55 | 0;
    $51 = $51 - $55 | 0;
    if (($51 | 0) > 0) {
     continue;
    }
    break;
   }
  }
  HEAP32[$0 + 7440 >> 2] = $63 - $4;
 }
 tonality_get_info($0, $11, $4);
 __stack_pointer = $14 + 11360 | 0;
}
function dlmalloc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $12 = __stack_pointer - 16 | 0;
 __stack_pointer = $12;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     label$5 : {
      label$6 : {
       label$7 : {
        label$8 : {
         label$9 : {
          label$10 : {
           label$11 : {
            label$12 : {
             if ($0 >>> 0 <= 244) {
              $6 = HEAP32[13232];
              $4 = $0 >>> 0 < 11 ? 16 : $0 + 11 & -8;
              $2 = $4 >>> 3 | 0;
              $0 = $6 >>> $2 | 0;
              if ($0 & 3) {
               $4 = (($0 ^ -1) & 1) + $2 | 0;
               $3 = $4 << 3;
               $2 = HEAP32[$3 + 52976 >> 2];
               $0 = $2 + 8 | 0;
               $1 = HEAP32[$2 + 8 >> 2];
               $3 = $3 + 52968 | 0;
               label$15 : {
                if (($1 | 0) == ($3 | 0)) {
                 HEAP32[13232] = __wasm_rotl_i32(-2, $4) & $6;
                 break label$15;
                }
                HEAP32[$1 + 12 >> 2] = $3;
                HEAP32[$3 + 8 >> 2] = $1;
               }
               $1 = $4 << 3;
               HEAP32[$2 + 4 >> 2] = $1 | 3;
               $2 = $2 + $1 | 0;
               HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 1;
               break label$1;
              }
              $9 = HEAP32[13234];
              if ($9 >>> 0 >= $4 >>> 0) {
               break label$12;
              }
              if ($0) {
               $1 = $0 << $2;
               $0 = 2 << $2;
               $0 = $1 & ($0 | 0 - $0);
               $0 = ($0 & 0 - $0) - 1 | 0;
               $1 = $0;
               $0 = $0 >>> 12 & 16;
               $2 = $1 >>> $0 | 0;
               $1 = $2 >>> 5 & 8;
               $3 = $0 | $1;
               $0 = $2 >>> $1 | 0;
               $2 = $0 >>> 2 & 4;
               $1 = $3 | $2;
               $0 = $0 >>> $2 | 0;
               $2 = $0 >>> 1 & 2;
               $1 = $1 | $2;
               $0 = $0 >>> $2 | 0;
               $2 = $0 >>> 1 & 1;
               $1 = ($1 | $2) + ($0 >>> $2 | 0) | 0;
               $3 = $1 << 3;
               $2 = HEAP32[$3 + 52976 >> 2];
               $0 = HEAP32[$2 + 8 >> 2];
               $3 = $3 + 52968 | 0;
               label$18 : {
                if (($0 | 0) == ($3 | 0)) {
                 $6 = __wasm_rotl_i32(-2, $1) & $6;
                 HEAP32[13232] = $6;
                 break label$18;
                }
                HEAP32[$0 + 12 >> 2] = $3;
                HEAP32[$3 + 8 >> 2] = $0;
               }
               $0 = $2 + 8 | 0;
               HEAP32[$2 + 4 >> 2] = $4 | 3;
               $3 = $2 + $4 | 0;
               $5 = $1 << 3;
               $1 = $5 - $4 | 0;
               HEAP32[$3 + 4 >> 2] = $1 | 1;
               HEAP32[$2 + $5 >> 2] = $1;
               if ($9) {
                $5 = $9 >>> 3 | 0;
                $4 = ($5 << 3) + 52968 | 0;
                $2 = HEAP32[13237];
                $5 = 1 << $5;
                label$21 : {
                 if (!($6 & $5)) {
                  HEAP32[13232] = $5 | $6;
                  $5 = $4;
                  break label$21;
                 }
                 $5 = HEAP32[$4 + 8 >> 2];
                }
                HEAP32[$4 + 8 >> 2] = $2;
                HEAP32[$5 + 12 >> 2] = $2;
                HEAP32[$2 + 12 >> 2] = $4;
                HEAP32[$2 + 8 >> 2] = $5;
               }
               HEAP32[13237] = $3;
               HEAP32[13234] = $1;
               break label$1;
              }
              $8 = HEAP32[13233];
              if (!$8) {
               break label$12;
              }
              $0 = (0 - $8 & $8) - 1 | 0;
              $1 = $0;
              $0 = $0 >>> 12 & 16;
              $2 = $1 >>> $0 | 0;
              $1 = $2 >>> 5 & 8;
              $3 = $0 | $1;
              $0 = $2 >>> $1 | 0;
              $2 = $0 >>> 2 & 4;
              $1 = $3 | $2;
              $0 = $0 >>> $2 | 0;
              $2 = $0 >>> 1 & 2;
              $1 = $1 | $2;
              $0 = $0 >>> $2 | 0;
              $2 = $0 >>> 1 & 1;
              $3 = HEAP32[(($1 | $2) + ($0 >>> $2 | 0) << 2) + 53232 >> 2];
              $2 = (HEAP32[$3 + 4 >> 2] & -8) - $4 | 0;
              $1 = $3;
              while (1) {
               label$24 : {
                $0 = HEAP32[$1 + 16 >> 2];
                if (!$0) {
                 $0 = HEAP32[$1 + 20 >> 2];
                 if (!$0) {
                  break label$24;
                 }
                }
                $1 = (HEAP32[$0 + 4 >> 2] & -8) - $4 | 0;
                $5 = $1;
                $1 = $2 >>> 0 > $1 >>> 0;
                $2 = $1 ? $5 : $2;
                $3 = $1 ? $0 : $3;
                $1 = $0;
                continue;
               }
               break;
              }
              $10 = $3 + $4 | 0;
              if ($10 >>> 0 <= $3 >>> 0) {
               break label$11;
              }
              $11 = HEAP32[$3 + 24 >> 2];
              $5 = HEAP32[$3 + 12 >> 2];
              if (($5 | 0) != ($3 | 0)) {
               $0 = HEAP32[$3 + 8 >> 2];
               HEAP32[$0 + 12 >> 2] = $5;
               HEAP32[$5 + 8 >> 2] = $0;
               break label$2;
              }
              $1 = $3 + 20 | 0;
              $0 = HEAP32[$1 >> 2];
              if (!$0) {
               $0 = HEAP32[$3 + 16 >> 2];
               if (!$0) {
                break label$10;
               }
               $1 = $3 + 16 | 0;
              }
              while (1) {
               $7 = $1;
               $5 = $0;
               $1 = $0 + 20 | 0;
               $0 = HEAP32[$1 >> 2];
               if ($0) {
                continue;
               }
               $1 = $5 + 16 | 0;
               $0 = HEAP32[$5 + 16 >> 2];
               if ($0) {
                continue;
               }
               break;
              }
              HEAP32[$7 >> 2] = 0;
              break label$2;
             }
             $4 = -1;
             if ($0 >>> 0 > 4294967231) {
              break label$12;
             }
             $0 = $0 + 11 | 0;
             $4 = $0 & -8;
             $9 = HEAP32[13233];
             if (!$9) {
              break label$12;
             }
             $7 = 31;
             if ($4 >>> 0 <= 16777215) {
              $0 = $0 >>> 8 | 0;
              $1 = $0;
              $0 = $0 + 1048320 >>> 16 & 8;
              $2 = $1 << $0;
              $1 = $2;
              $2 = $2 + 520192 >>> 16 & 4;
              $1 = $1 << $2;
              $3 = $1;
              $1 = $1 + 245760 >>> 16 & 2;
              $0 = ($3 << $1 >>> 15 | 0) - ($0 | $2 | $1) | 0;
              $7 = ($0 << 1 | $4 >>> $0 + 21 & 1) + 28 | 0;
             }
             $2 = 0 - $4 | 0;
             $1 = HEAP32[($7 << 2) + 53232 >> 2];
             label$31 : {
              label$32 : {
               label$33 : {
                if (!$1) {
                 $0 = 0;
                 break label$33;
                }
                $0 = 0;
                $3 = $4 << (($7 | 0) == 31 ? 0 : 25 - ($7 >>> 1 | 0) | 0);
                while (1) {
                 label$36 : {
                  $6 = (HEAP32[$1 + 4 >> 2] & -8) - $4 | 0;
                  if ($6 >>> 0 >= $2 >>> 0) {
                   break label$36;
                  }
                  $5 = $1;
                  $2 = $6;
                  if ($2) {
                   break label$36;
                  }
                  $2 = 0;
                  $0 = $1;
                  break label$32;
                 }
                 $6 = HEAP32[$1 + 20 >> 2];
                 $1 = HEAP32[(($3 >>> 29 & 4) + $1 | 0) + 16 >> 2];
                 $0 = $6 ? ($6 | 0) == ($1 | 0) ? $0 : $6 : $0;
                 $3 = $3 << 1;
                 if ($1) {
                  continue;
                 }
                 break;
                }
               }
               if (!($0 | $5)) {
                $0 = 2 << $7;
                $0 = ($0 | 0 - $0) & $9;
                if (!$0) {
                 break label$12;
                }
                $0 = (0 - $0 & $0) - 1 | 0;
                $1 = $0;
                $0 = $0 >>> 12 & 16;
                $1 = $1 >>> $0 | 0;
                $3 = $1 >>> 5 & 8;
                $6 = $0 | $3;
                $0 = $1 >>> $3 | 0;
                $1 = $0 >>> 2 & 4;
                $3 = $6 | $1;
                $0 = $0 >>> $1 | 0;
                $1 = $0 >>> 1 & 2;
                $3 = $3 | $1;
                $0 = $0 >>> $1 | 0;
                $1 = $0 >>> 1 & 1;
                $0 = HEAP32[(($3 | $1) + ($0 >>> $1 | 0) << 2) + 53232 >> 2];
               }
               if (!$0) {
                break label$31;
               }
              }
              while (1) {
               $6 = (HEAP32[$0 + 4 >> 2] & -8) - $4 | 0;
               $3 = $6 >>> 0 < $2 >>> 0;
               $2 = $3 ? $6 : $2;
               $5 = $3 ? $0 : $5;
               $1 = HEAP32[$0 + 16 >> 2];
               if (!$1) {
                $1 = HEAP32[$0 + 20 >> 2];
               }
               $0 = $1;
               if ($0) {
                continue;
               }
               break;
              }
             }
             if (!$5 | HEAP32[13234] - $4 >>> 0 <= $2 >>> 0) {
              break label$12;
             }
             $7 = $4 + $5 | 0;
             if ($7 >>> 0 <= $5 >>> 0) {
              break label$11;
             }
             $8 = HEAP32[$5 + 24 >> 2];
             $3 = HEAP32[$5 + 12 >> 2];
             if (($5 | 0) != ($3 | 0)) {
              $0 = HEAP32[$5 + 8 >> 2];
              HEAP32[$0 + 12 >> 2] = $3;
              HEAP32[$3 + 8 >> 2] = $0;
              break label$3;
             }
             $1 = $5 + 20 | 0;
             $0 = HEAP32[$1 >> 2];
             if (!$0) {
              $0 = HEAP32[$5 + 16 >> 2];
              if (!$0) {
               break label$9;
              }
              $1 = $5 + 16 | 0;
             }
             while (1) {
              $6 = $1;
              $3 = $0;
              $1 = $0 + 20 | 0;
              $0 = HEAP32[$1 >> 2];
              if ($0) {
               continue;
              }
              $1 = $3 + 16 | 0;
              $0 = HEAP32[$3 + 16 >> 2];
              if ($0) {
               continue;
              }
              break;
             }
             HEAP32[$6 >> 2] = 0;
             break label$3;
            }
            $0 = HEAP32[13234];
            if ($4 >>> 0 <= $0 >>> 0) {
             $2 = HEAP32[13237];
             $1 = $0 - $4 | 0;
             label$45 : {
              if ($1 >>> 0 >= 16) {
               HEAP32[13234] = $1;
               $3 = $2 + $4 | 0;
               HEAP32[13237] = $3;
               HEAP32[$3 + 4 >> 2] = $1 | 1;
               HEAP32[$0 + $2 >> 2] = $1;
               HEAP32[$2 + 4 >> 2] = $4 | 3;
               break label$45;
              }
              HEAP32[13237] = 0;
              HEAP32[13234] = 0;
              HEAP32[$2 + 4 >> 2] = $0 | 3;
              $0 = $0 + $2 | 0;
              HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | 1;
             }
             $0 = $2 + 8 | 0;
             break label$1;
            }
            $3 = HEAP32[13235];
            if ($4 >>> 0 < $3 >>> 0) {
             $2 = $3 - $4 | 0;
             HEAP32[13235] = $2;
             $0 = HEAP32[13238];
             $1 = $4 + $0 | 0;
             HEAP32[13238] = $1;
             HEAP32[$1 + 4 >> 2] = $2 | 1;
             HEAP32[$0 + 4 >> 2] = $4 | 3;
             $0 = $0 + 8 | 0;
             break label$1;
            }
            $0 = 0;
            $9 = $4 + 47 | 0;
            $1 = $9;
            if (HEAP32[13350]) {
             $2 = HEAP32[13352];
            } else {
             HEAP32[13353] = -1;
             HEAP32[13354] = -1;
             HEAP32[13351] = 4096;
             HEAP32[13352] = 4096;
             HEAP32[13350] = $12 + 12 & -16 ^ 1431655768;
             HEAP32[13355] = 0;
             HEAP32[13343] = 0;
             $2 = 4096;
            }
            $6 = $1 + $2 | 0;
            $7 = 0 - $2 | 0;
            $5 = $6 & $7;
            if ($5 >>> 0 <= $4 >>> 0) {
             break label$1;
            }
            $2 = HEAP32[13342];
            if ($2) {
             $1 = HEAP32[13340];
             $8 = $5 + $1 | 0;
             if ($2 >>> 0 < $8 >>> 0 | $1 >>> 0 >= $8 >>> 0) {
              break label$1;
             }
            }
            if (HEAPU8[53372] & 4) {
             break label$6;
            }
            label$51 : {
             label$52 : {
              $2 = HEAP32[13238];
              if ($2) {
               $0 = 53376;
               while (1) {
                $1 = HEAP32[$0 >> 2];
                if (HEAP32[$0 + 4 >> 2] + $1 >>> 0 > $2 >>> 0 ? $1 >>> 0 <= $2 >>> 0 : 0) {
                 break label$52;
                }
                $0 = HEAP32[$0 + 8 >> 2];
                if ($0) {
                 continue;
                }
                break;
               }
              }
              $3 = sbrk(0);
              if (($3 | 0) == -1) {
               break label$7;
              }
              $6 = $5;
              $0 = HEAP32[13351];
              $2 = $0 - 1 | 0;
              if ($3 & $2) {
               $6 = ($5 - $3 | 0) + ($2 + $3 & 0 - $0) | 0;
              }
              if ($6 >>> 0 > 2147483646 | $4 >>> 0 >= $6 >>> 0) {
               break label$7;
              }
              $0 = HEAP32[13342];
              if ($0) {
               $2 = HEAP32[13340];
               $1 = $6 + $2 | 0;
               if ($0 >>> 0 < $1 >>> 0 | $2 >>> 0 >= $1 >>> 0) {
                break label$7;
               }
              }
              $0 = sbrk($6);
              if (($3 | 0) != ($0 | 0)) {
               break label$51;
              }
              break label$5;
             }
             $6 = $6 - $3 & $7;
             if ($6 >>> 0 > 2147483646) {
              break label$7;
             }
             $3 = sbrk($6);
             if (($3 | 0) == (HEAP32[$0 >> 2] + HEAP32[$0 + 4 >> 2] | 0)) {
              break label$8;
             }
             $0 = $3;
            }
            if (!(($0 | 0) == -1 | $4 + 48 >>> 0 <= $6 >>> 0)) {
             $2 = HEAP32[13352];
             $2 = $2 + ($9 - $6 | 0) & 0 - $2;
             if ($2 >>> 0 > 2147483646) {
              $3 = $0;
              break label$5;
             }
             if ((sbrk($2) | 0) != -1) {
              $6 = $2 + $6 | 0;
              $3 = $0;
              break label$5;
             }
             sbrk(0 - $6 | 0);
             break label$7;
            }
            $3 = $0;
            if (($0 | 0) != -1) {
             break label$5;
            }
            break label$7;
           }
           abort();
          }
          $5 = 0;
          break label$2;
         }
         $3 = 0;
         break label$3;
        }
        if (($3 | 0) != -1) {
         break label$5;
        }
       }
       HEAP32[13343] = HEAP32[13343] | 4;
      }
      if ($5 >>> 0 > 2147483646) {
       break label$4;
      }
      $3 = sbrk($5);
      $1 = ($3 | 0) == -1;
      $0 = sbrk(0);
      if ($1 | $3 >>> 0 >= $0 >>> 0 | ($0 | 0) == -1) {
       break label$4;
      }
      $6 = $0 - $3 | 0;
      if ($6 >>> 0 <= $4 + 40 >>> 0) {
       break label$4;
      }
     }
     $0 = HEAP32[13340] + $6 | 0;
     HEAP32[13340] = $0;
     if (HEAPU32[13341] < $0 >>> 0) {
      HEAP32[13341] = $0;
     }
     label$62 : {
      label$63 : {
       label$64 : {
        $2 = HEAP32[13238];
        if ($2) {
         $0 = 53376;
         while (1) {
          $1 = HEAP32[$0 >> 2];
          $5 = HEAP32[$0 + 4 >> 2];
          if (($1 + $5 | 0) == ($3 | 0)) {
           break label$64;
          }
          $0 = HEAP32[$0 + 8 >> 2];
          if ($0) {
           continue;
          }
          break;
         }
         break label$63;
        }
        $0 = HEAP32[13236];
        if (!($0 >>> 0 <= $3 >>> 0 ? $0 : 0)) {
         HEAP32[13236] = $3;
        }
        $0 = 0;
        HEAP32[13345] = $6;
        HEAP32[13344] = $3;
        HEAP32[13240] = -1;
        HEAP32[13241] = HEAP32[13350];
        HEAP32[13347] = 0;
        while (1) {
         $2 = $0 << 3;
         $1 = $2 + 52968 | 0;
         HEAP32[$2 + 52976 >> 2] = $1;
         HEAP32[$2 + 52980 >> 2] = $1;
         $0 = $0 + 1 | 0;
         if (($0 | 0) != 32) {
          continue;
         }
         break;
        }
        $0 = $6 - 40 | 0;
        $2 = $3 + 8 & 7 ? -8 - $3 & 7 : 0;
        $1 = $0 - $2 | 0;
        HEAP32[13235] = $1;
        $2 = $2 + $3 | 0;
        HEAP32[13238] = $2;
        HEAP32[$2 + 4 >> 2] = $1 | 1;
        HEAP32[($0 + $3 | 0) + 4 >> 2] = 40;
        HEAP32[13239] = HEAP32[13354];
        break label$62;
       }
       if (HEAP32[$0 + 12 >> 2] & 8 | ($2 >>> 0 < $1 >>> 0 | $2 >>> 0 >= $3 >>> 0)) {
        break label$63;
       }
       HEAP32[$0 + 4 >> 2] = $5 + $6;
       $0 = $2 + 8 & 7 ? -8 - $2 & 7 : 0;
       $1 = $2 + $0 | 0;
       HEAP32[13238] = $1;
       $3 = HEAP32[13235] + $6 | 0;
       $0 = $3 - $0 | 0;
       HEAP32[13235] = $0;
       HEAP32[$1 + 4 >> 2] = $0 | 1;
       HEAP32[($2 + $3 | 0) + 4 >> 2] = 40;
       HEAP32[13239] = HEAP32[13354];
       break label$62;
      }
      $5 = HEAP32[13236];
      if ($5 >>> 0 > $3 >>> 0) {
       HEAP32[13236] = $3;
      }
      $1 = $3 + $6 | 0;
      $0 = 53376;
      label$70 : {
       label$71 : {
        label$72 : {
         label$73 : {
          label$74 : {
           label$75 : {
            while (1) {
             if (HEAP32[$0 >> 2] != ($1 | 0)) {
              $0 = HEAP32[$0 + 8 >> 2];
              if ($0) {
               continue;
              }
              break label$75;
             }
             break;
            }
            if (!(HEAPU8[$0 + 12 | 0] & 8)) {
             break label$74;
            }
           }
           $0 = 53376;
           while (1) {
            $1 = HEAP32[$0 >> 2];
            if ($1 >>> 0 <= $2 >>> 0) {
             $1 = HEAP32[$0 + 4 >> 2] + $1 | 0;
             if ($1 >>> 0 > $2 >>> 0) {
              break label$73;
             }
            }
            $0 = HEAP32[$0 + 8 >> 2];
            continue;
           }
          }
          HEAP32[$0 >> 2] = $3;
          HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + $6;
          $7 = ($3 + 8 & 7 ? -8 - $3 & 7 : 0) + $3 | 0;
          HEAP32[$7 + 4 >> 2] = $4 | 3;
          $6 = ($1 + 8 & 7 ? -8 - $1 & 7 : 0) + $1 | 0;
          $1 = ($6 - $7 | 0) - $4 | 0;
          $4 = $4 + $7 | 0;
          if (($2 | 0) == ($6 | 0)) {
           HEAP32[13238] = $4;
           $0 = HEAP32[13235] + $1 | 0;
           HEAP32[13235] = $0;
           HEAP32[$4 + 4 >> 2] = $0 | 1;
           break label$71;
          }
          if (HEAP32[13237] == ($6 | 0)) {
           HEAP32[13237] = $4;
           $0 = HEAP32[13234] + $1 | 0;
           HEAP32[13234] = $0;
           HEAP32[$4 + 4 >> 2] = $0 | 1;
           HEAP32[$0 + $4 >> 2] = $0;
           break label$71;
          }
          $0 = HEAP32[$6 + 4 >> 2];
          if (($0 & 3) == 1) {
           $9 = $0 & -8;
           label$83 : {
            if ($0 >>> 0 <= 255) {
             $8 = $0 >>> 3 | 0;
             $0 = ($8 << 3) + 52968 | 0;
             $3 = HEAP32[$6 + 8 >> 2];
             $2 = HEAP32[$6 + 12 >> 2];
             if (($3 | 0) == ($2 | 0)) {
              HEAP32[13232] = HEAP32[13232] & __wasm_rotl_i32(-2, $8);
              break label$83;
             }
             HEAP32[$3 + 12 >> 2] = $2;
             HEAP32[$2 + 8 >> 2] = $3;
             break label$83;
            }
            $8 = HEAP32[$6 + 24 >> 2];
            $3 = HEAP32[$6 + 12 >> 2];
            label$86 : {
             if (($6 | 0) != ($3 | 0)) {
              $0 = HEAP32[$6 + 8 >> 2];
              HEAP32[$0 + 12 >> 2] = $3;
              HEAP32[$3 + 8 >> 2] = $0;
              break label$86;
             }
             label$89 : {
              $0 = $6 + 20 | 0;
              $2 = HEAP32[$0 >> 2];
              if ($2) {
               break label$89;
              }
              $0 = $6 + 16 | 0;
              $2 = HEAP32[$0 >> 2];
              if ($2) {
               break label$89;
              }
              $3 = 0;
              break label$86;
             }
             while (1) {
              $5 = $0;
              $3 = $2;
              $0 = $2 + 20 | 0;
              $2 = HEAP32[$0 >> 2];
              if ($2) {
               continue;
              }
              $0 = $3 + 16 | 0;
              $2 = HEAP32[$3 + 16 >> 2];
              if ($2) {
               continue;
              }
              break;
             }
             HEAP32[$5 >> 2] = 0;
            }
            if (!$8) {
             break label$83;
            }
            $2 = HEAP32[$6 + 28 >> 2];
            $0 = ($2 << 2) + 53232 | 0;
            label$91 : {
             if (HEAP32[$0 >> 2] == ($6 | 0)) {
              HEAP32[$0 >> 2] = $3;
              if ($3) {
               break label$91;
              }
              HEAP32[13233] = HEAP32[13233] & __wasm_rotl_i32(-2, $2);
              break label$83;
             }
             HEAP32[(HEAP32[$8 + 16 >> 2] == ($6 | 0) ? 16 : 20) + $8 >> 2] = $3;
             if (!$3) {
              break label$83;
             }
            }
            HEAP32[$3 + 24 >> 2] = $8;
            $0 = HEAP32[$6 + 16 >> 2];
            if ($0) {
             HEAP32[$3 + 16 >> 2] = $0;
             HEAP32[$0 + 24 >> 2] = $3;
            }
            $0 = HEAP32[$6 + 20 >> 2];
            if (!$0) {
             break label$83;
            }
            HEAP32[$3 + 20 >> 2] = $0;
            HEAP32[$0 + 24 >> 2] = $3;
           }
           $6 = $6 + $9 | 0;
           $1 = $1 + $9 | 0;
          }
          HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] & -2;
          HEAP32[$4 + 4 >> 2] = $1 | 1;
          HEAP32[$1 + $4 >> 2] = $1;
          if ($1 >>> 0 <= 255) {
           $2 = $1 >>> 3 | 0;
           $0 = ($2 << 3) + 52968 | 0;
           $2 = 1 << $2;
           $1 = HEAP32[13232];
           label$95 : {
            if (!($2 & $1)) {
             HEAP32[13232] = $2 | $1;
             $2 = $0;
             break label$95;
            }
            $2 = HEAP32[$0 + 8 >> 2];
           }
           HEAP32[$0 + 8 >> 2] = $4;
           HEAP32[$2 + 12 >> 2] = $4;
           HEAP32[$4 + 12 >> 2] = $0;
           HEAP32[$4 + 8 >> 2] = $2;
           break label$71;
          }
          $0 = 31;
          if ($1 >>> 0 <= 16777215) {
           $0 = $1 >>> 8 | 0;
           $3 = $0;
           $0 = $0 + 1048320 >>> 16 & 8;
           $2 = $3 << $0;
           $3 = $2;
           $2 = $2 + 520192 >>> 16 & 4;
           $3 = $3 << $2;
           $5 = $3;
           $3 = $3 + 245760 >>> 16 & 2;
           $0 = ($5 << $3 >>> 15 | 0) - ($0 | $2 | $3) | 0;
           $0 = ($0 << 1 | $1 >>> $0 + 21 & 1) + 28 | 0;
          }
          HEAP32[$4 + 28 >> 2] = $0;
          HEAP32[$4 + 16 >> 2] = 0;
          HEAP32[$4 + 20 >> 2] = 0;
          $2 = ($0 << 2) + 53232 | 0;
          $3 = HEAP32[13233];
          $5 = 1 << $0;
          label$98 : {
           if (!($3 & $5)) {
            HEAP32[13233] = $3 | $5;
            HEAP32[$2 >> 2] = $4;
            break label$98;
           }
           $0 = $1 << (($0 | 0) == 31 ? 0 : 25 - ($0 >>> 1 | 0) | 0);
           $3 = HEAP32[$2 >> 2];
           while (1) {
            $2 = $3;
            if ((HEAP32[$2 + 4 >> 2] & -8) == ($1 | 0)) {
             break label$72;
            }
            $3 = $0 >>> 29 | 0;
            $0 = $0 << 1;
            $6 = ($3 & 4) + $2 | 0;
            $5 = $6 + 16 | 0;
            $3 = HEAP32[$5 >> 2];
            if ($3) {
             continue;
            }
            break;
           }
           HEAP32[$6 + 16 >> 2] = $4;
          }
          HEAP32[$4 + 24 >> 2] = $2;
          HEAP32[$4 + 12 >> 2] = $4;
          HEAP32[$4 + 8 >> 2] = $4;
          break label$71;
         }
         $0 = $6 - 40 | 0;
         $5 = $3 + 8 & 7 ? -8 - $3 & 7 : 0;
         $7 = $0 - $5 | 0;
         HEAP32[13235] = $7;
         $5 = $3 + $5 | 0;
         HEAP32[13238] = $5;
         HEAP32[$5 + 4 >> 2] = $7 | 1;
         HEAP32[($0 + $3 | 0) + 4 >> 2] = 40;
         HEAP32[13239] = HEAP32[13354];
         $0 = (($1 - 39 & 7 ? 39 - $1 & 7 : 0) + $1 | 0) - 47 | 0;
         $5 = $2 + 16 >>> 0 > $0 >>> 0 ? $2 : $0;
         HEAP32[$5 + 4 >> 2] = 27;
         $0 = HEAP32[13347];
         $7 = HEAP32[13346];
         HEAP32[$5 + 16 >> 2] = $7;
         HEAP32[$5 + 20 >> 2] = $0;
         $7 = HEAP32[13345];
         $0 = HEAP32[13344];
         HEAP32[$5 + 8 >> 2] = $0;
         HEAP32[$5 + 12 >> 2] = $7;
         HEAP32[13346] = $5 + 8;
         HEAP32[13345] = $6;
         HEAP32[13344] = $3;
         HEAP32[13347] = 0;
         $0 = $5 + 24 | 0;
         while (1) {
          HEAP32[$0 + 4 >> 2] = 7;
          $3 = $0 + 8 | 0;
          $0 = $0 + 4 | 0;
          if ($1 >>> 0 > $3 >>> 0) {
           continue;
          }
          break;
         }
         if (($2 | 0) == ($5 | 0)) {
          break label$62;
         }
         HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] & -2;
         $6 = $5 - $2 | 0;
         HEAP32[$2 + 4 >> 2] = $6 | 1;
         HEAP32[$5 >> 2] = $6;
         if ($6 >>> 0 <= 255) {
          $1 = $6 >>> 3 | 0;
          $0 = ($1 << 3) + 52968 | 0;
          $1 = 1 << $1;
          $3 = HEAP32[13232];
          label$103 : {
           if (!($1 & $3)) {
            HEAP32[13232] = $1 | $3;
            $1 = $0;
            break label$103;
           }
           $1 = HEAP32[$0 + 8 >> 2];
          }
          HEAP32[$0 + 8 >> 2] = $2;
          HEAP32[$1 + 12 >> 2] = $2;
          HEAP32[$2 + 12 >> 2] = $0;
          HEAP32[$2 + 8 >> 2] = $1;
          break label$62;
         }
         $0 = 31;
         HEAP32[$2 + 16 >> 2] = 0;
         HEAP32[$2 + 20 >> 2] = 0;
         if ($6 >>> 0 <= 16777215) {
          $0 = $6 >>> 8 | 0;
          $1 = $0;
          $0 = $0 + 1048320 >>> 16 & 8;
          $1 = $1 << $0;
          $3 = $1;
          $1 = $1 + 520192 >>> 16 & 4;
          $3 = $3 << $1;
          $5 = $3;
          $3 = $3 + 245760 >>> 16 & 2;
          $0 = ($5 << $3 >>> 15 | 0) - ($0 | $1 | $3) | 0;
          $0 = ($0 << 1 | $6 >>> $0 + 21 & 1) + 28 | 0;
         }
         HEAP32[$2 + 28 >> 2] = $0;
         $1 = ($0 << 2) + 53232 | 0;
         $3 = HEAP32[13233];
         $5 = 1 << $0;
         label$106 : {
          if (!($3 & $5)) {
           HEAP32[13233] = $3 | $5;
           HEAP32[$1 >> 2] = $2;
           break label$106;
          }
          $0 = $6 << (($0 | 0) == 31 ? 0 : 25 - ($0 >>> 1 | 0) | 0);
          $3 = HEAP32[$1 >> 2];
          while (1) {
           $1 = $3;
           if ((HEAP32[$1 + 4 >> 2] & -8) == ($6 | 0)) {
            break label$70;
           }
           $3 = $0 >>> 29 | 0;
           $0 = $0 << 1;
           $7 = ($3 & 4) + $1 | 0;
           $5 = $7 + 16 | 0;
           $3 = HEAP32[$5 >> 2];
           if ($3) {
            continue;
           }
           break;
          }
          HEAP32[$7 + 16 >> 2] = $2;
         }
         HEAP32[$2 + 24 >> 2] = $1;
         HEAP32[$2 + 12 >> 2] = $2;
         HEAP32[$2 + 8 >> 2] = $2;
         break label$62;
        }
        $0 = HEAP32[$2 + 8 >> 2];
        HEAP32[$0 + 12 >> 2] = $4;
        HEAP32[$2 + 8 >> 2] = $4;
        HEAP32[$4 + 24 >> 2] = 0;
        HEAP32[$4 + 12 >> 2] = $2;
        HEAP32[$4 + 8 >> 2] = $0;
       }
       $0 = $7 + 8 | 0;
       break label$1;
      }
      $0 = HEAP32[$1 + 8 >> 2];
      HEAP32[$0 + 12 >> 2] = $2;
      HEAP32[$1 + 8 >> 2] = $2;
      HEAP32[$2 + 24 >> 2] = 0;
      HEAP32[$2 + 12 >> 2] = $1;
      HEAP32[$2 + 8 >> 2] = $0;
     }
     $0 = HEAP32[13235];
     if ($4 >>> 0 >= $0 >>> 0) {
      break label$4;
     }
     $2 = $0 - $4 | 0;
     HEAP32[13235] = $2;
     $0 = HEAP32[13238];
     $1 = $4 + $0 | 0;
     HEAP32[13238] = $1;
     HEAP32[$1 + 4 >> 2] = $2 | 1;
     HEAP32[$0 + 4 >> 2] = $4 | 3;
     $0 = $0 + 8 | 0;
     break label$1;
    }
    HEAP32[__errno_location() >> 2] = 48;
    $0 = 0;
    break label$1;
   }
   label$109 : {
    if (!$8) {
     break label$109;
    }
    $1 = HEAP32[$5 + 28 >> 2];
    $0 = ($1 << 2) + 53232 | 0;
    label$110 : {
     if (HEAP32[$0 >> 2] == ($5 | 0)) {
      HEAP32[$0 >> 2] = $3;
      if ($3) {
       break label$110;
      }
      $9 = __wasm_rotl_i32(-2, $1) & $9;
      HEAP32[13233] = $9;
      break label$109;
     }
     HEAP32[(HEAP32[$8 + 16 >> 2] == ($5 | 0) ? 16 : 20) + $8 >> 2] = $3;
     if (!$3) {
      break label$109;
     }
    }
    HEAP32[$3 + 24 >> 2] = $8;
    $0 = HEAP32[$5 + 16 >> 2];
    if ($0) {
     HEAP32[$3 + 16 >> 2] = $0;
     HEAP32[$0 + 24 >> 2] = $3;
    }
    $0 = HEAP32[$5 + 20 >> 2];
    if (!$0) {
     break label$109;
    }
    HEAP32[$3 + 20 >> 2] = $0;
    HEAP32[$0 + 24 >> 2] = $3;
   }
   label$113 : {
    if ($2 >>> 0 <= 15) {
     $0 = $2 + $4 | 0;
     HEAP32[$5 + 4 >> 2] = $0 | 3;
     $0 = $0 + $5 | 0;
     HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | 1;
     break label$113;
    }
    HEAP32[$5 + 4 >> 2] = $4 | 3;
    HEAP32[$7 + 4 >> 2] = $2 | 1;
    HEAP32[$2 + $7 >> 2] = $2;
    if ($2 >>> 0 <= 255) {
     $2 = $2 >>> 3 | 0;
     $0 = ($2 << 3) + 52968 | 0;
     $2 = 1 << $2;
     $1 = HEAP32[13232];
     label$116 : {
      if (!($2 & $1)) {
       HEAP32[13232] = $2 | $1;
       $2 = $0;
       break label$116;
      }
      $2 = HEAP32[$0 + 8 >> 2];
     }
     HEAP32[$0 + 8 >> 2] = $7;
     HEAP32[$2 + 12 >> 2] = $7;
     HEAP32[$7 + 12 >> 2] = $0;
     HEAP32[$7 + 8 >> 2] = $2;
     break label$113;
    }
    $0 = 31;
    if ($2 >>> 0 <= 16777215) {
     $0 = $2 >>> 8 | 0;
     $1 = $0;
     $0 = $0 + 1048320 >>> 16 & 8;
     $1 = $1 << $0;
     $3 = $1;
     $1 = $1 + 520192 >>> 16 & 4;
     $4 = $3 << $1;
     $3 = $4;
     $4 = $4 + 245760 >>> 16 & 2;
     $0 = ($3 << $4 >>> 15 | 0) - ($0 | $1 | $4) | 0;
     $0 = ($0 << 1 | $2 >>> $0 + 21 & 1) + 28 | 0;
    }
    HEAP32[$7 + 28 >> 2] = $0;
    HEAP32[$7 + 16 >> 2] = 0;
    HEAP32[$7 + 20 >> 2] = 0;
    $1 = ($0 << 2) + 53232 | 0;
    label$119 : {
     $4 = 1 << $0;
     label$120 : {
      if (!($9 & $4)) {
       HEAP32[13233] = $4 | $9;
       HEAP32[$1 >> 2] = $7;
       break label$120;
      }
      $0 = $2 << (($0 | 0) == 31 ? 0 : 25 - ($0 >>> 1 | 0) | 0);
      $4 = HEAP32[$1 >> 2];
      while (1) {
       $1 = $4;
       if ((HEAP32[$1 + 4 >> 2] & -8) == ($2 | 0)) {
        break label$119;
       }
       $4 = $0 >>> 29 | 0;
       $0 = $0 << 1;
       $6 = ($4 & 4) + $1 | 0;
       $3 = $6 + 16 | 0;
       $4 = HEAP32[$3 >> 2];
       if ($4) {
        continue;
       }
       break;
      }
      HEAP32[$6 + 16 >> 2] = $7;
     }
     HEAP32[$7 + 24 >> 2] = $1;
     HEAP32[$7 + 12 >> 2] = $7;
     HEAP32[$7 + 8 >> 2] = $7;
     break label$113;
    }
    $0 = HEAP32[$1 + 8 >> 2];
    HEAP32[$0 + 12 >> 2] = $7;
    HEAP32[$1 + 8 >> 2] = $7;
    HEAP32[$7 + 24 >> 2] = 0;
    HEAP32[$7 + 12 >> 2] = $1;
    HEAP32[$7 + 8 >> 2] = $0;
   }
   $0 = $5 + 8 | 0;
   break label$1;
  }
  label$123 : {
   if (!$11) {
    break label$123;
   }
   $1 = HEAP32[$3 + 28 >> 2];
   $0 = ($1 << 2) + 53232 | 0;
   label$124 : {
    if (HEAP32[$0 >> 2] == ($3 | 0)) {
     HEAP32[$0 >> 2] = $5;
     if ($5) {
      break label$124;
     }
     HEAP32[13233] = __wasm_rotl_i32(-2, $1) & $8;
     break label$123;
    }
    HEAP32[(HEAP32[$11 + 16 >> 2] == ($3 | 0) ? 16 : 20) + $11 >> 2] = $5;
    if (!$5) {
     break label$123;
    }
   }
   HEAP32[$5 + 24 >> 2] = $11;
   $0 = HEAP32[$3 + 16 >> 2];
   if ($0) {
    HEAP32[$5 + 16 >> 2] = $0;
    HEAP32[$0 + 24 >> 2] = $5;
   }
   $0 = HEAP32[$3 + 20 >> 2];
   if (!$0) {
    break label$123;
   }
   HEAP32[$5 + 20 >> 2] = $0;
   HEAP32[$0 + 24 >> 2] = $5;
  }
  label$127 : {
   if ($2 >>> 0 <= 15) {
    $0 = $2 + $4 | 0;
    HEAP32[$3 + 4 >> 2] = $0 | 3;
    $0 = $0 + $3 | 0;
    HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | 1;
    break label$127;
   }
   HEAP32[$3 + 4 >> 2] = $4 | 3;
   HEAP32[$10 + 4 >> 2] = $2 | 1;
   HEAP32[$2 + $10 >> 2] = $2;
   if ($9) {
    $4 = $9 >>> 3 | 0;
    $1 = ($4 << 3) + 52968 | 0;
    $0 = HEAP32[13237];
    $4 = 1 << $4;
    label$130 : {
     if (!($6 & $4)) {
      HEAP32[13232] = $4 | $6;
      $4 = $1;
      break label$130;
     }
     $4 = HEAP32[$1 + 8 >> 2];
    }
    HEAP32[$1 + 8 >> 2] = $0;
    HEAP32[$4 + 12 >> 2] = $0;
    HEAP32[$0 + 12 >> 2] = $1;
    HEAP32[$0 + 8 >> 2] = $4;
   }
   HEAP32[13237] = $10;
   HEAP32[13234] = $2;
  }
  $0 = $3 + 8 | 0;
 }
 __stack_pointer = $12 + 16 | 0;
 return $0 | 0;
}
function silk_pitch_analysis_core_FLP($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) {
 var $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = Math_fround(0), $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = Math_fround(0), $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = Math_fround(0), $33 = 0, $34 = 0, $35 = 0, $36 = Math_fround(0), $37 = 0, $38 = Math_fround(0), $39 = 0, $40 = Math_fround(0), $41 = Math_fround(0), $42 = Math_fround(0), $43 = 0;
 $15 = __stack_pointer - 11552 | 0;
 __stack_pointer = $15;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     label$5 : {
      label$6 : {
       label$7 : {
        label$8 : {
         if (!(!(1 << $8 & 69888) | $8 >>> 0 > 16)) {
          if (($9 | 0) <= -1) {
           break label$8;
          }
          if (($9 | 0) >= 3) {
           break label$7;
          }
          $16 = Math_imul($10, 5);
          $17 = $16 + 20 | 0;
          $19 = $17 << 3;
          $20 = Math_imul($8, $17);
          label$10 : {
           if (($8 | 0) == 16) {
            if (($20 | 0) >= 1) {
             $12 = $20;
             while (1) {
              $13 = $12 - 1 | 0;
              $22 = ($15 + 2720 | 0) + ($13 << 1) | 0;
              $14 = lrintf(HEAPF32[($13 << 2) + $0 >> 2]);
              $14 = ($14 | 0) > -32768 ? $14 : -32768;
              HEAP16[$22 >> 1] = ($14 | 0) < 32767 ? $14 : 32767;
              $14 = ($12 | 0) > 1;
              $12 = $13;
              if ($14) {
               continue;
              }
              break;
             }
            }
            HEAP32[$15 + 8544 >> 2] = 0;
            HEAP32[$15 + 8548 >> 2] = 0;
            silk_resampler_down2($15 + 8544 | 0, $15 + 8896 | 0, $15 + 2720 | 0, $20);
            if (($16 | 0) < -19) {
             break label$10;
            }
            $12 = $19;
            while (1) {
             $13 = $12 - 1 | 0;
             HEAPF32[($15 + 10176 | 0) + ($13 << 2) >> 2] = HEAP16[($15 + 8896 | 0) + ($13 << 1) >> 1];
             $14 = ($12 | 0) > 1;
             $12 = $13;
             if ($14) {
              continue;
             }
             break;
            }
            break label$10;
           }
           if (($8 | 0) == 12) {
            if (($20 | 0) >= 1) {
             $12 = $20;
             while (1) {
              $13 = $12 - 1 | 0;
              $22 = ($15 + 2720 | 0) + ($13 << 1) | 0;
              $14 = lrintf(HEAPF32[($13 << 2) + $0 >> 2]);
              $14 = ($14 | 0) > -32768 ? $14 : -32768;
              HEAP16[$22 >> 1] = ($14 | 0) < 32767 ? $14 : 32767;
              $14 = ($12 | 0) > 1;
              $12 = $13;
              if ($14) {
               continue;
              }
              break;
             }
            }
            $22 = $15 + 8560 | 0;
            HEAP32[$22 >> 2] = 0;
            HEAP32[$22 + 4 >> 2] = 0;
            HEAP32[$15 + 8552 >> 2] = 0;
            HEAP32[$15 + 8556 >> 2] = 0;
            HEAP32[$15 + 8544 >> 2] = 0;
            HEAP32[$15 + 8548 >> 2] = 0;
            silk_resampler_down2_3($15 + 8544 | 0, $15 + 8896 | 0, $15 + 2720 | 0, $20);
            if (($16 | 0) < -19) {
             break label$10;
            }
            $12 = $19;
            while (1) {
             $13 = $12 - 1 | 0;
             HEAPF32[($15 + 10176 | 0) + ($13 << 2) >> 2] = HEAP16[($15 + 8896 | 0) + ($13 << 1) >> 1];
             $14 = ($12 | 0) > 1;
             $12 = $13;
             if ($14) {
              continue;
             }
             break;
            }
            break label$10;
           }
           if (($8 | 0) != 8) {
            break label$6;
           }
           if (($16 | 0) < -19) {
            break label$10;
           }
           $12 = $19;
           while (1) {
            $13 = $12 - 1 | 0;
            $22 = ($15 + 8896 | 0) + ($13 << 1) | 0;
            $14 = lrintf(HEAPF32[($13 << 2) + $0 >> 2]);
            $14 = ($14 | 0) > -32768 ? $14 : -32768;
            HEAP16[$22 >> 1] = ($14 | 0) < 32767 ? $14 : 32767;
            $14 = ($12 | 0) > 1;
            $12 = $13;
            if ($14) {
             continue;
            }
            break;
           }
          }
          $17 = $17 << 2;
          HEAP32[$15 + 8544 >> 2] = 0;
          HEAP32[$15 + 8548 >> 2] = 0;
          silk_resampler_down2($15 + 8544 | 0, $15 + 8576 | 0, $15 + 8896 | 0, $19);
          label$20 : {
           if (($16 | 0) < -19) {
            break label$20;
           }
           $12 = $17;
           while (1) {
            $13 = $12 - 1 | 0;
            HEAPF32[($15 + 9536 | 0) + ($13 << 2) >> 2] = HEAP16[($15 + 8576 | 0) + ($13 << 1) >> 1];
            $14 = ($12 | 0) > 1;
            $12 = $13;
            if ($14) {
             continue;
            }
            break;
           }
           if (($16 | 0) < -19) {
            break label$20;
           }
           $12 = $17;
           while (1) {
            $25 = HEAPF32[(($12 << 2) + $15 | 0) + 9528 >> 2];
            $13 = $12 - 1 | 0;
            $14 = ($15 + 9536 | 0) + ($13 << 2) | 0;
            $18 = HEAPF32[$14 >> 2];
            label$23 : {
             if (Math_fround(Math_abs($18)) < Math_fround(2147483648)) {
              $16 = ~~$18;
              break label$23;
             }
             $16 = -2147483648;
            }
            $25 = Math_fround($25 + Math_fround($16 | 0));
            $18 = Math_fround(32767);
            label$26 : {
             if ($25 > Math_fround(32767)) {
              break label$26;
             }
             $18 = Math_fround(-32768);
             if ($25 < Math_fround(-32768)) {
              break label$26;
             }
             $18 = $25;
            }
            label$25 : {
             if (Math_fround(Math_abs($18)) < Math_fround(2147483648)) {
              $16 = ~~$18;
              break label$25;
             }
             $16 = -2147483648;
            }
            HEAPF32[$14 >> 2] = $16 | 0;
            $14 = ($12 | 0) > 2;
            $12 = $13;
            if ($14) {
             continue;
            }
            break;
           }
          }
          $16 = 0;
          memset($15 + 6160 | 0, 0, Math_imul($10, 596));
          if (($10 | 0) >= 2) {
           $12 = $10 >> 1;
           $19 = ($12 | 0) > 1 ? $12 : 1;
           $17 = ($15 + 9536 | 0) + ($17 << 2) | 0;
           $12 = $15 + 9856 | 0;
           while (1) {
            $20 = $12 + 160 | 0;
            if ($20 >>> 0 > $17 >>> 0) {
             break label$5;
            }
            $13 = $12 - 32 | 0;
            if ($13 >>> 0 < $15 + 9536 >>> 0) {
             break label$4;
            }
            if ($12 + 128 >>> 0 > $17 >>> 0) {
             break label$3;
            }
            celt_pitch_xcorr_c($12, $12 - 288 | 0, $15 + 5888 | 0, 40, 65, $11);
            $18 = HEAPF32[$15 + 6144 >> 2];
            $21 = silk_energy_FLP($12, 40);
            $23 = silk_energy_FLP($13, 40);
            $34 = +$18;
            $21 = $21 + $23 + 16e4;
            HEAPF32[$15 + 6192 >> 2] = HEAPF32[$15 + 6192 >> 2] + Math_fround(($34 + $34) / $21);
            $12 = 9;
            while (1) {
             $14 = ($15 + 6160 | 0) + ($12 << 2) | 0;
             $22 = $14;
             $18 = HEAPF32[$14 >> 2];
             $23 = +HEAPF32[((0 - $12 << 2) + $15 | 0) + 6176 >> 2];
             $34 = $23 + $23;
             $14 = $13 - 4 | 0;
             $23 = +HEAPF32[$14 >> 2];
             $39 = $23 * $23;
             $23 = +HEAPF32[$13 + 156 >> 2];
             $21 = $21 + ($39 - $23 * $23);
             HEAPF32[$22 >> 2] = $18 + Math_fround($34 / $21);
             $13 = $14;
             $12 = $12 + 1 | 0;
             if (($12 | 0) != 73) {
              continue;
             }
             break;
            }
            $12 = $20;
            $16 = $16 + 1 | 0;
            if (($19 | 0) != ($16 | 0)) {
             continue;
            }
            break;
           }
          }
          $27 = $8 << 1;
          $35 = Math_imul($8, 5);
          $30 = Math_imul($8, 18);
          $31 = $30 - 1 | 0;
          $14 = $10 << 2;
          $12 = 72;
          while (1) {
           $13 = ($15 + 6160 | 0) + ($12 << 2) | 0;
           $18 = HEAPF32[$13 >> 2];
           HEAPF32[$13 >> 2] = $18 + Math_fround(Math_fround($18 * Math_fround($12 | 0)) * Math_fround(-.000244140625));
           $13 = $12 >>> 0 > 8;
           $12 = $12 - 1 | 0;
           if ($13) {
            continue;
           }
           break;
          }
          $13 = ($9 << 1) + 4 | 0;
          silk_insertion_sort_decreasing_FLP($15 + 6192 | 0, $15 + 5744 | 0, 65, $13);
          label$32 : {
           $18 = HEAPF32[$15 + 6192 >> 2];
           label$33 : {
            if (!($18 < Math_fround(.20000000298023224) ^ 1)) {
             memset($1, 0, $14);
             break label$33;
            }
            label$35 : {
             if (($9 | 0) < -1) {
              break label$35;
             }
             $18 = Math_fround($18 * $6);
             $16 = ($13 | 0) > 1 ? $13 : 1;
             $12 = 0;
             while (1) {
              $14 = $12 << 2;
              if (HEAPF32[($14 + $15 | 0) + 6192 >> 2] > $18 ^ 1) {
               $13 = $12;
               break label$35;
              }
              $14 = ($15 + 5744 | 0) + $14 | 0;
              HEAP32[$14 >> 2] = (HEAP32[$14 >> 2] << 1) + 16;
              $12 = $12 + 1 | 0;
              if (($16 | 0) != ($12 | 0)) {
               continue;
              }
              break;
             }
            }
            $12 = 0;
            if (($13 | 0) <= 0) {
             break label$2;
            }
            memset($15 + 5462 | 0, 0, 274);
            while (1) {
             HEAP16[($15 + 5440 | 0) + (HEAP32[($15 + 5744 | 0) + ($12 << 2) >> 2] << 1) >> 1] = 1;
             $12 = $12 + 1 | 0;
             if (($13 | 0) != ($12 | 0)) {
              continue;
             }
             break;
            }
            $12 = 146;
            $14 = HEAPU16[$15 + 5730 >> 1];
            while (1) {
             $13 = ($15 + 5440 | 0) + ($12 << 1) | 0;
             $16 = HEAPU16[$13 - 4 >> 1];
             HEAP16[$13 >> 1] = HEAPU16[$13 >> 1] + ($14 + $16 | 0);
             $13 = 16;
             $17 = $12 >>> 0 > 16;
             $14 = $16;
             $12 = $12 - 1 | 0;
             if ($17) {
              continue;
             }
             break;
            }
            while (1) {
             $12 = $13 + 1 | 0;
             if (HEAP16[($15 + 5440 | 0) + ($12 << 1) >> 1] >= 1) {
              HEAP32[($15 + 5744 | 0) + ($28 << 2) >> 2] = $13;
              $28 = $28 + 1 | 0;
             }
             $13 = $12;
             if (($12 | 0) != 144) {
              continue;
             }
             break;
            }
            $13 = 146;
            $14 = HEAPU16[$15 + 5728 >> 1];
            $16 = HEAPU16[$15 + 5730 >> 1];
            while (1) {
             $17 = $14;
             $22 = $14 + $16 | 0;
             $12 = ($15 + 5440 | 0) + ($13 << 1) | 0;
             $14 = HEAPU16[$12 - 6 >> 1];
             HEAP16[$12 >> 1] = HEAPU16[$12 >> 1] + ($14 + $22 | 0);
             $12 = 16;
             $20 = $13 >>> 0 > 16;
             $16 = $17;
             $13 = $13 - 1 | 0;
             if ($20) {
              continue;
             }
             break;
            }
            $17 = 0;
            while (1) {
             if (HEAP16[($15 + 5440 | 0) + ($12 << 1) >> 1] >= 1) {
              HEAP16[($15 + 5440 | 0) + ($17 << 1) >> 1] = $12 - 2;
              $17 = $17 + 1 | 0;
             }
             $12 = $12 + 1 | 0;
             if (($12 | 0) != 147) {
              continue;
             }
             break;
            }
            $20 = 0;
            memset($15 + 6160 | 0, 0, 2384);
            if (($10 | 0) >= 1) {
             $13 = ($8 | 0) == 8 ? $0 + 640 | 0 : $15 + 10816 | 0;
             $19 = ($17 | 0) < 1;
             while (1) {
              $21 = silk_energy_FLP($13, 40);
              if (!$19) {
               $23 = $21 + 1;
               $12 = 0;
               while (1) {
                $18 = Math_fround(0);
                $14 = HEAP16[($15 + 5440 | 0) + ($12 << 1) >> 1] << 2;
                $16 = $13 - $14 | 0;
                $21 = silk_inner_product_FLP($16, $13, 40);
                if (!($21 > 0 ^ 1)) {
                 $18 = Math_fround(($21 + $21) / ($23 + silk_energy_FLP($16, 40)));
                }
                HEAPF32[(($15 + 6160 | 0) + Math_imul($20, 596) | 0) + $14 >> 2] = $18;
                $12 = $12 + 1 | 0;
                if (($17 | 0) != ($12 | 0)) {
                 continue;
                }
                break;
               }
              }
              $13 = $13 + 160 | 0;
              $20 = $20 + 1 | 0;
              if (($20 | 0) != ($10 | 0)) {
               continue;
              }
              break;
             }
            }
            if (($5 | 0) < 1) {
             $6 = Math_fround(0);
            } else {
             $5 = ($8 | 0) == 12 ? ($5 << 1) / 3 | 0 : $5 >>> (($8 | 0) == 16) | 0;
             $6 = Math_fround(log10(+Math_fround($5 | 0)) * 3.32192809488736);
            }
            $40 = $6;
            if (($28 | 0) >= 1) {
             $12 = ($10 | 0) == 4;
             $20 = $12 ? ($8 | 0) == 8 ? ($9 | 0) > 0 ? 11 : 3 : 3 : 3;
             $16 = $12 ? 10048 : 10007;
             $17 = $12 ? 11 : 3;
             $36 = Math_fround($10 | 0);
             $41 = Math_fround($36 * $7);
             $38 = Math_fround($36 * Math_fround(.20000000298023224));
             $24 = -1;
             $7 = Math_fround(-1e3);
             $6 = Math_fround(0);
             $29 = ($10 | 0) < 1;
             $37 = ($5 | 0) < 1;
             $5 = 0;
             while (1) {
              $14 = HEAP32[($15 + 5744 | 0) + ($26 << 2) >> 2];
              $13 = 0;
              while (1) {
               $19 = ($15 + 5840 | 0) + ($13 << 2) | 0;
               HEAP32[$19 >> 2] = 0;
               $18 = Math_fround(0);
               $12 = 0;
               if (!$29) {
                while (1) {
                 $18 = Math_fround(HEAPF32[(($15 + 6160 | 0) + Math_imul($12, 596) | 0) + (HEAP8[(Math_imul($12, $17) + $13 | 0) + $16 | 0] + $14 << 2) >> 2] + $18);
                 $12 = $12 + 1 | 0;
                 if (($12 | 0) != ($10 | 0)) {
                  continue;
                 }
                 break;
                }
                HEAPF32[$19 >> 2] = $18;
               }
               $13 = $13 + 1 | 0;
               if (($20 | 0) != ($13 | 0)) {
                continue;
               }
               break;
              }
              $18 = Math_fround(-1e3);
              $12 = 0;
              $13 = 0;
              while (1) {
               $25 = HEAPF32[($15 + 5840 | 0) + ($12 << 2) >> 2];
               $19 = $25 > $18;
               $18 = $19 ? $25 : $18;
               $13 = $19 ? $12 : $13;
               $12 = $12 + 1 | 0;
               if (($20 | 0) != ($12 | 0)) {
                continue;
               }
               break;
              }
              $32 = Math_fround(log10(+Math_fround($14 | 0)) * 3.32192809488736);
              $25 = Math_fround($18 - Math_fround($38 * $32));
              $42 = $18;
              if (!$37) {
               $32 = Math_fround($32 - $40);
               $32 = Math_fround($32 * $32);
               $25 = Math_fround($25 - Math_fround(Math_fround($32 * Math_fround($38 * HEAPF32[$4 >> 2])) / Math_fround($32 + Math_fround(.5))));
              }
              $12 = $7 < $25 & $18 > $41;
              $6 = $12 ? $42 : $6;
              $7 = $12 ? $25 : $7;
              $24 = $12 ? $14 : $24;
              $5 = $12 ? $13 : $5;
              $26 = $26 + 1 | 0;
              if (($26 | 0) != ($28 | 0)) {
               continue;
              }
              break;
             }
             if (($24 | 0) != -1) {
              break label$32;
             }
            }
            $22 = $1;
            HEAP32[$22 >> 2] = 0;
            HEAP32[$22 + 4 >> 2] = 0;
            HEAP32[$22 + 8 >> 2] = 0;
            HEAP32[$22 + 12 >> 2] = 0;
           }
           HEAP32[$4 >> 2] = 0;
           HEAP16[$2 >> 1] = 0;
           HEAP8[$3 | 0] = 0;
           $12 = 1;
           break label$1;
          }
          HEAPF32[$4 >> 2] = $6 / $36;
          $43 = $2;
          label$62 : {
           if (($8 | 0) <= 8) {
            $12 = 0;
            if (($10 | 0) > 0) {
             while (1) {
              $13 = HEAP8[(Math_imul($12, $17) + $5 | 0) + $16 | 0] + $24 | 0;
              $13 = ($13 | 0) > 16 ? $13 : 16;
              HEAP32[($12 << 2) + $1 >> 2] = ($13 | 0) < 144 ? $13 : 144;
              $12 = $12 + 1 | 0;
              if (($12 | 0) != ($10 | 0)) {
               continue;
              }
              break;
             }
            }
            $12 = $24 - 16 | 0;
            break label$62;
           }
           label$66 : {
            if (($8 | 0) == 12) {
             $12 = Math_imul($24 << 16 >> 16, 3);
             $12 = ($12 >> 1) + ($12 & 1) | 0;
             break label$66;
            }
            $12 = $24 << 1;
           }
           label$68 : {
            if (($27 | 0) >= ($30 | 0)) {
             $26 = $27;
             if (($12 | 0) > ($27 | 0)) {
              break label$68;
             }
             $26 = ($12 | 0) < ($31 | 0) ? $31 : $12;
             break label$68;
            }
            $26 = $31;
            if (($12 | 0) >= ($30 | 0)) {
             break label$68;
            }
            $26 = ($12 | 0) < ($27 | 0) ? $27 : $12;
           }
           $29 = 10016;
           $24 = 10040;
           $17 = 12;
           $4 = 12;
           label$70 : {
            switch ($10 - 2 | 0) {
            default:
             celt_fatal(10770, 10329, 518);
             abort();
            case 2:
             $24 = ($9 << 3) + 10240 | 0;
             $17 = HEAP8[$9 + 10264 | 0];
             $29 = 10096;
             $4 = 34;
             break;
            case 0:
             break label$70;
            }
           }
           $12 = $26 + 2 | 0;
           $31 = ($12 | 0) < ($31 | 0) ? $12 : $31;
           $12 = $26 - 2 | 0;
           $28 = ($12 | 0) > ($27 | 0) ? $12 : $27;
           $37 = 0 - $28 << 2;
           $8 = Math_imul($8, 80) + $0 | 0;
           $5 = $8;
           $16 = 0;
           while (1) {
            $12 = $16 << 1;
            $14 = HEAP8[($12 | 1) + $24 | 0];
            $19 = HEAP8[$12 + $24 | 0];
            $12 = 1 - $19 | 0;
            celt_pitch_xcorr_c($5, ($5 + $37 | 0) - ($14 << 2) | 0, $15 + 2720 | 0, $35, $14 + $12 | 0, $11);
            $13 = ($14 | 0) < ($19 | 0);
            if (!$13) {
             $20 = ($13 ? $19 : $14) + $12 | 0;
             $12 = 0;
             $13 = $19;
             while (1) {
              HEAP32[($15 + 11456 | 0) + ($12 << 2) >> 2] = HEAP32[($15 + 2720 | 0) + ($14 - $13 << 2) >> 2];
              $13 = $13 + 1 | 0;
              $12 = $12 + 1 | 0;
              if (($20 | 0) != ($12 | 0)) {
               continue;
              }
              break;
             }
            }
            if (($17 | 0) >= 1) {
             $20 = Math_imul($4, $16);
             $19 = ($15 + 11456 | 0) + (0 - $19 << 2) | 0;
             $12 = 0;
             while (1) {
              $14 = (HEAP8[($12 + $20 | 0) + $29 | 0] << 2) + $19 | 0;
              $33 = HEAP32[$14 >> 2];
              $22 = HEAP32[$14 + 4 >> 2];
              $13 = (Math_imul($16, 680) + $15 | 0) + Math_imul($12, 20) | 0;
              HEAP32[$13 >> 2] = $33;
              HEAP32[$13 + 4 >> 2] = $22;
              HEAP32[$13 + 16 >> 2] = HEAP32[$14 + 16 >> 2];
              $33 = HEAP32[$14 + 12 >> 2];
              $22 = HEAP32[$14 + 8 >> 2];
              HEAP32[$13 + 8 >> 2] = $22;
              HEAP32[$13 + 12 >> 2] = $33;
              $12 = $12 + 1 | 0;
              if (($17 | 0) != ($12 | 0)) {
               continue;
              }
              break;
             }
            }
            $5 = ($35 << 2) + $5 | 0;
            $16 = $16 + 1 | 0;
            if (($16 | 0) != ($10 | 0)) {
             continue;
            }
            break;
           }
           $29 = 10016;
           $24 = 10040;
           $17 = 12;
           $0 = 12;
           label$78 : {
            switch ($10 - 2 | 0) {
            default:
             celt_fatal(10770, 10329, 584);
             abort();
            case 2:
             $24 = ($9 << 3) + 10240 | 0;
             $17 = HEAP8[$9 + 10264 | 0];
             $29 = 10096;
             $0 = 34;
             break;
            case 0:
             break label$78;
            }
           }
           $5 = $8;
           $16 = 0;
           while (1) {
            $12 = $16 << 1;
            $19 = HEAP8[$24 + $12 | 0];
            $13 = $5 - ($28 + $19 << 2) | 0;
            $21 = silk_energy_FLP($13, $35) + .001;
            HEAPF32[$15 + 11456 >> 2] = $21;
            $14 = HEAP8[($12 | 1) + $24 | 0];
            if (($19 | 0) < ($14 | 0)) {
             $12 = 1;
             $20 = ($14 - $19 | 0) + 1 | 0;
             while (1) {
              $23 = +HEAPF32[($35 - $12 << 2) + $13 >> 2];
              $23 = $21 - $23 * $23;
              $14 = $12 << 2;
              $21 = +HEAPF32[$13 - $14 >> 2];
              $21 = $23 + $21 * $21;
              HEAPF32[($15 + 11456 | 0) + $14 >> 2] = $21;
              $12 = $12 + 1 | 0;
              if (($20 | 0) != ($12 | 0)) {
               continue;
              }
              break;
             }
            }
            if (($17 | 0) >= 1) {
             $20 = Math_imul($0, $16);
             $19 = ($15 + 11456 | 0) + (0 - $19 << 2) | 0;
             $12 = 0;
             while (1) {
              $14 = (HEAP8[($12 + $20 | 0) + $29 | 0] << 2) + $19 | 0;
              $33 = HEAP32[$14 >> 2];
              $22 = HEAP32[$14 + 4 >> 2];
              $13 = (($15 + 2720 | 0) + Math_imul($16, 680) | 0) + Math_imul($12, 20) | 0;
              HEAP32[$13 >> 2] = $33;
              HEAP32[$13 + 4 >> 2] = $22;
              HEAP32[$13 + 16 >> 2] = HEAP32[$14 + 16 >> 2];
              $33 = HEAP32[$14 + 12 >> 2];
              $22 = HEAP32[$14 + 8 >> 2];
              HEAP32[$13 + 8 >> 2] = $22;
              HEAP32[$13 + 12 >> 2] = $33;
              $12 = $12 + 1 | 0;
              if (($17 | 0) != ($12 | 0)) {
               continue;
              }
              break;
             }
            }
            $5 = ($35 << 2) + $5 | 0;
            $16 = $16 + 1 | 0;
            if (($16 | 0) != ($10 | 0)) {
             continue;
            }
            break;
           }
           label$86 : {
            if (($10 | 0) != 4) {
             $24 = 10016;
             $0 = 12;
             $19 = 12;
             break label$86;
            }
            $24 = 10096;
            $0 = 34;
            $19 = HEAP8[$9 + 10264 | 0];
           }
           $21 = silk_energy_FLP($8, Math_imul($10, $35));
           $5 = 0;
           if (($28 | 0) <= ($31 | 0)) {
            $7 = Math_fround(Math_fround(.05000000074505806) / Math_fround($26 | 0));
            $34 = $21 + 1;
            $25 = Math_fround(-1e3);
            $29 = ($10 | 0) < 1;
            $20 = 0;
            while (1) {
             $17 = 0;
             if (($19 | 0) > 0) {
              while (1) {
               $18 = Math_fround(0);
               label$92 : {
                if ($29) {
                 break label$92;
                }
                $21 = 0;
                $12 = 0;
                $23 = $34;
                while (1) {
                 $16 = $20 << 2;
                 $14 = Math_imul($17, 20);
                 $13 = Math_imul($12, 680);
                 $23 = $23 + +HEAPF32[$16 + ($14 + ($13 + ($15 + 2720 | 0) | 0) | 0) >> 2];
                 $21 = $21 + +HEAPF32[(($13 + $15 | 0) + $14 | 0) + $16 >> 2];
                 $12 = $12 + 1 | 0;
                 if (($12 | 0) != ($10 | 0)) {
                  continue;
                 }
                 break;
                }
                if ($21 > 0 ^ 1) {
                 break label$92;
                }
                $18 = Math_fround(Math_fround(Math_fround(1) - Math_fround($7 * Math_fround($17 | 0))) * Math_fround(($21 + $21) / $23));
               }
               if (!($18 > $25 ^ 1)) {
                $12 = (HEAP8[$17 + 10096 | 0] + $28 | 0) < ($30 | 0);
                $26 = $12 ? $28 : $26;
                $25 = $12 ? $18 : $25;
                $5 = $12 ? $17 : $5;
               }
               $17 = $17 + 1 | 0;
               if (($19 | 0) != ($17 | 0)) {
                continue;
               }
               break;
              }
             }
             $20 = $20 + 1 | 0;
             $12 = ($28 | 0) < ($31 | 0);
             $28 = $28 + 1 | 0;
             if ($12) {
              continue;
             }
             break;
            }
           }
           if (($10 | 0) >= 1) {
            $12 = 0;
            while (1) {
             $16 = ($12 << 2) + $1 | 0;
             $13 = HEAP8[(Math_imul($0, $12) + $5 | 0) + $24 | 0] + $26 | 0;
             HEAP32[$16 >> 2] = $13;
             label$97 : {
              if (($27 | 0) > ($30 | 0)) {
               $14 = $27;
               if (($14 | 0) < ($13 | 0)) {
                break label$97;
               }
               $14 = ($13 | 0) < ($30 | 0) ? $30 : $13;
               break label$97;
              }
              $14 = $30;
              if (($14 | 0) < ($13 | 0)) {
               break label$97;
              }
              $14 = ($13 | 0) < ($27 | 0) ? $27 : $13;
             }
             HEAP32[$16 >> 2] = $14;
             $12 = $12 + 1 | 0;
             if (($12 | 0) != ($10 | 0)) {
              continue;
             }
             break;
            }
           }
           $12 = $26 - $27 | 0;
          }
          HEAP16[$43 >> 1] = $12;
          HEAP8[$3 | 0] = $5;
          $12 = 0;
          if (HEAP16[$2 >> 1] > -1) {
           break label$1;
          }
          celt_fatal(10737, 10329, 474);
          abort();
         }
         celt_fatal(10267, 10329, 112);
         abort();
        }
        celt_fatal(10366, 10329, 115);
        abort();
       }
       celt_fatal(10418, 10329, 116);
       abort();
      }
      celt_fatal(10470, 10329, 151);
      abort();
     }
     celt_fatal(10500, 10329, 173);
     abort();
    }
    celt_fatal(10580, 10329, 178);
    abort();
   }
   celt_fatal(10622, 10329, 179);
   abort();
  }
  celt_fatal(10701, 10329, 241);
  abort();
 }
 __stack_pointer = $15 + 11552 | 0;
 return $12;
}
function opus_encoder_ctl($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = __stack_pointer - 208 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 204 >> 2] = $2;
 $4 = HEAP32[$0 >> 2] + $0 | 0;
 $2 = -5;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     label$5 : {
      label$6 : {
       label$7 : {
        label$8 : {
         label$9 : {
          label$10 : {
           label$11 : {
            label$12 : {
             label$13 : {
              label$14 : {
               label$15 : {
                label$16 : {
                 label$17 : {
                  label$18 : {
                   label$19 : {
                    label$20 : {
                     label$21 : {
                      label$22 : {
                       label$23 : {
                        label$24 : {
                         label$25 : {
                          switch ($1 - 4e3 | 0) {
                          default:
                           label$46 : {
                            switch ($1 - 10015 | 0) {
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 10:
                             break label$1;
                            case 0:
                             break label$2;
                            case 11:
                             break label$4;
                            case 9:
                             break label$5;
                            default:
                             break label$46;
                            }
                           }
                           switch ($1 - 11002 | 0) {
                           case 17:
                            break label$23;
                           case 16:
                            break label$24;
                           case 0:
                            break label$6;
                           default:
                            break label$1;
                           }
                          case 0:
                           $1 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $1 + 4;
                           $2 = -1;
                           $1 = HEAP32[$1 >> 2];
                           $4 = $1 - 2048 | 0;
                           if ($4 >>> 0 > 3 | ($4 | 0) == 2 | (HEAP32[$0 + 108 >> 2] != ($1 | 0) ? !HEAP32[$0 + 14252 >> 2] : 0)) {
                            break label$1;
                           }
                           HEAP32[$0 + 108 >> 2] = $1;
                           HEAP32[$0 + 192 >> 2] = $1;
                           $2 = 0;
                           break label$1;
                          case 1:
                           $2 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $2 + 4;
                           $2 = HEAP32[$2 >> 2];
                           if (!$2) {
                            $2 = -1;
                            break label$1;
                           }
                           HEAP32[$2 >> 2] = HEAP32[$0 + 108 >> 2];
                           $2 = 0;
                           break label$1;
                          case 2:
                           $2 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $2 + 4;
                           $4 = $0;
                           $1 = HEAP32[$2 >> 2];
                           label$49 : {
                            if (($1 | 0) == -1e3) {
                             $5 = $1;
                             break label$49;
                            }
                            $2 = -1;
                            $5 = $1;
                            if (($1 | 0) == -1) {
                             break label$49;
                            }
                            if (($1 | 0) < 1) {
                             break label$1;
                            }
                            $5 = 500;
                            if (($1 | 0) < 501) {
                             break label$49;
                            }
                            $2 = Math_imul(HEAP32[$0 + 112 >> 2], 3e5);
                            $5 = ($1 | 0) > ($2 | 0) ? $2 : $1;
                           }
                           $2 = $5;
                           HEAP32[$4 + 164 >> 2] = $2;
                           $2 = 0;
                           break label$1;
                          case 3:
                           $2 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $2 + 4;
                           $1 = HEAP32[$2 >> 2];
                           if (!$1) {
                            $2 = -1;
                            break label$1;
                           }
                           $4 = HEAP32[$0 + 14236 >> 2];
                           if (!$4) {
                            $4 = HEAP32[$0 + 144 >> 2] / 400 | 0;
                           }
                           $2 = HEAP32[$0 + 164 >> 2];
                           label$53 : {
                            if (($2 | 0) != -1) {
                             if (($2 | 0) != -1e3) {
                              break label$53;
                             }
                             $2 = HEAP32[$0 + 112 >> 2];
                             $0 = HEAP32[$0 + 144 >> 2];
                             $2 = Math_imul($2, $0) + ((Math_imul($0, 60) | 0) / ($4 | 0) | 0) | 0;
                             break label$53;
                            }
                            $2 = (Math_imul(HEAP32[$0 + 144 >> 2], 10208) | 0) / ($4 | 0) | 0;
                           }
                           HEAP32[$1 >> 2] = $2;
                           $2 = 0;
                           break label$1;
                          case 22:
                           $2 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $2 + 4;
                           $1 = HEAP32[$2 >> 2];
                           label$55 : {
                            if (($1 | 0) >= 1) {
                             $2 = -1;
                             if (HEAP32[$0 + 112 >> 2] >= ($1 | 0)) {
                              break label$55;
                             }
                             break label$1;
                            }
                            $2 = -1;
                            if (($1 | 0) != -1e3) {
                             break label$1;
                            }
                           }
                           HEAP32[$0 + 120 >> 2] = $1;
                           $2 = 0;
                           break label$1;
                          case 23:
                           $2 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $2 + 4;
                           $2 = HEAP32[$2 >> 2];
                           if (!$2) {
                            $2 = -1;
                            break label$1;
                           }
                           HEAP32[$2 >> 2] = HEAP32[$0 + 120 >> 2];
                           $2 = 0;
                           break label$1;
                          case 4:
                           $1 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $1 + 4;
                           $2 = -1;
                           $1 = HEAP32[$1 >> 2];
                           if ($1 - 1101 >>> 0 > 4) {
                            break label$1;
                           }
                           HEAP32[$0 + 132 >> 2] = $1;
                           if (($1 | 0) == 1101) {
                            HEAP32[$0 + 20 >> 2] = 8e3;
                            $2 = 0;
                            break label$1;
                           }
                           if (($1 | 0) == 1102) {
                            HEAP32[$0 + 20 >> 2] = 12e3;
                            $2 = 0;
                            break label$1;
                           }
                           HEAP32[$0 + 20 >> 2] = 16e3;
                           $2 = 0;
                           break label$1;
                          case 5:
                           $2 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $2 + 4;
                           $2 = HEAP32[$2 >> 2];
                           if (!$2) {
                            $2 = -1;
                            break label$1;
                           }
                           HEAP32[$2 >> 2] = HEAP32[$0 + 132 >> 2];
                           $2 = 0;
                           break label$1;
                          case 8:
                           $2 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $2 + 4;
                           $1 = HEAP32[$2 >> 2];
                           if ($1 - 1101 >>> 0 >= 5) {
                            $2 = -1;
                            if (($1 | 0) != -1e3) {
                             break label$1;
                            }
                           }
                           HEAP32[$0 + 128 >> 2] = $1;
                           if (($1 | 0) == 1101) {
                            HEAP32[$0 + 20 >> 2] = 8e3;
                            $2 = 0;
                            break label$1;
                           }
                           if (($1 | 0) == 1102) {
                            HEAP32[$0 + 20 >> 2] = 12e3;
                            $2 = 0;
                            break label$1;
                           }
                           HEAP32[$0 + 20 >> 2] = 16e3;
                           $2 = 0;
                           break label$1;
                          case 9:
                           $2 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $2 + 4;
                           $2 = HEAP32[$2 >> 2];
                           if (!$2) {
                            $2 = -1;
                            break label$1;
                           }
                           HEAP32[$2 >> 2] = HEAP32[$0 + 14240 >> 2];
                           $2 = 0;
                           break label$1;
                          case 16:
                           $1 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $1 + 4;
                           $2 = -1;
                           $1 = HEAP32[$1 >> 2];
                           if ($1 >>> 0 > 1) {
                            break label$1;
                           }
                           HEAP32[$0 + 184 >> 2] = $1;
                           $2 = 0;
                           break label$1;
                          case 17:
                           $2 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $2 + 4;
                           $2 = HEAP32[$2 >> 2];
                           if (!$2) {
                            $2 = -1;
                            break label$1;
                           }
                           HEAP32[$2 >> 2] = HEAP32[$0 + 184 >> 2];
                           $2 = 0;
                           break label$1;
                          case 10:
                           $1 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $1 + 4;
                           $2 = -1;
                           $1 = HEAP32[$1 >> 2];
                           if ($1 >>> 0 > 10) {
                            break label$1;
                           }
                           HEAP32[$0 + 44 >> 2] = $1;
                           HEAP32[$3 >> 2] = $1;
                           opus_custom_encoder_ctl($4, 4010, $3);
                           $2 = 0;
                           break label$1;
                          case 11:
                           $2 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $2 + 4;
                           $2 = HEAP32[$2 >> 2];
                           if (!$2) {
                            $2 = -1;
                            break label$1;
                           }
                           HEAP32[$2 >> 2] = HEAP32[$0 + 44 >> 2];
                           $2 = 0;
                           break label$1;
                          case 12:
                           $1 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $1 + 4;
                           $2 = -1;
                           $1 = HEAP32[$1 >> 2];
                           if ($1 >>> 0 > 1) {
                            break label$1;
                           }
                           HEAP32[$0 + 48 >> 2] = $1;
                           $2 = 0;
                           break label$1;
                          case 13:
                           $2 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $2 + 4;
                           $2 = HEAP32[$2 >> 2];
                           if (!$2) {
                            $2 = -1;
                            break label$1;
                           }
                           HEAP32[$2 >> 2] = HEAP32[$0 + 48 >> 2];
                           $2 = 0;
                           break label$1;
                          case 14:
                           $1 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $1 + 4;
                           $2 = -1;
                           $1 = HEAP32[$1 >> 2];
                           if ($1 >>> 0 > 100) {
                            break label$1;
                           }
                           HEAP32[$0 + 40 >> 2] = $1;
                           HEAP32[$3 + 16 >> 2] = $1;
                           opus_custom_encoder_ctl($4, 4014, $3 + 16 | 0);
                           $2 = 0;
                           break label$1;
                          case 15:
                           $2 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $2 + 4;
                           $2 = HEAP32[$2 >> 2];
                           if (!$2) {
                            $2 = -1;
                            break label$1;
                           }
                           HEAP32[$2 >> 2] = HEAP32[$0 + 40 >> 2];
                           $2 = 0;
                           break label$1;
                          case 6:
                           $1 = HEAP32[$3 + 204 >> 2];
                           HEAP32[$3 + 204 >> 2] = $1 + 4;
                           $2 = -1;
                           $1 = HEAP32[$1 >> 2];
                           if ($1 >>> 0 > 1) {
                            break label$1;
                           }
                           HEAP32[$0 + 148 >> 2] = $1;
                           HEAP32[$0 + 60 >> 2] = 1 - $1;
                           $2 = 0;
                           break label$1;
                          case 18:
                          case 19:
                          case 26:
                          case 30:
                          case 32:
                          case 33:
                          case 34:
                          case 35:
                          case 38:
                          case 39:
                          case 44:
                          case 45:
                          case 48:
                           break label$1;
                          case 43:
                           break label$10;
                          case 42:
                           break label$11;
                          case 41:
                           break label$12;
                          case 40:
                           break label$13;
                          case 37:
                           break label$14;
                          case 36:
                           break label$15;
                          case 31:
                           break label$16;
                          case 29:
                           break label$17;
                          case 27:
                           break label$18;
                          case 25:
                           break label$19;
                          case 24:
                           break label$20;
                          case 21:
                           break label$21;
                          case 20:
                           break label$22;
                          case 7:
                           break label$25;
                          case 49:
                           break label$3;
                          case 28:
                           break label$7;
                          case 47:
                           break label$8;
                          case 46:
                           break label$9;
                          }
                         }
                         $2 = HEAP32[$3 + 204 >> 2];
                         HEAP32[$3 + 204 >> 2] = $2 + 4;
                         $2 = HEAP32[$2 >> 2];
                         if (!$2) {
                          $2 = -1;
                          break label$1;
                         }
                         HEAP32[$2 >> 2] = HEAP32[$0 + 148 >> 2];
                         $2 = 0;
                         break label$1;
                        }
                        $1 = HEAP32[$3 + 204 >> 2];
                        HEAP32[$3 + 204 >> 2] = $1 + 4;
                        $2 = -1;
                        $1 = HEAP32[$1 >> 2];
                        if ($1 + 1 >>> 0 > 101) {
                         break label$1;
                        }
                        HEAP32[$0 + 140 >> 2] = $1;
                        $2 = 0;
                        break label$1;
                       }
                       $2 = HEAP32[$3 + 204 >> 2];
                       HEAP32[$3 + 204 >> 2] = $2 + 4;
                       $2 = HEAP32[$2 >> 2];
                       if (!$2) {
                        $2 = -1;
                        break label$1;
                       }
                       HEAP32[$2 >> 2] = HEAP32[$0 + 140 >> 2];
                       $2 = 0;
                       break label$1;
                      }
                      $1 = HEAP32[$3 + 204 >> 2];
                      HEAP32[$3 + 204 >> 2] = $1 + 4;
                      $2 = -1;
                      $1 = HEAP32[$1 >> 2];
                      if ($1 >>> 0 > 1) {
                       break label$1;
                      }
                      HEAP32[$0 + 152 >> 2] = $1;
                      $2 = 0;
                      break label$1;
                     }
                     $2 = HEAP32[$3 + 204 >> 2];
                     HEAP32[$3 + 204 >> 2] = $2 + 4;
                     $2 = HEAP32[$2 >> 2];
                     if (!$2) {
                      $2 = -1;
                      break label$1;
                     }
                     HEAP32[$2 >> 2] = HEAP32[$0 + 152 >> 2];
                     $2 = 0;
                     break label$1;
                    }
                    $2 = HEAP32[$3 + 204 >> 2];
                    HEAP32[$3 + 204 >> 2] = $2 + 4;
                    $1 = HEAP32[$2 >> 2];
                    if ($1 - 3001 >>> 0 >= 2) {
                     $2 = -1;
                     if (($1 | 0) != -1e3) {
                      break label$1;
                     }
                    }
                    HEAP32[$0 + 124 >> 2] = $1;
                    $2 = 0;
                    break label$1;
                   }
                   $2 = HEAP32[$3 + 204 >> 2];
                   HEAP32[$3 + 204 >> 2] = $2 + 4;
                   $2 = HEAP32[$2 >> 2];
                   if (!$2) {
                    $2 = -1;
                    break label$1;
                   }
                   HEAP32[$2 >> 2] = HEAP32[$0 + 124 >> 2];
                   $2 = 0;
                   break label$1;
                  }
                  $2 = HEAP32[$3 + 204 >> 2];
                  HEAP32[$3 + 204 >> 2] = $2 + 4;
                  $1 = HEAP32[$2 >> 2];
                  if (!$1) {
                   $2 = -1;
                   break label$1;
                  }
                  $4 = HEAP32[$0 + 144 >> 2] / 400 | 0;
                  HEAP32[$1 >> 2] = $4;
                  $2 = 0;
                  if (HEAP32[$0 + 108 >> 2] == 2051) {
                   break label$1;
                  }
                  HEAP32[$1 >> 2] = HEAP32[$0 + 116 >> 2] + $4;
                  break label$1;
                 }
                 $2 = HEAP32[$3 + 204 >> 2];
                 HEAP32[$3 + 204 >> 2] = $2 + 4;
                 $2 = HEAP32[$2 >> 2];
                 if (!$2) {
                  $2 = -1;
                  break label$1;
                 }
                 HEAP32[$2 >> 2] = HEAP32[$0 + 144 >> 2];
                 $2 = 0;
                 break label$1;
                }
                $2 = HEAP32[$3 + 204 >> 2];
                HEAP32[$3 + 204 >> 2] = $2 + 4;
                $2 = HEAP32[$2 >> 2];
                if (!$2) {
                 $2 = -1;
                 break label$1;
                }
                HEAP32[$2 >> 2] = HEAP32[$0 + 18136 >> 2];
                $2 = 0;
                break label$1;
               }
               $1 = HEAP32[$3 + 204 >> 2];
               HEAP32[$3 + 204 >> 2] = $1 + 4;
               $2 = -1;
               $1 = HEAP32[$1 >> 2];
               if ($1 - 8 >>> 0 > 16) {
                break label$1;
               }
               HEAP32[$0 + 168 >> 2] = $1;
               $2 = 0;
               break label$1;
              }
              $2 = HEAP32[$3 + 204 >> 2];
              HEAP32[$3 + 204 >> 2] = $2 + 4;
              $2 = HEAP32[$2 >> 2];
              if (!$2) {
               $2 = -1;
               break label$1;
              }
              HEAP32[$2 >> 2] = HEAP32[$0 + 168 >> 2];
              $2 = 0;
              break label$1;
             }
             $1 = HEAP32[$3 + 204 >> 2];
             HEAP32[$3 + 204 >> 2] = $1 + 4;
             $2 = -1;
             $1 = HEAP32[$1 >> 2];
             if ($1 - 5e3 >>> 0 > 9) {
              break label$1;
             }
             HEAP32[$0 + 156 >> 2] = $1;
             $2 = 0;
             break label$1;
            }
            $2 = HEAP32[$3 + 204 >> 2];
            HEAP32[$3 + 204 >> 2] = $2 + 4;
            $2 = HEAP32[$2 >> 2];
            if (!$2) {
             $2 = -1;
             break label$1;
            }
            HEAP32[$2 >> 2] = HEAP32[$0 + 156 >> 2];
            $2 = 0;
            break label$1;
           }
           $1 = HEAP32[$3 + 204 >> 2];
           HEAP32[$3 + 204 >> 2] = $1 + 4;
           $2 = -1;
           $1 = HEAP32[$1 >> 2];
           if ($1 >>> 0 > 1) {
            break label$1;
           }
           HEAP32[$0 + 76 >> 2] = $1;
           $2 = 0;
           break label$1;
          }
          $2 = HEAP32[$3 + 204 >> 2];
          HEAP32[$3 + 204 >> 2] = $2 + 4;
          $2 = HEAP32[$2 >> 2];
          if (!$2) {
           $2 = -1;
           break label$1;
          }
          HEAP32[$2 >> 2] = HEAP32[$0 + 76 >> 2];
          $2 = 0;
          break label$1;
         }
         $0 = HEAP32[$3 + 204 >> 2];
         HEAP32[$3 + 204 >> 2] = $0 + 4;
         $2 = -1;
         $0 = HEAP32[$0 >> 2];
         if ($0 >>> 0 > 1) {
          break label$1;
         }
         HEAP32[$3 + 32 >> 2] = $0;
         opus_custom_encoder_ctl($4, 4046, $3 + 32 | 0);
         $2 = 0;
         break label$1;
        }
        $0 = HEAP32[$3 + 204 >> 2];
        HEAP32[$3 + 204 >> 2] = $0 + 4;
        $0 = HEAP32[$0 >> 2];
        if (!$0) {
         $2 = -1;
         break label$1;
        }
        HEAP32[$3 + 48 >> 2] = $0;
        opus_custom_encoder_ctl($4, 4047, $3 + 48 | 0);
        $2 = 0;
        break label$1;
       }
       $1 = HEAP32[$0 + 4 >> 2];
       tonality_analysis_reset($0 + 188 | 0);
       $2 = 0;
       memset($0 + 14192 | 0, 0, 3948);
       opus_custom_encoder_ctl($4, 4028, 0);
       silk_InitEncoder($0 + $1 | 0, HEAP32[$0 + 180 >> 2], $3 + 104 | 0);
       HEAP32[$0 + 14252 >> 2] = 1;
       HEAP32[$0 + 14204 >> 2] = 1065353216;
       HEAP16[$0 + 14196 >> 1] = 16384;
       HEAP32[$0 + 14240 >> 2] = 1105;
       HEAP32[$0 + 14224 >> 2] = 1001;
       HEAP32[$0 + 14192 >> 2] = HEAP32[$0 + 112 >> 2];
       HEAP32[$0 + 14200 >> 2] = silk_lin2log(60) << 8;
       break label$1;
      }
      $2 = HEAP32[$3 + 204 >> 2];
      HEAP32[$3 + 204 >> 2] = $2 + 4;
      $1 = HEAP32[$2 >> 2];
      if ($1 - 1e3 >>> 0 >= 3) {
       $2 = -1;
       if (($1 | 0) != -1e3) {
        break label$1;
       }
      }
      HEAP32[$0 + 136 >> 2] = $1;
      $2 = 0;
      break label$1;
     }
     $2 = HEAP32[$3 + 204 >> 2];
     HEAP32[$3 + 204 >> 2] = $2 + 4;
     $2 = HEAP32[$2 >> 2];
     HEAP32[$0 + 176 >> 2] = $2;
     HEAP32[$3 + 64 >> 2] = $2;
     $2 = opus_custom_encoder_ctl($4, 10024, $3 - -64 | 0);
     break label$1;
    }
    $2 = HEAP32[$3 + 204 >> 2];
    HEAP32[$3 + 204 >> 2] = $2 + 4;
    $2 = HEAP32[$2 >> 2];
    HEAP32[$0 + 14256 >> 2] = $2;
    HEAP32[$3 + 80 >> 2] = $2;
    $2 = opus_custom_encoder_ctl($4, 10026, $3 + 80 | 0);
    break label$1;
   }
   $2 = HEAP32[$3 + 204 >> 2];
   HEAP32[$3 + 204 >> 2] = $2 + 4;
   $6 = HEAP32[$2 >> 2];
   if (!$6) {
    $2 = -1;
    break label$1;
   }
   if (!(!HEAP32[$0 + 56 >> 2] | (HEAP32[$0 + 14228 >> 2] & -2) != 1e3)) {
    $2 = HEAP32[$0 + 4 >> 2];
    HEAP32[$6 >> 2] = 1;
    if (HEAP32[$0 + 12 >> 2] < 1) {
     $2 = 0;
     break label$1;
    }
    $7 = $0 + $2 | 0;
    $4 = 0;
    $5 = 1;
    while (1) {
     $1 = 0;
     $1 = $5 ? HEAP32[(Math_imul($4, 10064) + $7 | 0) + 6084 >> 2] > 9 : $1;
     HEAP32[$6 >> 2] = $1;
     $2 = 0;
     $5 = $1;
     $4 = $4 + 1 | 0;
     if (($4 | 0) < HEAP32[$0 + 12 >> 2]) {
      continue;
     }
     break;
    }
    break label$1;
   }
   if (HEAP32[$0 + 184 >> 2]) {
    HEAP32[$6 >> 2] = HEAP32[$0 + 18124 >> 2] > 9;
    $2 = 0;
    break label$1;
   }
   $2 = 0;
   HEAP32[$6 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$3 + 204 >> 2];
  HEAP32[$3 + 204 >> 2] = $0 + 4;
  $0 = HEAP32[$0 >> 2];
  if (!$0) {
   $2 = -1;
   break label$1;
  }
  HEAP32[$3 + 96 >> 2] = $0;
  $2 = opus_custom_encoder_ctl($4, 10015, $3 + 96 | 0);
 }
 __stack_pointer = $3 + 208 | 0;
 return $2 | 0;
}
function silk_Encode($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0;
 $16 = __stack_pointer - 32 | 0;
 $15 = $16;
 __stack_pointer = $15;
 if (HEAP32[$1 + 68 >> 2]) {
  HEAP32[$0 + 14728 >> 2] = 1;
  HEAP32[$0 + 4664 >> 2] = 1;
 }
 HEAP32[$0 + 5748 >> 2] = 0;
 HEAP32[$0 + 15812 >> 2] = 0;
 if (!check_control_input($1)) {
  $34 = $0 + 10064 | 0;
  HEAP32[$1 + 88 >> 2] = 0;
  label$3 : {
   if (HEAP32[$1 + 4 >> 2] <= HEAP32[$0 + 20196 >> 2]) {
    break label$3;
   }
   $14 = silk_init_encoder($34, HEAP32[$0 + 5092 >> 2]);
   HEAP32[$0 + 20144 >> 2] = 1;
   HEAP32[$0 + 20148 >> 2] = 0;
   HEAP32[$0 + 20136 >> 2] = 0;
   HEAP32[$0 + 20140 >> 2] = 0;
   HEAP32[$0 + 20128 >> 2] = 0;
   HEAP32[$0 + 20152 >> 2] = 1;
   HEAP32[$0 + 20156 >> 2] = 16384;
   if (HEAP32[$0 + 20192 >> 2] != 2) {
    break label$3;
   }
   memcpy($0 + 15840 | 0, $0 + 5776 | 0, 300);
   $20 = HEAP32[$0 + 4 >> 2];
   $12 = HEAP32[$0 >> 2];
   HEAP32[$0 + 10064 >> 2] = $12;
   HEAP32[$0 + 10068 >> 2] = $20;
  }
  $24 = HEAP32[$1 + 24 >> 2];
  label$4 : {
   if (($24 | 0) != HEAP32[$0 + 4612 >> 2]) {
    $8 = HEAP32[$1 + 4 >> 2];
    $21 = 1;
    break label$4;
   }
   $8 = HEAP32[$1 + 4 >> 2];
   $21 = ($8 | 0) != HEAP32[$0 + 20196 >> 2];
  }
  $9 = HEAP32[$1 >> 2];
  HEAP32[$0 + 20196 >> 2] = $8;
  HEAP32[$0 + 20192 >> 2] = $9;
  $10 = Math_imul($3, 100);
  $9 = HEAP32[$1 + 8 >> 2];
  $18 = ($10 | 0) / ($9 | 0) | 0;
  label$6 : {
   label$7 : {
    label$8 : {
     label$9 : {
      if ($6) {
       if (($18 | 0) != 1) {
        break label$6;
       }
       if (($6 | 0) == 2) {
        $12 = HEAP32[$0 + 28 >> 2];
        $20 = HEAP32[$0 + 24 >> 2];
        HEAP32[$15 + 24 >> 2] = $20;
        HEAP32[$15 + 28 >> 2] = $12;
        $20 = HEAP32[$0 + 20 >> 2];
        $12 = HEAP32[$0 + 16 >> 2];
        HEAP32[$15 + 16 >> 2] = $12;
        HEAP32[$15 + 20 >> 2] = $20;
        $13 = HEAP32[$0 + 4576 >> 2];
       }
       $9 = 0;
       label$12 : {
        if (($8 | 0) > 0) {
         $11 = ($6 | 0) != 2;
         $23 = $15;
         break label$12;
        }
        HEAP32[$1 + 24 >> 2] = 10;
        $35 = HEAP32[$1 + 36 >> 2];
        HEAP32[$1 + 36 >> 2] = 0;
        break label$9;
       }
       label$14 : {
        while (1) {
         $8 = Math_imul($9, 10064) + $0 | 0;
         $10 = silk_init_encoder($8, HEAP32[$8 + 5092 >> 2]);
         if (!$11) {
          $12 = HEAP32[$15 + 20 >> 2];
          $20 = HEAP32[$15 + 16 >> 2];
          HEAP32[$8 + 16 >> 2] = $20;
          HEAP32[$8 + 20 >> 2] = $12;
          $20 = HEAP32[$23 + 28 >> 2];
          $12 = HEAP32[$23 + 24 >> 2];
          HEAP32[$8 + 24 >> 2] = $12;
          HEAP32[$8 + 28 >> 2] = $20;
          HEAP32[$8 + 32 >> 2] = $13;
         }
         if (!$10) {
          $8 = HEAP32[$1 + 4 >> 2];
          $9 = $9 + 1 | 0;
          if (($8 | 0) <= ($9 | 0)) {
           break label$14;
          }
          continue;
         }
         break;
        }
        celt_fatal(17522, 17507, 222);
        abort();
       }
       $24 = HEAP32[$1 + 24 >> 2];
       HEAP32[$1 + 24 >> 2] = 10;
       $35 = HEAP32[$1 + 36 >> 2];
       $14 = 0;
       HEAP32[$1 + 36 >> 2] = 0;
       if (($8 | 0) < 1) {
        break label$9;
       }
       while (1) {
        $9 = Math_imul($14, 10064) + $0 | 0;
        HEAP32[$9 + 4680 >> 2] = 1;
        HEAP32[$9 + 4668 >> 2] = 0;
        $14 = $14 + 1 | 0;
        if (($14 | 0) != ($8 | 0)) {
         continue;
        }
        break;
       }
       $14 = 0;
       break label$9;
      }
      if ((Math_imul($9, $18) | 0) != ($10 | 0) | ($3 | 0) < 0) {
       break label$7;
      }
      $9 = Math_imul($9, $24);
      $24 = 0;
      if ((Math_imul($3, 1e3) | 0) > ($9 | 0)) {
       break label$8;
      }
     }
     label$19 : {
      label$20 : {
       label$21 : {
        label$22 : {
         if (($8 | 0) < 1) {
          break label$22;
         }
         $11 = $21 ^ -1;
         $10 = 0;
         while (1) {
          $8 = 0;
          $9 = Math_imul($10, 10064) + $0 | 0;
          $8 = ($10 | 0) == 1 ? HEAP32[$0 + 4576 >> 2] : $8;
          $14 = silk_control_encoder($9, $1, HEAP32[$0 + 20208 >> 2], $10, $8);
          if ($14) {
           break label$20;
          }
          label$26 : {
           if (!HEAP32[$9 + 4664 >> 2] & $11) {
            break label$26;
           }
           $8 = 0;
           if (HEAP32[$0 + 5744 >> 2] < 1) {
            break label$26;
           }
           while (1) {
            HEAP32[(($8 << 2) + $9 | 0) + 4724 >> 2] = 0;
            $8 = $8 + 1 | 0;
            if (($8 | 0) < HEAP32[$0 + 5744 >> 2]) {
             continue;
            }
            break;
           }
          }
          HEAP32[$9 + 6080 >> 2] = HEAP32[$9 + 6076 >> 2];
          $8 = HEAP32[$1 + 4 >> 2];
          $10 = $10 + 1 | 0;
          if (($8 | 0) > ($10 | 0)) {
           continue;
          }
          break;
         }
         $14 = 0;
         if (($8 | 0) != 1) {
          break label$22;
         }
         $8 = HEAP32[$0 + 4576 >> 2];
         break label$21;
        }
        $8 = HEAP32[$0 + 4576 >> 2];
        if (($8 | 0) != HEAP32[$0 + 14640 >> 2]) {
         break label$19;
        }
       }
       $27 = ($18 | 0) > 1 ? $18 >> 1 : 1;
       $39 = $27 << 1;
       $40 = $27 - 1 | 0;
       $41 = $0 + 10212 | 0;
       $20 = $0 + 17232 | 0;
       $36 = $0 + 14784 | 0;
       $42 = $0 + 15164 | 0;
       $43 = $0 + 5100 | 0;
       $44 = $0 + 20128 | 0;
       $25 = $0 + 20180 | 0;
       $45 = $0 + 14788 | 0;
       $29 = $0 + 20162 | 0;
       $30 = $0 + 15160 | 0;
       $31 = $0 + 15840 | 0;
       $26 = $0 + 5096 | 0;
       $28 = $0 + 5776 | 0;
       $37 = Math_imul($18, 10);
       $32 = Math_imul($37, $8);
       $22 = $16 - (((Math_imul($32, HEAP32[$0 + 4556 >> 2]) | 0) / (Math_imul($8, 1e3) | 0) << 1) + 15 & -16) | 0;
       __stack_pointer = $22;
       $21 = 0;
       label$28 : {
        while (1) {
         $10 = HEAP32[$0 + 5740 >> 2];
         $8 = HEAP32[$0 + 4584 >> 2] - $10 | 0;
         $11 = ($8 | 0) < ($32 | 0) ? $8 : $32;
         $19 = (Math_imul($11, HEAP32[$0 + 4556 >> 2]) | 0) / (Math_imul(HEAP32[$0 + 4576 >> 2], 1e3) | 0) | 0;
         label$30 : {
          label$31 : {
           label$32 : {
            label$33 : {
             label$34 : {
              label$35 : {
               label$36 : {
                switch (HEAP32[$1 >> 2] - 1 | 0) {
                case 1:
                 label$38 : {
                  switch (HEAP32[$1 + 4 >> 2] - 1 | 0) {
                  case 1:
                   $9 = HEAP32[$0 + 5748 >> 2];
                   $8 = 0;
                   $13 = ($19 | 0) < 1;
                   if (!$13) {
                    while (1) {
                     HEAP16[($8 << 1) + $22 >> 1] = HEAPU16[($8 << 2) + $2 >> 1];
                     $8 = $8 + 1 | 0;
                     if (($19 | 0) != ($8 | 0)) {
                      continue;
                     }
                     break;
                    }
                   }
                   if (!(HEAP32[$0 + 20200 >> 2] != 1 | $9)) {
                    memcpy($31, $28, 300);
                   }
                   $8 = silk_resampler($28, (($10 << 1) + $26 | 0) + 4 | 0, $22, $19);
                   HEAP32[$0 + 5740 >> 2] = HEAP32[$0 + 5740 >> 2] + $11;
                   $9 = HEAP32[$0 + 15804 >> 2];
                   $10 = HEAP32[$0 + 14648 >> 2] - $9 | 0;
                   $11 = Math_imul(HEAP32[$0 + 14640 >> 2], $37);
                   $10 = ($10 | 0) < ($11 | 0) ? $10 : $11;
                   $11 = $8 + $14 | 0;
                   $8 = 0;
                   if (!$13) {
                    while (1) {
                     HEAP16[($8 << 1) + $22 >> 1] = HEAPU16[($8 << 2 | 2) + $2 >> 1];
                     $8 = $8 + 1 | 0;
                     if (($19 | 0) != ($8 | 0)) {
                      continue;
                     }
                     break;
                    }
                   }
                   $8 = silk_resampler($31, (($9 << 1) + $30 | 0) + 4 | 0, $22, $19);
                   HEAP32[$0 + 15804 >> 2] = HEAP32[$0 + 15804 >> 2] + $10;
                   $14 = $8 + $11 | 0;
                   $8 = HEAP32[$0 + 5740 >> 2];
                   break label$35;
                  case 0:
                   break label$38;
                  default:
                   break label$34;
                  }
                 }
                 $8 = 0;
                 if (($19 | 0) >= 1) {
                  while (1) {
                   $9 = $8 << 2;
                   $9 = HEAP16[($9 | 2) + $2 >> 1] + HEAP16[$2 + $9 >> 1] | 0;
                   HEAP16[($8 << 1) + $22 >> 1] = ($9 >>> 1 | 0) + ($9 & 1);
                   $8 = $8 + 1 | 0;
                   if (($19 | 0) != ($8 | 0)) {
                    continue;
                   }
                   break;
                  }
                 }
                 $14 = silk_resampler($28, (($10 << 1) + $26 | 0) + 4 | 0, $22, $19) + $14 | 0;
                 label$47 : {
                  if (HEAP32[$0 + 5748 >> 2] | HEAP32[$0 + 20200 >> 2] != 2) {
                   break label$47;
                  }
                  $14 = silk_resampler($31, ((HEAP32[$0 + 15804 >> 2] << 1) + $30 | 0) + 4 | 0, $22, $19) + $14 | 0;
                  $13 = HEAP32[$0 + 4584 >> 2];
                  if (($13 | 0) < 1) {
                   break label$47;
                  }
                  $17 = HEAP32[$0 + 15804 >> 2];
                  $18 = HEAP32[$0 + 5740 >> 2];
                  $8 = 0;
                  while (1) {
                   $9 = $8 + 2 | 0;
                   $10 = ($18 + $9 << 1) + $26 | 0;
                   HEAP16[$10 >> 1] = HEAP16[($9 + $17 << 1) + $30 >> 1] + HEAP16[$10 >> 1] >>> 1;
                   $8 = $8 + 1 | 0;
                   if (($13 | 0) != ($8 | 0)) {
                    continue;
                   }
                   break;
                  }
                 }
                 $8 = HEAP32[$0 + 5740 >> 2] + $11 | 0;
                 HEAP32[$0 + 5740 >> 2] = $8;
                 break label$35;
                case 0:
                 break label$36;
                default:
                 break label$34;
                }
               }
               if (HEAP32[$1 + 4 >> 2] != 1) {
                break label$34;
               }
               $9 = silk_resampler($28, (($10 << 1) + $26 | 0) + 4 | 0, memcpy($22, $2, $19 << 1), $19);
               $8 = HEAP32[$0 + 5740 >> 2] + $11 | 0;
               HEAP32[$0 + 5740 >> 2] = $8;
               $14 = $9 + $14 | 0;
              }
              $46 = HEAP32[$1 >> 2];
              HEAP32[$0 + 20208 >> 2] = 0;
              $9 = HEAP32[$0 + 4584 >> 2];
              $12 = 0;
              if (($9 | 0) > ($8 | 0)) {
               break label$28;
              }
              if (($8 | 0) != ($9 | 0)) {
               break label$33;
              }
              $8 = HEAP32[$1 + 4 >> 2];
              if (HEAP32[$0 + 15804 >> 2] != HEAP32[$0 + 14648 >> 2] ? ($8 | 0) != 1 : 0) {
               break label$32;
              }
              if (HEAP32[$0 + 5748 >> 2] | $6) {
               break label$30;
              }
              $17 = 0;
              HEAP16[$15 + 14 >> 1] = 0;
              HEAP8[$15 + 14 | 0] = 0 - (256 >>> Math_imul(HEAP32[$0 + 5744 >> 2] + 1 | 0, $8) | 0);
              ec_enc_icdf($4, 0, $15 + 14 | 0, 8);
              $11 = HEAP32[$1 + 4 >> 2];
              if (($11 | 0) <= 0) {
               break label$31;
              }
              while (1) {
               $8 = 0;
               $9 = 0;
               $13 = Math_imul($17, 10064) + $0 | 0;
               $10 = HEAP32[$13 + 5744 >> 2];
               if (($10 | 0) >= 1) {
                while (1) {
                 $9 = HEAP32[(($8 << 2) + $13 | 0) + 4724 >> 2] << $8 | $9;
                 $8 = $8 + 1 | 0;
                 if (($10 | 0) != ($8 | 0)) {
                  continue;
                 }
                 break;
                }
               }
               HEAP8[$13 + 4723 | 0] = ($9 | 0) > 0;
               if (!(!$9 | ($10 | 0) < 2)) {
                ec_enc_icdf($4, $9 - 1 | 0, HEAP32[($10 << 2) + 5808 >> 2], 8);
                $11 = HEAP32[$1 + 4 >> 2];
               }
               $17 = $17 + 1 | 0;
               if (($17 | 0) < ($11 | 0)) {
                continue;
               }
               break;
              }
              break label$31;
             }
             celt_fatal(17672, 17507, 320);
             abort();
            }
            celt_fatal(17758, 17507, 336);
            abort();
           }
           celt_fatal(17857, 17507, 337);
           abort();
          }
          $10 = 0;
          if (HEAP32[$0 + 5744 >> 2] > 0) {
           while (1) {
            if (($11 | 0) >= 1) {
             $17 = $10 - 1 | 0;
             $33 = $10 + $25 | 0;
             $13 = $10 << 2;
             $18 = $45 + $13 | 0;
             $16 = Math_imul($10, 6) + $29 | 0;
             $9 = 0;
             while (1) {
              $8 = Math_imul($9, 10064) + $0 | 0;
              if (HEAP32[($13 + $8 | 0) + 4724 >> 2]) {
               label$59 : {
                if (($11 | 0) != 2 | $9) {
                 break label$59;
                }
                silk_stereo_encode_pred($4, $16);
                if (HEAP32[$18 >> 2]) {
                 break label$59;
                }
                silk_stereo_encode_mid_only($4, HEAP8[$33 | 0]);
               }
               $12 = $8;
               $23 = $4;
               $47 = $10;
               label$60 : {
                if ($10) {
                 $11 = 2;
                 if (HEAP32[(($17 << 2) + $8 | 0) + 4724 >> 2]) {
                  break label$60;
                 }
                }
                $11 = 0;
               }
               silk_encode_indices($12, $23, $47, 1, $11);
               $11 = Math_imul($10, 36) + $8 | 0;
               silk_encode_pulses($4, HEAP8[$11 + 6129 | 0], HEAP8[$11 + 6130 | 0], (Math_imul($10, 320) + $8 | 0) + 6208 | 0, HEAP32[$8 + 4584 >> 2]);
               $11 = HEAP32[$1 + 4 >> 2];
              }
              $9 = $9 + 1 | 0;
              if (($11 | 0) > ($9 | 0)) {
               continue;
              }
              break;
             }
            }
            $10 = $10 + 1 | 0;
            if (($10 | 0) < HEAP32[$0 + 5744 >> 2]) {
             continue;
            }
            break;
           }
          }
          $8 = 0;
          if (($11 | 0) > 0) {
           while (1) {
            $9 = Math_imul($8, 10064) + $0 | 0;
            HEAP32[$9 + 4724 >> 2] = 0;
            HEAP32[$9 + 4728 >> 2] = 0;
            HEAP32[$9 + 4732 >> 2] = 0;
            $8 = $8 + 1 | 0;
            if (($8 | 0) < HEAP32[$1 + 4 >> 2]) {
             continue;
            }
            break;
           }
          }
          HEAP32[$0 + 20184 >> 2] = (HEAP32[$4 + 20 >> 2] + Math_clz32(HEAP32[$4 + 28 >> 2]) | 0) - 32;
         }
         silk_HP_variable_cutoff($0);
         $8 = HEAP32[$1 + 28 >> 2];
         $10 = HEAP32[$1 + 24 >> 2];
         $9 = (Math_imul($8, $10) | 0) / 1e3 | 0;
         $9 = $6 ? $9 : $9 - HEAP32[$0 + 20184 >> 2] | 0;
         $11 = ($9 | 0) / HEAP32[$0 + 5744 >> 2] | 0;
         $9 = Math_imul($11 << 16 >> 16, ($10 | 0) == 10 ? 100 : 50) - (HEAP32[$0 + 20188 >> 2] << 1) | 0;
         label$65 : {
          if ($6) {
           break label$65;
          }
          $10 = HEAP32[$0 + 5748 >> 2];
          if (($10 | 0) < 1) {
           break label$65;
          }
          $9 = ((HEAP32[$0 + 20184 >> 2] + ((Math_imul($10, $11) - HEAP32[$4 + 20 >> 2] | 0) - Math_clz32(HEAP32[$4 + 28 >> 2]) | 0) << 1) + $9 | 0) - -64 | 0;
         }
         label$66 : {
          if (($8 | 0) >= 5001) {
           $16 = $8;
           if (($8 | 0) < ($9 | 0)) {
            break label$66;
           }
           $16 = ($9 | 0) > 5e3 ? $9 : 5e3;
           break label$66;
          }
          $16 = 5e3;
          if (($9 | 0) > 5e3) {
           break label$66;
          }
          $16 = ($8 | 0) > ($9 | 0) ? $8 : $9;
         }
         label$68 : {
          if (HEAP32[$1 + 4 >> 2] == 2) {
           $8 = HEAP32[$0 + 5748 >> 2];
           silk_stereo_LR_to_MS($44, $43, $42, Math_imul($8, 6) + $29 | 0, $8 + $25 | 0, $15 + 16 | 0, $16, HEAP32[$0 + 4532 >> 2], HEAP32[$1 + 60 >> 2], HEAP32[$0 + 4576 >> 2], HEAP32[$0 + 4584 >> 2]);
           $8 = HEAP32[$0 + 5748 >> 2];
           label$70 : {
            if (!HEAPU8[$25 + $8 | 0]) {
             if (HEAP32[$0 + 20212 >> 2] == 1) {
              $12 = $20;
              HEAP32[$12 >> 2] = 0;
              HEAP32[$12 + 4 >> 2] = 0;
              HEAP32[$12 + 8 >> 2] = 0;
              HEAP32[$0 + 10080 >> 2] = 0;
              HEAP32[$0 + 10084 >> 2] = 0;
              memset($41, 0, 4384);
              HEAP8[$0 + 17232 | 0] = 10;
              HEAP32[$0 + 14540 >> 2] = 100;
              HEAP32[$0 + 14608 >> 2] = 100;
              HEAP8[$0 + 14605 | 0] = 0;
              HEAP32[$0 + 14728 >> 2] = 1;
              HEAP32[$0 + 14556 >> 2] = 65536;
             }
             silk_encode_do_VAD_FLP($34, $7);
             break label$70;
            }
            HEAP8[$8 + $36 | 0] = 0;
           }
           if ($6) {
            break label$68;
           }
           silk_stereo_encode_pred($4, Math_imul(HEAP32[$0 + 5748 >> 2], 6) + $29 | 0);
           $8 = HEAP32[$0 + 5748 >> 2];
           if (HEAPU8[$36 + $8 | 0]) {
            break label$68;
           }
           silk_stereo_encode_mid_only($4, HEAP8[$8 + $25 | 0]);
           break label$68;
          }
          HEAP32[$0 + 5096 >> 2] = HEAP32[$0 + 20132 >> 2];
          $12 = (HEAP32[$0 + 4584 >> 2] << 1) + $26 | 0;
          HEAP32[$0 + 20132 >> 2] = HEAPU16[$12 >> 1] | HEAPU16[$12 + 2 >> 1] << 16;
         }
         $33 = Math_imul($19, $46);
         silk_encode_do_VAD_FLP($0, $7);
         $13 = HEAP32[$1 + 4 >> 2];
         if (($13 | 0) >= 1) {
          $18 = !$21 & ($27 | 0) == 2;
          $8 = 0;
          while (1) {
           $10 = HEAP32[$1 + 56 >> 2];
           $11 = (Math_imul($10, 3) | 0) / 5 | 0;
           label$75 : {
            if ($18) {
             break label$75;
            }
            $11 = $10;
            if (($27 | 0) != 3) {
             break label$75;
            }
            $11 = ($10 << 1) / 5 | 0;
            if (!$21) {
             break label$75;
            }
            $11 = $10;
            if (($21 | 0) != 1) {
             break label$75;
            }
            $11 = (Math_imul($10, 3) | 0) / 4 | 0;
           }
           $17 = ($21 | 0) == ($40 | 0) & HEAP32[$1 + 52 >> 2] != 0;
           label$76 : {
            if (($13 | 0) == 1) {
             $9 = $16;
             break label$76;
            }
            $9 = HEAP32[($15 + 16 | 0) + ($8 << 2) >> 2];
            if (HEAP32[$15 + 20 >> 2] < 1 | $8) {
             break label$76;
            }
            $11 = $11 - (($10 | 0) / ($39 | 0) | 0) | 0;
            $17 = 0;
           }
           if (($9 | 0) >= 1) {
            $10 = Math_imul($8, 10064) + $0 | 0;
            silk_control_SNR($10, $9);
            $12 = $5;
            $23 = $4;
            $9 = 0;
            label$79 : {
             if (HEAP32[$0 + 5748 >> 2] <= ($8 | 0)) {
              break label$79;
             }
             if ($8) {
              $9 = 1;
              if (HEAP32[$0 + 20212 >> 2]) {
               break label$79;
              }
             }
             $9 = 2;
            }
            $14 = silk_encode_frame_FLP($10, $12, $23, $9, $11, $17);
            $13 = HEAP32[$1 + 4 >> 2];
           }
           $9 = Math_imul($8, 10064) + $0 | 0;
           HEAP32[$9 + 5740 >> 2] = 0;
           HEAP32[$9 + 4668 >> 2] = 0;
           HEAP32[$9 + 5748 >> 2] = HEAP32[$9 + 5748 >> 2] + 1;
           $8 = $8 + 1 | 0;
           if (($13 | 0) > ($8 | 0)) {
            continue;
           }
           break;
          }
         }
         $18 = $33 << 1;
         $3 = $3 - $19 | 0;
         $16 = HEAP32[$0 + 5748 >> 2];
         HEAP32[$0 + 20212 >> 2] = HEAP8[($25 + $16 | 0) - 1 | 0];
         label$81 : {
          if (HEAP32[$0 + 5744 >> 2] != ($16 | 0) | HEAP32[$5 >> 2] < 1) {
           break label$81;
          }
          $17 = 0;
          $8 = 0;
          if (($13 | 0) >= 1) {
           while (1) {
            $9 = $8 << 1;
            $8 = 0;
            $10 = Math_imul($17, 10064) + $0 | 0;
            $11 = HEAP32[$10 + 5744 >> 2];
            if (($11 | 0) >= 1) {
             while (1) {
              $9 = (HEAP8[($8 + $10 | 0) + 4720 | 0] | $9) << 1;
              $8 = $8 + 1 | 0;
              if (($11 | 0) != ($8 | 0)) {
               continue;
              }
              break;
             }
            }
            $8 = HEAP8[$10 + 4723 | 0] | $9;
            $17 = $17 + 1 | 0;
            if (($17 | 0) != ($13 | 0)) {
             continue;
            }
            break;
           }
          }
          if (!$6) {
           ec_enc_patch_initial_bits($4, $8, Math_imul($16 + 1 | 0, $13));
          }
          if (!(!HEAP32[$0 + 6080 >> 2] | (HEAP32[$0 + 16144 >> 2] ? 0 : HEAP32[$1 + 4 >> 2] != 1))) {
           HEAP32[$5 >> 2] = 0;
          }
          $9 = HEAP32[$1 + 24 >> 2];
          $8 = (HEAP32[$0 + 20188 >> 2] + (HEAP32[$5 >> 2] << 3) | 0) + ((Math_imul($9, HEAP32[$1 + 28 >> 2]) | 0) / -1e3 | 0) | 0;
          $8 = ($8 | 0) > 0 ? $8 : 0;
          HEAP32[$0 + 20188 >> 2] = ($8 | 0) < 1e4 ? $8 : 1e4;
          $8 = HEAP32[$0 + 20204 >> 2];
          if (HEAP32[$0 + 4532 >> 2] < ((Math_imul($8 << 16 >> 16, 3188) >> 16) + 13 | 0)) {
           HEAP32[$0 + 20204 >> 2] = 0;
           HEAP32[$0 + 20208 >> 2] = 1;
           break label$81;
          }
          HEAP32[$0 + 20208 >> 2] = 0;
          HEAP32[$0 + 20204 >> 2] = $8 + $9;
         }
         $2 = $2 + $18 | 0;
         $21 = $21 + 1 | 0;
         if ($3) {
          continue;
         }
         break;
        }
        $12 = HEAP32[$0 + 20208 >> 2];
       }
       $10 = HEAP32[$1 + 4 >> 2];
       HEAP32[$0 + 20200 >> 2] = $10;
       $8 = $12;
       HEAP32[$1 + 76 >> 2] = $8;
       $8 = HEAP32[$0 + 4576 >> 2];
       $38 = ($8 | 0) == 16 ? !HEAP32[$0 + 28 >> 2] : $38;
       HEAP32[$1 + 80 >> 2] = $38;
       HEAP32[$1 + 72 >> 2] = Math_imul($8 << 16 >> 16, 1e3);
       $8 = 0;
       $8 = HEAP32[$1 + 60 >> 2] ? $8 : HEAP16[$0 + 20156 >> 1];
       HEAP32[$1 + 84 >> 2] = $8;
       label$93 : {
        if (!$6) {
         break label$93;
        }
        HEAP32[$1 + 36 >> 2] = $35;
        HEAP32[$1 + 24 >> 2] = $24;
        if (($10 | 0) < 1) {
         break label$93;
        }
        $8 = 0;
        while (1) {
         $9 = Math_imul($8, 10064) + $0 | 0;
         HEAP32[$9 + 4680 >> 2] = 0;
         HEAP32[$9 + 4668 >> 2] = 0;
         $8 = $8 + 1 | 0;
         if (($10 | 0) != ($8 | 0)) {
          continue;
         }
         break;
        }
       }
       $8 = HEAP8[$0 + 4765 | 0];
       HEAP32[$1 + 92 >> 2] = $8;
       HEAP32[$1 + 96 >> 2] = HEAP16[(($8 << 1 & -4) + (HEAP8[$0 + 4766 | 0] << 1) | 0) + 5840 >> 1];
      }
      __stack_pointer = $15 + 32 | 0;
      return $14;
     }
     celt_fatal(17545, 17507, 262);
     abort();
    }
    celt_fatal(17487, 17507, 241);
    abort();
   }
   celt_fatal(17487, 17507, 235);
   abort();
  }
  celt_fatal(17487, 17507, 206);
  abort();
 }
 celt_fatal(17487, 17507, 170);
 abort();
}
function quant_all_bands($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22) {
 var $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = Math_fround(0), $34 = Math_fround(0), $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = Math_fround(0), $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = Math_fround(0), $87 = 0, $88 = 0, $89 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = Math_fround(0);
 $27 = __stack_pointer - 1568 | 0;
 $25 = $27;
 __stack_pointer = $25;
 $28 = 1;
 $37 = HEAP32[$1 + 32 >> 2];
 $63 = $37 + ($2 << 1) | 0;
 $41 = HEAP16[$63 >> 1] << $17;
 $49 = $5 ? 2 : 1;
 $31 = $25 - ((Math_imul($49, (HEAP16[((HEAP32[$1 + 8 >> 2] << 1) + $37 | 0) - 2 >> 1] << $17) - $41 | 0) << 2) + 15 & -16) | 0;
 $26 = $31;
 __stack_pointer = $26;
 $27 = HEAP32[$1 + 8 >> 2];
 $29 = HEAP16[(($27 << 1) + $37 | 0) - 2 >> 1];
 $38 = $29 << $17 << 2;
 $50 = !$11 & (($0 | 0) != 0 & ($5 | 0) != 0) & ($20 | 0) > 7;
 $59 = $50 | !$0;
 $39 = $9 ? 1 << $17 : 1;
 label$1 : {
  if ($50) {
   $28 = HEAP16[($27 << 1) + $37 >> 1] - $29 << $17;
   $32 = $26 - (($28 << 2) + 15 & -16) | 0;
   $26 = $32;
   __stack_pointer = $26;
   break label$1;
  }
  $32 = $4 + $38 | 0;
 }
 $27 = ($28 << 2) + 15 & -16;
 $64 = $26 - $27 | 0;
 $26 = $64;
 __stack_pointer = $26;
 $65 = $26 - $27 | 0;
 $26 = $65;
 __stack_pointer = $26;
 $66 = $26 - $27 | 0;
 $26 = $66;
 __stack_pointer = $26;
 $67 = $26 - $27 | 0;
 $26 = $67;
 __stack_pointer = $26;
 $60 = $26 - $27 | 0;
 __stack_pointer = $60;
 HEAP32[$25 + 1532 >> 2] = $16;
 HEAP32[$25 + 1540 >> 2] = $7;
 HEAP32[$25 + 1520 >> 2] = $12;
 HEAP32[$25 + 1504 >> 2] = $0;
 HEAP32[$25 + 1512 >> 2] = $1;
 $27 = HEAP32[$19 >> 2];
 HEAP32[$25 + 1556 >> 2] = $22;
 HEAP32[$25 + 1548 >> 2] = $21;
 HEAP32[$25 + 1524 >> 2] = $10;
 HEAP32[$25 + 1544 >> 2] = $27;
 $0 = ($39 | 0) > 1;
 HEAP32[$25 + 1560 >> 2] = $0;
 HEAP32[$25 + 1552 >> 2] = 0;
 HEAP32[$25 + 1508 >> 2] = $59;
 if (($2 | 0) < ($3 | 0)) {
  $101 = $5 ? $31 : 0;
  $102 = ($10 | 0) != 3 | $0;
  $45 = $16 + 28 | 0;
  $46 = $16 + 8 | 0;
  $103 = $59 ^ 1;
  $21 = $49 - 1 | 0;
  $68 = $2 + 2 | 0;
  $51 = $2 + 1 | 0;
  $69 = $3 - 1 | 0;
  $27 = 0 - $41 << 2;
  $38 = ($31 + $38 | 0) - ($41 << 2) | 0;
  $104 = $27 + $38 | 0;
  $42 = $27 + $31 | 0;
  $70 = -1 << $39 ^ -1;
  $52 = $2;
  $10 = 1;
  while (1) {
   $22 = $52;
   HEAP32[$25 + 1516 >> 2] = $22;
   label$5 : {
    label$6 : {
     $52 = $22 + 1 | 0;
     $35 = ($22 << 1) + $37 | 0;
     $0 = HEAP16[$35 >> 1] << $17;
     $27 = (HEAP16[($52 << 1) + $37 >> 1] << $17) - $0 | 0;
     if (($27 | 0) > 0) {
      $61 = ec_tell_frac($16);
      $26 = $14 - $61 | 0;
      HEAP32[$25 + 1536 >> 2] = $26 - 1;
      $71 = $15 - (($2 | 0) == ($22 | 0) ? 0 : $61) | 0;
      $36 = 0;
      label$8 : {
       if (($18 | 0) <= ($22 | 0)) {
        break label$8;
       }
       $15 = $18 - $22 | 0;
       $15 = HEAP32[($22 << 2) + $8 >> 2] + (($71 | 0) / ((($15 | 0) < 3 ? $15 : 3) | 0) | 0) | 0;
       $15 = ($15 | 0) > ($26 | 0) ? $26 : $15;
       $36 = 16383;
       if (($15 | 0) > 16383) {
        break label$8;
       }
       $36 = ($15 | 0) > 0 ? $15 : 0;
      }
      $15 = $0 << 2;
      $40 = !$59 | (((HEAP16[$35 >> 1] << $17) - $27 | 0) < HEAP16[$63 >> 1] << $17 ? ($22 | 0) != ($51 | 0) : 0) ? $40 : $10 ? $22 : $40 ? $40 : $22;
      $0 = $5 + $15 | 0;
      $72 = ($22 | 0) != ($51 | 0);
      label$11 : {
       if ($72) {
        break label$11;
       }
       $26 = HEAP32[$1 + 32 >> 2];
       $28 = HEAP16[$26 + ($51 << 1) >> 1];
       $10 = $28 - HEAP16[($2 << 1) + $26 >> 1] << $17;
       $9 = $10 << 2;
       $26 = HEAP16[($68 << 1) + $26 >> 1] - $28 << $17;
       $28 = ($10 << 1) - $26 << 2;
       $26 = $26 - $10 << 2;
       memcpy($31 + $9 | 0, $31 + $28 | 0, $26);
       if (!$11) {
        break label$11;
       }
       memcpy($9 + $38 | 0, $28 + $38 | 0, $26);
      }
      $43 = $5 ? $0 : 0;
      $20 = $4 + $15 | 0;
      $62 = $22 << 2;
      $15 = HEAP32[$62 + $13 >> 2];
      HEAP32[$25 + 1528 >> 2] = $15;
      $29 = HEAP32[$1 + 12 >> 2] > ($22 | 0);
      $32 = $29 ? $32 : 0;
      $44 = ($22 | 0) == ($69 | 0);
      $47 = $44 ? 0 : $32;
      $30 = -1;
      label$12 : {
       if (!$40) {
        $0 = $70;
        $26 = $0;
        break label$12;
       }
       $0 = $70;
       $26 = $0;
       if (!(($15 | 0) < 0 | $102)) {
        break label$12;
       }
       $15 = ((HEAP16[($40 << 1) + $37 >> 1] << $17) - $41 | 0) - $27 | 0;
       $30 = ($15 | 0) > 0 ? $15 : 0;
       $0 = $41 + $30 | 0;
       $15 = $40;
       while (1) {
        $26 = $15;
        $15 = $15 - 1 | 0;
        if (HEAP16[($15 << 1) + $37 >> 1] << $17 > ($0 | 0)) {
         continue;
        }
        break;
       }
       $9 = $0 + $27 | 0;
       $10 = $40 - 1 | 0;
       $28 = (($22 | 0) < ($40 | 0) ? $40 : $22) - 1 | 0;
       while (1) {
        label$16 : {
         $0 = $10;
         if (($28 | 0) == ($0 | 0)) {
          $0 = $28;
          break label$16;
         }
         $10 = $0 + 1 | 0;
         if (HEAP16[($10 << 1) + $37 >> 1] << $17 < ($9 | 0)) {
          continue;
         }
        }
        break;
       }
       $28 = ($0 | 0) < ($26 | 0) ? $15 : $0;
       $0 = 0;
       $26 = 0;
       while (1) {
        $10 = Math_imul($15, $49);
        $0 = HEAPU8[$10 + $6 | 0] | $0;
        $26 = HEAPU8[($10 + $21 | 0) + $6 | 0] | $26;
        $10 = ($15 | 0) != ($28 | 0);
        $15 = $15 + 1 | 0;
        if ($10) {
         continue;
        }
        break;
       }
      }
      $32 = $50 ? $32 : $47;
      $20 = $29 ? $20 : $31;
      $9 = $29 ? $43 : $101;
      if (!$11) {
       break label$6;
      }
      if (!(($12 | 0) != ($22 | 0) | $103)) {
       $15 = HEAP16[$35 >> 1] << $17;
       if (($41 | 0) >= ($15 | 0)) {
        break label$6;
       }
       $15 = $15 - $41 | 0;
       $29 = ($15 | 0) > 1 ? $15 : 1;
       $15 = 0;
       while (1) {
        $10 = $15 << 2;
        $28 = $31 + $10 | 0;
        HEAPF32[$28 >> 2] = Math_fround(HEAPF32[$28 >> 2] + HEAPF32[$10 + $38 >> 2]) * Math_fround(.5);
        $15 = $15 + 1 | 0;
        if (($29 | 0) != ($15 | 0)) {
         continue;
        }
        break;
       }
       break label$6;
      }
      if (($12 | 0) == ($22 | 0)) {
       break label$6;
      }
      $10 = $30 << 2;
      $28 = ($30 | 0) == -1;
      $29 = $28 ? 0 : $31 + $10 | 0;
      $15 = $36 >>> 1 | 0;
      label$21 : {
       if (($22 | 0) == ($69 | 0)) {
        $30 = 0;
        $10 = $28 ? 0 : $10 + $38 | 0;
        $20 = quant_band($25 + 1504 | 0, $20, $27, $15, $39, $29, $17, 0, Math_fround(1), $32, $0);
        break label$21;
       }
       $10 = $28 ? 0 : $10 + $38 | 0;
       $20 = quant_band($25 + 1504 | 0, $20, $27, $15, $39, $29, $17, (HEAP16[$35 >> 1] << $17 << 2) + $42 | 0, Math_fround(1), $32, $0);
       $30 = (HEAP16[$35 >> 1] << $17 << 2) + $104 | 0;
      }
      $15 = quant_band($25 + 1504 | 0, $9, $27, $15, $39, $10, $17, $30, Math_fround(1), $32, $26);
      break label$5;
     }
     celt_fatal(41890, 41800, 1495);
     abort();
    }
    label$23 : {
     if ($9) {
      if (!($50 ^ 1 | ($12 | 0) <= ($22 | 0))) {
       $33 = HEAPF32[$7 + $62 >> 2];
       $34 = HEAPF32[(HEAP32[$1 + 8 >> 2] + $22 << 2) + $7 >> 2];
       $73 = HEAP32[$16 + 4 >> 2];
       $74 = HEAP32[$16 >> 2];
       $24 = $46;
       $23 = HEAP32[$24 + 8 >> 2];
       $15 = HEAP32[$24 + 12 >> 2];
       $10 = $23;
       $75 = $25 + 1496 | 0;
       $23 = $75;
       HEAP32[$23 >> 2] = $10;
       HEAP32[$23 + 4 >> 2] = $15;
       $23 = HEAP32[$24 + 4 >> 2];
       $15 = HEAP32[$24 >> 2];
       $10 = $15;
       $15 = $25;
       HEAP32[$15 + 1488 >> 2] = $10;
       HEAP32[$15 + 1492 >> 2] = $23;
       $47 = HEAP32[$16 + 24 >> 2];
       $76 = $15 + 1480 | 0;
       HEAP32[$76 >> 2] = HEAP32[$45 + 16 >> 2];
       $77 = $15 + 1472 | 0;
       $24 = $45;
       $23 = HEAP32[$24 + 8 >> 2];
       $15 = HEAP32[$24 + 12 >> 2];
       $10 = $23;
       $23 = $77;
       HEAP32[$23 >> 2] = $10;
       HEAP32[$23 + 4 >> 2] = $15;
       $23 = HEAP32[$24 + 4 >> 2];
       $15 = HEAP32[$24 >> 2];
       $10 = $15;
       $15 = $25;
       HEAP32[$15 + 1464 >> 2] = $10;
       HEAP32[$15 + 1468 >> 2] = $23;
       $78 = $15 + 1408 | 0;
       $53 = $15 + 1560 | 0;
       HEAP32[$78 >> 2] = HEAP32[$53 >> 2];
       $79 = $15 + 1400 | 0;
       $43 = $15 + 1552 | 0;
       $24 = $43;
       $23 = HEAP32[$24 >> 2];
       $15 = HEAP32[$24 + 4 >> 2];
       $10 = $23;
       $23 = $79;
       HEAP32[$23 >> 2] = $10;
       HEAP32[$23 + 4 >> 2] = $15;
       $54 = $25 + 1544 | 0;
       $24 = $54;
       $15 = HEAP32[$24 >> 2];
       $23 = HEAP32[$24 + 4 >> 2];
       $10 = $15;
       $80 = $25 + 1392 | 0;
       $15 = $80;
       HEAP32[$15 >> 2] = $10;
       HEAP32[$15 + 4 >> 2] = $23;
       $55 = $25 + 1536 | 0;
       $24 = $55;
       $23 = HEAP32[$24 >> 2];
       $15 = HEAP32[$24 + 4 >> 2];
       $10 = $23;
       $81 = $25 + 1384 | 0;
       $23 = $81;
       HEAP32[$23 >> 2] = $10;
       HEAP32[$23 + 4 >> 2] = $15;
       $56 = $25 + 1528 | 0;
       $24 = $56;
       $15 = HEAP32[$24 >> 2];
       $23 = HEAP32[$24 + 4 >> 2];
       $10 = $15;
       $82 = $25 + 1376 | 0;
       $15 = $82;
       HEAP32[$15 >> 2] = $10;
       HEAP32[$15 + 4 >> 2] = $23;
       $57 = $25 + 1520 | 0;
       $24 = $57;
       $23 = HEAP32[$24 >> 2];
       $15 = HEAP32[$24 + 4 >> 2];
       $10 = $23;
       $83 = $25 + 1368 | 0;
       $23 = $83;
       HEAP32[$23 >> 2] = $10;
       HEAP32[$23 + 4 >> 2] = $15;
       $58 = $25 + 1512 | 0;
       $24 = $58;
       $15 = HEAP32[$24 >> 2];
       $23 = HEAP32[$24 + 4 >> 2];
       $10 = $15;
       $84 = $25 + 1360 | 0;
       $15 = $84;
       HEAP32[$15 >> 2] = $10;
       HEAP32[$15 + 4 >> 2] = $23;
       $24 = $25;
       $23 = HEAP32[$24 + 1504 >> 2];
       $15 = HEAP32[$24 + 1508 >> 2];
       $10 = $23;
       $23 = $24;
       HEAP32[$23 + 1352 >> 2] = $10;
       HEAP32[$23 + 1356 >> 2] = $15;
       $11 = $27 << 2;
       $10 = memcpy($64, $20, $11);
       $28 = memcpy($65, $9, $11);
       HEAP32[$43 >> 2] = -1;
       $15 = 0;
       $85 = $0 | $26;
       $0 = 0;
       $48 = Math_fround(($33 < $34 ? $33 : $34) / Math_fround(3));
       $86 = Math_fround($34 + $48);
       $48 = Math_fround($33 + $48);
       $33 = Math_fround(0);
       $30 = ($30 | 0) == -1 ? 0 : ($30 << 2) + $31 | 0;
       $0 = $44 ? $0 : (HEAP16[$35 >> 1] << $17 << 2) + $42 | 0;
       $105 = quant_band_stereo($23 + 1504 | 0, $20, $9, $27, $36, $39, $30, $17, $0, $32, $85);
       $34 = Math_fround(0);
       while (1) {
        $0 = $15 << 2;
        $34 = Math_fround($34 + Math_fround(HEAPF32[$10 + $0 >> 2] * HEAPF32[$0 + $20 >> 2]));
        $15 = $15 + 1 | 0;
        if (($27 | 0) != ($15 | 0)) {
         continue;
        }
        break;
       }
       $15 = 0;
       while (1) {
        $0 = $15 << 2;
        $33 = Math_fround($33 + Math_fround(HEAPF32[$28 + $0 >> 2] * HEAPF32[$0 + $9 >> 2]));
        $15 = $15 + 1 | 0;
        if (($27 | 0) != ($15 | 0)) {
         continue;
        }
        break;
       }
       $24 = $16;
       $15 = HEAP32[$24 + 40 >> 2];
       $23 = HEAP32[$24 + 44 >> 2];
       $0 = $15;
       $87 = $25 + 1456 | 0;
       $15 = $87;
       HEAP32[$15 >> 2] = $0;
       HEAP32[$15 + 4 >> 2] = $23;
       $15 = HEAP32[$24 + 36 >> 2];
       $23 = HEAP32[$24 + 32 >> 2];
       $0 = $23;
       $88 = $25 + 1448 | 0;
       $23 = $88;
       HEAP32[$23 >> 2] = $0;
       HEAP32[$23 + 4 >> 2] = $15;
       $23 = HEAP32[$24 + 28 >> 2];
       $15 = HEAP32[$24 + 24 >> 2];
       $0 = $15;
       $89 = $25 + 1440 | 0;
       $15 = $89;
       HEAP32[$15 >> 2] = $0;
       HEAP32[$15 + 4 >> 2] = $23;
       $15 = HEAP32[$24 + 20 >> 2];
       $23 = HEAP32[$24 + 16 >> 2];
       $0 = $23;
       $90 = $25 + 1432 | 0;
       $23 = $90;
       HEAP32[$23 >> 2] = $0;
       HEAP32[$23 + 4 >> 2] = $15;
       $24 = $46;
       $15 = HEAP32[$24 >> 2];
       $23 = HEAP32[$24 + 4 >> 2];
       $0 = $15;
       $91 = $25 + 1424 | 0;
       $15 = $91;
       HEAP32[$15 >> 2] = $0;
       HEAP32[$15 + 4 >> 2] = $23;
       $24 = $16;
       $23 = HEAP32[$24 >> 2];
       $26 = $23;
       $15 = HEAP32[$24 + 4 >> 2];
       $0 = $15;
       $24 = $58;
       $15 = HEAP32[$24 >> 2];
       $23 = HEAP32[$24 + 4 >> 2];
       $24 = $15;
       $92 = $25 + 1296 | 0;
       $15 = $92;
       HEAP32[$15 >> 2] = $24;
       HEAP32[$15 + 4 >> 2] = $23;
       $24 = $57;
       $23 = HEAP32[$24 >> 2];
       $15 = HEAP32[$24 + 4 >> 2];
       $24 = $23;
       $93 = $25 + 1304 | 0;
       $23 = $93;
       HEAP32[$23 >> 2] = $24;
       HEAP32[$23 + 4 >> 2] = $15;
       $24 = $56;
       $15 = HEAP32[$24 >> 2];
       $23 = HEAP32[$24 + 4 >> 2];
       $24 = $15;
       $94 = $25 + 1312 | 0;
       $15 = $94;
       HEAP32[$15 >> 2] = $24;
       HEAP32[$15 + 4 >> 2] = $23;
       $24 = $55;
       $23 = HEAP32[$24 >> 2];
       $15 = HEAP32[$24 + 4 >> 2];
       $24 = $23;
       $95 = $25 + 1320 | 0;
       $23 = $95;
       HEAP32[$23 >> 2] = $24;
       HEAP32[$23 + 4 >> 2] = $15;
       $24 = $54;
       $15 = HEAP32[$24 >> 2];
       $23 = HEAP32[$24 + 4 >> 2];
       $24 = $15;
       $96 = $25 + 1328 | 0;
       $15 = $96;
       HEAP32[$15 >> 2] = $24;
       HEAP32[$15 + 4 >> 2] = $23;
       $24 = $43;
       $23 = HEAP32[$24 >> 2];
       $15 = HEAP32[$24 + 4 >> 2];
       $24 = $23;
       $97 = $25 + 1336 | 0;
       $23 = $97;
       HEAP32[$23 >> 2] = $24;
       HEAP32[$23 + 4 >> 2] = $15;
       $98 = $25 + 1344 | 0;
       HEAP32[$98 >> 2] = HEAP32[$53 >> 2];
       $23 = $25;
       HEAP32[$23 + 1416 >> 2] = $26;
       $15 = $0;
       HEAP32[$23 + 1420 >> 2] = $15;
       $24 = $23;
       $15 = HEAP32[$23 + 1504 >> 2];
       $23 = HEAP32[$23 + 1508 >> 2];
       $0 = $15;
       $15 = $24;
       HEAP32[$15 + 1288 >> 2] = $0;
       HEAP32[$15 + 1292 >> 2] = $23;
       $106 = memcpy($66, $20, $11);
       $107 = memcpy($67, $9, $11);
       if (!$44) {
        memcpy($60, (HEAP16[$35 >> 1] << $17 << 2) + $42 | 0, $11);
       }
       $99 = $47 + $74 | 0;
       $100 = $73 - $47 | 0;
       $29 = memcpy($25, $99, $100);
       HEAP32[$16 + 4 >> 2] = $73;
       HEAP32[$16 >> 2] = $74;
       $24 = $75;
       $23 = HEAP32[$24 >> 2];
       $15 = HEAP32[$24 + 4 >> 2];
       $0 = $23;
       $23 = $46;
       HEAP32[$23 + 8 >> 2] = $0;
       HEAP32[$23 + 12 >> 2] = $15;
       $24 = $29;
       $15 = HEAP32[$24 + 1488 >> 2];
       $23 = HEAP32[$24 + 1492 >> 2];
       $0 = $15;
       $15 = $46;
       HEAP32[$15 >> 2] = $0;
       HEAP32[$15 + 4 >> 2] = $23;
       HEAP32[$16 + 24 >> 2] = $47;
       HEAP32[$45 + 16 >> 2] = HEAP32[$76 >> 2];
       $24 = $77;
       $23 = HEAP32[$24 >> 2];
       $15 = HEAP32[$24 + 4 >> 2];
       $0 = $23;
       $23 = $45;
       HEAP32[$23 + 8 >> 2] = $0;
       HEAP32[$23 + 12 >> 2] = $15;
       $24 = $29;
       $15 = HEAP32[$24 + 1464 >> 2];
       $23 = HEAP32[$24 + 1468 >> 2];
       $0 = $15;
       $15 = $45;
       HEAP32[$15 >> 2] = $0;
       HEAP32[$15 + 4 >> 2] = $23;
       $24 = $84;
       $23 = HEAP32[$24 >> 2];
       $15 = HEAP32[$24 + 4 >> 2];
       $0 = $23;
       $23 = $58;
       HEAP32[$23 >> 2] = $0;
       HEAP32[$23 + 4 >> 2] = $15;
       $24 = $83;
       $15 = HEAP32[$24 >> 2];
       $23 = HEAP32[$24 + 4 >> 2];
       $0 = $15;
       $15 = $57;
       HEAP32[$15 >> 2] = $0;
       HEAP32[$15 + 4 >> 2] = $23;
       $24 = $82;
       $23 = HEAP32[$24 >> 2];
       $15 = HEAP32[$24 + 4 >> 2];
       $0 = $23;
       $23 = $56;
       HEAP32[$23 >> 2] = $0;
       HEAP32[$23 + 4 >> 2] = $15;
       $24 = $81;
       $15 = HEAP32[$24 >> 2];
       $23 = HEAP32[$24 + 4 >> 2];
       $0 = $15;
       $15 = $55;
       HEAP32[$15 >> 2] = $0;
       HEAP32[$15 + 4 >> 2] = $23;
       $24 = $80;
       $23 = HEAP32[$24 >> 2];
       $15 = HEAP32[$24 + 4 >> 2];
       $0 = $23;
       $23 = $54;
       HEAP32[$23 >> 2] = $0;
       HEAP32[$23 + 4 >> 2] = $15;
       $24 = $79;
       $15 = HEAP32[$24 >> 2];
       $23 = HEAP32[$24 + 4 >> 2];
       $0 = $15;
       $15 = $43;
       HEAP32[$15 >> 2] = $0;
       HEAP32[$15 + 4 >> 2] = $23;
       HEAP32[$53 >> 2] = HEAP32[$78 >> 2];
       $24 = $29;
       $23 = HEAP32[$24 + 1352 >> 2];
       $15 = HEAP32[$24 + 1356 >> 2];
       $0 = $23;
       $23 = $24;
       HEAP32[$23 + 1504 >> 2] = $0;
       HEAP32[$23 + 1508 >> 2] = $15;
       $26 = memcpy($20, $10, $11);
       $9 = memcpy($9, $28, $11);
       if (!$72) {
        $15 = HEAP32[$1 + 32 >> 2];
        $20 = HEAP16[$15 + ($51 << 1) >> 1];
        $0 = $20 - HEAP16[($2 << 1) + $15 >> 1] << $17;
        $15 = HEAP16[($68 << 1) + $15 >> 1] - $20 << $17;
        memcpy(($0 << 2) + $31 | 0, (($0 << 1) - $15 << 2) + $31 | 0, $15 - $0 << 2);
       }
       HEAP32[$29 + 1552 >> 2] = 1;
       $15 = 0;
       $0 = 0;
       $34 = Math_fround($48 * $34);
       $33 = Math_fround($86 * $33);
       $108 = Math_fround($34 + $33);
       $33 = Math_fround(0);
       $0 = $44 ? $0 : (HEAP16[$35 >> 1] << $17 << 2) + $42 | 0;
       $20 = quant_band_stereo($29 + 1504 | 0, $26, $9, $27, $36, $39, $30, $17, $0, $32, $85);
       $34 = Math_fround(0);
       while (1) {
        $0 = $15 << 2;
        $34 = Math_fround($34 + Math_fround(HEAPF32[$10 + $0 >> 2] * HEAPF32[$0 + $26 >> 2]));
        $15 = $15 + 1 | 0;
        if (($27 | 0) != ($15 | 0)) {
         continue;
        }
        break;
       }
       $15 = 0;
       while (1) {
        $0 = $15 << 2;
        $33 = Math_fround($33 + Math_fround(HEAPF32[$28 + $0 >> 2] * HEAPF32[$0 + $9 >> 2]));
        $15 = $15 + 1 | 0;
        if (($27 | 0) != ($15 | 0)) {
         continue;
        }
        break;
       }
       if (!(Math_fround(Math_fround($48 * $34) + Math_fround($86 * $33)) <= $108 ^ 1)) {
        $15 = HEAP32[$29 + 1416 >> 2];
        $23 = HEAP32[$24 + 1420 >> 2];
        $0 = $15;
        $15 = $16;
        HEAP32[$15 >> 2] = $0;
        HEAP32[$15 + 4 >> 2] = $23;
        $24 = $87;
        $23 = HEAP32[$24 >> 2];
        $15 = HEAP32[$24 + 4 >> 2];
        $0 = $23;
        $23 = $16;
        HEAP32[$23 + 40 >> 2] = $0;
        HEAP32[$23 + 44 >> 2] = $15;
        $24 = $88;
        $15 = HEAP32[$24 >> 2];
        $23 = HEAP32[$24 + 4 >> 2];
        $0 = $15;
        $15 = $16;
        HEAP32[$15 + 32 >> 2] = $0;
        HEAP32[$15 + 36 >> 2] = $23;
        $24 = $89;
        $23 = HEAP32[$24 >> 2];
        $15 = HEAP32[$24 + 4 >> 2];
        $0 = $23;
        $23 = $16;
        HEAP32[$23 + 24 >> 2] = $0;
        HEAP32[$23 + 28 >> 2] = $15;
        $24 = $90;
        $15 = HEAP32[$24 >> 2];
        $23 = HEAP32[$24 + 4 >> 2];
        $0 = $15;
        $15 = $16;
        HEAP32[$15 + 16 >> 2] = $0;
        HEAP32[$15 + 20 >> 2] = $23;
        $24 = $91;
        $23 = HEAP32[$24 >> 2];
        $15 = HEAP32[$24 + 4 >> 2];
        $0 = $23;
        $23 = $46;
        HEAP32[$23 >> 2] = $0;
        HEAP32[$23 + 4 >> 2] = $15;
        $24 = $92;
        $15 = HEAP32[$24 >> 2];
        $23 = HEAP32[$24 + 4 >> 2];
        $0 = $15;
        $15 = $58;
        HEAP32[$15 >> 2] = $0;
        HEAP32[$15 + 4 >> 2] = $23;
        $24 = $93;
        $23 = HEAP32[$24 >> 2];
        $15 = HEAP32[$24 + 4 >> 2];
        $0 = $23;
        $23 = $57;
        HEAP32[$23 >> 2] = $0;
        HEAP32[$23 + 4 >> 2] = $15;
        $24 = $94;
        $15 = HEAP32[$24 >> 2];
        $23 = HEAP32[$24 + 4 >> 2];
        $0 = $15;
        $15 = $56;
        HEAP32[$15 >> 2] = $0;
        HEAP32[$15 + 4 >> 2] = $23;
        $24 = $95;
        $23 = HEAP32[$24 >> 2];
        $15 = HEAP32[$24 + 4 >> 2];
        $0 = $23;
        $23 = $55;
        HEAP32[$23 >> 2] = $0;
        HEAP32[$23 + 4 >> 2] = $15;
        $24 = $96;
        $15 = HEAP32[$24 >> 2];
        $23 = HEAP32[$24 + 4 >> 2];
        $0 = $15;
        $15 = $54;
        HEAP32[$15 >> 2] = $0;
        HEAP32[$15 + 4 >> 2] = $23;
        $24 = $97;
        $23 = HEAP32[$24 >> 2];
        $15 = HEAP32[$24 + 4 >> 2];
        $0 = $23;
        $23 = $43;
        HEAP32[$23 >> 2] = $0;
        HEAP32[$23 + 4 >> 2] = $15;
        HEAP32[$53 >> 2] = HEAP32[$98 >> 2];
        $24 = $29;
        $15 = HEAP32[$24 + 1288 >> 2];
        $23 = HEAP32[$24 + 1292 >> 2];
        $0 = $15;
        $15 = $24;
        HEAP32[$15 + 1504 >> 2] = $0;
        HEAP32[$15 + 1508 >> 2] = $23;
        memcpy($26, $106, $11);
        memcpy($9, $107, $11);
        if (!$44) {
         memcpy((HEAP16[$35 >> 1] << $17 << 2) + $42 | 0, $60, $11);
        }
        memcpy($99, $29, $100);
        $20 = $105;
       }
       $11 = 0;
       break label$23;
      }
      $11 = 0;
      HEAP32[$25 + 1552 >> 2] = 0;
      $15 = 0;
      $10 = ($30 | 0) == -1 ? 0 : ($30 << 2) + $31 | 0;
      $15 = $44 ? $15 : (HEAP16[$35 >> 1] << $17 << 2) + $42 | 0;
      $20 = quant_band_stereo($25 + 1504 | 0, $20, $9, $27, $36, $39, $10, $17, $15, $32, $0 | $26);
      break label$23;
     }
     $11 = 0;
     $15 = 0;
     $10 = ($30 | 0) == -1 ? 0 : ($30 << 2) + $31 | 0;
     $15 = $44 ? $15 : (HEAP16[$35 >> 1] << $17 << 2) + $42 | 0;
     $20 = quant_band($25 + 1504 | 0, $20, $27, $36, $39, $10, $17, $15, Math_fround(1), $32, $0 | $26);
    }
    $15 = $20;
   }
   $0 = Math_imul($22, $49);
   HEAP8[$6 + $0 | 0] = $20;
   HEAP8[($0 + $21 | 0) + $6 | 0] = $15;
   $15 = HEAP32[$8 + $62 >> 2];
   HEAP32[$25 + 1560 >> 2] = 0;
   $15 = ($61 + $71 | 0) + $15 | 0;
   $10 = $27 << 3 < ($36 | 0);
   if (($3 | 0) != ($52 | 0)) {
    continue;
   }
   break;
  }
  $27 = HEAP32[$25 + 1544 >> 2];
 }
 HEAP32[$19 >> 2] = $27;
 __stack_pointer = $25 + 1568 | 0;
}
function silk_NSQ_c($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) {
 var $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $70 = 0, $71 = 0, $72 = 0;
 $15 = __stack_pointer;
 $60 = $15;
 HEAP32[$1 + 4340 >> 2] = HEAP8[$2 + 34 | 0];
 $32 = HEAP32[$1 + 4328 >> 2];
 $19 = HEAPU8[$2 + 31 | 0];
 $23 = HEAP8[$2 + 29 | 0];
 $22 = HEAP8[$2 + 30 | 0];
 $18 = HEAP32[$0 + 4592 >> 2];
 $17 = HEAP32[$0 + 4584 >> 2];
 $16 = $18 + $17 | 0;
 $34 = $15 - (($16 << 2) + 15 & -16) | 0;
 $15 = $34;
 __stack_pointer = $15;
 $39 = $15 - (($16 << 1) + 15 & -16) | 0;
 $16 = $39;
 __stack_pointer = $16;
 $15 = HEAP32[$0 + 4588 >> 2];
 $40 = $16 - (($15 << 2) + 15 & -16) | 0;
 __stack_pointer = $40;
 HEAP32[$1 + 4332 >> 2] = $18;
 HEAP32[$1 + 4336 >> 2] = $18;
 label$1 : {
  label$2 : {
   label$3 : {
    $16 = HEAP32[$0 + 4580 >> 2];
    if (($16 | 0) >= 1) {
     $30 = $13 << 16 >> 16;
     $25 = HEAP16[(($23 << 1 & -4) + ($22 << 1) | 0) + 5840 >> 1];
     $41 = $25 + 944 | 0;
     $46 = Math_imul($30, $41 << 16 >> 16);
     $47 = $25 - 944 | 0;
     $61 = Math_imul(0 - ($47 << 16) >> 16, $30);
     $48 = ($19 & 255) == 4;
     $62 = $48 ? 3 : 1;
     $63 = $25 - 80 | 0;
     $64 = $1 + 3900 | 0;
     $16 = $13 >>> 1 | 0;
     $65 = 512 - $16 | 0;
     $42 = $16 - 512 | 0;
     $49 = $14 << 16 >> 16;
     $43 = ($18 << 1) + $1 | 0;
     $44 = Math_imul($25, $30);
     $66 = ($13 | 0) < 2049;
     $28 = $1 + 3840 | 0;
     $67 = $28;
     while (1) {
      $22 = $24 << 2;
      $29 = HEAP32[$22 + $8 >> 2];
      HEAP32[$1 + 4348 >> 2] = 0;
      $19 = 1;
      $21 = (($24 >>> 1 | $48) << 5) + $5 | 0;
      label$6 : {
       if (($23 & 255) != 2) {
        break label$6;
       }
       $23 = 2;
       $32 = HEAP32[($24 << 2) + $12 >> 2];
       if ($24 & $62) {
        break label$6;
       }
       $18 = HEAP32[$0 + 4592 >> 2];
       $13 = HEAP32[$0 + 4640 >> 2];
       $16 = ($18 - $32 | 0) - $13 | 0;
       if (($16 | 0) <= 2) {
        break label$3;
       }
       $16 = $16 - 2 | 0;
       silk_LPC_analysis_filter(($16 << 1) + $39 | 0, (Math_imul($15, $24) + $16 << 1) + $1 | 0, $21, $18 - $16 | 0, $13, HEAP32[$0 + 5092 >> 2]);
       HEAP32[$1 + 4348 >> 2] = 1;
       HEAP32[$1 + 4332 >> 2] = HEAP32[$0 + 4592 >> 2];
       $23 = HEAPU8[$2 + 29 | 0];
       $19 = 0;
      }
      $20 = $11 + $22 | 0;
      $14 = HEAP32[$20 >> 2];
      $16 = ($14 | 0) > 1 ? $14 : 1;
      $13 = Math_clz32($16);
      $15 = $16 << $13 - 1;
      $18 = $15 >> 16;
      $17 = 536870911 / ($18 | 0) | 0;
      $35 = ($17 >> 15) + 1 >> 1;
      $26 = $15 & 65535;
      $17 = $17 << 16;
      $15 = $17 >> 16;
      $18 = 0 - ((Math_imul($26, $15) >> 16) + Math_imul($15, $18) << 3) | 0;
      $15 = ((Math_imul($18, $35) + $17 | 0) + Math_imul($18 >> 16, $15) | 0) + (Math_imul($18 & 65528, $15) >> 16) | 0;
      $18 = 15 - $13 | 0;
      $27 = HEAP32[$12 + $22 >> 2];
      label$7 : {
       if ($16 >>> 0 <= 131071) {
        $16 = 0 - $18 | 0;
        $18 = 2147483647 >>> $16 | 0;
        $13 = -2147483648 >> $16;
        $17 = (($15 | 0) > ($18 | 0) ? $18 : ($13 | 0) > ($15 | 0) ? $13 : $15) << $16;
        break label$7;
       }
       $17 = $15 >> $18;
      }
      $33 = HEAP32[$0 + 4588 >> 2];
      if (($33 | 0) >= 1) {
       $15 = ($17 >> 4) + 1 | 0;
       $18 = $15 << 15 >> 16;
       $13 = ($15 >> 16) + 1 >> 1;
       $15 = 0;
       while (1) {
        $16 = HEAP16[($15 << 1) + $3 >> 1];
        HEAP32[($15 << 2) + $40 >> 2] = (Math_imul($16 >> 16, $18) + Math_imul($13, $16) | 0) + (Math_imul($16 & 65535, $18) >> 16);
        $15 = $15 + 1 | 0;
        if (($33 | 0) != ($15 | 0)) {
         continue;
        }
        break;
       }
      }
      label$11 : {
       if ($19) {
        break label$11;
       }
       $17 = $24 ? $17 : Math_imul($17 >> 16, $49) + (Math_imul($17 & 65535, $49) >> 16) << 2;
       $18 = HEAP32[$1 + 4332 >> 2];
       $15 = ($18 - $27 | 0) - 2 | 0;
       if (($15 | 0) >= ($18 | 0)) {
        break label$11;
       }
       $13 = $17 & 65535;
       $17 = $17 >> 16;
       while (1) {
        $16 = HEAP16[($15 << 1) + $39 >> 1];
        HEAP32[($15 << 2) + $34 >> 2] = (Math_imul($16, $13) >> 16) + Math_imul($16, $17);
        $15 = $15 + 1 | 0;
        if (($18 | 0) != ($15 | 0)) {
         continue;
        }
        break;
       }
      }
      $15 = HEAP32[$1 + 4344 >> 2];
      if (($15 | 0) != ($14 | 0)) {
       $16 = $15 >> 31;
       $18 = Math_clz32($16 ^ $15 + $16);
       $16 = $15 << $18 - 1;
       $35 = $16;
       $15 = $14 >> 31;
       $13 = Math_clz32($15 ^ $14 + $15);
       $17 = $14 << $13 - 1;
       $15 = 536870911 / ($17 >> 16) << 16 >> 16;
       $16 = (Math_imul($15, $16 & 65535) >> 16) + Math_imul($16 >> 16, $15) | 0;
       $19 = $16 >> 31;
       $26 = $19;
       $19 = $17 >> 31;
       $14 = $19;
       $19 = $26;
       $14 = __wasm_i64_mul($16, $19, $17, $14);
       $17 = $14;
       $19 = i64toi32_i32$HIGH_BITS;
       $17 = $35 - ((($19 & 536870911) << 3 | $17 >>> 29) & -8) | 0;
       $15 = (Math_imul($17 >> 16, $15) + $16 | 0) + (Math_imul($17 & 65535, $15) >> 16) | 0;
       $16 = $18 - $13 | 0;
       $18 = $16 + 13 | 0;
       $16 = $16 + 29 | 0;
       label$15 : {
        if (($16 | 0) <= 15) {
         $16 = 0 - $18 | 0;
         $18 = 2147483647 >>> $16 | 0;
         $13 = -2147483648 >> $16;
         $18 = (($15 | 0) > ($18 | 0) ? $18 : ($13 | 0) > ($15 | 0) ? $13 : $15) << $16;
         break label$15;
        }
        $18 = ($16 | 0) < 48 ? $15 >> $18 : 0;
       }
       $15 = HEAP32[$0 + 4592 >> 2];
       if (($15 | 0) >= 1) {
        $17 = $18 & 65535;
        $14 = $18 >> 16;
        $15 = HEAP32[$1 + 4336 >> 2] - $15 | 0;
        while (1) {
         $16 = (($15 << 2) + $1 | 0) + 1280 | 0;
         $19 = $16;
         $16 = HEAP32[$16 >> 2];
         $13 = $16 << 16 >> 16;
         HEAP32[$19 >> 2] = ((Math_imul($17, $13) >> 16) + Math_imul($13, $14) | 0) + Math_imul(($16 >> 15) + 1 >> 1, $18);
         $15 = $15 + 1 | 0;
         if (($15 | 0) < HEAP32[$1 + 4336 >> 2]) {
          continue;
         }
         break;
        }
       }
       label$19 : {
        if (HEAP32[$1 + 4348 >> 2] | ($23 & 255) != 2) {
         break label$19;
        }
        $17 = HEAP32[$1 + 4332 >> 2];
        $15 = ($17 - $27 | 0) - 2 | 0;
        if (($15 | 0) >= ($17 | 0)) {
         break label$19;
        }
        $14 = $18 & 65535;
        $19 = $18 >> 16;
        while (1) {
         $16 = ($15 << 2) + $34 | 0;
         $26 = $16;
         $16 = HEAP32[$16 >> 2];
         $13 = $16 << 16 >> 16;
         HEAP32[$26 >> 2] = ((Math_imul($14, $13) >> 16) + Math_imul($13, $19) | 0) + Math_imul(($16 >> 15) + 1 >> 1, $18);
         $15 = $15 + 1 | 0;
         if (($17 | 0) != ($15 | 0)) {
          continue;
         }
         break;
        }
       }
       $13 = $18 & 65535;
       $15 = HEAP32[$1 + 4320 >> 2];
       $16 = $15 << 16 >> 16;
       $17 = $18 >> 16;
       HEAP32[$1 + 4320 >> 2] = ((Math_imul($13, $16) >> 16) + Math_imul($17, $16) | 0) + Math_imul(($15 >> 15) + 1 >> 1, $18);
       $15 = HEAP32[$1 + 4324 >> 2];
       $16 = $15 << 16 >> 16;
       HEAP32[$1 + 4324 >> 2] = ((Math_imul($16, $13) >> 16) + Math_imul($16, $17) | 0) + Math_imul(($15 >> 15) + 1 >> 1, $18);
       $15 = 0;
       $16 = 0;
       while (1) {
        $14 = (($16 << 2) + $1 | 0) + 3840 | 0;
        $26 = $14;
        $14 = HEAP32[$14 >> 2];
        $19 = $14 << 16 >> 16;
        HEAP32[$26 >> 2] = ((Math_imul($19, $13) >> 16) + Math_imul($17, $19) | 0) + Math_imul(($14 >> 15) + 1 >> 1, $18);
        $16 = $16 + 1 | 0;
        if (($16 | 0) != 16) {
         continue;
        }
        break;
       }
       while (1) {
        $16 = (($15 << 2) + $1 | 0) + 4224 | 0;
        $19 = $16;
        $16 = HEAP32[$16 >> 2];
        $14 = $16 << 16 >> 16;
        HEAP32[$19 >> 2] = ((Math_imul($14, $13) >> 16) + Math_imul($14, $17) | 0) + Math_imul(($16 >> 15) + 1 >> 1, $18);
        $15 = $15 + 1 | 0;
        if (($15 | 0) != 24) {
         continue;
        }
        break;
       }
       HEAP32[$1 + 4344 >> 2] = HEAP32[$20 >> 2];
       $33 = HEAP32[$0 + 4588 >> 2];
       $14 = HEAP32[$20 >> 2];
      }
      if (($33 | 0) >= 1) {
       $36 = Math_imul($24, 10) + $6 | 0;
       $27 = 0;
       $50 = ($23 & 255) != 2;
       $68 = $50 | ($32 | 0) > 0;
       $15 = $29 >> 2;
       $51 = ($15 | $29 << 15) >> 16;
       $16 = HEAP32[$10 + $22 >> 2];
       $52 = $16 >> 16;
       $29 = HEAP32[$0 + 4636 >> 2];
       $69 = $29 >> 1;
       $70 = $29 & 1;
       $53 = HEAP32[$0 + 4640 >> 2];
       $71 = $53 >> 1;
       $54 = $14 << 10 >> 16;
       $55 = $15 << 16 >> 16;
       $56 = $16 << 16 >> 16;
       $72 = ($14 >> 21) + 1 >> 1;
       $14 = Math_imul($24, 48) + $7 | 0;
       $15 = $29 - 1 | 0;
       $35 = $14 + ($15 << 1) | 0;
       $26 = (($15 << 2) + $1 | 0) + 4224 | 0;
       $37 = ((HEAP32[$1 + 4336 >> 2] - $32 << 2) + $1 | 0) + 1284 | 0;
       $31 = ((HEAP32[$1 + 4332 >> 2] - $32 << 2) + $34 | 0) + 8 | 0;
       $57 = HEAP16[$9 + $22 >> 1];
       $15 = HEAP32[$1 + 4340 >> 2];
       $20 = $64;
       while (1) {
        HEAP32[$1 + 4340 >> 2] = Math_imul($15, 196314165) + 907633515;
        $16 = HEAP16[$21 >> 1];
        $15 = HEAP32[$20 >> 2];
        $13 = (Math_imul($16, $15 >> 16) + $71 | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
        $16 = HEAP16[$21 + 2 >> 1];
        $15 = HEAP32[$20 - 4 >> 2];
        $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
        $16 = HEAP16[$21 + 4 >> 1];
        $15 = HEAP32[$20 - 8 >> 2];
        $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
        $16 = HEAP16[$21 + 6 >> 1];
        $15 = HEAP32[$20 - 12 >> 2];
        $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
        $16 = HEAP16[$21 + 8 >> 1];
        $15 = HEAP32[$20 - 16 >> 2];
        $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
        $16 = HEAP16[$21 + 10 >> 1];
        $15 = HEAP32[$20 - 20 >> 2];
        $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
        $16 = HEAP16[$21 + 12 >> 1];
        $15 = HEAP32[$20 - 24 >> 2];
        $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
        $16 = HEAP16[$21 + 14 >> 1];
        $15 = HEAP32[$20 - 28 >> 2];
        $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
        $16 = HEAP16[$21 + 16 >> 1];
        $15 = HEAP32[$20 - 32 >> 2];
        $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
        $16 = HEAP16[$21 + 18 >> 1];
        $15 = HEAP32[$20 - 36 >> 2];
        $38 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
        if (($53 | 0) == 16) {
         $16 = HEAP16[$21 + 20 >> 1];
         $15 = HEAP32[$20 - 40 >> 2];
         $13 = (Math_imul($16, $15 >> 16) + $38 | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
         $16 = HEAP16[$21 + 22 >> 1];
         $15 = HEAP32[$20 - 44 >> 2];
         $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
         $16 = HEAP16[$21 + 24 >> 1];
         $15 = HEAP32[$20 - 48 >> 2];
         $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
         $16 = HEAP16[$21 + 26 >> 1];
         $15 = HEAP32[$20 - 52 >> 2];
         $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
         $16 = HEAP16[$21 + 28 >> 1];
         $15 = HEAP32[$20 - 56 >> 2];
         $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
         $16 = HEAP16[$21 + 30 >> 1];
         $15 = HEAP32[$20 - 60 >> 2];
         $38 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
        }
        $45 = 0;
        if (!$50) {
         $16 = HEAP16[$36 >> 1];
         $15 = HEAP32[$31 >> 2];
         $13 = Math_imul($16, $15 >> 16) + (Math_imul($15 & 65535, $16) >> 16) | 0;
         $16 = HEAP16[$36 + 2 >> 1];
         $15 = HEAP32[$31 - 4 >> 2];
         $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
         $16 = HEAP16[$36 + 4 >> 1];
         $15 = HEAP32[$31 - 8 >> 2];
         $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
         $16 = HEAP16[$36 + 6 >> 1];
         $15 = HEAP32[$31 - 12 >> 2];
         $13 = ($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0;
         $16 = HEAP16[$36 + 8 >> 1];
         $15 = HEAP32[$31 - 16 >> 2];
         $45 = (($13 + Math_imul($16, $15 >> 16) | 0) + (Math_imul($15 & 65535, $16) >> 16) | 0) + 2 | 0;
         $31 = $31 + 4 | 0;
        }
        if ($70) {
         break label$2;
        }
        $16 = HEAP32[$1 + 4224 >> 2];
        $15 = HEAP32[$1 + 4324 >> 2];
        HEAP32[$1 + 4224 >> 2] = $15;
        $18 = HEAP16[$14 >> 1];
        $17 = (Math_imul($18, $15 >> 16) + $69 | 0) + (Math_imul($15 & 65535, $18) >> 16) | 0;
        $15 = 2;
        if (($29 | 0) >= 3) {
         while (1) {
          $13 = $1 + 4224 | 0;
          $19 = $15 - 1 | 0;
          $22 = $13 + ($19 << 2) | 0;
          $18 = HEAP32[$22 >> 2];
          HEAP32[$22 >> 2] = $16;
          $22 = ($15 << 2) + $13 | 0;
          $23 = HEAP32[$22 >> 2];
          $13 = HEAP16[($19 << 1) + $14 >> 1];
          HEAP32[$22 >> 2] = $18;
          $13 = (Math_imul($16 >> 16, $13) + $17 | 0) + (Math_imul($16 & 65535, $13) >> 16) | 0;
          $16 = HEAP16[($15 << 1) + $14 >> 1];
          $17 = ($13 + Math_imul($16, $18 >> 16) | 0) + (Math_imul($18 & 65535, $16) >> 16) | 0;
          $16 = $23;
          $15 = $15 + 2 | 0;
          if (($29 | 0) > ($15 | 0)) {
           continue;
          }
          break;
         }
        }
        HEAP32[$26 >> 2] = $16;
        if (!$68) {
         break label$1;
        }
        $15 = HEAP32[$1 + 4320 >> 2];
        $18 = $15 & 65535;
        $15 = $15 >> 16;
        $13 = HEAP16[$35 >> 1];
        $22 = ((Math_imul($57, $18) >> 16) + Math_imul($57, $15) | 0) + ((Math_imul($13, $16 >> 16) + $17 | 0) + (Math_imul($16 & 65535, $13) >> 16) << 1) | 0;
        $13 = Math_imul($15, $52) + (Math_imul($18, $52) >> 16) | 0;
        $15 = HEAP32[((HEAP32[$1 + 4336 >> 2] << 2) + $1 | 0) + 1276 >> 2];
        $23 = ($13 + Math_imul($15 >> 16, $56) | 0) + (Math_imul($15 & 65535, $56) >> 16) | 0;
        $15 = (($38 << 2) - $22 | 0) - $23 | 0;
        label$29 : {
         if (($32 | 0) >= 1) {
          $13 = ($15 << 1) + $45 | 0;
          $15 = HEAP32[$37 - 4 >> 2];
          $16 = HEAP32[$37 - 8 >> 2] + HEAP32[$37 >> 2] | 0;
          $15 = $13 - (((Math_imul($15 >> 16, $51) + Math_imul($16 >> 16, $55) | 0) + (Math_imul($16 & 65535, $55) >> 16) | 0) + (Math_imul($15 & 65535, $51) >> 16) << 1) >> 2;
          $37 = $37 + 4 | 0;
          break label$29;
         }
         $15 = $15 >> 1;
        }
        label$31 : {
         label$32 : {
          label$33 : {
           label$34 : {
            $58 = ($27 << 2) + $40 | 0;
            $15 = HEAP32[$58 >> 2] - ($15 + 1 >> 1) | 0;
            $15 = HEAP32[$1 + 4340 >> 2] < 0 ? 0 - $15 | 0 : $15;
            $15 = ($15 | 0) > -31744 ? $15 : -31744;
            $13 = ($15 | 0) < 30720 ? $15 : 30720;
            $15 = $13 - $25 | 0;
            $16 = $15;
            label$35 : {
             if ($66) {
              break label$35;
             }
             $16 = $15 - $42 | 0;
             if (($15 | 0) > ($42 | 0)) {
              break label$35;
             }
             if (($15 | 0) >= ($65 | 0)) {
              break label$34;
             }
             $16 = $15 + $42 | 0;
            }
            $15 = $16;
            if (($15 | 0) >= 1024) {
             $16 = ($15 & -1024) + $63 | 0;
             $17 = Math_imul($16 << 16 >> 16, $30);
             $18 = $16 + 1024 | 0;
             $19 = Math_imul($18 << 16 >> 16, $30);
             break label$31;
            }
            $16 = $25;
            $18 = $41;
            $17 = $44;
            $19 = $46;
            switch (($15 >> 10) + 1 | 0) {
            case 1:
             break label$31;
            case 0:
             break label$33;
            default:
             break label$32;
            }
           }
           $16 = $25;
           $18 = $41;
           $17 = $44;
           $19 = $46;
           if (($15 | 0) >= 0) {
            break label$31;
           }
          }
          $16 = $47;
          $18 = $25;
          $17 = $61;
          $19 = $44;
          break label$31;
         }
         $16 = ($15 & -1024 | 80) + $25 | 0;
         $17 = Math_imul(0 - ($16 << 16) >> 16, $30);
         $18 = $16 + 1024 | 0;
         $19 = Math_imul(0 - ($18 << 16) >> 16, $30);
        }
        $59 = $4 + $27 | 0;
        $15 = $13 - $18 << 16 >> 16;
        $19 = Math_imul($15, $15) + $19 | 0;
        $15 = $13 - $16 << 16 >> 16;
        $15 = ($19 | 0) < (Math_imul($15, $15) + $17 | 0) ? $18 : $16;
        HEAP8[$59 | 0] = ($15 >>> 9 | 0) + 1 >>> 1;
        $15 = $15 << 4;
        $18 = ($45 << 1) + (HEAP32[$1 + 4340 >> 2] < 0 ? 0 - $15 | 0 : $15) | 0;
        $15 = $18 + ($38 << 4) | 0;
        $16 = (Math_imul($15 >> 16, $54) + Math_imul($15, $72) | 0) + (Math_imul($15 & 65534, $54) >> 16) | 0;
        HEAP16[($27 << 1) + $43 >> 1] = ($16 | 0) > 8388479 ? 32767 : ($16 | 0) < -8388736 ? -32768 : ($16 >>> 7 | 0) + 1 >>> 1 | 0;
        HEAP32[$20 + 4 >> 2] = $15;
        $15 = $15 - (HEAP32[$58 >> 2] << 4) | 0;
        HEAP32[$1 + 4324 >> 2] = $15;
        $15 = $15 - ($22 << 2) | 0;
        HEAP32[$1 + 4320 >> 2] = $15;
        HEAP32[((HEAP32[$1 + 4336 >> 2] << 2) + $1 | 0) + 1280 >> 2] = $15 - ($23 << 2);
        $15 = HEAP32[$1 + 4332 >> 2];
        HEAP32[($15 << 2) + $34 >> 2] = $18 << 1;
        HEAP32[$1 + 4332 >> 2] = $15 + 1;
        HEAP32[$1 + 4336 >> 2] = HEAP32[$1 + 4336 >> 2] + 1;
        $15 = HEAP32[$1 + 4340 >> 2] + HEAP8[$59 | 0] | 0;
        HEAP32[$1 + 4340 >> 2] = $15;
        $20 = $20 + 4 | 0;
        $27 = $27 + 1 | 0;
        if (($33 | 0) != ($27 | 0)) {
         continue;
        }
        break;
       }
      }
      $15 = ($33 << 2) + $1 | 0;
      $19 = $15 + 3896 | 0;
      $14 = HEAP32[$19 >> 2];
      $17 = HEAP32[$19 + 4 >> 2];
      $13 = $14;
      $14 = $67;
      HEAP32[$14 + 56 >> 2] = $13;
      HEAP32[$14 + 60 >> 2] = $17;
      $19 = $15 + 3888 | 0;
      $17 = HEAP32[$19 >> 2];
      $14 = HEAP32[$19 + 4 >> 2];
      $13 = $17;
      $17 = $28;
      HEAP32[$17 + 48 >> 2] = $13;
      HEAP32[$17 + 52 >> 2] = $14;
      $19 = $15 + 3880 | 0;
      $14 = HEAP32[$19 >> 2];
      $17 = HEAP32[$19 + 4 >> 2];
      $13 = $14;
      $14 = $28;
      HEAP32[$14 + 40 >> 2] = $13;
      HEAP32[$14 + 44 >> 2] = $17;
      $19 = $15 + 3872 | 0;
      $17 = HEAP32[$19 >> 2];
      $14 = HEAP32[$19 + 4 >> 2];
      $13 = $17;
      $17 = $28;
      HEAP32[$17 + 32 >> 2] = $13;
      HEAP32[$17 + 36 >> 2] = $14;
      $19 = $15 + 3864 | 0;
      $14 = HEAP32[$19 >> 2];
      $17 = HEAP32[$19 + 4 >> 2];
      $13 = $14;
      $14 = $28;
      HEAP32[$14 + 24 >> 2] = $13;
      HEAP32[$14 + 28 >> 2] = $17;
      $19 = $15 + 3856 | 0;
      $17 = HEAP32[$19 >> 2];
      $14 = HEAP32[$19 + 4 >> 2];
      $13 = $17;
      $17 = $28;
      HEAP32[$17 + 16 >> 2] = $13;
      HEAP32[$17 + 20 >> 2] = $14;
      $19 = $15 + 3848 | 0;
      $14 = HEAP32[$19 >> 2];
      $17 = HEAP32[$19 + 4 >> 2];
      $13 = $14;
      $14 = $28;
      HEAP32[$14 + 8 >> 2] = $13;
      HEAP32[$14 + 12 >> 2] = $17;
      $19 = $15 + 3840 | 0;
      $17 = HEAP32[$19 >> 2];
      $14 = HEAP32[$19 + 4 >> 2];
      $13 = $17;
      $17 = $28;
      HEAP32[$17 >> 2] = $13;
      HEAP32[$17 + 4 >> 2] = $14;
      $16 = HEAP32[$0 + 4580 >> 2];
      $24 = $24 + 1 | 0;
      if (($16 | 0) > ($24 | 0)) {
       $15 = HEAP32[$0 + 4588 >> 2];
       $4 = $15 + $4 | 0;
       $16 = $15 << 1;
       $3 = $16 + $3 | 0;
       $43 = $16 + $43 | 0;
       $23 = HEAPU8[$2 + 29 | 0];
       continue;
      }
      break;
     }
     $17 = HEAP32[$0 + 4584 >> 2];
     $18 = HEAP32[$0 + 4592 >> 2];
    }
    HEAP32[$1 + 4328 >> 2] = HEAP32[(($16 << 2) + $12 | 0) - 4 >> 2];
    $15 = memmove($1, ($17 << 1) + $1 | 0, $18 << 1) + 1280 | 0;
    memmove($15, (HEAP32[$0 + 4584 >> 2] << 2) + $15 | 0, HEAP32[$0 + 4592 >> 2] << 2);
    __stack_pointer = $60;
    return;
   }
   celt_fatal(16318, 16350, 146);
   abort();
  }
  celt_fatal(16361, 16350, 250);
  abort();
 }
 celt_fatal(16408, 16350, 258);
 abort();
}
function silk_encode_frame_FLP($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = Math_fround(0), $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0;
 $9 = __stack_pointer - 13584 | 0;
 __stack_pointer = $9;
 HEAP32[$9 + 40 >> 2] = 0;
 HEAP32[$9 + 44 >> 2] = 0;
 HEAP32[$9 + 32 >> 2] = 0;
 HEAP32[$9 + 36 >> 2] = 0;
 $10 = HEAP32[$0 + 4620 >> 2];
 HEAP8[$0 + 4770 | 0] = $10 & 3;
 HEAP32[$0 + 4620 >> 2] = $10 + 1;
 $10 = HEAP32[$0 + 4592 >> 2];
 silk_LP_variable_cutoff($0 + 16 | 0, $0 + 5098 | 0, HEAP32[$0 + 4584 >> 2]);
 $14 = $10 << 2;
 $28 = $0 + 7180 | 0;
 $15 = $14 + $28 | 0;
 $11 = Math_imul(HEAP32[$0 + 4576 >> 2], 5);
 $12 = $15 + ($11 << 2) | 0;
 $13 = HEAP32[$0 + 4584 >> 2];
 if (($13 | 0) >= 1) {
  $10 = $13;
  while (1) {
   $6 = $10 - 1 | 0;
   HEAPF32[($6 << 2) + $12 >> 2] = HEAP16[(($10 << 1) + $0 | 0) + 5096 >> 1];
   $7 = ($10 | 0) > 1;
   $10 = $6;
   if ($7) {
    continue;
   }
   break;
  }
 }
 HEAPF32[$12 >> 2] = HEAPF32[$12 >> 2] + Math_fround(9.999999974752427e-7);
 $10 = $13 >> 3;
 $6 = ($11 + $10 << 2) + $15 | 0;
 HEAPF32[$6 >> 2] = HEAPF32[$6 >> 2] + Math_fround(9.999999974752427e-7);
 $6 = (($10 << 1) + $11 << 2) + $15 | 0;
 HEAPF32[$6 >> 2] = HEAPF32[$6 >> 2] + Math_fround(-9.999999974752427e-7);
 $6 = (Math_imul($10, 3) + $11 << 2) + $15 | 0;
 HEAPF32[$6 >> 2] = HEAPF32[$6 >> 2] + Math_fround(-9.999999974752427e-7);
 $6 = (($10 << 2) + $11 << 2) + $15 | 0;
 HEAPF32[$6 >> 2] = HEAPF32[$6 >> 2] + Math_fround(9.999999974752427e-7);
 $6 = (Math_imul($10, 5) + $11 << 2) + $15 | 0;
 HEAPF32[$6 >> 2] = HEAPF32[$6 >> 2] + Math_fround(9.999999974752427e-7);
 $6 = (Math_imul($10, 6) + $11 << 2) + $15 | 0;
 HEAPF32[$6 >> 2] = HEAPF32[$6 >> 2] + Math_fround(-9.999999974752427e-7);
 $10 = (Math_imul($10, 7) + $11 << 2) + $15 | 0;
 HEAPF32[$10 >> 2] = HEAPF32[$10 >> 2] + Math_fround(-9.999999974752427e-7);
 label$3 : {
  if (HEAP32[$0 + 4680 >> 2]) {
   break label$3;
  }
  $20 = $0 + 4736 | 0;
  silk_find_pitch_lags_FLP($0, $9 + 8480 | 0, $9 + 5792 | 0, $15, HEAP32[$0 + 5092 >> 2]);
  $10 = ($9 + 5792 | 0) + $14 | 0;
  silk_noise_shape_analysis_FLP($0, $9 + 8480 | 0, $10, $15);
  silk_find_pred_coefs_FLP($0, $9 + 8480 | 0, $10, $15, $3);
  silk_process_gains_FLP($0, $9 + 8480 | 0, $3);
  if (!(!HEAP32[$0 + 6092 >> 2] | HEAP32[$0 + 4532 >> 2] < 78)) {
   $10 = HEAP32[$0 + 5748 >> 2];
   HEAP32[(($10 << 2) + $0 | 0) + 4724 >> 2] = 1;
   memcpy($9 + 9232 | 0, $0 + 148 | 0, 4352);
   $12 = (Math_imul($10, 36) + $0 | 0) + 6100 | 0;
   $7 = $0 + 4768 | 0;
   $7 = HEAPU16[$7 >> 1] | HEAPU16[$7 + 2 >> 1] << 16;
   HEAP16[$12 + 32 >> 1] = $7;
   HEAP16[$12 + 34 >> 1] = $7 >>> 16;
   $8 = $0 + 4760 | 0;
   $6 = HEAPU16[$8 >> 1] | HEAPU16[$8 + 2 >> 1] << 16;
   $7 = HEAPU16[$8 + 4 >> 1] | HEAPU16[$8 + 6 >> 1] << 16;
   $8 = $6;
   $6 = $12;
   HEAP16[$6 + 24 >> 1] = $8;
   HEAP16[$6 + 26 >> 1] = $8 >>> 16;
   HEAP16[$6 + 28 >> 1] = $7;
   HEAP16[$6 + 30 >> 1] = $7 >>> 16;
   $8 = $0 + 4752 | 0;
   $7 = HEAPU16[$8 >> 1] | HEAPU16[$8 + 2 >> 1] << 16;
   $6 = HEAPU16[$8 + 4 >> 1] | HEAPU16[$8 + 6 >> 1] << 16;
   $8 = $7;
   $7 = $12;
   HEAP16[$7 + 16 >> 1] = $8;
   HEAP16[$7 + 18 >> 1] = $8 >>> 16;
   HEAP16[$7 + 20 >> 1] = $6;
   HEAP16[$7 + 22 >> 1] = $6 >>> 16;
   $8 = $0 + 4744 | 0;
   $6 = HEAPU16[$8 >> 1] | HEAPU16[$8 + 2 >> 1] << 16;
   $7 = HEAPU16[$8 + 4 >> 1] | HEAPU16[$8 + 6 >> 1] << 16;
   $8 = $6;
   $6 = $12;
   HEAP16[$6 + 8 >> 1] = $8;
   HEAP16[$6 + 10 >> 1] = $8 >>> 16;
   HEAP16[$6 + 12 >> 1] = $7;
   HEAP16[$6 + 14 >> 1] = $7 >>> 16;
   $6 = HEAPU16[$0 + 4740 >> 1] | HEAPU16[$0 + 4742 >> 1] << 16;
   $7 = HEAPU16[$0 + 4736 >> 1] | HEAPU16[$0 + 4738 >> 1] << 16;
   $8 = $7;
   $7 = $12;
   HEAP16[$7 >> 1] = $8;
   HEAP16[$7 + 2 >> 1] = $8 >>> 16;
   HEAP16[$7 + 4 >> 1] = $6;
   HEAP16[$7 + 6 >> 1] = $6 >>> 16;
   $10 = HEAP32[$0 + 4580 >> 2];
   memcpy($9 + 48 | 0, $9 + 8480 | 0, $10 << 2);
   $8 = $9 + 1344 | 0;
   $11 = $0 + 4540 | 0;
   $14 = ($3 | 0) == 2;
   $6 = HEAP32[$0 + 5748 >> 2];
   if (!(HEAP32[(($6 << 2) + $0 | 0) + 4720 >> 2] ? $6 : 0)) {
    HEAP8[$0 + 4540 | 0] = HEAPU8[$0 + 7168 | 0];
    $10 = HEAPU8[$12 | 0] + HEAPU8[$0 + 6096 | 0] | 0;
    HEAP8[$12 | 0] = $10 << 24 >> 24 < 63 ? $10 : 63;
    $10 = HEAP32[$0 + 4580 >> 2];
   }
   silk_gains_dequant($8, $7, $11, $14, $10);
   $7 = HEAP32[$0 + 4580 >> 2];
   if (($7 | 0) >= 1) {
    $10 = 0;
    while (1) {
     $6 = $10 << 2;
     HEAPF32[$6 + ($9 + 8480 | 0) >> 2] = Math_fround(HEAP32[($9 + 1344 | 0) + $6 >> 2]) * Math_fround(152587890625e-16);
     $10 = $10 + 1 | 0;
     if (($7 | 0) != ($10 | 0)) {
      continue;
     }
     break;
    }
   }
   silk_NSQ_wrapper_FLP($0, $9 + 8480 | 0, $12, $9 + 9232 | 0, (Math_imul(HEAP32[$0 + 5748 >> 2], 320) + $0 | 0) + 6208 | 0, $15);
   memcpy($9 + 8480 | 0, $9 + 48 | 0, HEAP32[$0 + 4580 >> 2] << 2);
  }
  $16 = silk_gains_ID($20, HEAP32[$0 + 4580 >> 2]);
  $8 = $2;
  $6 = HEAP32[$8 + 40 >> 2];
  $7 = HEAP32[$8 + 44 >> 2];
  $11 = $6;
  $29 = $9 + 5784 | 0;
  $6 = $29;
  HEAP32[$6 >> 2] = $11;
  HEAP32[$6 + 4 >> 2] = $7;
  $6 = HEAP32[$8 + 36 >> 2];
  $7 = HEAP32[$8 + 32 >> 2];
  $11 = $7;
  $30 = $9 + 5776 | 0;
  $7 = $30;
  HEAP32[$7 >> 2] = $11;
  HEAP32[$7 + 4 >> 2] = $6;
  $7 = HEAP32[$8 + 28 >> 2];
  $6 = HEAP32[$8 + 24 >> 2];
  $11 = $6;
  $31 = $9 + 5768 | 0;
  $6 = $31;
  HEAP32[$6 >> 2] = $11;
  HEAP32[$6 + 4 >> 2] = $7;
  $6 = HEAP32[$8 + 20 >> 2];
  $7 = HEAP32[$8 + 16 >> 2];
  $11 = $7;
  $32 = $9 + 5760 | 0;
  $7 = $32;
  HEAP32[$7 >> 2] = $11;
  HEAP32[$7 + 4 >> 2] = $6;
  $7 = HEAP32[$8 + 12 >> 2];
  $6 = HEAP32[$8 + 8 >> 2];
  $11 = $6;
  $33 = $9 + 5752 | 0;
  $6 = $33;
  HEAP32[$6 >> 2] = $11;
  HEAP32[$6 + 4 >> 2] = $7;
  $6 = HEAP32[$8 + 4 >> 2];
  $7 = HEAP32[$8 >> 2];
  HEAP32[$9 + 5744 >> 2] = $7;
  HEAP32[$9 + 5748 >> 2] = $6;
  $21 = $0 + 148 | 0;
  memcpy($9 + 9232 | 0, $21, 4352);
  $41 = $0 + 4736 | 0;
  $34 = ($3 | 0) == 2;
  $42 = $4 - 5 | 0;
  $26 = $0 + 7168 | 0;
  $24 = $0 + 4772 | 0;
  $35 = HEAP32[$0 + 5768 >> 2];
  $36 = HEAPU16[$0 + 5772 >> 1];
  $43 = HEAPU8[$0 + 4770 | 0];
  $13 = 256;
  $27 = -1;
  $14 = -1;
  while (1) {
   $10 = ($16 | 0) == ($27 | 0);
   label$10 : {
    if ($10) {
     $11 = $25;
     break label$10;
    }
    if (($14 | 0) == ($16 | 0)) {
     $11 = $22;
     break label$10;
    }
    if ($17) {
     $7 = HEAP32[$9 + 5748 >> 2];
     $6 = HEAP32[$9 + 5744 >> 2];
     $8 = $6;
     $6 = $2;
     HEAP32[$6 >> 2] = $8;
     HEAP32[$6 + 4 >> 2] = $7;
     $8 = $29;
     $7 = HEAP32[$8 >> 2];
     $6 = HEAP32[$8 + 4 >> 2];
     $8 = $7;
     $7 = $2;
     HEAP32[$7 + 40 >> 2] = $8;
     HEAP32[$7 + 44 >> 2] = $6;
     $8 = $30;
     $6 = HEAP32[$8 >> 2];
     $7 = HEAP32[$8 + 4 >> 2];
     $8 = $6;
     $6 = $2;
     HEAP32[$6 + 32 >> 2] = $8;
     HEAP32[$6 + 36 >> 2] = $7;
     $8 = $31;
     $7 = HEAP32[$8 >> 2];
     $6 = HEAP32[$8 + 4 >> 2];
     $8 = $7;
     $7 = $2;
     HEAP32[$7 + 24 >> 2] = $8;
     HEAP32[$7 + 28 >> 2] = $6;
     $8 = $32;
     $6 = HEAP32[$8 >> 2];
     $7 = HEAP32[$8 + 4 >> 2];
     $8 = $6;
     $6 = $2;
     HEAP32[$6 + 16 >> 2] = $8;
     HEAP32[$6 + 20 >> 2] = $7;
     $8 = $33;
     $7 = HEAP32[$8 >> 2];
     $6 = HEAP32[$8 + 4 >> 2];
     $8 = $7;
     $7 = $2;
     HEAP32[$7 + 8 >> 2] = $8;
     HEAP32[$7 + 12 >> 2] = $6;
     memcpy($21, $9 + 9232 | 0, 4352);
     HEAP16[$0 + 5772 >> 1] = $36;
     HEAP8[$0 + 4770 | 0] = $43;
     HEAP32[$0 + 5768 >> 2] = $35;
    }
    silk_NSQ_wrapper_FLP($0, $9 + 8480 | 0, $20, $21, $24, $15);
    if (!(($17 | 0) != 6 | $19)) {
     $8 = $2;
     $6 = HEAP32[$8 + 16 >> 2];
     $7 = HEAP32[$8 + 20 >> 2];
     $11 = $6;
     $6 = $9 + 5736 | 0;
     HEAP32[$6 >> 2] = $11;
     HEAP32[$6 + 4 >> 2] = $7;
     $6 = HEAP32[$8 + 12 >> 2];
     $7 = HEAP32[$8 + 8 >> 2];
     $11 = $7;
     $7 = $9 + 5728 | 0;
     HEAP32[$7 >> 2] = $11;
     HEAP32[$7 + 4 >> 2] = $6;
     $7 = HEAP32[$8 + 4 >> 2];
     $6 = HEAP32[$8 >> 2];
     HEAP32[$9 + 5720 >> 2] = $6;
     HEAP32[$9 + 5724 >> 2] = $7;
     $18 = HEAP32[$8 + 24 >> 2];
     $6 = HEAP32[$8 + 40 >> 2];
     $7 = HEAP32[$8 + 36 >> 2];
     $11 = $7;
     $7 = $9 + 5704 | 0;
     HEAP32[$7 >> 2] = $11;
     HEAP32[$7 + 4 >> 2] = $6;
     HEAP32[$9 + 5712 >> 2] = HEAP32[$8 + 44 >> 2];
     $7 = HEAP32[$8 + 32 >> 2];
     $6 = HEAP32[$8 + 28 >> 2];
     HEAP32[$9 + 5696 >> 2] = $6;
     HEAP32[$9 + 5700 >> 2] = $7;
    }
    silk_encode_indices($0, $2, HEAP32[$0 + 5748 >> 2], 0, $3);
    silk_encode_pulses($2, HEAP8[$0 + 4765 | 0], HEAP8[$0 + 4766 | 0], $24, HEAP32[$0 + 4584 >> 2]);
    $11 = (HEAP32[$2 + 20 >> 2] + Math_clz32(HEAP32[$2 + 28 >> 2]) | 0) - 32 | 0;
    if (!($19 | ($11 | 0) <= ($4 | 0) | ($17 | 0) != 6)) {
     $6 = HEAP32[$9 + 5724 >> 2];
     $7 = HEAP32[$9 + 5720 >> 2];
     $8 = $7;
     $7 = $2;
     HEAP32[$7 >> 2] = $8;
     HEAP32[$7 + 4 >> 2] = $6;
     $8 = $9 + 5736 | 0;
     $6 = HEAP32[$8 >> 2];
     $7 = HEAP32[$8 + 4 >> 2];
     $8 = $6;
     $6 = $2;
     HEAP32[$6 + 16 >> 2] = $8;
     HEAP32[$6 + 20 >> 2] = $7;
     $8 = $9 + 5728 | 0;
     $7 = HEAP32[$8 >> 2];
     $6 = HEAP32[$8 + 4 >> 2];
     $8 = $7;
     $7 = $2;
     HEAP32[$7 + 8 >> 2] = $8;
     HEAP32[$7 + 12 >> 2] = $6;
     HEAP32[$7 + 24 >> 2] = $18;
     HEAP32[$7 + 44 >> 2] = HEAP32[$9 + 5712 >> 2];
     $8 = $9 + 5704 | 0;
     $6 = HEAP32[$8 >> 2];
     $7 = HEAP32[$8 + 4 >> 2];
     $8 = $6;
     $6 = $2;
     HEAP32[$6 + 36 >> 2] = $8;
     HEAP32[$6 + 40 >> 2] = $7;
     $6 = HEAP32[$9 + 5700 >> 2];
     $7 = HEAP32[$9 + 5696 >> 2];
     $8 = $7;
     $7 = $2;
     HEAP32[$7 + 28 >> 2] = $8;
     HEAP32[$7 + 32 >> 2] = $6;
     $7 = HEAPU8[$9 + 9224 | 0];
     HEAP8[$0 + 7168 | 0] = $7;
     $6 = HEAP32[$0 + 4580 >> 2];
     if (($6 | 0) >= 1) {
      memset($41, 4, $6);
     }
     if (!$34) {
      HEAP8[$20 | 0] = $7;
     }
     HEAP32[$0 + 5768 >> 2] = $35;
     HEAP16[$0 + 5772 >> 1] = $36;
     $6 = HEAP32[$0 + 4584 >> 2];
     if (($6 | 0) >= 1) {
      memset($24, 0, $6);
     }
     silk_encode_indices($0, $2, HEAP32[$0 + 5748 >> 2], 0, $3);
     silk_encode_pulses($2, HEAP8[$0 + 4765 | 0], HEAP8[$0 + 4766 | 0], $24, HEAP32[$0 + 4584 >> 2]);
     $11 = (HEAP32[$2 + 20 >> 2] + Math_clz32(HEAP32[$2 + 28 >> 2]) | 0) - 32 | 0;
    }
    if ($5 | $17) {
     break label$10;
    }
    if (($4 | 0) >= ($11 | 0)) {
     break label$3;
    }
   }
   label$19 : {
    label$20 : {
     label$21 : {
      label$22 : {
       label$23 : {
        label$24 : {
         if (($17 | 0) == 6) {
          if (!$19 | !(($4 | 0) < ($11 | 0) | $10)) {
           break label$3;
          }
          $7 = HEAP32[$9 + 5724 >> 2];
          $6 = HEAP32[$9 + 5720 >> 2];
          $3 = $6;
          $6 = $2;
          HEAP32[$6 >> 2] = $3;
          HEAP32[$6 + 4 >> 2] = $7;
          $8 = $9 + 5736 | 0;
          $7 = HEAP32[$8 >> 2];
          $6 = HEAP32[$8 + 4 >> 2];
          $3 = $7;
          $7 = $2;
          HEAP32[$7 + 16 >> 2] = $3;
          HEAP32[$7 + 20 >> 2] = $6;
          $8 = $9 + 5728 | 0;
          $6 = HEAP32[$8 >> 2];
          $7 = HEAP32[$8 + 4 >> 2];
          $3 = $6;
          $6 = $2;
          HEAP32[$6 + 8 >> 2] = $3;
          HEAP32[$6 + 12 >> 2] = $7;
          HEAP32[$6 + 24 >> 2] = $18;
          HEAP32[$6 + 44 >> 2] = HEAP32[$9 + 5712 >> 2];
          $8 = $9 + 5704 | 0;
          $7 = HEAP32[$8 >> 2];
          $6 = HEAP32[$8 + 4 >> 2];
          $3 = $7;
          $7 = $2;
          HEAP32[$7 + 36 >> 2] = $3;
          HEAP32[$7 + 40 >> 2] = $6;
          $7 = HEAP32[$9 + 5700 >> 2];
          $6 = HEAP32[$9 + 5696 >> 2];
          $3 = $6;
          $6 = $2;
          HEAP32[$6 + 28 >> 2] = $3;
          HEAP32[$6 + 32 >> 2] = $7;
          if ($18 >>> 0 >= 1276) {
           break label$24;
          }
          memcpy(HEAP32[$2 >> 2], $9 + 48 | 0, $18);
          memcpy($21, $9 + 1344 | 0, 4352);
          HEAP8[$26 | 0] = $44;
          break label$3;
         }
         label$26 : {
          label$27 : {
           label$28 : {
            label$29 : {
             if (($4 | 0) < ($11 | 0)) {
              if ($17 >>> 0 < 2 | $19) {
               break label$29;
              }
              $37 = Math_fround(HEAPF32[$9 + 9172 >> 2] * Math_fround(1.5));
              HEAPF32[$9 + 9172 >> 2] = $37 > Math_fround(1.5) ? $37 : Math_fround(1.5);
              $38 = 0;
              HEAP8[$0 + 4766 | 0] = 0;
              $16 = -1;
              break label$28;
             }
             if (($11 | 0) >= ($42 | 0)) {
              break label$3;
             }
             if (!$10) {
              $8 = $2;
              $7 = HEAP32[$8 + 16 >> 2];
              $6 = HEAP32[$8 + 20 >> 2];
              $12 = $7;
              $7 = $9 + 5736 | 0;
              HEAP32[$7 >> 2] = $12;
              HEAP32[$7 + 4 >> 2] = $6;
              $7 = HEAP32[$8 + 12 >> 2];
              $6 = HEAP32[$8 + 8 >> 2];
              $12 = $6;
              $6 = $9 + 5728 | 0;
              HEAP32[$6 >> 2] = $12;
              HEAP32[$6 + 4 >> 2] = $7;
              $6 = HEAP32[$8 + 4 >> 2];
              $7 = HEAP32[$8 >> 2];
              HEAP32[$9 + 5720 >> 2] = $7;
              HEAP32[$9 + 5724 >> 2] = $6;
              $18 = HEAP32[$8 + 24 >> 2];
              $7 = HEAP32[$8 + 40 >> 2];
              $6 = HEAP32[$8 + 36 >> 2];
              $12 = $6;
              $6 = $9 + 5704 | 0;
              HEAP32[$6 >> 2] = $12;
              HEAP32[$6 + 4 >> 2] = $7;
              HEAP32[$9 + 5712 >> 2] = HEAP32[$8 + 44 >> 2];
              $6 = HEAP32[$8 + 32 >> 2];
              $7 = HEAP32[$8 + 28 >> 2];
              HEAP32[$9 + 5696 >> 2] = $7;
              HEAP32[$9 + 5700 >> 2] = $6;
              if ($18 >>> 0 >= 1276) {
               break label$23;
              }
              memcpy($9 + 48 | 0, HEAP32[$2 >> 2], $18);
              memcpy($9 + 1344 | 0, $21, 4352);
              $44 = HEAPU8[$26 | 0];
             }
             $23 = $13 << 16 >> 16;
             $19 = 1;
             if (!$38) {
              break label$22;
             }
             $25 = $11;
             $11 = $22;
             $27 = $16;
             break label$26;
            }
            $39 = $13 << 16 >> 16;
            $38 = 1;
            if ($19) {
             break label$27;
            }
            $22 = $11;
           }
           $40 = HEAP32[$0 + 4580 >> 2];
           if (($40 | 0) < 1) {
            break label$21;
           }
           $11 = 0;
           $14 = HEAP32[$0 + 4588 >> 2];
           $12 = $14;
           while (1) {
            $6 = 0;
            $10 = Math_imul($11, $14);
            $8 = $11 + 1 | 0;
            if (($10 | 0) < (Math_imul($8, $14) | 0)) {
             while (1) {
              $7 = HEAP8[($0 + $10 | 0) + 4772 | 0];
              $45 = $7;
              $7 = $7 >> 31;
              $6 = ($7 ^ $7 + $45) + $6 | 0;
              $10 = $10 + 1 | 0;
              if (($12 | 0) != ($10 | 0)) {
               continue;
              }
              break;
             }
            }
            label$35 : {
             label$36 : {
              if ($17) {
               $10 = $11 << 2;
               if (HEAP32[$10 + $9 >> 2] <= ($6 | 0) | HEAP32[($9 + 32 | 0) + $10 >> 2]) {
                break label$36;
               }
              }
              HEAP16[($9 + 24 | 0) + ($11 << 1) >> 1] = $13;
              HEAP32[($11 << 2) + $9 >> 2] = $6;
              break label$35;
             }
             HEAP32[($9 + 32 | 0) + $10 >> 2] = 1;
            }
            $12 = $12 + $14 | 0;
            $11 = $8;
            if (($40 | 0) != ($11 | 0)) {
             continue;
            }
            break;
           }
           break label$21;
          }
          $14 = $16;
          $16 = $14;
          if (!$19) {
           break label$20;
          }
         }
         $10 = $39 - $23 | 0;
         $6 = ((Math_imul($10, $4 - $25 | 0) | 0) / ($11 - $25 | 0) | 0) + $23 | 0;
         $7 = $6 << 16 >> 16;
         $10 = $10 >> 2;
         $13 = $23 + $10 | 0;
         if (($7 | 0) > ($13 | 0)) {
          break label$19;
         }
         $10 = $39 - $10 | 0;
         $13 = ($10 | 0) > ($7 | 0) ? $10 : $6;
         break label$19;
        }
        celt_fatal(16895, 16942, 251);
        abort();
       }
       celt_fatal(16972, 16942, 281);
       abort();
      }
      $10 = silk_log2lin((($11 - $4 << 7) / HEAP32[$0 + 4584 >> 2] | 0) + 2048 | 0);
      $13 = (Math_imul($10 & 65535, $23) >>> 16 | 0) + Math_imul($10 >> 16, $23) | 0;
      $25 = $11;
      $11 = $22;
      $27 = $16;
      break label$19;
     }
     $11 = $22;
    }
    $14 = $16;
    $13 = $13 << 16 >> 16 < 16384 ? $13 << 1 : 32767;
   }
   $10 = 0;
   $12 = HEAP32[$0 + 4580 >> 2];
   if (($12 | 0) >= 1) {
    while (1) {
     $7 = $13;
     $6 = $10 << 2;
     $7 = HEAP32[$6 + ($9 + 32 | 0) >> 2] ? HEAPU16[($9 + 24 | 0) + ($10 << 1) >> 1] : $7;
     $8 = ($9 + 1328 | 0) + $6 | 0;
     $7 = $7 << 16 >> 16;
     $6 = HEAP32[($9 + $6 | 0) + 9208 >> 2];
     $6 = (Math_imul($7, $6 & 65535) >> 16) + Math_imul($6 >> 16, $7) | 0;
     $6 = ($6 | 0) > -8388608 ? $6 : -8388608;
     HEAP32[$8 >> 2] = (($6 | 0) < 8388607 ? $6 : 8388607) << 8;
     $10 = $10 + 1 | 0;
     if (($12 | 0) != ($10 | 0)) {
      continue;
     }
     break;
    }
   }
   HEAP8[$0 + 7168 | 0] = HEAPU8[$9 + 9224 | 0];
   silk_gains_quant($20, $9 + 1328 | 0, $26, $34, $12);
   $16 = silk_gains_ID($20, HEAP32[$0 + 4580 >> 2]);
   $10 = 0;
   $7 = HEAP32[$0 + 4580 >> 2];
   if (($7 | 0) >= 1) {
    while (1) {
     $6 = $10 << 2;
     HEAPF32[$6 + ($9 + 8480 | 0) >> 2] = Math_fround(HEAP32[($9 + 1328 | 0) + $6 >> 2]) * Math_fround(152587890625e-16);
     $10 = $10 + 1 | 0;
     if (($7 | 0) != ($10 | 0)) {
      continue;
     }
     break;
    }
   }
   $17 = $17 + 1 | 0;
   $22 = $11;
   continue;
  }
 }
 memmove($28, ((HEAP32[$0 + 4584 >> 2] << 2) + $0 | 0) + 7180 | 0, HEAP32[$0 + 4592 >> 2] + Math_imul(HEAP32[$0 + 4576 >> 2], 5) << 2);
 $10 = 0;
 if (!HEAP32[$0 + 4680 >> 2]) {
  $10 = HEAP32[((HEAP32[$0 + 4580 >> 2] << 2) + $9 | 0) + 8704 >> 2];
  HEAP32[$0 + 4664 >> 2] = 0;
  HEAP8[$0 + 4541 | 0] = HEAPU8[$0 + 4765 | 0];
  HEAP32[$0 + 4544 >> 2] = $10;
  $10 = (HEAP32[$2 + 20 >> 2] + Math_clz32(HEAP32[$2 + 28 >> 2]) | 0) - 25 >> 3;
 }
 HEAP32[$1 >> 2] = $10;
 __stack_pointer = $9 + 13584 | 0;
 return 0;
}
function printf_core($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0;
 $7 = __stack_pointer - 80 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 76 >> 2] = $1;
 $22 = $7 + 55 | 0;
 $20 = $7 + 56 | 0;
 $1 = 0;
 label$1 : {
  label$2 : while (1) {
   label$3 : {
    if (($17 | 0) < 0) {
     break label$3;
    }
    if ((2147483647 - $17 | 0) < ($1 | 0)) {
     HEAP32[__errno_location() >> 2] = 61;
     $17 = -1;
     break label$3;
    }
    $17 = $1 + $17 | 0;
   }
   label$5 : {
    label$7 : {
     label$8 : {
      $13 = HEAP32[$7 + 76 >> 2];
      $1 = $13;
      $8 = HEAPU8[$1 | 0];
      if ($8) {
       while (1) {
        label$11 : {
         $8 = $8 & 255;
         label$12 : {
          if (!$8) {
           $8 = $1;
           break label$12;
          }
          if (($8 | 0) != 37) {
           break label$11;
          }
          $8 = $1;
          while (1) {
           if (HEAPU8[$1 + 1 | 0] != 37) {
            break label$12;
           }
           $9 = $1 + 2 | 0;
           HEAP32[$7 + 76 >> 2] = $9;
           $8 = $8 + 1 | 0;
           $12 = HEAPU8[$1 + 2 | 0];
           $1 = $9;
           if (($12 | 0) == 37) {
            continue;
           }
           break;
          }
         }
         $1 = $8 - $13 | 0;
         if ($0) {
          out($0, $13, $1);
         }
         if ($1) {
          continue label$2;
         }
         $1 = isdigit(HEAP8[HEAP32[$7 + 76 >> 2] + 1 | 0]);
         $10 = $7;
         $8 = HEAP32[$7 + 76 >> 2];
         label$16 : {
          if (!(!$1 | HEAPU8[$8 + 2 | 0] != 36)) {
           $21 = 1;
           $1 = $8 + 3 | 0;
           $19 = HEAP8[$8 + 1 | 0] - 48 | 0;
           break label$16;
          }
          $1 = $8 + 1 | 0;
          $19 = -1;
         }
         HEAP32[$10 + 76 >> 2] = $1;
         $18 = 0;
         $12 = HEAP8[$1 | 0];
         $9 = $12 - 32 | 0;
         label$18 : {
          if ($9 >>> 0 > 31) {
           $8 = $1;
           break label$18;
          }
          $8 = $1;
          $9 = 1 << $9;
          if (!($9 & 75913)) {
           break label$18;
          }
          while (1) {
           $8 = $1 + 1 | 0;
           HEAP32[$7 + 76 >> 2] = $8;
           $18 = $9 | $18;
           $12 = HEAP8[$1 + 1 | 0];
           $9 = $12 - 32 | 0;
           if ($9 >>> 0 >= 32) {
            break label$18;
           }
           $1 = $8;
           $9 = 1 << $9;
           if ($9 & 75913) {
            continue;
           }
           break;
          }
         }
         label$21 : {
          if (($12 | 0) == 42) {
           $10 = $7;
           label$23 : {
            label$24 : {
             if (!isdigit(HEAP8[$8 + 1 | 0])) {
              break label$24;
             }
             $8 = HEAP32[$7 + 76 >> 2];
             if (HEAPU8[$8 + 2 | 0] != 36) {
              break label$24;
             }
             HEAP32[((HEAP8[$8 + 1 | 0] << 2) + $4 | 0) - 192 >> 2] = 10;
             $15 = HEAP32[((HEAP8[$8 + 1 | 0] << 3) + $3 | 0) - 384 >> 2];
             $21 = 1;
             $1 = $8 + 3 | 0;
             break label$23;
            }
            if ($21) {
             break label$8;
            }
            $21 = 0;
            $15 = 0;
            if ($0) {
             $1 = HEAP32[$2 >> 2];
             HEAP32[$2 >> 2] = $1 + 4;
             $15 = HEAP32[$1 >> 2];
            }
            $1 = HEAP32[$7 + 76 >> 2] + 1 | 0;
           }
           HEAP32[$10 + 76 >> 2] = $1;
           if (($15 | 0) > -1) {
            break label$21;
           }
           $15 = 0 - $15 | 0;
           $18 = $18 | 8192;
           break label$21;
          }
          $15 = getint($7 + 76 | 0);
          if (($15 | 0) < 0) {
           break label$8;
          }
          $1 = HEAP32[$7 + 76 >> 2];
         }
         $11 = -1;
         label$26 : {
          if (HEAPU8[$1 | 0] != 46) {
           break label$26;
          }
          if (HEAPU8[$1 + 1 | 0] == 42) {
           label$28 : {
            if (!isdigit(HEAP8[$1 + 2 | 0])) {
             break label$28;
            }
            $1 = HEAP32[$7 + 76 >> 2];
            if (HEAPU8[$1 + 3 | 0] != 36) {
             break label$28;
            }
            HEAP32[((HEAP8[$1 + 2 | 0] << 2) + $4 | 0) - 192 >> 2] = 10;
            $11 = HEAP32[((HEAP8[$1 + 2 | 0] << 3) + $3 | 0) - 384 >> 2];
            $1 = $1 + 4 | 0;
            HEAP32[$7 + 76 >> 2] = $1;
            break label$26;
           }
           if ($21) {
            break label$8;
           }
           if ($0) {
            $1 = HEAP32[$2 >> 2];
            HEAP32[$2 >> 2] = $1 + 4;
            $11 = HEAP32[$1 >> 2];
           } else {
            $11 = 0;
           }
           $1 = HEAP32[$7 + 76 >> 2] + 2 | 0;
           HEAP32[$7 + 76 >> 2] = $1;
           break label$26;
          }
          HEAP32[$7 + 76 >> 2] = $1 + 1;
          $11 = getint($7 + 76 | 0);
          $1 = HEAP32[$7 + 76 >> 2];
         }
         $8 = 0;
         while (1) {
          $9 = $8;
          $16 = -1;
          if (HEAP8[$1 | 0] - 65 >>> 0 > 57) {
           break label$1;
          }
          $12 = $1 + 1 | 0;
          HEAP32[$7 + 76 >> 2] = $12;
          $8 = HEAP8[$1 | 0];
          $1 = $12;
          $8 = HEAPU8[(Math_imul($9, 58) + $8 | 0) + 1071 | 0];
          if ($8 - 1 >>> 0 < 8) {
           continue;
          }
          break;
         }
         label$32 : {
          label$33 : {
           if (($8 | 0) != 19) {
            if (!$8) {
             break label$1;
            }
            if (($19 | 0) >= 0) {
             HEAP32[($19 << 2) + $4 >> 2] = $8;
             $10 = ($19 << 3) + $3 | 0;
             $14 = HEAP32[$10 >> 2];
             $10 = HEAP32[$10 + 4 >> 2];
             HEAP32[$7 + 64 >> 2] = $14;
             HEAP32[$7 + 68 >> 2] = $10;
             break label$33;
            }
            if (!$0) {
             break label$5;
            }
            pop_arg($7 - -64 | 0, $8, $2, $6);
            $12 = HEAP32[$7 + 76 >> 2];
            break label$32;
           }
           if (($19 | 0) > -1) {
            break label$1;
           }
          }
          $1 = 0;
          if (!$0) {
           continue label$2;
          }
         }
         $14 = $18 & -65537;
         $8 = $18 & 8192 ? $14 : $18;
         $16 = 0;
         $19 = 1116;
         $18 = $20;
         label$36 : {
          label$37 : {
           label$38 : {
            label$39 : {
             label$40 : {
              label$41 : {
               label$42 : {
                label$43 : {
                 label$44 : {
                  label$45 : {
                   label$46 : {
                    label$47 : {
                     label$48 : {
                      label$49 : {
                       label$50 : {
                        label$51 : {
                         $1 = HEAP8[$12 - 1 | 0];
                         $1 = $9 ? ($1 & 15) == 3 ? $1 & -33 : $1 : $1;
                         switch ($1 - 88 | 0) {
                         case 11:
                          break label$36;
                         case 9:
                         case 13:
                         case 14:
                         case 15:
                          break label$37;
                         case 27:
                          break label$42;
                         case 12:
                         case 17:
                          break label$45;
                         case 23:
                          break label$46;
                         case 0:
                         case 32:
                          break label$47;
                         case 24:
                          break label$48;
                         case 22:
                          break label$49;
                         case 29:
                          break label$50;
                         case 1:
                         case 2:
                         case 3:
                         case 4:
                         case 5:
                         case 6:
                         case 7:
                         case 8:
                         case 10:
                         case 16:
                         case 18:
                         case 19:
                         case 20:
                         case 21:
                         case 25:
                         case 26:
                         case 28:
                         case 30:
                         case 31:
                          break label$7;
                         default:
                          break label$51;
                         }
                        }
                        label$52 : {
                         switch ($1 - 65 | 0) {
                         case 0:
                         case 4:
                         case 5:
                         case 6:
                          break label$37;
                         case 2:
                          break label$40;
                         case 1:
                         case 3:
                          break label$7;
                         default:
                          break label$52;
                         }
                        }
                        if (($1 | 0) == 83) {
                         break label$41;
                        }
                        break label$7;
                       }
                       $10 = HEAP32[$7 + 64 >> 2];
                       $9 = $10;
                       $14 = HEAP32[$7 + 68 >> 2];
                       $1 = $14;
                       $19 = 1116;
                       break label$44;
                      }
                      $1 = 0;
                      label$53 : {
                       switch ($9 & 255) {
                       case 0:
                        HEAP32[HEAP32[$7 + 64 >> 2] >> 2] = $17;
                        continue label$2;
                       case 1:
                        HEAP32[HEAP32[$7 + 64 >> 2] >> 2] = $17;
                        continue label$2;
                       case 2:
                        $10 = $17;
                        $14 = $10 >> 31;
                        $10 = HEAP32[$7 + 64 >> 2];
                        HEAP32[$10 >> 2] = $17;
                        HEAP32[$10 + 4 >> 2] = $14;
                        continue label$2;
                       case 3:
                        HEAP16[HEAP32[$7 + 64 >> 2] >> 1] = $17;
                        continue label$2;
                       case 4:
                        HEAP8[HEAP32[$7 + 64 >> 2]] = $17;
                        continue label$2;
                       case 6:
                        HEAP32[HEAP32[$7 + 64 >> 2] >> 2] = $17;
                        continue label$2;
                       case 7:
                        break label$53;
                       default:
                        continue label$2;
                       }
                      }
                      $10 = $17;
                      $14 = $10 >> 31;
                      $10 = HEAP32[$7 + 64 >> 2];
                      HEAP32[$10 >> 2] = $17;
                      HEAP32[$10 + 4 >> 2] = $14;
                      continue label$2;
                     }
                     $11 = $11 >>> 0 > 8 ? $11 : 8;
                     $8 = $8 | 8;
                     $1 = 120;
                    }
                    $14 = HEAP32[$7 + 64 >> 2];
                    $10 = HEAP32[$7 + 68 >> 2];
                    $13 = fmt_x($14, $10, $20, $1 & 32);
                    if (!($8 & 8)) {
                     break label$43;
                    }
                    $10 = HEAP32[$7 + 64 >> 2];
                    $14 = HEAP32[$7 + 68 >> 2];
                    if (!($10 | $14)) {
                     break label$43;
                    }
                    $19 = ($1 >>> 4 | 0) + 1116 | 0;
                    $16 = 2;
                    break label$43;
                   }
                   $14 = HEAP32[$7 + 64 >> 2];
                   $10 = HEAP32[$7 + 68 >> 2];
                   $13 = fmt_o($14, $10, $20);
                   if (!($8 & 8)) {
                    break label$43;
                   }
                   $1 = $20 - $13 | 0;
                   $11 = ($1 | 0) < ($11 | 0) ? $11 : $1 + 1 | 0;
                   break label$43;
                  }
                  $14 = HEAP32[$7 + 68 >> 2];
                  $1 = $14;
                  $10 = HEAP32[$7 + 64 >> 2];
                  $9 = $10;
                  if (($14 | 0) < -1 ? 1 : ($14 | 0) <= -1) {
                   $10 = $9;
                   $9 = 0 - $10 | 0;
                   $14 = $1;
                   $10 = $14 + (($10 | 0) != 0) | 0;
                   $10 = 0 - $10 | 0;
                   $1 = $10;
                   HEAP32[$7 + 64 >> 2] = $9;
                   HEAP32[$7 + 68 >> 2] = $10;
                   $16 = 1;
                   $19 = 1116;
                   break label$44;
                  }
                  if ($8 & 2048) {
                   $16 = 1;
                   $19 = 1117;
                   break label$44;
                  }
                  $16 = $8 & 1;
                  $19 = $16 ? 1118 : 1116;
                 }
                 $10 = $1;
                 $13 = fmt_u($9, $10, $20);
                }
                $8 = ($11 | 0) > -1 ? $8 & -65537 : $8;
                $10 = HEAP32[$7 + 64 >> 2];
                $9 = $10;
                $1 = HEAP32[$7 + 68 >> 2];
                if (!(!!($10 | $1) | $11)) {
                 $11 = 0;
                 $13 = $20;
                 break label$7;
                }
                $1 = !($9 | $1) + ($20 - $13 | 0) | 0;
                $11 = ($1 | 0) < ($11 | 0) ? $11 : $1;
                break label$7;
               }
               $1 = HEAP32[$7 + 64 >> 2];
               $13 = $1 ? $1 : 1126;
               $1 = memchr($13, 0, $11);
               $18 = $1 ? $1 : $11 + $13 | 0;
               $8 = $14;
               $11 = $1 ? $1 - $13 | 0 : $11;
               break label$7;
              }
              $9 = HEAP32[$7 + 64 >> 2];
              if ($11) {
               break label$39;
              }
              $1 = 0;
              pad($0, 32, $15, 0, $8);
              break label$38;
             }
             HEAP32[$7 + 12 >> 2] = 0;
             HEAP32[$7 + 8 >> 2] = HEAP32[$7 + 64 >> 2];
             HEAP32[$7 + 64 >> 2] = $7 + 8;
             $11 = -1;
             $9 = $7 + 8 | 0;
            }
            $1 = 0;
            label$64 : {
             while (1) {
              $12 = HEAP32[$9 >> 2];
              if (!$12) {
               break label$64;
              }
              $12 = wctomb($7 + 4 | 0, $12);
              $13 = ($12 | 0) < 0;
              if (!($13 | $11 - $1 >>> 0 < $12 >>> 0)) {
               $9 = $9 + 4 | 0;
               $1 = $1 + $12 | 0;
               if ($11 >>> 0 > $1 >>> 0) {
                continue;
               }
               break label$64;
              }
              break;
             }
             $16 = -1;
             if ($13) {
              break label$1;
             }
            }
            pad($0, 32, $15, $1, $8);
            if (!$1) {
             $1 = 0;
             break label$38;
            }
            $9 = 0;
            $12 = HEAP32[$7 + 64 >> 2];
            while (1) {
             $13 = HEAP32[$12 >> 2];
             if (!$13) {
              break label$38;
             }
             $13 = wctomb($7 + 4 | 0, $13);
             $9 = $13 + $9 | 0;
             if (($9 | 0) > ($1 | 0)) {
              break label$38;
             }
             out($0, $7 + 4 | 0, $13);
             $12 = $12 + 4 | 0;
             if ($1 >>> 0 > $9 >>> 0) {
              continue;
             }
             break;
            }
           }
           pad($0, 32, $15, $1, $8 ^ 8192);
           $1 = ($1 | 0) < ($15 | 0) ? $15 : $1;
           continue label$2;
          }
          $1 = FUNCTION_TABLE[$5 | 0]($0, HEAPF64[$7 + 64 >> 3], $15, $11, $8, $1) | 0;
          continue label$2;
         }
         $10 = HEAP32[$7 + 64 >> 2];
         HEAP8[$7 + 55 | 0] = $10;
         $11 = 1;
         $13 = $22;
         $8 = $14;
         break label$7;
        }
        $9 = $1 + 1 | 0;
        HEAP32[$7 + 76 >> 2] = $9;
        $8 = HEAPU8[$1 + 1 | 0];
        $1 = $9;
        continue;
       }
      }
      $16 = $17;
      if ($0) {
       break label$1;
      }
      if (!$21) {
       break label$5;
      }
      $1 = 1;
      while (1) {
       $8 = HEAP32[($1 << 2) + $4 >> 2];
       if ($8) {
        pop_arg(($1 << 3) + $3 | 0, $8, $2, $6);
        $16 = 1;
        $1 = $1 + 1 | 0;
        if (($1 | 0) != 10) {
         continue;
        }
        break label$1;
       }
       break;
      }
      $16 = 1;
      if ($1 >>> 0 >= 10) {
       break label$1;
      }
      while (1) {
       if (HEAP32[($1 << 2) + $4 >> 2]) {
        break label$8;
       }
       $1 = $1 + 1 | 0;
       if (($1 | 0) != 10) {
        continue;
       }
       break;
      }
      break label$1;
     }
     $16 = -1;
     break label$1;
    }
    $12 = $18 - $13 | 0;
    $18 = ($11 | 0) < ($12 | 0) ? $12 : $11;
    $9 = $18 + $16 | 0;
    $1 = ($9 | 0) > ($15 | 0) ? $9 : $15;
    pad($0, 32, $1, $9, $8);
    out($0, $19, $16);
    pad($0, 48, $1, $9, $8 ^ 65536);
    pad($0, 48, $18, $12, 0);
    out($0, $13, $12);
    pad($0, 32, $1, $9, $8 ^ 8192);
    continue;
   }
   break;
  }
  $16 = 0;
 }
 __stack_pointer = $7 + 80 | 0;
 return $16;
}
function silk_NSQ_del_dec_c($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) {
 var $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0;
 $15 = __stack_pointer - 176 | 0;
 $28 = $15;
 __stack_pointer = $15;
 $30 = HEAP32[$1 + 4328 >> 2];
 $15 = $15 - (Math_imul(HEAP32[$0 + 4628 >> 2], 1300) + 15 & -16) | 0;
 $29 = $15;
 __stack_pointer = $15;
 $21 = HEAP32[$0 + 4628 >> 2];
 $27 = memset($15, 0, Math_imul($21, 1300));
 if (($21 | 0) >= 1) {
  $17 = $1 + 4224 | 0;
  $16 = $1 + 3840 | 0;
  $22 = HEAP32[((HEAP32[$0 + 4592 >> 2] << 2) + $1 | 0) + 1276 >> 2];
  $24 = HEAP32[$1 + 4324 >> 2];
  $25 = HEAP32[$1 + 4320 >> 2];
  $31 = HEAPU8[$2 + 34 | 0];
  while (1) {
   $15 = Math_imul($18, 1300) + $27 | 0;
   HEAP32[$15 + 1296 >> 2] = 0;
   $19 = $18 + $31 & 3;
   HEAP32[$15 + 1292 >> 2] = $19;
   HEAP32[$15 + 1288 >> 2] = $19;
   HEAP32[$15 + 1284 >> 2] = $24;
   HEAP32[$15 + 1280 >> 2] = $25;
   HEAP32[$15 + 1024 >> 2] = $22;
   $20 = HEAP32[$16 + 4 >> 2];
   $23 = HEAP32[$16 >> 2];
   HEAP32[$15 >> 2] = $23;
   HEAP32[$15 + 4 >> 2] = $20;
   $23 = HEAP32[$16 + 12 >> 2];
   $20 = HEAP32[$16 + 8 >> 2];
   HEAP32[$15 + 8 >> 2] = $20;
   HEAP32[$15 + 12 >> 2] = $23;
   $20 = HEAP32[$16 + 20 >> 2];
   $23 = HEAP32[$16 + 16 >> 2];
   HEAP32[$15 + 16 >> 2] = $23;
   HEAP32[$15 + 20 >> 2] = $20;
   $23 = HEAP32[$16 + 28 >> 2];
   $20 = HEAP32[$16 + 24 >> 2];
   HEAP32[$15 + 24 >> 2] = $20;
   HEAP32[$15 + 28 >> 2] = $23;
   $20 = HEAP32[$16 + 36 >> 2];
   $23 = HEAP32[$16 + 32 >> 2];
   HEAP32[$15 + 32 >> 2] = $23;
   HEAP32[$15 + 36 >> 2] = $20;
   $23 = HEAP32[$16 + 44 >> 2];
   $20 = HEAP32[$16 + 40 >> 2];
   HEAP32[$15 + 40 >> 2] = $20;
   HEAP32[$15 + 44 >> 2] = $23;
   $20 = HEAP32[$16 + 52 >> 2];
   $23 = HEAP32[$16 + 48 >> 2];
   HEAP32[$15 + 48 >> 2] = $23;
   HEAP32[$15 + 52 >> 2] = $20;
   $23 = HEAP32[$16 + 60 >> 2];
   $20 = HEAP32[$16 + 56 >> 2];
   HEAP32[$15 + 56 >> 2] = $20;
   HEAP32[$15 + 60 >> 2] = $23;
   memcpy($15 + 1184 | 0, $17, 96);
   $18 = $18 + 1 | 0;
   if (($21 | 0) != ($18 | 0)) {
    continue;
   }
   break;
  }
 }
 $24 = HEAPU8[$2 + 29 | 0];
 $17 = HEAP8[$2 + 30 | 0];
 HEAP32[$28 + 172 >> 2] = 0;
 $18 = HEAP32[$0 + 4588 >> 2];
 $26 = ($18 | 0) < 40 ? $18 : 40;
 label$3 : {
  if (($24 | 0) == 2) {
   $19 = HEAP32[$0 + 4580 >> 2];
   if (($19 | 0) < 1) {
    break label$3;
   }
   $15 = 0;
   while (1) {
    $16 = HEAP32[($15 << 2) + $12 >> 2] - 3 | 0;
    $26 = ($16 | 0) > ($26 | 0) ? $26 : $16;
    $15 = $15 + 1 | 0;
    if (($19 | 0) != ($15 | 0)) {
     continue;
    }
    break;
   }
   break label$3;
  }
  if (($30 | 0) < 1) {
   break label$3;
  }
  $15 = $30 - 3 | 0;
  $26 = ($15 | 0) > ($26 | 0) ? $26 : $15;
 }
 $22 = HEAPU8[$2 + 31 | 0];
 $15 = HEAP32[$0 + 4592 >> 2];
 $16 = $15 + HEAP32[$0 + 4584 >> 2] | 0;
 $35 = $29 - (($16 << 2) + 15 & -16) | 0;
 $19 = $35;
 __stack_pointer = $19;
 $38 = $19 - (($16 << 1) + 15 & -16) | 0;
 $16 = $38;
 __stack_pointer = $16;
 $31 = $16 - (($18 << 2) + 15 & -16) | 0;
 __stack_pointer = $31;
 HEAP32[$1 + 4332 >> 2] = $15;
 HEAP32[$1 + 4336 >> 2] = $15;
 $32 = ($15 << 1) + $1 | 0;
 label$6 : {
  $25 = HEAP32[$0 + 4580 >> 2];
  if (($25 | 0) >= 1) {
   $46 = HEAP16[(($24 << 24 >> 24 << 1 & -4) + ($17 << 1) | 0) + 5840 >> 1];
   $42 = ($22 & 255) == 4;
   $47 = $42 ? 3 : 1;
   $43 = $14 << 16 >> 16;
   $14 = 0;
   while (1) {
    $33 = $14 << 2;
    $25 = HEAP32[$33 + $8 >> 2];
    HEAP32[$1 + 4348 >> 2] = 0;
    $36 = 1;
    $44 = (($14 >>> 1 | $42) << 5) + $5 | 0;
    label$9 : {
     if (($24 & 255) != 2) {
      break label$9;
     }
     $24 = 2;
     $30 = HEAP32[($14 << 2) + $12 >> 2];
     if ($14 & $47) {
      break label$9;
     }
     label$10 : {
      if (($14 | 0) != 2) {
       break label$10;
      }
      $16 = 0;
      $15 = 0;
      $21 = HEAP32[$0 + 4628 >> 2];
      if (($21 | 0) >= 2) {
       $19 = HEAP32[$27 + 1296 >> 2];
       $18 = 1;
       while (1) {
        $17 = HEAP32[(Math_imul($18, 1300) + $27 | 0) + 1296 >> 2];
        $20 = $17;
        $17 = ($19 | 0) > ($17 | 0);
        $19 = $17 ? $20 : $19;
        $15 = $17 ? $18 : $15;
        $18 = $18 + 1 | 0;
        if (($21 | 0) != ($18 | 0)) {
         continue;
        }
        break;
       }
      }
      if (($21 | 0) > 0) {
       while (1) {
        if (($15 | 0) != ($16 | 0)) {
         $18 = Math_imul($16, 1300) + $27 | 0;
         HEAP32[$18 + 1296 >> 2] = HEAP32[$18 + 1296 >> 2] + 134217727;
        }
        $16 = $16 + 1 | 0;
        if (($21 | 0) != ($16 | 0)) {
         continue;
        }
        break;
       }
      }
      if (($26 | 0) < 1) {
       $37 = 0;
       break label$10;
      }
      $17 = HEAP32[$28 + 172 >> 2] + $26 | 0;
      $37 = 0;
      $16 = 0;
      while (1) {
       $18 = $16 - $26 | 0;
       $19 = ($17 - 1 | 0) % 40 | 0;
       $17 = ($19 | 0) < 0 ? $19 + 40 | 0 : $19;
       $19 = (Math_imul($15, 1300) + $27 | 0) + ($17 << 2) | 0;
       HEAP8[$18 + $4 | 0] = (HEAP32[$19 + 544 >> 2] >>> 9 | 0) + 1 >>> 1;
       $22 = HEAP32[$11 + 4 >> 2];
       $24 = $22 << 16 >> 16;
       $21 = HEAP32[$19 + 704 >> 2];
       $21 = ((Math_imul($24, $21 & 65535) >> 16) + Math_imul($21 >> 16, $24) | 0) + Math_imul(($22 >> 15) + 1 >> 1, $21) | 0;
       HEAP16[($18 << 1) + $32 >> 1] = ($21 | 0) > 536862719 ? 32767 : ($21 | 0) < -536879104 ? -32768 : ($21 >>> 13 | 0) + 1 >>> 1 | 0;
       HEAP32[((HEAP32[$1 + 4336 >> 2] + $18 << 2) + $1 | 0) + 1280 >> 2] = HEAP32[$19 + 1024 >> 2];
       $16 = $16 + 1 | 0;
       if (($26 | 0) != ($16 | 0)) {
        continue;
       }
       break;
      }
     }
     $16 = HEAP32[$0 + 4592 >> 2];
     $18 = HEAP32[$0 + 4640 >> 2];
     $15 = ($16 - $30 | 0) - $18 | 0;
     if (($15 | 0) <= 2) {
      break label$6;
     }
     $15 = $15 - 2 | 0;
     silk_LPC_analysis_filter(($15 << 1) + $38 | 0, (Math_imul(HEAP32[$0 + 4588 >> 2], $14) + $15 << 1) + $1 | 0, $44, $16 - $15 | 0, $18, HEAP32[$0 + 5092 >> 2]);
     $15 = HEAP32[$0 + 4592 >> 2];
     HEAP32[$1 + 4348 >> 2] = 1;
     HEAP32[$1 + 4332 >> 2] = $15;
     $24 = HEAPU8[$2 + 29 | 0];
     $36 = 0;
    }
    $39 = $11 + $33 | 0;
    $22 = HEAP32[$39 >> 2];
    $16 = ($22 | 0) > 1 ? $22 : 1;
    $19 = Math_clz32($16);
    $15 = $16 << $19 - 1;
    $18 = $15 >> 16;
    $21 = 536870911 / ($18 | 0) | 0;
    $17 = ($21 >> 15) + 1 >> 1;
    $20 = $15 & 65535;
    $21 = $21 << 16;
    $15 = $21 >> 16;
    $18 = 0 - ((Math_imul($20, $15) >> 16) + Math_imul($15, $18) << 3) | 0;
    $15 = ((Math_imul($18, $17) + $21 | 0) + Math_imul($18 >> 16, $15) | 0) + (Math_imul($18 & 65528, $15) >> 16) | 0;
    $18 = 15 - $19 | 0;
    $45 = HEAP32[$12 + $33 >> 2];
    $29 = HEAP32[$0 + 4628 >> 2];
    label$18 : {
     if ($16 >>> 0 <= 131071) {
      $16 = 0 - $18 | 0;
      $18 = 2147483647 >>> $16 | 0;
      $19 = -2147483648 >> $16;
      $17 = (($15 | 0) > ($18 | 0) ? $18 : ($15 | 0) < ($19 | 0) ? $19 : $15) << $16;
      break label$18;
     }
     $17 = $15 >> $18;
    }
    $34 = $25 << 15;
    $19 = HEAP32[$0 + 4588 >> 2];
    if (($19 | 0) >= 1) {
     $15 = ($17 >> 4) + 1 | 0;
     $18 = $15 << 15 >> 16;
     $21 = ($15 >> 16) + 1 >> 1;
     $15 = 0;
     while (1) {
      $16 = HEAP16[($15 << 1) + $3 >> 1];
      HEAP32[($15 << 2) + $31 >> 2] = (Math_imul($16 >> 16, $18) + Math_imul($16, $21) | 0) + (Math_imul($16 & 65535, $18) >> 16);
      $15 = $15 + 1 | 0;
      if (($19 | 0) != ($15 | 0)) {
       continue;
      }
      break;
     }
    }
    $25 = $25 >> 2;
    $34 = $34 & -65536;
    $40 = Math_imul($14, 48);
    $41 = Math_imul($14, 10);
    $20 = $24 << 24;
    label$22 : {
     if ($36) {
      break label$22;
     }
     $17 = $14 ? $17 : Math_imul($17 >> 16, $43) + (Math_imul($17 & 65535, $43) >> 16) << 2;
     $18 = HEAP32[$1 + 4332 >> 2];
     $15 = ($18 - $45 | 0) - 2 | 0;
     if (($15 | 0) >= ($18 | 0)) {
      break label$22;
     }
     $21 = $17 & 65535;
     $17 = $17 >> 16;
     while (1) {
      $16 = HEAP16[($15 << 1) + $38 >> 1];
      HEAP32[($15 << 2) + $35 >> 2] = (Math_imul($21, $16) >> 16) + Math_imul($16, $17);
      $15 = $15 + 1 | 0;
      if (($18 | 0) != ($15 | 0)) {
       continue;
      }
      break;
     }
    }
    $36 = $25 | $34;
    $34 = $7 + $40 | 0;
    $40 = $6 + $41 | 0;
    $41 = $20 >> 24;
    $15 = HEAP32[$1 + 4344 >> 2];
    if (($22 | 0) != ($15 | 0)) {
     $16 = $15 >> 31;
     $18 = Math_clz32($16 ^ $15 + $16);
     $16 = $15 << $18 - 1;
     $25 = $16;
     $15 = $22 >> 31;
     $19 = Math_clz32($15 ^ $15 + $22);
     $21 = $22 << $19 - 1;
     $15 = 536870911 / ($21 >> 16) << 16 >> 16;
     $16 = (Math_imul($15, $16 & 65535) >> 16) + Math_imul($16 >> 16, $15) | 0;
     $23 = $16 >> 31;
     $17 = $23;
     $23 = $21 >> 31;
     $20 = $23;
     $23 = $17;
     $20 = __wasm_i64_mul($16, $23, $21, $20);
     $17 = $20;
     $23 = i64toi32_i32$HIGH_BITS;
     $21 = $25 - ((($23 & 536870911) << 3 | $17 >>> 29) & -8) | 0;
     $15 = (Math_imul($21 >> 16, $15) + $16 | 0) + (Math_imul($21 & 65535, $15) >> 16) | 0;
     $16 = $18 - $19 | 0;
     $18 = $16 + 13 | 0;
     $16 = $16 + 29 | 0;
     label$26 : {
      if (($16 | 0) <= 15) {
       $16 = 0 - $18 | 0;
       $18 = 2147483647 >>> $16 | 0;
       $19 = -2147483648 >> $16;
       $15 = (($15 | 0) > ($18 | 0) ? $18 : ($15 | 0) < ($19 | 0) ? $19 : $15) << $16;
       break label$26;
      }
      $15 = ($16 | 0) < 48 ? $15 >> $18 : 0;
     }
     $16 = HEAP32[$0 + 4592 >> 2];
     if (($16 | 0) >= 1) {
      $21 = $15 & 65535;
      $17 = $15 >> 16;
      $16 = HEAP32[$1 + 4336 >> 2] - $16 | 0;
      while (1) {
       $18 = (($16 << 2) + $1 | 0) + 1280 | 0;
       $20 = $18;
       $18 = HEAP32[$18 >> 2];
       $19 = $18 << 16 >> 16;
       HEAP32[$20 >> 2] = ((Math_imul($21, $19) >> 16) + Math_imul($19, $17) | 0) + Math_imul(($18 >> 15) + 1 >> 1, $15);
       $16 = $16 + 1 | 0;
       if (($16 | 0) < HEAP32[$1 + 4336 >> 2]) {
        continue;
       }
       break;
      }
     }
     label$30 : {
      if (HEAP32[$1 + 4348 >> 2] | ($24 & 255) != 2) {
       break label$30;
      }
      $18 = HEAP32[$1 + 4332 >> 2];
      $16 = ($18 - $45 | 0) - 2 | 0;
      $21 = $18 - $26 | 0;
      if (($16 | 0) >= ($21 | 0)) {
       break label$30;
      }
      $17 = $15 & 65535;
      $22 = $15 >> 16;
      while (1) {
       $18 = ($16 << 2) + $35 | 0;
       $20 = $18;
       $18 = HEAP32[$18 >> 2];
       $19 = $18 << 16 >> 16;
       HEAP32[$20 >> 2] = ((Math_imul($17, $19) >> 16) + Math_imul($19, $22) | 0) + Math_imul(($18 >> 15) + 1 >> 1, $15);
       $16 = $16 + 1 | 0;
       if (($21 | 0) != ($16 | 0)) {
        continue;
       }
       break;
      }
     }
     if (($29 | 0) >= 1) {
      $16 = $15 & 65535;
      $18 = $15 >> 16;
      $25 = 0;
      while (1) {
       $21 = Math_imul($25, 1300) + $27 | 0;
       $19 = HEAP32[$21 + 1280 >> 2];
       $17 = $19 << 16 >> 16;
       HEAP32[$21 + 1280 >> 2] = (Math_imul($18, $17) + (Math_imul($16, $17) >> 16) | 0) + Math_imul(($19 >> 15) + 1 >> 1, $15);
       $19 = HEAP32[$21 + 1284 >> 2];
       $17 = $19 << 16 >> 16;
       HEAP32[$21 + 1284 >> 2] = ((Math_imul($17, $16) >> 16) + Math_imul($18, $17) | 0) + Math_imul(($19 >> 15) + 1 >> 1, $15);
       $17 = 0;
       while (1) {
        $19 = ($17 << 2) + $21 | 0;
        $20 = $19;
        $19 = HEAP32[$19 >> 2];
        $22 = $19 << 16 >> 16;
        HEAP32[$20 >> 2] = ((Math_imul($22, $16) >> 16) + Math_imul($18, $22) | 0) + Math_imul(($19 >> 15) + 1 >> 1, $15);
        $19 = 0;
        $17 = $17 + 1 | 0;
        if (($17 | 0) != 16) {
         continue;
        }
        break;
       }
       $17 = 0;
       while (1) {
        $22 = (($17 << 2) + $21 | 0) + 1184 | 0;
        $20 = $22;
        $22 = HEAP32[$22 >> 2];
        $24 = $22 << 16 >> 16;
        HEAP32[$20 >> 2] = ((Math_imul($24, $16) >> 16) + Math_imul($18, $24) | 0) + Math_imul(($22 >> 15) + 1 >> 1, $15);
        $17 = $17 + 1 | 0;
        if (($17 | 0) != 24) {
         continue;
        }
        break;
       }
       while (1) {
        $17 = ($19 << 2) + $21 | 0;
        $22 = $17 + 864 | 0;
        $20 = $22;
        $22 = HEAP32[$17 + 864 >> 2];
        $24 = $22 << 16 >> 16;
        HEAP32[$20 >> 2] = ((Math_imul($24, $16) >> 16) + Math_imul($18, $24) | 0) + Math_imul(($22 >> 15) + 1 >> 1, $15);
        $17 = $17 + 1024 | 0;
        $20 = $17;
        $17 = HEAP32[$17 >> 2];
        $22 = $17 << 16 >> 16;
        HEAP32[$20 >> 2] = ((Math_imul($22, $16) >> 16) + Math_imul($18, $22) | 0) + Math_imul(($17 >> 15) + 1 >> 1, $15);
        $19 = $19 + 1 | 0;
        if (($19 | 0) != 40) {
         continue;
        }
        break;
       }
       $25 = $25 + 1 | 0;
       if (($29 | 0) != ($25 | 0)) {
        continue;
       }
       break;
      }
     }
     HEAP32[$1 + 4344 >> 2] = HEAP32[$39 >> 2];
     $29 = HEAP32[$0 + 4628 >> 2];
     $22 = HEAP32[$39 >> 2];
     $19 = HEAP32[$0 + 4588 >> 2];
    }
    silk_noise_shape_quantizer_del_dec($1, $27, $41, $31, $4, $32, $35, $28, $44, $40, $34, $30, $36, HEAP32[$9 + $33 >> 2], HEAP32[$10 + $33 >> 2], $22, $13, $46, $19, $37, HEAP32[$0 + 4636 >> 2], HEAP32[$0 + 4640 >> 2], HEAP32[$0 + 4672 >> 2], $29, $28 + 172 | 0, $26);
    $18 = HEAP32[$0 + 4588 >> 2];
    $4 = $18 + $4 | 0;
    $15 = $18 << 1;
    $32 = $32 + $15 | 0;
    $14 = $14 + 1 | 0;
    $25 = HEAP32[$0 + 4580 >> 2];
    if (($14 | 0) < ($25 | 0)) {
     $37 = $37 + 1 | 0;
     $3 = $3 + $15 | 0;
     $24 = HEAPU8[$2 + 29 | 0];
     continue;
    }
    break;
   }
   $21 = HEAP32[$0 + 4628 >> 2];
  }
  $19 = 0;
  if (($21 | 0) >= 2) {
   $16 = HEAP32[$27 + 1296 >> 2];
   $15 = 1;
   while (1) {
    $17 = HEAP32[(Math_imul($15, 1300) + $27 | 0) + 1296 >> 2];
    $3 = $17;
    $17 = ($16 | 0) > ($17 | 0);
    $16 = $17 ? $3 : $16;
    $19 = $17 ? $15 : $19;
    $15 = $15 + 1 | 0;
    if (($21 | 0) != ($15 | 0)) {
     continue;
    }
    break;
   }
  }
  $22 = Math_imul($19, 1300) + $27 | 0;
  HEAP8[$2 + 34 | 0] = HEAP32[$22 + 1292 >> 2];
  if (($26 | 0) >= 1) {
   $21 = HEAP32[$28 + 172 >> 2] + $26 | 0;
   $15 = HEAP32[(($25 << 2) + $11 | 0) - 4 >> 2];
   $17 = $15 << 10 >> 16;
   $24 = ($15 >> 21) + 1 >> 1;
   $15 = 0;
   while (1) {
    $16 = $15 - $26 | 0;
    $18 = ($21 - 1 | 0) % 40 | 0;
    $21 = ($18 | 0) < 0 ? $18 + 40 | 0 : $18;
    $18 = ($21 << 2) + $22 | 0;
    HEAP8[$16 + $4 | 0] = (HEAP32[$18 + 544 >> 2] >>> 9 | 0) + 1 >>> 1;
    $19 = HEAP32[$18 + 704 >> 2];
    $19 = (Math_imul($19 >> 16, $17) + Math_imul($19, $24) | 0) + (Math_imul($19 & 65535, $17) >> 16) | 0;
    HEAP16[($16 << 1) + $32 >> 1] = ($19 | 0) > 8388479 ? 32767 : ($19 | 0) < -8388736 ? -32768 : ($19 >>> 7 | 0) + 1 >>> 1 | 0;
    HEAP32[((HEAP32[$1 + 4336 >> 2] + $16 << 2) + $1 | 0) + 1280 >> 2] = HEAP32[$18 + 1024 >> 2];
    $15 = $15 + 1 | 0;
    if (($26 | 0) != ($15 | 0)) {
     continue;
    }
    break;
   }
   $18 = HEAP32[$0 + 4588 >> 2];
  }
  $15 = ($18 << 2) + $22 | 0;
  $17 = HEAP32[$15 + 4 >> 2];
  $20 = HEAP32[$15 >> 2];
  HEAP32[$1 + 3840 >> 2] = $20;
  HEAP32[$1 + 3844 >> 2] = $17;
  $20 = HEAP32[$15 + 60 >> 2];
  $17 = HEAP32[$15 + 56 >> 2];
  $2 = $17;
  $17 = $1 + 3896 | 0;
  HEAP32[$17 >> 2] = $2;
  HEAP32[$17 + 4 >> 2] = $20;
  $17 = HEAP32[$15 + 52 >> 2];
  $20 = HEAP32[$15 + 48 >> 2];
  $2 = $20;
  $20 = $1 + 3888 | 0;
  HEAP32[$20 >> 2] = $2;
  HEAP32[$20 + 4 >> 2] = $17;
  $20 = HEAP32[$15 + 44 >> 2];
  $17 = HEAP32[$15 + 40 >> 2];
  $2 = $17;
  $17 = $1 + 3880 | 0;
  HEAP32[$17 >> 2] = $2;
  HEAP32[$17 + 4 >> 2] = $20;
  $17 = HEAP32[$15 + 36 >> 2];
  $20 = HEAP32[$15 + 32 >> 2];
  $2 = $20;
  $20 = $1 + 3872 | 0;
  HEAP32[$20 >> 2] = $2;
  HEAP32[$20 + 4 >> 2] = $17;
  $20 = HEAP32[$15 + 28 >> 2];
  $17 = HEAP32[$15 + 24 >> 2];
  $2 = $17;
  $17 = $1 + 3864 | 0;
  HEAP32[$17 >> 2] = $2;
  HEAP32[$17 + 4 >> 2] = $20;
  $17 = HEAP32[$15 + 20 >> 2];
  $20 = HEAP32[$15 + 16 >> 2];
  $2 = $20;
  $20 = $1 + 3856 | 0;
  HEAP32[$20 >> 2] = $2;
  HEAP32[$20 + 4 >> 2] = $17;
  $20 = HEAP32[$15 + 12 >> 2];
  $17 = HEAP32[$15 + 8 >> 2];
  $2 = $17;
  $17 = $1 + 3848 | 0;
  HEAP32[$17 >> 2] = $2;
  HEAP32[$17 + 4 >> 2] = $20;
  memcpy($1 + 4224 | 0, $22 + 1184 | 0, 96);
  HEAP32[$1 + 4320 >> 2] = HEAP32[$22 + 1280 >> 2];
  HEAP32[$1 + 4324 >> 2] = HEAP32[$22 + 1284 >> 2];
  HEAP32[$1 + 4328 >> 2] = HEAP32[((HEAP32[$0 + 4580 >> 2] << 2) + $12 | 0) - 4 >> 2];
  $15 = memmove($1, (HEAP32[$0 + 4584 >> 2] << 1) + $1 | 0, HEAP32[$0 + 4592 >> 2] << 1) + 1280 | 0;
  memmove($15, (HEAP32[$0 + 4584 >> 2] << 2) + $15 | 0, HEAP32[$0 + 4592 >> 2] << 2);
  __stack_pointer = $28 + 176 | 0;
  return;
 }
 celt_fatal(16175, 16207, 253);
 abort();
}
function silk_noise_shape_quantizer_del_dec($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25) {
 var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0;
 $26 = __stack_pointer;
 $63 = $26;
 label$1 : {
  if (($23 | 0) > 0) {
   $30 = $26 - (Math_imul($23, 56) + 15 & -16) | 0;
   __stack_pointer = $30;
   if (($18 | 0) >= 1) {
    $64 = $15 >> 6;
    $31 = $16 << 16 >> 16;
    $38 = Math_imul($31, $17 << 16 >> 16);
    $39 = $17 + 944 | 0;
    $42 = Math_imul($39 << 16 >> 16, $31);
    $43 = $17 - 944 | 0;
    $65 = Math_imul(0 - ($43 << 16) >> 16, $31);
    $66 = $17 - 80 | 0;
    $44 = $14 >> 16;
    $67 = $20 >> 1;
    $68 = $20 & 1;
    $69 = $21 >> 1;
    $45 = $12 >> 16;
    $26 = $16 >>> 1 | 0;
    $70 = 512 - $26 | 0;
    $40 = $26 - 512 | 0;
    $46 = $14 << 16 >> 16;
    $47 = $13 << 16 >> 16;
    $14 = $22 << 16 >> 16;
    $48 = $12 << 16 >> 16;
    $49 = $20 - 1 | 0;
    $71 = ($49 << 1) + $10 | 0;
    $34 = ((HEAP32[$0 + 4336 >> 2] - $11 << 2) + $0 | 0) + 1284 | 0;
    $32 = ((HEAP32[$0 + 4332 >> 2] - $11 << 2) + $6 | 0) + 8 | 0;
    $72 = ($2 | 0) != 2;
    $73 = ($20 | 0) < 3;
    $74 = ($16 | 0) < 2049;
    $75 = ($19 | 0) > 0;
    while (1) {
     label$5 : {
      if ($72) {
       $37 = 0;
       break label$5;
      }
      $12 = HEAP16[$9 >> 1];
      $16 = HEAP32[$32 >> 2];
      $2 = Math_imul($12, $16 >> 16) + (Math_imul($16 & 65535, $12) >> 16) | 0;
      $12 = HEAP16[$9 + 2 >> 1];
      $16 = HEAP32[$32 - 4 >> 2];
      $2 = ($2 + Math_imul($12, $16 >> 16) | 0) + (Math_imul($16 & 65535, $12) >> 16) | 0;
      $12 = HEAP16[$9 + 4 >> 1];
      $16 = HEAP32[$32 - 8 >> 2];
      $2 = ($2 + Math_imul($12, $16 >> 16) | 0) + (Math_imul($16 & 65535, $12) >> 16) | 0;
      $12 = HEAP16[$9 + 6 >> 1];
      $16 = HEAP32[$32 - 12 >> 2];
      $2 = ($2 + Math_imul($12, $16 >> 16) | 0) + (Math_imul($16 & 65535, $12) >> 16) | 0;
      $12 = HEAP16[$9 + 8 >> 1];
      $16 = HEAP32[$32 - 16 >> 2];
      $37 = (($2 + Math_imul($12, $16 >> 16) | 0) + (Math_imul($16 & 65535, $12) >> 16) << 1) + 4 | 0;
      $32 = $32 + 4 | 0;
     }
     $35 = 0;
     label$7 : {
      if (($11 | 0) < 1) {
       $50 = 0;
       break label$7;
      }
      $16 = HEAP32[$34 - 4 >> 2];
      $12 = HEAP32[$34 - 8 >> 2] + HEAP32[$34 >> 2] | 0;
      $50 = $37 - (((Math_imul($16 >> 16, $45) + Math_imul($12 >> 16, $48) | 0) + (Math_imul($12 & 65535, $48) >> 16) | 0) + (Math_imul($16 & 65535, $45) >> 16) << 2) | 0;
      $34 = $34 + 4 | 0;
     }
     $76 = $33 + 15 | 0;
     $36 = $33 << 2;
     $77 = $36 + $3 | 0;
     $51 = HEAP16[$8 + 18 >> 1];
     $52 = HEAP16[$8 + 16 >> 1];
     $53 = HEAP16[$8 + 14 >> 1];
     $54 = HEAP16[$8 + 12 >> 1];
     $55 = HEAP16[$8 + 10 >> 1];
     $56 = HEAP16[$8 + 8 >> 1];
     $57 = HEAP16[$8 + 6 >> 1];
     $58 = HEAP16[$8 + 4 >> 1];
     $59 = HEAP16[$8 + 2 >> 1];
     $60 = HEAP16[$8 >> 1];
     while (1) {
      $27 = Math_imul($35, 1300) + $1 | 0;
      HEAP32[$27 + 1288 >> 2] = Math_imul(HEAP32[$27 + 1288 >> 2], 196314165) + 907633515;
      $16 = ($76 << 2) + $27 | 0;
      $12 = HEAP32[$16 >> 2];
      $2 = (Math_imul($12 >> 16, $60) + $69 | 0) + (Math_imul($12 & 65535, $60) >> 16) | 0;
      $12 = HEAP32[$16 - 4 >> 2];
      $2 = ($2 + Math_imul($12 >> 16, $59) | 0) + (Math_imul($12 & 65535, $59) >> 16) | 0;
      $12 = HEAP32[$16 - 8 >> 2];
      $2 = ($2 + Math_imul($12 >> 16, $58) | 0) + (Math_imul($12 & 65535, $58) >> 16) | 0;
      $12 = HEAP32[$16 - 12 >> 2];
      $2 = ($2 + Math_imul($12 >> 16, $57) | 0) + (Math_imul($12 & 65535, $57) >> 16) | 0;
      $12 = HEAP32[$16 - 16 >> 2];
      $2 = ($2 + Math_imul($12 >> 16, $56) | 0) + (Math_imul($12 & 65535, $56) >> 16) | 0;
      $12 = HEAP32[$16 - 20 >> 2];
      $2 = ($2 + Math_imul($12 >> 16, $55) | 0) + (Math_imul($12 & 65535, $55) >> 16) | 0;
      $12 = HEAP32[$16 - 24 >> 2];
      $2 = ($2 + Math_imul($12 >> 16, $54) | 0) + (Math_imul($12 & 65535, $54) >> 16) | 0;
      $12 = HEAP32[$16 - 28 >> 2];
      $2 = ($2 + Math_imul($12 >> 16, $53) | 0) + (Math_imul($12 & 65535, $53) >> 16) | 0;
      $12 = HEAP32[$16 - 32 >> 2];
      $2 = ($2 + Math_imul($12 >> 16, $52) | 0) + (Math_imul($12 & 65535, $52) >> 16) | 0;
      $12 = HEAP32[$16 - 36 >> 2];
      $12 = ($2 + Math_imul($12 >> 16, $51) | 0) + (Math_imul($12 & 65535, $51) >> 16) | 0;
      if (($21 | 0) == 16) {
       $2 = HEAP16[$8 + 20 >> 1];
       $26 = HEAP32[$16 - 40 >> 2];
       $2 = (Math_imul($2, $26 >> 16) + $12 | 0) + (Math_imul($26 & 65535, $2) >> 16) | 0;
       $26 = HEAP16[$8 + 22 >> 1];
       $12 = HEAP32[$16 - 44 >> 2];
       $2 = ($2 + Math_imul($26, $12 >> 16) | 0) + (Math_imul($12 & 65535, $26) >> 16) | 0;
       $26 = HEAP16[$8 + 24 >> 1];
       $12 = HEAP32[$16 - 48 >> 2];
       $2 = ($2 + Math_imul($26, $12 >> 16) | 0) + (Math_imul($12 & 65535, $26) >> 16) | 0;
       $26 = HEAP16[$8 + 26 >> 1];
       $12 = HEAP32[$16 - 52 >> 2];
       $2 = ($2 + Math_imul($26, $12 >> 16) | 0) + (Math_imul($12 & 65535, $26) >> 16) | 0;
       $12 = HEAP16[$8 + 28 >> 1];
       $16 = HEAP32[$16 - 56 >> 2];
       $2 = ($2 + Math_imul($12, $16 >> 16) | 0) + (Math_imul($16 & 65535, $12) >> 16) | 0;
       $12 = HEAP16[$8 + 30 >> 1];
       $16 = HEAP32[$27 + $36 >> 2];
       $12 = ($2 + Math_imul($12, $16 >> 16) | 0) + (Math_imul($16 & 65535, $12) >> 16) | 0;
      }
      if ($68) {
       break label$1;
      }
      $41 = $12 << 4;
      $12 = HEAP32[$27 + 1184 >> 2];
      $16 = (HEAP32[$27 + 1284 >> 2] + Math_imul($12 >> 16, $14) | 0) + (Math_imul($12 & 65535, $14) >> 16) | 0;
      HEAP32[$27 + 1184 >> 2] = $16;
      $26 = HEAP16[$10 >> 1];
      $15 = (Math_imul($26, $16 >> 16) + $67 | 0) + (Math_imul($16 & 65535, $26) >> 16) | 0;
      $16 = HEAP32[$27 + 1188 >> 2] - $16 | 0;
      $16 = (Math_imul($16 >> 16, $14) + $12 | 0) + (Math_imul($16 & 65535, $14) >> 16) | 0;
      $12 = 2;
      if (!$73) {
       while (1) {
        $26 = $27 + 1184 | 0;
        $13 = $12 - 1 | 0;
        $19 = $26 + ($13 << 2) | 0;
        $22 = HEAP32[$19 >> 2];
        $28 = $12 << 2;
        $29 = $28 + $26 | 0;
        $2 = HEAP32[$29 >> 2];
        HEAP32[$19 >> 2] = $16;
        $19 = HEAP32[($28 | 4) + $26 >> 2];
        $13 = HEAP16[($13 << 1) + $10 >> 1];
        $26 = $2 - $16 | 0;
        $26 = (Math_imul($26 >> 16, $14) + $22 | 0) + (Math_imul($26 & 65535, $14) >> 16) | 0;
        HEAP32[$29 >> 2] = $26;
        $13 = (Math_imul($16 >> 16, $13) + $15 | 0) + (Math_imul($16 & 65535, $13) >> 16) | 0;
        $16 = HEAP16[($12 << 1) + $10 >> 1];
        $15 = ($13 + Math_imul($16, $26 >> 16) | 0) + (Math_imul($26 & 65535, $16) >> 16) | 0;
        $16 = $19 - $26 | 0;
        $16 = (Math_imul($16 >> 16, $14) + $2 | 0) + (Math_imul($16 & 65535, $14) >> 16) | 0;
        $12 = $12 + 2 | 0;
        if (($20 | 0) > ($12 | 0)) {
         continue;
        }
        break;
       }
      }
      HEAP32[(($49 << 2) + $27 | 0) + 1184 >> 2] = $16;
      label$13 : {
       label$14 : {
        label$15 : {
         label$16 : {
          $61 = HEAP32[$77 >> 2];
          $12 = HEAP32[$27 + 1280 >> 2];
          $26 = $12 & 65535;
          $12 = $12 >> 16;
          $2 = HEAP16[$71 >> 1];
          $13 = ((Math_imul($47, $26) >> 16) + Math_imul($47, $12) | 0) + ((Math_imul($2, $16 >> 16) + $15 | 0) + (Math_imul($16 & 65535, $2) >> 16) << 1) << 2;
          $62 = HEAP32[$24 >> 2];
          $16 = HEAP32[(($62 << 2) + $27 | 0) + 1024 >> 2];
          $15 = ((Math_imul($12, $44) + (Math_imul($26, $44) >> 16) | 0) + Math_imul($16 >> 16, $46) | 0) + (Math_imul($16 & 65535, $46) >> 16) << 2;
          $16 = $61 - (((($41 + $50 | 0) - $13 | 0) - $15 >> 3) + 1 >> 1) | 0;
          $19 = HEAP32[$27 + 1288 >> 2] < 0;
          $16 = $19 ? 0 - $16 | 0 : $16;
          $16 = ($16 | 0) > -31744 ? $16 : -31744;
          $2 = ($16 | 0) < 30720 ? $16 : 30720;
          $16 = $2 - $17 | 0;
          $12 = $16;
          label$17 : {
           if ($74) {
            break label$17;
           }
           $12 = $16 - $40 | 0;
           if (($16 | 0) > ($40 | 0)) {
            break label$17;
           }
           if (($16 | 0) >= ($70 | 0)) {
            break label$16;
           }
           $12 = $16 + $40 | 0;
          }
          $16 = $12;
          if (($16 | 0) >= 1024) {
           $12 = ($16 & -1024) + $66 | 0;
           $28 = Math_imul($12 << 16 >> 16, $31);
           $26 = $12 + 1024 | 0;
           $29 = Math_imul($26 << 16 >> 16, $31);
           break label$13;
          }
          $28 = $38;
          $29 = $42;
          $12 = $17;
          $26 = $39;
          switch (($16 >> 10) + 1 | 0) {
          case 1:
           break label$13;
          case 0:
           break label$15;
          default:
           break label$14;
          }
         }
         $28 = $38;
         $29 = $42;
         $12 = $17;
         $26 = $39;
         if (($16 | 0) >= 0) {
          break label$13;
         }
        }
        $28 = $65;
        $29 = $38;
        $12 = $43;
        $26 = $17;
        break label$13;
       }
       $12 = ($16 & -1024 | 80) + $17 | 0;
       $28 = Math_imul(0 - ($12 << 16) >> 16, $31);
       $26 = $12 + 1024 | 0;
       $29 = Math_imul(0 - ($26 << 16) >> 16, $31);
      }
      $22 = HEAP32[$27 + 1296 >> 2];
      $16 = Math_imul($35, 56) + $30 | 0;
      $27 = $2 - $12 << 16 >> 16;
      $28 = Math_imul($27, $27) + $28 >> 10;
      $2 = $2 - $26 << 16 >> 16;
      $29 = Math_imul($2, $2) + $29 >> 10;
      $2 = ($28 | 0) < ($29 | 0);
      $27 = $2 ? $26 : $12;
      HEAP32[$16 + 28 >> 2] = $27;
      $12 = $2 ? $12 : $26;
      HEAP32[$16 >> 2] = $12;
      HEAP32[$16 + 32 >> 2] = ($2 ? $29 : $28) + $22;
      HEAP32[$16 + 4 >> 2] = ($2 ? $28 : $29) + $22;
      $12 = $12 << 4;
      $12 = ($19 ? 0 - $12 | 0 : $12) + $37 | 0;
      HEAP32[$16 + 24 >> 2] = $12;
      $26 = $27 << 4;
      $26 = ($19 ? 0 - $26 | 0 : $26) + $37 | 0;
      HEAP32[$16 + 52 >> 2] = $26;
      $12 = $12 + $41 | 0;
      HEAP32[$16 + 8 >> 2] = $12;
      $26 = $26 + $41 | 0;
      HEAP32[$16 + 36 >> 2] = $26;
      $2 = $61 << 4;
      $12 = $12 - $2 | 0;
      HEAP32[$16 + 16 >> 2] = $12;
      $26 = $26 - $2 | 0;
      HEAP32[$16 + 44 >> 2] = $26;
      $12 = $12 - $13 | 0;
      HEAP32[$16 + 12 >> 2] = $12;
      $26 = $26 - $13 | 0;
      HEAP32[$16 + 40 >> 2] = $26;
      HEAP32[$16 + 20 >> 2] = $12 - $15;
      HEAP32[$16 + 48 >> 2] = $26 - $15;
      $35 = $35 + 1 | 0;
      if (($35 | 0) != ($23 | 0)) {
       continue;
      }
      break;
     }
     $16 = 0;
     $12 = ($62 - 1 | 0) % 40 | 0;
     $12 = ($12 | 0) < 0 ? $12 + 40 | 0 : $12;
     HEAP32[$24 >> 2] = $12;
     $15 = ($12 + $25 | 0) % 40 | 0;
     $2 = 0;
     $19 = ($23 | 0) < 2;
     if (!$19) {
      $26 = HEAP32[$30 + 4 >> 2];
      $12 = 1;
      while (1) {
       $13 = HEAP32[(Math_imul($12, 56) + $30 | 0) + 4 >> 2];
       $22 = $13;
       $13 = ($13 | 0) < ($26 | 0);
       $26 = $13 ? $22 : $26;
       $2 = $13 ? $12 : $2;
       $12 = $12 + 1 | 0;
       if (($23 | 0) != ($12 | 0)) {
        continue;
       }
       break;
      }
     }
     $15 = $15 << 2;
     $28 = $15 + (Math_imul($2, 1300) + $1 | 0) | 0;
     $26 = HEAP32[$28 + 384 >> 2];
     while (1) {
      if (HEAP32[((Math_imul($16, 1300) + $1 | 0) + $15 | 0) + 384 >> 2] != ($26 | 0)) {
       $12 = Math_imul($16, 56) + $30 | 0;
       HEAP32[$12 + 4 >> 2] = HEAP32[$12 + 4 >> 2] + 134217727;
       $2 = $12;
       $12 = $12 + 32 | 0;
       HEAP32[$12 >> 2] = HEAP32[$2 + 32 >> 2] + 134217727;
      }
      $16 = $16 + 1 | 0;
      if (($23 | 0) != ($16 | 0)) {
       continue;
      }
      break;
     }
     $12 = HEAP32[$30 + 32 >> 2];
     $26 = HEAP32[$30 + 4 >> 2];
     $2 = 0;
     $16 = 1;
     $13 = 0;
     if (!$19) {
      while (1) {
       $19 = Math_imul($16, 56) + $30 | 0;
       $22 = HEAP32[$19 + 4 >> 2];
       $29 = $22;
       $22 = ($22 | 0) > ($26 | 0);
       $26 = $22 ? $29 : $26;
       $19 = HEAP32[$19 + 32 >> 2];
       $29 = $19;
       $19 = ($12 | 0) > ($19 | 0);
       $12 = $19 ? $29 : $12;
       $13 = $22 ? $16 : $13;
       $2 = $19 ? $16 : $2;
       $16 = $16 + 1 | 0;
       if (($23 | 0) != ($16 | 0)) {
        continue;
       }
       break;
      }
     }
     if (($12 | 0) < ($26 | 0)) {
      memcpy((Math_imul($13, 1300) + $1 | 0) + $36 | 0, (Math_imul($2, 1300) + $1 | 0) + $36 | 0, 1300 - $36 | 0);
      $16 = Math_imul($13, 56) + $30 | 0;
      $12 = Math_imul($2, 56) + $30 | 0;
      HEAP32[$16 + 24 >> 2] = HEAP32[$12 + 52 >> 2];
      $13 = HEAP32[$12 + 48 >> 2];
      $2 = HEAP32[$12 + 44 >> 2];
      HEAP32[$16 + 16 >> 2] = $2;
      HEAP32[$16 + 20 >> 2] = $13;
      $2 = HEAP32[$12 + 40 >> 2];
      $13 = HEAP32[$12 + 36 >> 2];
      HEAP32[$16 + 8 >> 2] = $13;
      HEAP32[$16 + 12 >> 2] = $2;
      $13 = HEAP32[$12 + 32 >> 2];
      $2 = HEAP32[$12 + 28 >> 2];
      HEAP32[$16 >> 2] = $2;
      HEAP32[$16 + 4 >> 2] = $13;
     }
     if (!(($25 | 0) > ($33 | 0) ? !$75 : 0)) {
      $16 = $33 - $25 | 0;
      HEAP8[$16 + $4 | 0] = (HEAP32[$28 + 544 >> 2] >>> 9 | 0) + 1 >>> 1;
      $2 = ($16 << 1) + $5 | 0;
      $12 = HEAP32[$7 + $15 >> 2];
      $26 = $12 << 16 >> 16;
      $16 = HEAP32[$28 + 704 >> 2];
      $16 = ((Math_imul($26, $16 & 65535) >> 16) + Math_imul($16 >> 16, $26) | 0) + Math_imul(($12 >> 15) + 1 >> 1, $16) | 0;
      HEAP16[$2 >> 1] = ($16 | 0) > 8388479 ? 32767 : ($16 | 0) < -8388736 ? -32768 : ($16 >>> 7 | 0) + 1 >>> 1 | 0;
      HEAP32[((HEAP32[$0 + 4336 >> 2] - $25 << 2) + $0 | 0) + 1280 >> 2] = HEAP32[$28 + 1024 >> 2];
      HEAP32[(HEAP32[$0 + 4332 >> 2] - $25 << 2) + $6 >> 2] = HEAP32[$28 + 864 >> 2];
     }
     HEAP32[$0 + 4336 >> 2] = HEAP32[$0 + 4336 >> 2] + 1;
     HEAP32[$0 + 4332 >> 2] = HEAP32[$0 + 4332 >> 2] + 1;
     $13 = $33 + 16 | 0;
     $26 = 0;
     while (1) {
      $16 = Math_imul($26, 1300) + $1 | 0;
      $12 = Math_imul($26, 56) + $30 | 0;
      HEAP32[$16 + 1280 >> 2] = HEAP32[$12 + 12 >> 2];
      HEAP32[$16 + 1284 >> 2] = HEAP32[$12 + 16 >> 2];
      $2 = HEAP32[$12 + 8 >> 2];
      HEAP32[($13 << 2) + $16 >> 2] = $2;
      HEAP32[((HEAP32[$24 >> 2] << 2) + $16 | 0) + 704 >> 2] = $2;
      $2 = HEAP32[$12 >> 2];
      HEAP32[((HEAP32[$24 >> 2] << 2) + $16 | 0) + 544 >> 2] = $2;
      HEAP32[((HEAP32[$24 >> 2] << 2) + $16 | 0) + 864 >> 2] = HEAP32[$12 + 24 >> 2] << 1;
      HEAP32[((HEAP32[$24 >> 2] << 2) + $16 | 0) + 1024 >> 2] = HEAP32[$12 + 20 >> 2];
      $2 = HEAP32[$16 + 1288 >> 2] + (($2 >> 9) + 1 >> 1) | 0;
      HEAP32[$16 + 1288 >> 2] = $2;
      HEAP32[((HEAP32[$24 >> 2] << 2) + $16 | 0) + 384 >> 2] = $2;
      HEAP32[$16 + 1296 >> 2] = HEAP32[$12 + 4 >> 2];
      $26 = $26 + 1 | 0;
      if (($26 | 0) != ($23 | 0)) {
       continue;
      }
      break;
     }
     HEAP32[(HEAP32[$24 >> 2] << 2) + $7 >> 2] = $64;
     $33 = $33 + 1 | 0;
     if (($33 | 0) != ($18 | 0)) {
      continue;
     }
     break;
    }
   }
   $14 = 0;
   $26 = $18 << 2;
   while (1) {
    $16 = Math_imul($14, 1300) + $1 | 0;
    $12 = $26 + $16 | 0;
    $13 = HEAP32[$12 >> 2];
    $2 = HEAP32[$12 + 4 >> 2];
    HEAP32[$16 >> 2] = $13;
    HEAP32[$16 + 4 >> 2] = $2;
    $13 = HEAP32[$12 + 60 >> 2];
    $2 = HEAP32[$12 + 56 >> 2];
    HEAP32[$16 + 56 >> 2] = $2;
    HEAP32[$16 + 60 >> 2] = $13;
    $2 = HEAP32[$12 + 52 >> 2];
    $13 = HEAP32[$12 + 48 >> 2];
    HEAP32[$16 + 48 >> 2] = $13;
    HEAP32[$16 + 52 >> 2] = $2;
    $13 = HEAP32[$12 + 44 >> 2];
    $2 = HEAP32[$12 + 40 >> 2];
    HEAP32[$16 + 40 >> 2] = $2;
    HEAP32[$16 + 44 >> 2] = $13;
    $2 = HEAP32[$12 + 36 >> 2];
    $13 = HEAP32[$12 + 32 >> 2];
    HEAP32[$16 + 32 >> 2] = $13;
    HEAP32[$16 + 36 >> 2] = $2;
    $13 = HEAP32[$12 + 28 >> 2];
    $2 = HEAP32[$12 + 24 >> 2];
    HEAP32[$16 + 24 >> 2] = $2;
    HEAP32[$16 + 28 >> 2] = $13;
    $2 = HEAP32[$12 + 20 >> 2];
    $13 = HEAP32[$12 + 16 >> 2];
    HEAP32[$16 + 16 >> 2] = $13;
    HEAP32[$16 + 20 >> 2] = $2;
    $13 = HEAP32[$12 + 12 >> 2];
    $2 = HEAP32[$12 + 8 >> 2];
    HEAP32[$16 + 8 >> 2] = $2;
    HEAP32[$16 + 12 >> 2] = $13;
    $14 = $14 + 1 | 0;
    if (($23 | 0) != ($14 | 0)) {
     continue;
    }
    break;
   }
   __stack_pointer = $63;
   return;
  }
  celt_fatal(16226, 16207, 364);
  abort();
 }
 celt_fatal(16271, 16207, 422);
 abort();
}
function dynalloc_analysis($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20) {
 var $21 = Math_fround(0), $22 = 0, $23 = Math_fround(0), $24 = 0, $25 = 0, $26 = Math_fround(0), $27 = Math_fround(0), $28 = Math_fround(0), $29 = 0, $30 = 0, $31 = Math_fround(0), $32 = 0, $33 = Math_fround(0), $34 = 0, $35 = 0, $36 = Math_fround(0), $37 = 0, $38 = 0, $39 = 0, $40 = Math_fround(0), $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = Math_fround(0);
 $24 = __stack_pointer;
 $41 = $24;
 $22 = (Math_imul($2, $5) << 2) + 15 & -16;
 $30 = $24 - $22 | 0;
 $24 = $30;
 __stack_pointer = $24;
 $32 = $24 - $22 | 0;
 $29 = $32;
 __stack_pointer = $29;
 $24 = 0;
 $38 = memset($6, 0, $2 << 2);
 $25 = ($4 | 0) < 1;
 if (!$25) {
  $21 = Math_fround(9 - $7 | 0);
  $6 = 0;
  while (1) {
   $22 = $6 << 2;
   $7 = $6 + 5 | 0;
   HEAPF32[$32 + $22 >> 2] = Math_fround(Math_fround(Math_imul($7, $7) | 0) * Math_fround(.006200000178068876)) + Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(HEAP16[($6 << 1) + $8 >> 1]) * Math_fround(.0625)) + Math_fround(.5)) + $21) - HEAPF32[$22 + 32928 >> 2]);
   $6 = $6 + 1 | 0;
   if (($6 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
 }
 $37 = ($5 | 0) > 1 ? $5 : 1;
 $33 = Math_fround(-31.899999618530273);
 label$3 : {
  label$4 : {
   label$5 : {
    label$6 : {
     while (1) {
      if (!$25) {
       $22 = Math_imul($2, $24);
       $6 = 0;
       while (1) {
        $21 = Math_fround(HEAPF32[($6 + $22 << 2) + $0 >> 2] - HEAPF32[($6 << 2) + $32 >> 2]);
        $33 = $21 < $33 ? $33 : $21;
        $6 = $6 + 1 | 0;
        if (($6 | 0) != ($4 | 0)) {
         continue;
        }
        break;
       }
       $24 = $24 + 1 | 0;
       if (($37 | 0) != ($24 | 0)) {
        continue;
       }
       $24 = $29;
       $22 = ($2 << 2) + 15 & -16;
       $6 = $24 - $22 | 0;
       __stack_pointer = $6;
       $22 = $6 - $22 | 0;
       __stack_pointer = $22;
       if (($4 | 0) < 1) {
        break label$6;
       }
       $7 = 0;
       while (1) {
        $25 = $7 << 2;
        HEAPF32[$25 + $6 >> 2] = HEAPF32[$0 + $25 >> 2] - HEAPF32[$25 + $32 >> 2];
        $7 = $7 + 1 | 0;
        if (($7 | 0) != ($4 | 0)) {
         continue;
        }
        break;
       }
       if (!(($5 | 0) != 2 | ($4 | 0) < 1)) {
        $7 = 0;
        while (1) {
         $25 = $7 << 2;
         $8 = $25 + $6 | 0;
         $21 = HEAPF32[$8 >> 2];
         $23 = Math_fround(HEAPF32[($2 + $7 << 2) + $0 >> 2] - HEAPF32[$25 + $32 >> 2]);
         HEAPF32[$8 >> 2] = $21 > $23 ? $21 : $23;
         $7 = $7 + 1 | 0;
         if (($7 | 0) != ($4 | 0)) {
          continue;
         }
         break;
        }
       }
       $8 = memcpy($22, $6, $4 << 2);
       if (($4 | 0) > 1) {
        break label$5;
       }
       $34 = $4 - 2 | 0;
       $35 = 0;
       break label$4;
      }
      $24 = $24 + 1 | 0;
      if (($37 | 0) != ($24 | 0)) {
       continue;
      }
      break;
     }
     $24 = $29;
     $22 = ($2 << 2) + 15 & -16;
     $6 = $24 - $22 | 0;
     __stack_pointer = $6;
     $22 = $6 - $22 | 0;
     __stack_pointer = $22;
    }
    memcpy($22, $6, $4 << 2);
    $34 = $4 - 2 | 0;
    $39 = ($5 | 0) == 2;
    break label$3;
   }
   $21 = HEAPF32[$6 >> 2];
   $22 = 1;
   while (1) {
    $7 = ($22 << 2) + $6 | 0;
    $23 = HEAPF32[$7 >> 2];
    $21 = Math_fround($21 + Math_fround(-2));
    $21 = $21 < $23 ? $23 : $21;
    HEAPF32[$7 >> 2] = $21;
    $22 = $22 + 1 | 0;
    if (($22 | 0) != ($4 | 0)) {
     continue;
    }
    break;
   }
   $34 = $4 - 2 | 0;
   $35 = 0;
   if (($4 | 0) <= 1) {
    break label$4;
   }
   $22 = $34;
   while (1) {
    $7 = ($22 << 2) + $6 | 0;
    $21 = HEAPF32[$7 >> 2];
    $23 = Math_fround(HEAPF32[$7 + 4 >> 2] + Math_fround(-3));
    HEAPF32[$7 >> 2] = $21 > $23 ? $21 : $23;
    $7 = ($22 | 0) > 0;
    $22 = $22 - 1 | 0;
    if ($7) {
     continue;
    }
    break;
   }
   $35 = 1;
  }
  $39 = ($5 | 0) == 2;
  if (($4 | 0) < 1) {
   break label$3;
  }
  $21 = Math_fround(Math_max(Math_fround($33 + Math_fround(-12)), Math_fround(0)));
  $22 = 0;
  while (1) {
   $7 = $22 << 2;
   $23 = HEAPF32[$7 + $6 >> 2];
   $23 = Math_fround(Math_floor(Math_fround(Math_fround(HEAPF32[$7 + $8 >> 2] - ($21 > $23 ? $21 : $23)) + Math_fround(.5))));
   label$16 : {
    if (Math_fround(Math_abs($23)) < Math_fround(2147483648)) {
     $24 = ~~$23;
     break label$16;
    }
    $24 = -2147483648;
   }
   $29 = $7 + $20 | 0;
   $25 = $24;
   $7 = ($25 | 0) > 0 ? 0 : 0 - $25 | 0;
   HEAP32[$29 >> 2] = 32 >>> (($7 | 0) < 5 ? $7 : 5);
   $22 = $22 + 1 | 0;
   if (($22 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
 }
 label$18 : {
  if (!($16 | (($13 | 0) < 1 | ($14 | 0) < 51))) {
   $42 = $4 - 3 | 0;
   $8 = 0;
   $43 = ($4 | 0) > 4;
   $44 = $4 - 1 << 2;
   $16 = 0;
   while (1) {
    $7 = Math_imul($2, $16);
    $6 = $7 << 2;
    $24 = $30 + $6 | 0;
    $20 = $1 + $6 | 0;
    $36 = HEAPF32[$20 >> 2];
    $6 = HEAP32[$20 >> 2];
    HEAP32[$24 >> 2] = $6;
    $23 = $36;
    $6 = 1;
    if ($35) {
     while (1) {
      $22 = ($6 + $7 << 2) + $1 | 0;
      $26 = HEAPF32[$22 - 4 >> 2];
      $23 = Math_fround($23 + Math_fround(1.5));
      $21 = HEAPF32[$22 >> 2];
      $23 = $21 > $23 ? $23 : $21;
      HEAPF32[($6 << 2) + $24 >> 2] = $23;
      $8 = Math_fround($26 + Math_fround(.5)) < $21 ? $6 : $8;
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($4 | 0)) {
       continue;
      }
      break;
     }
    }
    if (($8 | 0) >= 1) {
     $21 = HEAPF32[($8 << 2) + $24 >> 2];
     $6 = $8;
     while (1) {
      $22 = $6 - 1 | 0;
      $25 = ($22 << 2) + $24 | 0;
      $23 = HEAPF32[$25 >> 2];
      $21 = Math_fround($21 + Math_fround(2));
      $26 = HEAPF32[($7 + $22 << 2) + $1 >> 2];
      $21 = $21 < $26 ? $21 : $26;
      $21 = $21 > $23 ? $23 : $21;
      HEAPF32[$25 >> 2] = $21;
      $25 = ($6 | 0) > 1;
      $6 = $22;
      if ($25) {
       continue;
      }
      break;
     }
    }
    $6 = 2;
    if ($43) {
     while (1) {
      $22 = ($6 + $7 << 2) + $1 | 0;
      $25 = $22 - 8 | 0;
      $21 = HEAPF32[$25 >> 2];
      $23 = HEAPF32[$25 + 4 >> 2];
      $25 = $21 > $23;
      $26 = HEAPF32[$22 + 4 >> 2];
      $27 = HEAPF32[$22 + 8 >> 2];
      $29 = $26 > $27;
      $28 = $25 ? $21 : $23;
      $40 = $29 ? $26 : $27;
      $21 = $25 ? $23 : $21;
      $23 = $29 ? $27 : $26;
      $25 = $21 > $23;
      $31 = $25 ? $28 : $40;
      $21 = $25 ? $21 : $23;
      $29 = ($6 << 2) + $24 | 0;
      $23 = HEAPF32[$29 >> 2];
      $45 = $23;
      $26 = HEAPF32[$22 >> 2];
      $27 = $25 ? $40 : $28;
      $22 = $26 > $27 ^ 1;
      label$27 : {
       if (!$22) {
        $28 = $21 > $26 ? $26 : $21;
        if (!($21 > $27 ^ 1)) {
         break label$27;
        }
        $28 = $27 > $31 ? $31 : $27;
        break label$27;
       }
       $28 = $21 > $27 ? $27 : $21;
       if (!($21 > $26 ^ 1)) {
        break label$27;
       }
       $28 = $26 < $31 ? $26 : $31;
      }
      if (!(Math_fround($28 + Math_fround(-1)) < $45)) {
       label$30 : {
        if (!$22) {
         $28 = $21 > $26 ? $26 : $21;
         if (!($21 > $27 ^ 1)) {
          break label$30;
         }
         $28 = $27 > $31 ? $31 : $27;
         break label$30;
        }
        $28 = $21 > $27 ? $27 : $21;
        if (!($21 > $26 ^ 1)) {
         break label$30;
        }
        $28 = $26 < $31 ? $26 : $31;
       }
       $21 = $28;
       $23 = Math_fround($21 + Math_fround(-1));
      }
      HEAPF32[$29 >> 2] = $23;
      $6 = $6 + 1 | 0;
      if (($34 | 0) != ($6 | 0)) {
       continue;
      }
      break;
     }
    }
    $21 = HEAPF32[$20 + 4 >> 2];
    $6 = $36 > $21;
    $26 = HEAPF32[$24 >> 2];
    $27 = $6 ? $36 : $21;
    $23 = HEAPF32[$20 + 8 >> 2];
    $21 = $6 ? $21 : $36;
    $21 = Math_fround(($23 > $27 ? $27 : $21 < $23 ? $23 : $21) + Math_fround(-1));
    HEAPF32[$24 >> 2] = $21 < $26 ? $26 : $21;
    $23 = HEAPF32[$24 + 4 >> 2];
    HEAPF32[$24 + 4 >> 2] = $21 < $23 ? $23 : $21;
    $6 = ($34 << 2) + $24 | 0;
    $20 = $6;
    $27 = HEAPF32[$6 >> 2];
    $6 = ($7 + $42 << 2) + $1 | 0;
    $21 = HEAPF32[$6 >> 2];
    $23 = HEAPF32[$6 + 4 >> 2];
    $22 = $21 > $23;
    $31 = $22 ? $21 : $23;
    $26 = HEAPF32[$6 + 8 >> 2];
    $21 = $22 ? $23 : $21;
    $21 = Math_fround(($26 > $31 ? $31 : $21 < $26 ? $26 : $21) + Math_fround(-1));
    HEAPF32[$20 >> 2] = $21 < $27 ? $27 : $21;
    $6 = $24 + $44 | 0;
    $23 = HEAPF32[$6 >> 2];
    HEAPF32[$6 >> 2] = $21 < $23 ? $23 : $21;
    $6 = 0;
    if (($4 | 0) >= 1) {
     while (1) {
      $22 = $6 << 2;
      $7 = $24 + $22 | 0;
      $21 = HEAPF32[$7 >> 2];
      $23 = HEAPF32[$22 + $32 >> 2];
      HEAPF32[$7 >> 2] = $21 > $23 ? $21 : $23;
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($4 | 0)) {
       continue;
      }
      break;
     }
    }
    $16 = $16 + 1 | 0;
    if (($37 | 0) != ($16 | 0)) {
     continue;
    }
    break;
   }
   label$34 : {
    label$35 : {
     if (!$39) {
      if (($3 | 0) >= ($4 | 0)) {
       break label$34;
      }
      $6 = $3;
      while (1) {
       $24 = $6 << 2;
       $22 = $30 + $24 | 0;
       HEAPF32[$22 >> 2] = Math_max(Math_fround(HEAPF32[$0 + $24 >> 2] - HEAPF32[$22 >> 2]), Math_fround(0));
       $6 = $6 + 1 | 0;
       if (($6 | 0) != ($4 | 0)) {
        continue;
       }
       break;
      }
      break label$35;
     }
     if (($3 | 0) >= ($4 | 0)) {
      break label$34;
     }
     $6 = $3;
     while (1) {
      $1 = $2 + $6 << 2;
      $22 = $30 + $1 | 0;
      $21 = HEAPF32[$22 >> 2];
      $7 = $6 << 2;
      $24 = $30 + $7 | 0;
      $23 = Math_fround(HEAPF32[$24 >> 2] + Math_fround(-4));
      $21 = $21 > $23 ? $21 : $23;
      HEAPF32[$22 >> 2] = $21;
      $23 = HEAPF32[$24 >> 2];
      $21 = Math_fround($21 + Math_fround(-4));
      $21 = $21 < $23 ? $23 : $21;
      HEAPF32[$24 >> 2] = $21;
      HEAPF32[$24 >> 2] = Math_fround(Math_fround(Math_max(Math_fround(HEAPF32[$0 + $7 >> 2] - $21), Math_fround(0))) + Math_fround(Math_max(Math_fround(HEAPF32[$0 + $1 >> 2] - HEAPF32[$22 >> 2]), Math_fround(0)))) * Math_fround(.5);
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($4 | 0)) {
       continue;
      }
      break;
     }
    }
    $1 = ($3 | 0) < ($4 | 0);
    if (!$1) {
     break label$34;
    }
    $6 = $3;
    while (1) {
     $24 = $6 << 2;
     $22 = $30 + $24 | 0;
     $21 = HEAPF32[$22 >> 2];
     $23 = HEAPF32[$17 + $24 >> 2];
     HEAPF32[$22 >> 2] = $21 > $23 ? $21 : $23;
     $6 = $6 + 1 | 0;
     if (($6 | 0) != ($4 | 0)) {
      continue;
     }
     break;
    }
    if (!$1) {
     break label$34;
    }
    $6 = $3;
    while (1) {
     $24 = $6 << 2;
     $21 = HEAPF32[$30 + $24 >> 2];
     $21 = Math_fround(Math_floor(Math_fround(Math_fround(Math_fround(exp(+($21 < Math_fround(4) ? $21 : Math_fround(4)) * .6931471805599453)) * Math_fround(13)) + Math_fround(.5))));
     label$41 : {
      if (Math_fround(Math_abs($21)) < Math_fround(2147483648)) {
       $22 = ~~$21;
       break label$41;
      }
      $22 = -2147483648;
     }
     HEAP32[$19 + $24 >> 2] = $22;
     $6 = $6 + 1 | 0;
     if (($6 | 0) != ($4 | 0)) {
      continue;
     }
     break;
    }
   }
   $1 = ($3 | 0) >= ($4 | 0);
   if (!(!$11 & ($10 | 0) != 0 | ($9 | $1))) {
    $6 = $3;
    while (1) {
     $24 = ($6 << 2) + $30 | 0;
     HEAPF32[$24 >> 2] = HEAPF32[$24 >> 2] * Math_fround(.5);
     $6 = $6 + 1 | 0;
     if (($6 | 0) != ($4 | 0)) {
      continue;
     }
     break;
    }
   }
   if (!$1) {
    $6 = $3;
    while (1) {
     $21 = Math_fround(2);
     label$47 : {
      if (($6 | 0) >= 8) {
       $21 = Math_fround(.5);
       if (($6 | 0) < 12) {
        break label$47;
       }
      }
      $24 = ($6 << 2) + $30 | 0;
      HEAPF32[$24 >> 2] = HEAPF32[$24 >> 2] * $21;
     }
     $6 = $6 + 1 | 0;
     if (($6 | 0) != ($4 | 0)) {
      continue;
     }
     break;
    }
   }
   label$49 : {
    if (!HEAP32[$18 >> 2]) {
     break label$49;
    }
    $22 = ($4 | 0) < 19 ? $4 : 19;
    if (($22 | 0) <= ($3 | 0)) {
     break label$49;
    }
    $6 = $3;
    while (1) {
     $24 = ($6 << 2) + $30 | 0;
     HEAPF32[$24 >> 2] = HEAPF32[$24 >> 2] + Math_fround(Math_fround(HEAPU8[($6 + $18 | 0) + 44 | 0]) * Math_fround(.015625));
     $6 = $6 + 1 | 0;
     if (($22 | 0) != ($6 | 0)) {
      continue;
     }
     break;
    }
   }
   $22 = 0;
   if ($1) {
    break label$18;
   }
   $8 = ($14 << 1) / 3 | 0;
   $1 = 0;
   $7 = HEAPU16[($3 << 1) + $12 >> 1];
   $29 = (!$10 | !$9 & ($11 | 0) != 0) ^ 1;
   while (1) {
    $25 = $3 << 2;
    $6 = $30 + $25 | 0;
    $21 = HEAPF32[$6 >> 2];
    $21 = $21 < Math_fround(4) ? $21 : Math_fround(4);
    HEAPF32[$6 >> 2] = $21;
    $6 = $7 << 16;
    $24 = $3 + 1 | 0;
    $7 = HEAP16[($24 << 1) + $12 >> 1];
    $22 = Math_imul($7 - ($6 >> 16) | 0, $5) << $13;
    label$52 : {
     if (($22 | 0) <= 5) {
      if (Math_fround(Math_abs($21)) < Math_fround(2147483648)) {
       $6 = ~~$21;
      } else {
       $6 = -2147483648;
      }
      $22 = Math_imul($22, $6) << 3;
      break label$52;
     }
     if (($22 | 0) >= 49) {
      $21 = Math_fround($21 * Math_fround(8));
      label$57 : {
       if (Math_fround(Math_abs($21)) < Math_fround(2147483648)) {
        $6 = ~~$21;
        break label$57;
       }
       $6 = -2147483648;
      }
      $22 = (Math_imul($22, $6) << 3) / 8 | 0;
      break label$52;
     }
     $21 = Math_fround(Math_fround($21 * Math_fround($22 | 0)) / Math_fround(6));
     label$59 : {
      if (Math_fround(Math_abs($21)) < Math_fround(2147483648)) {
       $6 = ~~$21;
       break label$59;
      }
      $6 = -2147483648;
     }
     $22 = Math_imul($6, 48);
    }
    $22 = $22 + $1 | 0;
    if (!($22 >> 6 <= ($8 | 0) | $29)) {
     $22 = $8 << 6;
     HEAP32[($3 << 2) + $38 >> 2] = $22 - $1;
     break label$18;
    }
    HEAP32[$25 + $38 >> 2] = $6;
    $3 = $24;
    $1 = $22;
    if (($4 | 0) != ($24 | 0)) {
     continue;
    }
    break;
   }
   break label$18;
  }
  $22 = 0;
  if (($3 | 0) >= ($4 | 0)) {
   break label$18;
  }
  while (1) {
   HEAP32[($3 << 2) + $19 >> 2] = 13;
   $3 = $3 + 1 | 0;
   if (($4 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
 }
 HEAP32[$15 >> 2] = $22;
 __stack_pointer = $41;
 return $33;
}
function opus_fft_impl($0, $1) {
 var $2 = 0, $3 = Math_fround(0), $4 = 0, $5 = Math_fround(0), $6 = Math_fround(0), $7 = 0, $8 = Math_fround(0), $9 = 0, $10 = 0, $11 = Math_fround(0), $12 = 0, $13 = Math_fround(0), $14 = 0, $15 = Math_fround(0), $16 = Math_fround(0), $17 = Math_fround(0), $18 = 0, $19 = Math_fround(0), $20 = Math_fround(0), $21 = 0, $22 = Math_fround(0), $23 = Math_fround(0), $24 = Math_fround(0), $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = Math_fround(0), $32 = Math_fround(0), $33 = Math_fround(0), $34 = 0, $35 = 0, $36 = 0, $37 = Math_fround(0), $38 = 0, $39 = 0, $40 = Math_fround(0), $41 = Math_fround(0), $42 = Math_fround(0), $43 = Math_fround(0), $44 = Math_fround(0), $45 = Math_fround(0), $46 = Math_fround(0), $47 = Math_fround(0), $48 = Math_fround(0), $49 = Math_fround(0), $50 = 0;
 $29 = __stack_pointer - 32 | 0;
 __stack_pointer = $29;
 $14 = HEAP32[$0 + 8 >> 2];
 HEAP32[$29 >> 2] = 1;
 $7 = $0 + 12 | 0;
 $9 = 1;
 while (1) {
  $2 = $4;
  $10 = $2 << 2;
  $18 = HEAPU16[($10 | 2) + $7 >> 1];
  $4 = $2 + 1 | 0;
  $9 = Math_imul(HEAP16[$7 + $10 >> 1], $9);
  HEAP32[($4 << 2) + $29 >> 2] = $9;
  if (($18 | 0) != 1) {
   continue;
  }
  break;
 }
 $38 = ($14 | 0) > 0 ? $14 : 0;
 $35 = HEAP16[(($4 << 2) + $0 | 0) + 10 >> 1];
 label$2 : {
  while (1) {
   $12 = $35;
   $4 = 0;
   $35 = 1;
   $30 = $2;
   if ($2) {
    $35 = HEAP16[(($30 << 2) + $0 | 0) + 10 >> 1];
    $4 = $30 << 1;
   }
   label$5 : {
    label$6 : {
     switch (HEAP16[(($4 << 1) + $0 | 0) + 12 >> 1] - 2 | 0) {
     case 0:
      if (($12 | 0) != 4) {
       break label$2;
      }
      $4 = 0;
      $2 = $1;
      $10 = HEAP32[($30 << 2) + $29 >> 2];
      if (($10 | 0) <= 0) {
       break label$5;
      }
      while (1) {
       $6 = HEAPF32[$2 >> 2];
       $3 = HEAPF32[$2 + 32 >> 2];
       HEAPF32[$2 + 32 >> 2] = $6 - $3;
       HEAPF32[$2 >> 2] = $3 + $6;
       $7 = $2 + 36 | 0;
       $6 = HEAPF32[$7 >> 2];
       $3 = HEAPF32[$2 + 4 >> 2];
       HEAPF32[$2 + 4 >> 2] = $6 + $3;
       HEAPF32[$2 + 36 >> 2] = $3 - $6;
       $6 = HEAPF32[$2 + 8 >> 2];
       $3 = HEAPF32[$2 + 40 >> 2];
       $7 = $2 + 44 | 0;
       $5 = HEAPF32[$7 >> 2];
       $8 = Math_fround(Math_fround($3 + $5) * Math_fround(.7071067690849304));
       HEAPF32[$2 + 40 >> 2] = $6 - $8;
       $9 = $2 + 12 | 0;
       $11 = HEAPF32[$9 >> 2];
       $3 = Math_fround(Math_fround($5 - $3) * Math_fround(.7071067690849304));
       HEAPF32[$2 + 44 >> 2] = $11 - $3;
       HEAPF32[$2 + 8 >> 2] = $6 + $8;
       HEAPF32[$2 + 12 >> 2] = $3 + $11;
       $6 = HEAPF32[$2 + 48 >> 2];
       $3 = HEAPF32[$2 + 16 >> 2];
       $7 = $2 + 52 | 0;
       $5 = HEAPF32[$7 >> 2];
       HEAPF32[$2 + 48 >> 2] = $3 - $5;
       $9 = $2 + 20 | 0;
       $8 = HEAPF32[$9 >> 2];
       HEAPF32[$2 + 52 >> 2] = $6 + $8;
       HEAPF32[$2 + 20 >> 2] = $8 - $6;
       HEAPF32[$2 + 16 >> 2] = $5 + $3;
       $6 = HEAPF32[$2 + 24 >> 2];
       $7 = $2 + 60 | 0;
       $3 = HEAPF32[$7 >> 2];
       $5 = HEAPF32[$2 + 56 >> 2];
       $8 = Math_fround(Math_fround($3 - $5) * Math_fround(.7071067690849304));
       HEAPF32[$2 + 56 >> 2] = $6 - $8;
       $9 = $2 + 28 | 0;
       $11 = HEAPF32[$9 >> 2];
       $3 = Math_fround(Math_fround($3 + $5) * Math_fround(-.7071067690849304));
       HEAPF32[$2 + 60 >> 2] = $11 - $3;
       HEAPF32[$2 + 28 >> 2] = $3 + $11;
       HEAPF32[$2 + 24 >> 2] = $6 + $8;
       $2 = $2 - -64 | 0;
       $4 = $4 + 1 | 0;
       if (($10 | 0) != ($4 | 0)) {
        continue;
       }
       break;
      }
      break label$5;
     case 2:
      $34 = HEAP32[($30 << 2) + $29 >> 2];
      if (($12 | 0) == 1) {
       $4 = 0;
       $2 = $1;
       if (($34 | 0) < 1) {
        break label$5;
       }
       while (1) {
        $6 = HEAPF32[$2 >> 2];
        $3 = HEAPF32[$2 + 16 >> 2];
        $5 = Math_fround($6 + $3);
        $8 = HEAPF32[$2 + 8 >> 2];
        $11 = HEAPF32[$2 + 24 >> 2];
        $15 = Math_fround($8 + $11);
        HEAPF32[$2 + 16 >> 2] = $5 - $15;
        HEAPF32[$2 >> 2] = $5 + $15;
        $7 = $2 + 20 | 0;
        $12 = $7;
        $5 = HEAPF32[$2 + 4 >> 2];
        $15 = HEAPF32[$2 + 20 >> 2];
        $20 = Math_fround($5 + $15);
        $7 = $2 + 12 | 0;
        $22 = HEAPF32[$7 >> 2];
        $9 = $2 + 28 | 0;
        $16 = HEAPF32[$9 >> 2];
        $17 = Math_fround($22 + $16);
        HEAPF32[$12 >> 2] = $20 - $17;
        $5 = Math_fround($5 - $15);
        $8 = Math_fround($8 - $11);
        HEAPF32[$2 + 28 >> 2] = $5 + $8;
        $6 = Math_fround($6 - $3);
        $3 = Math_fround($22 - $16);
        HEAPF32[$2 + 24 >> 2] = $6 - $3;
        HEAPF32[$2 + 12 >> 2] = $5 - $8;
        HEAPF32[$2 + 8 >> 2] = $6 + $3;
        HEAPF32[$2 + 4 >> 2] = $20 + $17;
        $2 = $2 + 32 | 0;
        $4 = $4 + 1 | 0;
        if (($34 | 0) != ($4 | 0)) {
         continue;
        }
        break;
       }
       break label$5;
      }
      if (($34 | 0) < 1) {
       break label$5;
      }
      $26 = Math_imul($12, 3);
      $27 = $12 << 1;
      $21 = $34 << $38;
      $28 = Math_imul($21, 3);
      $39 = $21 << 1;
      $50 = HEAP32[$0 + 48 >> 2];
      $36 = 0;
      while (1) {
       if (($12 | 0) >= 1) {
        $2 = (Math_imul($35, $36) << 3) + $1 | 0;
        $25 = 0;
        $4 = $50;
        $7 = $4;
        $9 = $4;
        while (1) {
         $10 = ($12 << 3) + $2 | 0;
         $6 = HEAPF32[$10 + 4 >> 2];
         $3 = HEAPF32[$10 >> 2];
         $18 = ($26 << 3) + $2 | 0;
         $5 = HEAPF32[$18 + 4 >> 2];
         $8 = HEAPF32[$18 >> 2];
         $11 = HEAPF32[$9 >> 2];
         $15 = HEAPF32[$9 + 4 >> 2];
         $20 = HEAPF32[$4 >> 2];
         $22 = HEAPF32[$4 + 4 >> 2];
         $16 = HEAPF32[$7 >> 2];
         $14 = ($27 << 3) + $2 | 0;
         $17 = HEAPF32[$14 + 4 >> 2];
         $13 = HEAPF32[$14 >> 2];
         $19 = HEAPF32[$7 + 4 >> 2];
         $31 = Math_fround(Math_fround($16 * $17) + Math_fround($13 * $19));
         $23 = HEAPF32[$2 + 4 >> 2];
         $24 = Math_fround($31 + $23);
         HEAPF32[$2 + 4 >> 2] = $24;
         $16 = Math_fround(Math_fround($13 * $16) - Math_fround($17 * $19));
         $17 = HEAPF32[$2 >> 2];
         $13 = Math_fround($16 + $17);
         HEAPF32[$2 >> 2] = $13;
         $19 = Math_fround(Math_fround($11 * $6) + Math_fround($3 * $15));
         $32 = Math_fround(Math_fround($20 * $5) + Math_fround($8 * $22));
         $33 = Math_fround($19 + $32);
         HEAPF32[$14 + 4 >> 2] = $24 - $33;
         $6 = Math_fround(Math_fround($3 * $11) - Math_fround($6 * $15));
         $3 = Math_fround(Math_fround($8 * $20) - Math_fround($5 * $22));
         $5 = Math_fround($6 + $3);
         HEAPF32[$14 >> 2] = $13 - $5;
         HEAPF32[$2 >> 2] = $5 + HEAPF32[$2 >> 2];
         HEAPF32[$2 + 4 >> 2] = $33 + HEAPF32[$2 + 4 >> 2];
         $5 = Math_fround($23 - $31);
         $6 = Math_fround($6 - $3);
         HEAPF32[$10 + 4 >> 2] = $5 - $6;
         $3 = Math_fround($17 - $16);
         $8 = Math_fround($19 - $32);
         HEAPF32[$10 >> 2] = $3 + $8;
         HEAPF32[$18 + 4 >> 2] = $5 + $6;
         HEAPF32[$18 >> 2] = $3 - $8;
         $2 = $2 + 8 | 0;
         $4 = ($28 << 3) + $4 | 0;
         $7 = ($39 << 3) + $7 | 0;
         $9 = ($21 << 3) + $9 | 0;
         $25 = $25 + 1 | 0;
         if (($25 | 0) != ($12 | 0)) {
          continue;
         }
         break;
        }
       }
       $36 = $36 + 1 | 0;
       if (($36 | 0) != ($34 | 0)) {
        continue;
       }
       break;
      }
      break label$5;
     case 1:
      $28 = HEAP32[($30 << 2) + $29 >> 2];
      if (($28 | 0) < 1) {
       break label$5;
      }
      $25 = $12 << 1;
      $27 = HEAP32[$0 + 48 >> 2];
      $14 = $28 << $38;
      $6 = HEAPF32[($27 + (Math_imul($14, $12) << 3) | 0) + 4 >> 2];
      $21 = $14 << 1;
      $26 = 0;
      while (1) {
       $2 = (Math_imul($26, $35) << 3) + $1 | 0;
       $7 = $27;
       $9 = $7;
       $18 = $12;
       while (1) {
        $4 = ($12 << 3) + $2 | 0;
        $3 = HEAPF32[$4 >> 2];
        $5 = HEAPF32[$9 >> 2];
        $8 = HEAPF32[$4 + 4 >> 2];
        $11 = HEAPF32[$9 + 4 >> 2];
        $15 = Math_fround(Math_fround($3 * $5) - Math_fround($8 * $11));
        $10 = ($25 << 3) + $2 | 0;
        $20 = HEAPF32[$10 >> 2];
        $22 = HEAPF32[$7 >> 2];
        $16 = HEAPF32[$10 + 4 >> 2];
        $17 = HEAPF32[$7 + 4 >> 2];
        $13 = Math_fround(Math_fround($20 * $22) - Math_fround($16 * $17));
        $19 = Math_fround($15 + $13);
        HEAPF32[$4 >> 2] = HEAPF32[$2 >> 2] - Math_fround($19 * Math_fround(.5));
        $3 = Math_fround(Math_fround($5 * $8) + Math_fround($3 * $11));
        $5 = Math_fround(Math_fround($22 * $16) + Math_fround($20 * $17));
        $8 = Math_fround($3 + $5);
        HEAPF32[$4 + 4 >> 2] = HEAPF32[$2 + 4 >> 2] - Math_fround($8 * Math_fround(.5));
        HEAPF32[$2 >> 2] = $19 + HEAPF32[$2 >> 2];
        HEAPF32[$2 + 4 >> 2] = $8 + HEAPF32[$2 + 4 >> 2];
        $3 = Math_fround($6 * Math_fround($3 - $5));
        HEAPF32[$10 >> 2] = $3 + HEAPF32[$4 >> 2];
        $5 = Math_fround($6 * Math_fround($15 - $13));
        HEAPF32[$10 + 4 >> 2] = HEAPF32[$4 + 4 >> 2] - $5;
        HEAPF32[$4 >> 2] = HEAPF32[$4 >> 2] - $3;
        HEAPF32[$4 + 4 >> 2] = $5 + HEAPF32[$4 + 4 >> 2];
        $2 = $2 + 8 | 0;
        $7 = ($21 << 3) + $7 | 0;
        $9 = ($14 << 3) + $9 | 0;
        $18 = $18 - 1 | 0;
        if ($18) {
         continue;
        }
        break;
       }
       $26 = $26 + 1 | 0;
       if (($28 | 0) != ($26 | 0)) {
        continue;
       }
       break;
      }
      break label$5;
     case 3:
      break label$6;
     default:
      break label$5;
     }
    }
    $28 = HEAP32[($30 << 2) + $29 >> 2];
    if (($28 | 0) < 1) {
     break label$5;
    }
    $18 = HEAP32[$0 + 48 >> 2];
    $26 = $28 << $38;
    $2 = Math_imul($26, $12);
    $4 = $18 + ($2 << 4) | 0;
    $6 = HEAPF32[$4 + 4 >> 2];
    $3 = HEAPF32[$4 >> 2];
    $2 = ($2 << 3) + $18 | 0;
    $5 = HEAPF32[$2 + 4 >> 2];
    $8 = HEAPF32[$2 >> 2];
    $39 = $12 << 2;
    $36 = Math_imul($12, 3);
    $34 = $12 << 1;
    $27 = 0;
    while (1) {
     if (($12 | 0) >= 1) {
      $2 = (Math_imul($27, $35) << 3) + $1 | 0;
      $4 = $2 + ($12 << 3) | 0;
      $7 = ($34 << 3) + $2 | 0;
      $9 = ($36 << 3) + $2 | 0;
      $10 = ($39 << 3) + $2 | 0;
      $25 = 0;
      while (1) {
       $11 = HEAPF32[$2 >> 2];
       $15 = HEAPF32[$2 + 4 >> 2];
       $14 = Math_imul($25, $26);
       $21 = ($14 << 4) + $18 | 0;
       $16 = HEAPF32[$21 >> 2];
       $17 = HEAPF32[$7 + 4 >> 2];
       $13 = HEAPF32[$7 >> 2];
       $19 = HEAPF32[$21 + 4 >> 2];
       $31 = Math_fround(Math_fround($16 * $17) + Math_fround($13 * $19));
       $21 = Math_imul($14, 24) + $18 | 0;
       $23 = HEAPF32[$21 >> 2];
       $24 = HEAPF32[$9 + 4 >> 2];
       $32 = HEAPF32[$9 >> 2];
       $33 = HEAPF32[$21 + 4 >> 2];
       $37 = Math_fround(Math_fround($23 * $24) + Math_fround($32 * $33));
       $20 = Math_fround($31 + $37);
       $21 = ($14 << 3) + $18 | 0;
       $40 = HEAPF32[$21 >> 2];
       $41 = HEAPF32[$4 + 4 >> 2];
       $42 = HEAPF32[$4 >> 2];
       $43 = HEAPF32[$21 + 4 >> 2];
       $44 = Math_fround(Math_fround($40 * $41) + Math_fround($42 * $43));
       $14 = ($14 << 5) + $18 | 0;
       $45 = HEAPF32[$14 >> 2];
       $46 = HEAPF32[$10 + 4 >> 2];
       $47 = HEAPF32[$10 >> 2];
       $48 = HEAPF32[$14 + 4 >> 2];
       $49 = Math_fround(Math_fround($45 * $46) + Math_fround($47 * $48));
       $22 = Math_fround($44 + $49);
       HEAPF32[$2 + 4 >> 2] = $15 + Math_fround($20 + $22);
       $13 = Math_fround(Math_fround($13 * $16) - Math_fround($17 * $19));
       $19 = Math_fround(Math_fround($32 * $23) - Math_fround($24 * $33));
       $16 = Math_fround($13 + $19);
       $23 = Math_fround(Math_fround($42 * $40) - Math_fround($41 * $43));
       $24 = Math_fround(Math_fround($47 * $45) - Math_fround($46 * $48));
       $17 = Math_fround($23 + $24);
       HEAPF32[$2 >> 2] = $11 + Math_fround($16 + $17);
       $13 = Math_fround($13 - $19);
       $19 = Math_fround($23 - $24);
       $23 = Math_fround(Math_fround($6 * $13) + Math_fround($5 * $19));
       $24 = Math_fround($15 + Math_fround(Math_fround($3 * $20) + Math_fround($8 * $22)));
       HEAPF32[$4 + 4 >> 2] = $23 + $24;
       $32 = Math_fround($11 + Math_fround(Math_fround($3 * $16) + Math_fround($8 * $17)));
       $31 = Math_fround($31 - $37);
       $33 = Math_fround($44 - $49);
       $37 = Math_fround(Math_fround($6 * $31) + Math_fround($5 * $33));
       HEAPF32[$4 >> 2] = $32 - $37;
       HEAPF32[$10 + 4 >> 2] = $24 - $23;
       HEAPF32[$10 >> 2] = $37 + $32;
       $13 = Math_fround(Math_fround($6 * $19) - Math_fround($5 * $13));
       $15 = Math_fround($15 + Math_fround(Math_fround($8 * $20) + Math_fround($3 * $22)));
       HEAPF32[$7 + 4 >> 2] = $13 + $15;
       $20 = Math_fround(Math_fround($5 * $31) - Math_fround($6 * $33));
       $11 = Math_fround($11 + Math_fround(Math_fround($8 * $16) + Math_fround($3 * $17)));
       HEAPF32[$7 >> 2] = $20 + $11;
       HEAPF32[$9 + 4 >> 2] = $15 - $13;
       HEAPF32[$9 >> 2] = $11 - $20;
       $10 = $10 + 8 | 0;
       $9 = $9 + 8 | 0;
       $7 = $7 + 8 | 0;
       $4 = $4 + 8 | 0;
       $2 = $2 + 8 | 0;
       $25 = $25 + 1 | 0;
       if (($25 | 0) != ($12 | 0)) {
        continue;
       }
       break;
      }
     }
     $27 = $27 + 1 | 0;
     if (($28 | 0) != ($27 | 0)) {
      continue;
     }
     break;
    }
   }
   $2 = $30 - 1 | 0;
   if (($30 | 0) > 0) {
    continue;
   }
   break;
  }
  __stack_pointer = $29 + 32 | 0;
  return;
 }
 celt_fatal(42449, 42433, 76);
 abort();
}
function clt_compute_allocation($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18) {
 var $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0;
 $19 = __stack_pointer;
 $41 = $19;
 $8 = ($8 | 0) > 0 ? $8 : 0;
 $39 = (($8 | 0) > 7) << 3;
 $33 = $8 - $39 | 0;
 $37 = HEAP32[$0 + 8 >> 2];
 label$1 : {
  if (($13 | 0) != 2) {
   break label$1;
  }
  $35 = HEAPU8[($2 - $1 | 0) + 42192 | 0];
  if (($35 | 0) > ($33 | 0)) {
   $35 = 0;
   break label$1;
  }
  $8 = $33 - $35 | 0;
  $36 = (($8 | 0) > 7) << 3;
  $33 = $8 - $36 | 0;
 }
 $8 = ($37 << 2) + 15 & -16;
 $23 = $19 - $8 | 0;
 $19 = $23;
 __stack_pointer = $19;
 $30 = $19 - $8 | 0;
 $19 = $30;
 __stack_pointer = $19;
 $27 = $19 - $8 | 0;
 $19 = $27;
 __stack_pointer = $19;
 $28 = $13 << 3;
 $34 = $19 - $8 | 0;
 __stack_pointer = $34;
 $38 = ($1 | 0) >= ($2 | 0);
 if (!$38) {
  $25 = $14 + 3 | 0;
  $24 = Math_imul(($5 - $14 | 0) - 5 | 0, $13);
  $26 = HEAP32[$0 + 32 >> 2];
  $20 = HEAPU16[$26 + ($1 << 1) >> 1];
  $8 = $1;
  while (1) {
   $5 = $20 << 16;
   $21 = $8 << 2;
   $19 = $8 + 1 | 0;
   $20 = HEAP16[($19 << 1) + $26 >> 1];
   $5 = $20 - ($5 >> 16) | 0;
   $22 = Math_imul($5, 3) << $14 << 3 >> 4;
   HEAP32[$27 + $21 >> 2] = ($22 | 0) < ($28 | 0) ? $28 : $22;
   HEAP32[$21 + $34 >> 2] = (Math_imul(Math_imul(($8 ^ -1) + $2 | 0, $24), $5) << $25 >> 6) - ($5 << $14 == 1 ? $28 : 0);
   $8 = $19;
   if (($2 | 0) != ($19 | 0)) {
    continue;
   }
   break;
  }
 }
 $40 = HEAP32[$0 + 48 >> 2];
 $32 = $40 - 1 | 0;
 $29 = 1;
 label$6 : {
  while (1) {
   $31 = $29 + $32 >> 1;
   if (!$38) {
    $25 = Math_imul($31, $37);
    $24 = HEAP32[$0 + 32 >> 2];
    $21 = HEAPU16[$24 + ($2 << 1) >> 1];
    $26 = HEAP32[$0 + 52 >> 2];
    $20 = 0;
    $8 = $2;
    $22 = 0;
    while (1) {
     $5 = $21 << 16 >> 16;
     $8 = $8 - 1 | 0;
     $21 = HEAP16[($8 << 1) + $24 >> 1];
     $5 = Math_imul(Math_imul($5 - $21 | 0, $13), HEAPU8[($8 + $25 | 0) + $26 | 0]) << $14;
     $19 = $5 >> 2;
     $22 = !$22;
     if (($5 | 0) >= 4) {
      $19 = HEAP32[($8 << 2) + $34 >> 2] + $19 | 0;
      $19 = ($19 | 0) > 0 ? $19 : 0;
     }
     $5 = $8 << 2;
     $19 = HEAP32[$5 + $3 >> 2] + $19 | 0;
     label$11 : {
      if (!(($19 | 0) < HEAP32[$5 + $27 >> 2] ? $22 : 0)) {
       $5 = HEAP32[$4 + $5 >> 2];
       $19 = ($5 | 0) > ($19 | 0) ? $19 : $5;
       $22 = 1;
       break label$11;
      }
      $19 = ($19 | 0) < ($28 | 0) ? 0 : $28;
      $22 = 0;
     }
     $20 = $20 + $19 | 0;
     if (($1 | 0) < ($8 | 0)) {
      continue;
     }
     break;
    }
    $8 = ($20 | 0) > ($33 | 0);
    $29 = $8 ? $29 : $31 + 1 | 0;
    $32 = $8 ? $31 - 1 | 0 : $32;
    if (($29 | 0) <= ($32 | 0)) {
     continue;
    }
    $31 = $1;
    if ($38) {
     break label$6;
    }
    $42 = Math_imul($29, $37);
    $26 = Math_imul($29 - 1 | 0, $37);
    $32 = HEAP32[$0 + 32 >> 2];
    $25 = HEAPU16[$32 + ($1 << 1) >> 1];
    $24 = HEAP32[$0 + 52 >> 2];
    $8 = $1;
    $31 = $8;
    while (1) {
     $19 = $25 << 16;
     $5 = $8 + 1 | 0;
     $25 = HEAP16[($5 << 1) + $32 >> 1];
     $19 = Math_imul($25 - ($19 >> 16) | 0, $13);
     $20 = Math_imul($19, HEAPU8[($8 + $26 | 0) + $24 | 0]) << $14;
     if (($29 | 0) >= ($40 | 0)) {
      $19 = HEAP32[($8 << 2) + $4 >> 2];
     } else {
      $19 = Math_imul(HEAPU8[($8 + $42 | 0) + $24 | 0], $19) << $14 >> 2;
     }
     $21 = $20 >> 2;
     if (($20 | 0) >= 4) {
      $20 = HEAP32[($8 << 2) + $34 >> 2] + $21 | 0;
      $21 = ($20 | 0) > 0 ? $20 : 0;
     }
     if (($19 | 0) >= 1) {
      $19 = HEAP32[($8 << 2) + $34 >> 2] + $19 | 0;
      $19 = ($19 | 0) > 0 ? $19 : 0;
     }
     $20 = $8 << 2;
     $22 = HEAP32[$20 + $3 >> 2];
     $21 = (($29 | 0) > 1 ? $22 : 0) + $21 | 0;
     HEAP32[$20 + $23 >> 2] = $21;
     $19 = ($19 - $21 | 0) + $22 | 0;
     HEAP32[$20 + $30 >> 2] = ($19 | 0) > 0 ? $19 : 0;
     $31 = ($22 | 0) > 0 ? $8 : $31;
     $8 = $5;
     if (($8 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
    break label$6;
   }
   $8 = ($33 | 0) < 0;
   $29 = $8 ? $29 : $31 + 1 | 0;
   $32 = $8 ? $31 - 1 | 0 : $32;
   if (($29 | 0) <= ($32 | 0)) {
    continue;
   }
   break;
  }
  $31 = $1;
 }
 $3 = ($13 | 0) > 1;
 $24 = 64;
 $25 = 0;
 $26 = 0;
 while (1) {
  label$20 : {
   $22 = $24 + $25 >> 1;
   $5 = $2;
   $20 = 0;
   $21 = 0;
   if (!$38) {
    while (1) {
     $5 = $5 - 1 | 0;
     $8 = $5 << 2;
     $19 = (Math_imul(HEAP32[$30 + $8 >> 2], $22) >> 6) + HEAP32[$8 + $23 >> 2] | 0;
     label$23 : {
      if (!(($19 | 0) < HEAP32[$8 + $27 >> 2] ? !$21 : 0)) {
       $8 = HEAP32[$4 + $8 >> 2];
       $8 = ($8 | 0) > ($19 | 0) ? $19 : $8;
       $21 = 1;
       break label$23;
      }
      $8 = ($19 | 0) < ($28 | 0) ? 0 : $28;
      $21 = 0;
     }
     $20 = $20 + $8 | 0;
     if (($1 | 0) < ($5 | 0)) {
      continue;
     }
     break;
    }
    $8 = ($20 | 0) > ($33 | 0);
    $25 = $8 ? $25 : $22;
    $24 = $8 ? $22 : $24;
    $26 = $26 + 1 | 0;
    if (($26 | 0) != 6) {
     continue;
    }
    $8 = 0;
    $20 = $2;
    $21 = 0;
    while (1) {
     $20 = $20 - 1 | 0;
     $19 = $20 << 2;
     $5 = HEAP32[$19 + $23 >> 2] + (Math_imul(HEAP32[$19 + $30 >> 2], $25) >> 6) | 0;
     $22 = ($5 | 0) >= HEAP32[$19 + $27 >> 2];
     $24 = $19 + $10 | 0;
     $5 = $21 ? $5 : $22 ? $5 : ($5 | 0) < ($28 | 0) ? 0 : $28;
     $19 = HEAP32[$4 + $19 >> 2];
     $19 = ($5 | 0) < ($19 | 0) ? $5 : $19;
     HEAP32[$24 >> 2] = $19;
     $8 = $8 + $19 | 0;
     $21 = $21 | $22;
     if (($1 | 0) < ($20 | 0)) {
      continue;
     }
     break;
    }
    break label$20;
   }
   $8 = 0;
   $19 = ($33 | 0) < 0;
   $25 = $19 ? $25 : $22;
   $24 = $19 ? $22 : $24;
   $26 = $26 + 1 | 0;
   if (($26 | 0) != 6) {
    continue;
   }
  }
  break;
 }
 $22 = $2 - 1 | 0;
 label$27 : {
  label$28 : {
   if (($31 | 0) >= ($22 | 0)) {
    $5 = $2;
    $19 = $35;
    break label$28;
   }
   $32 = $1 + 2 | 0;
   $30 = $28 + 8 | 0;
   $21 = $2;
   while (1) {
    $19 = HEAP32[$0 + 32 >> 2];
    $20 = HEAP16[$19 + ($21 << 1) >> 1];
    $5 = $22;
    $25 = HEAP16[($5 << 1) + $19 >> 1];
    $29 = $20 - $25 | 0;
    $34 = $5 << 2;
    $22 = $34 + $10 | 0;
    $23 = HEAP32[$22 >> 2];
    $24 = $33 - $8 | 0;
    $19 = HEAP16[($1 << 1) + $19 >> 1];
    $26 = ($24 >>> 0) / ($20 - $19 >>> 0) | 0;
    $19 = Math_imul($19 - $20 | 0, $26) + $24 + ($19 - $25) | 0;
    $20 = ($23 + Math_imul($29, $26) | 0) + (($19 | 0) > 0 ? $19 : 0) | 0;
    $19 = HEAP32[$27 + $34 >> 2];
    if (($20 | 0) >= ((($19 | 0) > ($30 | 0) ? $19 : $30) | 0)) {
     label$32 : {
      label$33 : {
       if ($16) {
        if (!(($21 | 0) <= ($32 | 0) | (Math_imul(($21 | 0) > 17 ? ($17 | 0) < ($21 | 0) ? 9 : 7 : 0, $29) << $14 << 3 >> 4 < ($20 | 0) ? ($5 | 0) <= ($18 | 0) : 0))) {
         ec_enc_bit_logp($15, 0, 1);
         break label$32;
        }
        ec_enc_bit_logp($15, 1, 1);
        break label$33;
       }
       if (!ec_dec_bit_logp($15, 1)) {
        break label$32;
       }
      }
      $5 = $21;
      $19 = $35;
      break label$27;
     }
     $20 = $20 - 8 | 0;
     $23 = HEAP32[$22 >> 2];
     $8 = $8 + 8 | 0;
    }
    $19 = $35;
    if (($19 | 0) >= 1) {
     $19 = HEAPU8[($5 - $1 | 0) + 42192 | 0];
    }
    $20 = ($20 | 0) < ($28 | 0) ? 0 : $28;
    HEAP32[$22 >> 2] = $20;
    $8 = (($8 - ($23 + $35 | 0) | 0) + $20 | 0) + $19 | 0;
    $35 = $19;
    $21 = $5;
    $22 = $21 - 1 | 0;
    if (($31 | 0) < ($22 | 0)) {
     continue;
    }
    break;
   }
  }
  $33 = $33 + $39 | 0;
 }
 label$38 : {
  label$39 : {
   label$40 : {
    if (($1 | 0) < ($5 | 0)) {
     label$42 : {
      label$43 : {
       label$44 : {
        label$45 : {
         $17 = $36;
         label$46 : {
          if (($19 | 0) >= 1) {
           if (!$16) {
            break label$45;
           }
           $19 = HEAP32[$6 >> 2];
           $19 = ($5 | 0) > ($19 | 0) ? $19 : $5;
           HEAP32[$6 >> 2] = $19;
           ec_enc_uint($15, $19 - $1 | 0, ($5 - $1 | 0) + 1 | 0);
           $19 = HEAP32[$6 >> 2];
           break label$46;
          }
          HEAP32[$6 >> 2] = 0;
          $19 = 0;
         }
         $20 = ($19 | 0) > ($1 | 0);
         $19 = $20 ? 0 : $17;
         if (!$36 | !$20) {
          break label$43;
         }
         if (!$16) {
          break label$44;
         }
         ec_enc_bit_logp($15, HEAP32[$7 >> 2], 1);
         break label$42;
        }
        $19 = ec_dec_uint($15, ($5 - $1 | 0) + 1 | 0) + $1 | 0;
        HEAP32[$6 >> 2] = $19;
        $20 = ($1 | 0) < ($19 | 0);
        $19 = $20 ? 0 : $36;
        if (!$36 | !$20) {
         break label$43;
        }
       }
       HEAP32[$7 >> 2] = ec_dec_bit_logp($15, 1);
       break label$42;
      }
      HEAP32[$7 >> 2] = 0;
     }
     $31 = $14 << 3;
     $22 = HEAP32[$0 + 32 >> 2];
     $30 = HEAP16[$22 + ($1 << 1) >> 1];
     $25 = ($33 - $8 | 0) + $19 | 0;
     $20 = HEAP16[($5 << 1) + $22 >> 1];
     $23 = ($25 >>> 0) / ($20 - $30 >>> 0) | 0;
     $24 = Math_imul($23, $30 - $20 | 0);
     $20 = $30;
     $8 = $1;
     while (1) {
      $21 = $20 << 16;
      $27 = ($8 << 2) + $10 | 0;
      $19 = $8 + 1 | 0;
      $20 = HEAP16[($19 << 1) + $22 >> 1];
      HEAP32[$27 >> 2] = HEAP32[$27 >> 2] + Math_imul($20 - ($21 >> 16) | 0, $23);
      $8 = $19;
      if (($5 | 0) != ($19 | 0)) {
       continue;
      }
      break;
     }
     $8 = $24 + $25 | 0;
     $21 = $30;
     $19 = $1;
     while (1) {
      $27 = $21 << 16;
      $23 = ($19 << 2) + $10 | 0;
      $20 = $19 + 1 | 0;
      $21 = HEAP16[($20 << 1) + $22 >> 1];
      $19 = $21 - ($27 >> 16) | 0;
      $19 = ($8 | 0) < ($19 | 0) ? $8 : $19;
      HEAP32[$23 >> 2] = $19 + HEAP32[$23 >> 2];
      $8 = $8 - $19 | 0;
      $19 = $20;
      if (($19 | 0) != ($5 | 0)) {
       continue;
      }
      break;
     }
     $29 = ($13 | 0) > 1 ? 4 : 3;
     $27 = 0;
     label$50 : {
      while (1) {
       if (($1 | 0) == ($5 | 0)) {
        break label$50;
       }
       $8 = $1 << 2;
       $19 = $10 + $8 | 0;
       $20 = HEAP32[$19 >> 2];
       if (($20 | 0) <= -1) {
        break label$40;
       }
       $23 = $30 << 16;
       $21 = $20 + $27 | 0;
       $25 = $1 + 1 | 0;
       $30 = HEAP16[($25 << 1) + $22 >> 1];
       $23 = $30 - ($23 >> 16) << $14;
       label$52 : {
        if (($23 | 0) >= 2) {
         $26 = 0;
         $20 = $21 - HEAP32[$4 + $8 >> 2] | 0;
         $20 = ($20 | 0) > 0 ? $20 : 0;
         $24 = $21 - $20 | 0;
         HEAP32[$19 >> 2] = $24;
         $21 = Math_imul($13, $23);
         if (!(HEAP32[$7 >> 2] | (($23 | 0) == 2 | ($13 | 0) != 2))) {
          $26 = HEAP32[$6 >> 2] > ($1 | 0);
         }
         $21 = $21 + $26 | 0;
         $26 = $21 << 3;
         $15 = (($23 | 0) == 2 ? $26 >> 2 : 0) + Math_imul($21, -21) | 0;
         $23 = Math_imul(HEAP16[HEAP32[$0 + 56 >> 2] + ($1 << 1) >> 1] + $31 | 0, $21);
         $1 = $15 + ($23 >> 1) | 0;
         $34 = $24 + $1 | 0;
         label$55 : {
          if (($34 | 0) < $21 << 4) {
           $1 = ($23 >> 2) + $1 | 0;
           break label$55;
          }
          if ((Math_imul($21, 24) | 0) <= ($34 | 0)) {
           break label$55;
          }
          $1 = ($23 >> 3) + $1 | 0;
         }
         $23 = $8 + $11 | 0;
         $24 = (($21 << 2) + $24 | 0) + $1 | 0;
         $21 = ((($24 | 0) > 0 ? $24 : 0) >>> 0) / ($21 >>> 0) >>> 3 | 0;
         HEAP32[$23 >> 2] = $21;
         $24 = HEAP32[$19 >> 2];
         if ((Math_imul($13, $21) | 0) > $24 >> 3) {
          $21 = $24 >> $3 >> 3;
          HEAP32[$23 >> 2] = $21;
         }
         $21 = ($21 | 0) < 8 ? $21 : 8;
         HEAP32[$23 >> 2] = $21;
         HEAP32[$8 + $12 >> 2] = (HEAP32[$19 >> 2] + $1 | 0) <= (Math_imul($21, $26) | 0);
         HEAP32[$19 >> 2] = HEAP32[$19 >> 2] - Math_imul(HEAP32[$23 >> 2], $28);
         break label$52;
        }
        $1 = $21 - $28 | 0;
        $20 = ($1 | 0) > 0 ? $1 : 0;
        HEAP32[$19 >> 2] = $21 - $20;
        HEAP32[$8 + $11 >> 2] = 0;
        HEAP32[$8 + $12 >> 2] = 1;
       }
       if ($20) {
        $1 = $8 + $11 | 0;
        $15 = $1;
        $21 = $20 >>> $29 | 0;
        $1 = HEAP32[$1 >> 2];
        $23 = 8 - $1 | 0;
        $21 = ($21 | 0) < ($23 | 0) ? $21 : $23;
        HEAP32[$15 >> 2] = $1 + $21;
        $1 = Math_imul($21, $28);
        HEAP32[$8 + $12 >> 2] = ($1 | 0) >= ($20 - $27 | 0);
        $27 = $20 - $1 | 0;
       } else {
        $27 = 0;
       }
       if (HEAP32[$19 >> 2] <= -1) {
        break label$39;
       }
       $1 = $25;
       if (HEAP32[$8 + $11 >> 2] > -1) {
        continue;
       }
       break;
      }
      celt_fatal(42296, 42253, 514);
      abort();
     }
     HEAP32[$9 >> 2] = $27;
     if (($2 | 0) > ($5 | 0)) {
      $8 = $5;
      while (1) {
       $19 = $8 << 2;
       $20 = $19 + $11 | 0;
       $1 = $10 + $19 | 0;
       $21 = HEAP32[$1 >> 2] >> $3 >> 3;
       HEAP32[$20 >> 2] = $21;
       if (HEAP32[$1 >> 2] != (Math_imul($21, $28) | 0)) {
        break label$38;
       }
       HEAP32[$1 >> 2] = 0;
       HEAP32[$12 + $19 >> 2] = HEAP32[$20 >> 2] < 1;
       $8 = $8 + 1 | 0;
       if (($8 | 0) != ($2 | 0)) {
        continue;
       }
       break;
      }
     }
     __stack_pointer = $41;
     return $5;
    }
    celt_fatal(42216, 42253, 391);
    abort();
   }
   celt_fatal(42265, 42253, 442);
   abort();
  }
  celt_fatal(42265, 42253, 513);
  abort();
 }
 celt_fatal(42328, 42253, 524);
 abort();
}
function compute_theta($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = Math_fround(0), $16 = Math_fround(0), $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = Math_fround(0), $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 $22 = HEAP32[$0 + 36 >> 2];
 $14 = HEAP32[$0 + 28 >> 2];
 $12 = HEAP32[$0 + 16 >> 2];
 $23 = HEAP32[$0 >> 2];
 $11 = 1;
 $19 = HEAP32[$5 >> 2];
 $24 = HEAP32[$0 + 8 >> 2];
 $20 = HEAP32[$0 + 12 >> 2];
 $8 = HEAP16[HEAP32[$24 + 56 >> 2] + ($20 << 1) >> 1] + ($8 << 3) | 0;
 $13 = ($19 - $8 | 0) - 32 | 0;
 $17 = $8 >> 1;
 $8 = ($4 | 0) == 2 & ($9 | 0) != 0;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     label$5 : {
      label$6 : {
       label$7 : {
        label$8 : {
         label$9 : {
          label$10 : {
           label$11 : {
            label$12 : {
             $17 = $17 + ($8 ? -16 : -4) | 0;
             $8 = ($4 << 1) + ($8 ? -2 : -1) | 0;
             $8 = (Math_imul($17, $8) + $19 | 0) / ($8 | 0) | 0;
             $8 = ($8 | 0) > ($13 | 0) ? $13 : $8;
             $8 = ($8 | 0) < 64 ? $8 : 64;
             if (($8 | 0) >= 4) {
              $11 = (HEAP16[(($8 & 7) << 1) + 42144 >> 1] >> 14 - ($8 >>> 3 | 0)) + 1 & -2;
              if (($11 | 0) >= 257) {
               break label$12;
              }
             }
             $11 = ($12 | 0) > ($20 | 0) ? $11 : $9 ? 1 : $11;
             label$14 : {
              label$15 : {
               label$16 : {
                if ($23) {
                 $8 = stereo_itheta($2, $3, $9, $4, HEAP32[$0 + 44 >> 2]);
                 $19 = ec_tell_frac($14);
                 if (($11 | 0) == 1) {
                  break label$14;
                 }
                 label$18 : {
                  label$19 : {
                   if ($9) {
                    $0 = HEAP32[$0 + 48 >> 2];
                    if ($0) {
                     break label$19;
                    }
                    $0 = Math_imul($8, $11) - -8192 >> 14;
                    break label$18;
                   }
                   $8 = Math_imul($8, $11);
                   $13 = $8 - -8192 | 0;
                   $12 = $13 >> 14;
                   label$21 : {
                    if (($12 | 0) >= ($11 | 0)) {
                     $0 = $12;
                     break label$21;
                    }
                    if (($8 | 0) < 8192) {
                     $0 = $12;
                     break label$21;
                    }
                    if (!HEAP32[$0 + 56 >> 2]) {
                     $0 = $12;
                     break label$21;
                    }
                    $0 = $11;
                    $13 = (($13 & -16384) >>> 0) / ($0 >>> 0) << 16;
                    $8 = Math_imul($13 >> 13, $13 >> 16) + 32768 >> 16;
                    $18 = ((Math_imul($8, ((Math_imul((Math_imul($8, -626) + 16384 >> 15) + 8277 | 0, $8) << 1) + 32768 & -65536) - 501415936 >> 16) + 16384 >>> 15 | 0) - $8 << 16) - -2147483648 >> 16;
                    $17 = Math_clz32($18);
                    $8 = 1073741824 - $13 | 0;
                    $8 = Math_imul($8 >> 13, $8 >> 16) + 32768 >> 16;
                    $8 = ((Math_imul($8, ((Math_imul((Math_imul($8, -626) + 16384 >> 15) + 8277 | 0, $8) << 1) + 32768 & -65536) - 501415936 >> 16) + 16384 >>> 15 | 0) - $8 << 16) - -2147483648 >> 16;
                    $13 = Math_clz32($8);
                    $18 = $18 << $17 - 17 << 16 >> 16;
                    $8 = $8 << $13 - 17 << 16 >> 16;
                    $8 = Math_imul(($17 - $13 << 11) - (Math_imul($18, (Math_imul($18, -2597) + 16384 >> 15) + 7932 | 0) + 16384 >>> 15 | 0) + (Math_imul($8, (Math_imul($8, -2597) + 16384 >> 15) + 7932 | 0) + 16384 >>> 15) << 16 >> 16, ($4 << 23) - 8388608 >> 16) + 16384 >> 15;
                    $13 = HEAP32[$5 >> 2];
                    if (($8 | 0) > ($13 | 0)) {
                     break label$21;
                    }
                    $0 = (0 - $13 | 0) > ($8 | 0) ? 0 : $12;
                   }
                   if (($7 | 0) < 2) {
                    break label$16;
                   }
                   break label$9;
                  }
                  $8 = Math_imul($8, $11) + (((($8 | 0) > 8192 ? 32767 : -32767) | 0) / ($11 | 0) | 0) | 0;
                  $8 = ($8 | 0) < 0 ? 0 : $8 >> 14;
                  $0 = (($0 ^ -1) >>> 31 | 0) + (($8 | 0) < ($11 | 0) ? $8 : $11 - 1 | 0) | 0;
                 }
                 if (($4 | 0) <= 2) {
                  break label$9;
                 }
                 $8 = ($11 | 0) / 2 | 0;
                 $12 = Math_imul($8, 3) + 3 | 0;
                 $13 = Math_imul($0, 3);
                 $7 = ($0 | 0) > ($8 | 0);
                 ec_encode($14, $7 ? ($12 + ($8 ^ -1) | 0) + $0 | 0 : $13, $7 ? ($12 - $8 | 0) + $0 | 0 : $13 + 3 | 0, $8 + $12 | 0);
                 break label$8;
                }
                $19 = ec_tell_frac($14);
                if (($11 | 0) == 1) {
                 break label$11;
                }
                if (!(!$9 | ($4 | 0) < 3)) {
                 $17 = $14;
                 $8 = ($11 | 0) / 2 | 0;
                 $7 = $8 + 1 | 0;
                 $12 = Math_imul($7, 3);
                 $13 = $8 + $12 | 0;
                 $0 = ec_decode($14, $13);
                 label$26 : {
                  if (($12 | 0) > ($0 | 0)) {
                   $0 = ($0 | 0) / 3 | 0;
                   break label$26;
                  }
                  $0 = $0 - ($7 << 1) | 0;
                 }
                 $7 = Math_imul($0, 3);
                 $18 = ($0 | 0) > ($8 | 0);
                 ec_dec_update($17, $18 ? (($8 ^ -1) + $12 | 0) + $0 | 0 : $7, $18 ? ($12 - $8 | 0) + $0 | 0 : $7 + 3 | 0, $13);
                 break label$8;
                }
                if ($9 ? 0 : ($7 | 0) <= 1) {
                 break label$15;
                }
                $0 = ec_dec_uint($14, $11 + 1 | 0);
                break label$8;
               }
               $18 = $11 - $0 | 0;
               $17 = $18 + 1 | 0;
               $25 = $0 + 1 | 0;
               $8 = $11 >> 1;
               $13 = ($8 | 0) < ($0 | 0);
               $7 = $13 ? $17 : $25;
               $8 = $8 + 1 | 0;
               $12 = Math_imul($8, $8);
               $8 = $13 ? $12 - (Math_imul($18 + 2 | 0, $17) >> 1) | 0 : Math_imul($0, $25) >> 1;
               ec_encode($14, $8, $7 + $8 | 0, $12);
               break label$8;
              }
              $7 = $14;
              $2 = $11 >> 1;
              $9 = $2 + 1 | 0;
              $3 = Math_imul($9, $9);
              $0 = ec_decode($14, $3);
              label$30 : {
               if (($0 | 0) < Math_imul($2, $9) >> 1) {
                $9 = isqrt32($0 << 3 | 1) - 1 >>> 1 | 0;
                $0 = $9 + 1 | 0;
                $2 = Math_imul($0, $9) >>> 1 | 0;
                break label$30;
               }
               $9 = $11 + 1 | 0;
               $2 = $9;
               $9 = ($9 << 1) - isqrt32(($0 ^ -1) + $3 << 3 | 1) >>> 1 | 0;
               $0 = $2 - $9 | 0;
               $2 = $3 - (Math_imul($0, ($11 - $9 | 0) + 2 | 0) >> 1) | 0;
              }
              ec_dec_update($7, $2, $0 + $2 | 0, $3);
              $8 = ($9 << 14 >>> 0) / ($11 >>> 0) | 0;
              break label$5;
             }
             if (!$9) {
              break label$5;
             }
             $9 = 0;
             $12 = 0;
             label$32 : {
              if (($8 | 0) < 8193) {
               break label$32;
              }
              $11 = HEAP32[$0 + 52 >> 2];
              if ($11) {
               break label$32;
              }
              $12 = 1;
              if (($4 | 0) < 1) {
               break label$32;
              }
              $12 = !$11;
              $11 = 0;
              while (1) {
               $8 = ($11 << 2) + $3 | 0;
               HEAPF32[$8 >> 2] = -HEAPF32[$8 >> 2];
               $11 = $11 + 1 | 0;
               if (($11 | 0) != ($4 | 0)) {
                continue;
               }
               break;
              }
             }
             if (($4 | 0) < 1) {
              break label$10;
             }
             $15 = HEAPF32[($20 << 2) + $22 >> 2];
             $16 = HEAPF32[(HEAP32[$24 + 8 >> 2] + $20 << 2) + $22 >> 2];
             $21 = Math_fround(Math_fround(Math_sqrt(Math_fround(Math_fround(Math_fround($15 * $15) + Math_fround(1.0000000036274937e-15)) + Math_fround($16 * $16)))) + Math_fround(1.0000000036274937e-15));
             $16 = Math_fround($16 / $21);
             $15 = Math_fround($15 / $21);
             while (1) {
              $11 = $9 << 2;
              $8 = $11 + $2 | 0;
              HEAPF32[$8 >> 2] = Math_fround($15 * HEAPF32[$8 >> 2]) + Math_fround($16 * HEAPF32[$3 + $11 >> 2]);
              $9 = $9 + 1 | 0;
              if (($9 | 0) != ($4 | 0)) {
               continue;
              }
              break;
             }
             break label$10;
            }
            celt_fatal(42160, 41800, 669);
            abort();
           }
           $12 = 0;
           if (!$9) {
            break label$7;
           }
          }
          $4 = 0;
          label$35 : {
           if (HEAP32[$5 >> 2] < 17) {
            break label$35;
           }
           $4 = 0;
           if (HEAP32[$0 + 32 >> 2] < 17) {
            break label$35;
           }
           if ($23) {
            ec_enc_bit_logp($14, $12, 2);
            $4 = $12;
            break label$35;
           }
           $4 = ec_dec_bit_logp($14, 2);
          }
          $12 = HEAP32[$0 + 52 >> 2] ? 0 : $4;
          break label$7;
         }
         ec_enc_uint($14, $0, $11 + 1 | 0);
        }
        if (($0 | 0) <= -1) {
         break label$6;
        }
        $0 = $0 << 14;
        $8 = ($0 >>> 0) / ($11 >>> 0) | 0;
        if (!$9 | !$23) {
         break label$5;
        }
        if ($0 >>> 0 < $11 >>> 0) {
         $12 = 0;
         if (($4 | 0) < 1) {
          break label$7;
         }
         $15 = HEAPF32[($20 << 2) + $22 >> 2];
         $16 = HEAPF32[(HEAP32[$24 + 8 >> 2] + $20 << 2) + $22 >> 2];
         $21 = Math_fround(Math_fround(Math_sqrt(Math_fround(Math_fround(Math_fround($15 * $15) + Math_fround(1.0000000036274937e-15)) + Math_fround($16 * $16)))) + Math_fround(1.0000000036274937e-15));
         $16 = Math_fround($16 / $21);
         $15 = Math_fround($15 / $21);
         $9 = 0;
         while (1) {
          $0 = $9 << 2;
          $11 = $2 + $0 | 0;
          HEAPF32[$11 >> 2] = Math_fround($15 * HEAPF32[$11 >> 2]) + Math_fround($16 * HEAPF32[$0 + $3 >> 2]);
          $9 = $9 + 1 | 0;
          if (($9 | 0) != ($4 | 0)) {
           continue;
          }
          break;
         }
         break label$7;
        }
        if (($4 | 0) < 1) {
         break label$5;
        }
        $9 = 0;
        while (1) {
         $0 = $9 << 2;
         $11 = $2 + $0 | 0;
         $16 = Math_fround(HEAPF32[$11 >> 2] * Math_fround(.7071067690849304));
         $0 = $0 + $3 | 0;
         $15 = Math_fround(HEAPF32[$0 >> 2] * Math_fround(.7071067690849304));
         HEAPF32[$11 >> 2] = $16 + $15;
         HEAPF32[$0 >> 2] = $15 - $16;
         $9 = $9 + 1 | 0;
         if (($9 | 0) != ($4 | 0)) {
          continue;
         }
         break;
        }
        break label$5;
       }
       $4 = ec_tell_frac($14);
       $0 = $4 - $19 | 0;
       HEAP32[$5 >> 2] = HEAP32[$5 >> 2] - $0;
       break label$4;
      }
      celt_fatal(42104, 41800, 838);
      abort();
     }
     $9 = ec_tell_frac($14);
     $0 = $9 - $19 | 0;
     HEAP32[$5 >> 2] = HEAP32[$5 >> 2] - $0;
     $9 = 16384;
     if (($8 | 0) == 16384) {
      break label$3;
     }
     if ($8) {
      break label$2;
     }
     $12 = $8;
    }
    HEAP32[$10 >> 2] = HEAP32[$10 >> 2] & (-1 << $6 ^ -1);
    $4 = -16384;
    $3 = 32767;
    $9 = 0;
    $2 = 0;
    break label$1;
   }
   HEAP32[$10 >> 2] = HEAP32[$10 >> 2] & (-1 << $6 ^ -1) << $6;
   $2 = 32767;
   $12 = 0;
   $3 = 0;
   $4 = 16384;
   break label$1;
  }
  $2 = $8 << 16;
  $9 = Math_imul($2 >> 13, $2 >> 16) + 32768 >> 16;
  $3 = ((Math_imul($9, ((Math_imul((Math_imul($9, -626) + 16384 >> 15) + 8277 | 0, $9) << 1) + 32768 & -65536) - 501415936 >> 16) + 16384 >>> 15 | 0) - $9 << 16) - -2147483648 >> 16;
  $11 = Math_clz32($3);
  $9 = 1073741824 - $2 | 0;
  $9 = Math_imul($9 >> 13, $9 >> 16) + 32768 >> 16;
  $2 = ((Math_imul($9, ((Math_imul((Math_imul($9, -626) + 16384 >> 15) + 8277 | 0, $9) << 1) + 32768 & -65536) - 501415936 >> 16) + 16384 >>> 15 | 0) - $9 << 16) - -2147483648 >> 16;
  $9 = Math_clz32($2);
  $5 = $11 - $9 << 11;
  $11 = $3 << $11 - 17 << 16 >> 16;
  $9 = $2 << $9 - 17 << 16 >> 16;
  $4 = Math_imul($5 - (Math_imul($11, (Math_imul($11, -2597) + 16384 >> 15) + 7932 | 0) + 16384 >>> 15 | 0) + (Math_imul($9, (Math_imul($9, -2597) + 16384 >> 15) + 7932 | 0) + 16384 >>> 15) << 16 >> 16, ($4 << 23) - 8388608 >> 16) + 16384 >> 15;
  $12 = 0;
  $9 = $8;
 }
 HEAP32[$1 + 20 >> 2] = $0;
 HEAP32[$1 + 16 >> 2] = $9;
 HEAP32[$1 + 12 >> 2] = $4;
 HEAP32[$1 + 8 >> 2] = $2;
 HEAP32[$1 + 4 >> 2] = $3;
 HEAP32[$1 >> 2] = $12;
}
function silk_noise_shape_analysis_FLP($0, $1, $2, $3) {
 var $4 = 0, $5 = Math_fround(0), $6 = 0, $7 = 0, $8 = 0, $9 = Math_fround(0), $10 = Math_fround(0), $11 = 0, $12 = Math_fround(0), $13 = 0, $14 = Math_fround(0), $15 = 0, $16 = Math_fround(0), $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = Math_fround(0), $22 = Math_fround(0), $23 = Math_fround(0), $24 = 0, $25 = 0, $26 = 0;
 $11 = __stack_pointer - 1184 | 0;
 __stack_pointer = $11;
 $13 = HEAP32[$0 + 4600 >> 2];
 $4 = HEAP32[$0 + 4716 >> 2];
 $5 = Math_fround(Math_fround(Math_fround(HEAP32[$0 + 4700 >> 2] + HEAP32[$0 + 4696 >> 2] | 0) * Math_fround(.5)) * Math_fround(30517578125e-15));
 HEAPF32[$1 + 696 >> 2] = $5;
 $10 = Math_fround($4 | 0);
 $12 = Math_fround($10 * Math_fround(.0078125));
 $9 = Math_fround(1 / (exp(+Math_fround(Math_fround($12 + Math_fround(-20)) * Math_fround(-.25))) + 1));
 HEAPF32[$1 + 700 >> 2] = $9;
 if (!HEAP32[$0 + 4676 >> 2]) {
  $14 = Math_fround(Math_fround(Math_fround(HEAP32[$0 + 4532 >> 2]) * Math_fround(-.00390625)) + Math_fround(1));
  $12 = Math_fround($12 - Math_fround($14 * Math_fround($14 * Math_fround(Math_fround(Math_fround($5 * Math_fround(.5)) + Math_fround(.5)) * Math_fround($9 + $9)))));
 }
 label$2 : {
  if (HEAPU8[$0 + 4765 | 0] == 2) {
   HEAP8[$0 + 4766 | 0] = 0;
   $5 = HEAPF32[$0 + 10060 >> 2];
   $21 = Math_fround($12 + Math_fround($5 + $5));
   break label$2;
  }
  $16 = Math_fround(Math_fround(Math_fround(Math_fround($10 * Math_fround(-.4000000059604645)) * Math_fround(.0078125)) + Math_fround(6)) * Math_fround(Math_fround(1) - $5));
  $4 = Math_imul(HEAP16[$0 + 4580 >> 1], 5);
  $6 = ($4 | 0) / 2 | 0;
  $5 = Math_fround(0);
  if (($4 | 0) >= 2) {
   $7 = HEAP32[$0 + 4576 >> 2] << 1;
   $14 = Math_fround($7 | 0);
   $9 = Math_fround(0);
   $4 = 0;
   $8 = $7 << 2;
   while (1) {
    $10 = Math_fround(log10(+Math_fround($14 + Math_fround(silk_energy_FLP($2, $7)))) * 3.32192809488736);
    $5 = $4 ? Math_fround($5 + Math_fround(Math_abs(Math_fround($10 - $9)))) : $5;
    $2 = $2 + $8 | 0;
    $9 = $10;
    $4 = $4 + 1 | 0;
    if (($6 | 0) != ($4 | 0)) {
     continue;
    }
    break;
   }
  }
  $21 = Math_fround($16 + $12);
  if (!(Math_fround(Math_fround($6 - 1 | 0) * Math_fround(.6000000238418579)) < $5 ^ 1)) {
   HEAP8[$0 + 4766 | 0] = 0;
   break label$2;
  }
  HEAP8[$0 + 4766 | 0] = 1;
 }
 $2 = HEAP32[$0 + 4580 >> 2];
 label$7 : {
  if (($2 | 0) < 1) {
   $4 = 0;
   break label$7;
  }
  $15 = $3 - ($13 << 2) | 0;
  $5 = Math_fround(HEAPF32[$1 + 704 >> 2] * Math_fround(.0010000000474974513));
  $23 = Math_fround(Math_fround(.9399999976158142) / Math_fround(Math_fround($5 * $5) + Math_fround(1)));
  $10 = Math_fround(Math_fround(Math_fround(HEAP32[$0 + 4672 >> 2]) * Math_fround(152587890625e-16)) + Math_fround(HEAPF32[$1 + 700 >> 2] * Math_fround(.009999999776482582)));
  $22 = Math_fround(Math_fround(1) - Math_fround($10 * $10));
  $16 = Math_fround(-$10);
  while (1) {
   $4 = HEAP32[$0 + 4576 >> 2];
   $6 = Math_imul($4, 3);
   $2 = (HEAP32[$0 + 4604 >> 2] - $6 | 0) / 2 | 0;
   silk_apply_sine_window_FLP($11 + 224 | 0, $15, 1, $2);
   $7 = $2 << 2;
   memcpy($7 + ($11 + 224 | 0) | 0, $7 + $15 | 0, Math_imul($4, 12));
   $4 = $2 + $6 << 2;
   silk_apply_sine_window_FLP($4 + ($11 + 224 | 0) | 0, $4 + $15 | 0, 2, $2);
   $8 = HEAP32[$0 + 4588 >> 2];
   $2 = HEAP32[$0 + 4636 >> 2];
   $4 = HEAP32[$0 + 4604 >> 2];
   label$10 : {
    if (HEAP32[$0 + 4672 >> 2] >= 1) {
     silk_warped_autocorrelation_FLP($11 + 112 | 0, $11 + 224 | 0, $10, $4, $2);
     break label$10;
    }
    silk_autocorrelation_FLP($11 + 112 | 0, $11 + 224 | 0, $4, $2 + 1 | 0);
   }
   $5 = HEAPF32[$11 + 112 >> 2];
   HEAPF32[$11 + 112 >> 2] = $5 + Math_fround(Math_fround($5 * Math_fround(29999999242136255e-21)) + Math_fround(1));
   $5 = silk_schur_FLP($11, $11 + 112 | 0, HEAP32[$0 + 4636 >> 2]);
   $2 = (Math_imul($17, 96) + $1 | 0) + 244 | 0;
   silk_k2a_FLP($2, $11, HEAP32[$0 + 4636 >> 2]);
   $3 = ($17 << 2) + $1 | 0;
   $9 = Math_fround(Math_sqrt($5));
   HEAPF32[$3 >> 2] = $9;
   $7 = HEAP32[$0 + 4636 >> 2];
   if (HEAP32[$0 + 4672 >> 2] >= 1) {
    $5 = Math_fround(HEAPF32[(($7 << 2) + $2 | 0) - 4 >> 2] * $16);
    if (($7 | 0) >= 2) {
     $4 = $7 - 2 | 0;
     while (1) {
      $5 = Math_fround(Math_fround($5 + HEAPF32[($4 << 2) + $2 >> 2]) * $16);
      $6 = ($4 | 0) > 0;
      $4 = $4 - 1 | 0;
      if ($6) {
       continue;
      }
      break;
     }
    }
    HEAPF32[$3 >> 2] = $9 * Math_fround(Math_fround(1) / Math_fround(Math_fround(1) - $5));
   }
   $24 = $8 << 2;
   silk_bwexpander_FLP($2, $7, $23);
   $6 = HEAP32[$0 + 4636 >> 2];
   label$15 : {
    if (HEAP32[$0 + 4672 >> 2] >= 1) {
     $18 = $6 - 1 | 0;
     $20 = ($6 | 0) < 2;
     if (!$20) {
      $5 = HEAPF32[($18 << 2) + $2 >> 2];
      $4 = $18;
      while (1) {
       $7 = $4 - 1 | 0;
       $8 = ($7 << 2) + $2 | 0;
       $5 = Math_fround(HEAPF32[$8 >> 2] - Math_fround($10 * $5));
       HEAPF32[$8 >> 2] = $5;
       $8 = ($4 | 0) > 1;
       $4 = $7;
       if ($8) {
        continue;
       }
       break;
      }
     }
     $7 = ($6 | 0) < 1;
     if ($7) {
      break label$15;
     }
     $5 = HEAPF32[$2 >> 2];
     $12 = Math_fround($22 / Math_fround(Math_fround($10 * $5) + Math_fround(1)));
     HEAPF32[$2 >> 2] = $12 * $5;
     $13 = 1;
     if (($6 | 0) != 1) {
      while (1) {
       $4 = ($13 << 2) + $2 | 0;
       HEAPF32[$4 >> 2] = $12 * HEAPF32[$4 >> 2];
       $13 = $13 + 1 | 0;
       if (($13 | 0) != ($6 | 0)) {
        continue;
       }
       break;
      }
      if ($7) {
       break label$15;
      }
      $13 = ($6 | 0) == 1;
     }
     $25 = ($18 << 2) + $2 | 0;
     $19 = 0;
     $7 = 0;
     while (1) {
      $5 = Math_fround(-1);
      $4 = 0;
      while (1) {
       $9 = Math_fround(Math_abs(HEAPF32[($4 << 2) + $2 >> 2]));
       $8 = $9 > $5;
       $5 = $8 ? $9 : $5;
       $7 = $8 ? $4 : $7;
       $4 = $4 + 1 | 0;
       if (($6 | 0) != ($4 | 0)) {
        continue;
       }
       break;
      }
      if ($5 <= Math_fround(3.999000072479248)) {
       break label$15;
      }
      if (!$20) {
       $9 = HEAPF32[$2 >> 2];
       $4 = 1;
       while (1) {
        $8 = ($4 << 2) + $2 | 0;
        $14 = HEAPF32[$8 >> 2];
        HEAPF32[$8 - 4 >> 2] = $9 + Math_fround($10 * $14);
        $9 = $14;
        $4 = $4 + 1 | 0;
        if (($6 | 0) != ($4 | 0)) {
         continue;
        }
        break;
       }
      }
      $9 = Math_fround(Math_fround(1) / $12);
      $4 = 0;
      while (1) {
       $8 = ($4 << 2) + $2 | 0;
       HEAPF32[$8 >> 2] = $9 * HEAPF32[$8 >> 2];
       $4 = $4 + 1 | 0;
       if (($6 | 0) != ($4 | 0)) {
        continue;
       }
       break;
      }
      silk_bwexpander_FLP($2, $6, Math_fround(Math_fround(.9900000095367432) - Math_fround(Math_fround(Math_fround(Math_fround(Math_fround($19 | 0) * Math_fround(.10000000149011612)) + Math_fround(.800000011920929)) * Math_fround($5 + Math_fround(-3.999000072479248))) / Math_fround($5 * Math_fround($7 + 1 | 0)))));
      if (!$20) {
       $5 = HEAPF32[$25 >> 2];
       $4 = $18;
       while (1) {
        $8 = $4 - 1 | 0;
        $3 = ($8 << 2) + $2 | 0;
        $5 = Math_fround(HEAPF32[$3 >> 2] - Math_fround($10 * $5));
        HEAPF32[$3 >> 2] = $5;
        $3 = ($4 | 0) > 1;
        $4 = $8;
        if ($3) {
         continue;
        }
        break;
       }
      }
      $5 = HEAPF32[$2 >> 2];
      $12 = Math_fround($22 / Math_fround(Math_fround($10 * $5) + Math_fround(1)));
      HEAPF32[$2 >> 2] = $12 * $5;
      $4 = 1;
      if (!$13) {
       while (1) {
        $8 = ($4 << 2) + $2 | 0;
        HEAPF32[$8 >> 2] = $12 * HEAPF32[$8 >> 2];
        $4 = $4 + 1 | 0;
        if (($6 | 0) != ($4 | 0)) {
         continue;
        }
        break;
       }
      }
      $19 = $19 + 1 | 0;
      if (($19 | 0) != 10) {
       continue;
      }
      break;
     }
     break label$15;
    }
    $3 = 0;
    $7 = 0;
    if (($6 | 0) < 1) {
     break label$15;
    }
    while (1) {
     $5 = Math_fround(-1);
     $4 = 0;
     while (1) {
      $9 = Math_fround(Math_abs(HEAPF32[($4 << 2) + $2 >> 2]));
      $8 = $9 > $5;
      $5 = $8 ? $9 : $5;
      $7 = $8 ? $4 : $7;
      $4 = $4 + 1 | 0;
      if (($6 | 0) != ($4 | 0)) {
       continue;
      }
      break;
     }
     if ($5 <= Math_fround(3.999000072479248)) {
      break label$15;
     }
     silk_bwexpander_FLP($2, $6, Math_fround(Math_fround(.9900000095367432) - Math_fround(Math_fround(Math_fround(Math_fround(Math_fround($3 | 0) * Math_fround(.10000000149011612)) + Math_fround(.800000011920929)) * Math_fround($5 + Math_fround(-3.999000072479248))) / Math_fround($5 * Math_fround($7 + 1 | 0)))));
     $3 = $3 + 1 | 0;
     if (($3 | 0) != 10) {
      continue;
     }
     break;
    }
   }
   $15 = $15 + $24 | 0;
   $2 = HEAP32[$0 + 4580 >> 2];
   $17 = $17 + 1 | 0;
   if (($2 | 0) > ($17 | 0)) {
    continue;
   }
   break;
  }
  $4 = 0;
  $26 = exp2(+Math_fround($21 * Math_fround(-.1599999964237213)));
  if (($2 | 0) < 1) {
   break label$7;
  }
  $7 = ($2 | 0) > 0;
  $5 = Math_fround($26);
  while (1) {
   $6 = ($4 << 2) + $1 | 0;
   HEAPF32[$6 >> 2] = Math_fround(HEAPF32[$6 >> 2] * $5) + Math_fround(1.2483305931091309);
   $4 = $4 + 1 | 0;
   if (($4 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
  $4 = $7;
 }
 $14 = Math_fround(HEAP32[$0 + 4532 >> 2]);
 $9 = Math_fround(Math_fround($14 * Math_fround(.00390625)) * Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(HEAP32[$0 + 4696 >> 2]) * Math_fround(30517578125e-15)) + Math_fround(-1)) * Math_fround(.5)) + Math_fround(1)) * Math_fround(4)));
 $13 = HEAPU8[$0 + 4765 | 0];
 label$33 : {
  label$34 : {
   label$35 : {
    if (($13 | 0) == 2) {
     if ($4) {
      $10 = Math_fround(Math_fround(.20000000298023224) / Math_fround(HEAP32[$0 + 4576 >> 2]));
      $6 = 0;
      while (1) {
       $7 = ($6 << 2) + $1 | 0;
       $5 = Math_fround($10 + Math_fround(Math_fround(3) / Math_fround(HEAP32[$7 + 228 >> 2])));
       HEAPF32[$7 + 628 >> 2] = $5 + Math_fround(-1);
       HEAPF32[$7 + 644 >> 2] = Math_fround(Math_fround(1) - $5) - Math_fround($9 * $5);
       $6 = $6 + 1 | 0;
       if (($6 | 0) != ($2 | 0)) {
        continue;
       }
       break;
      }
     }
     $9 = Math_fround(Math_fround(Math_fround($14 * Math_fround(-.26249998807907104)) * Math_fround(.00390625)) + Math_fround(-.25));
     break label$35;
    }
    $5 = Math_fround(Math_fround(1.2999999523162842) / Math_fround(HEAP32[$0 + 4576 >> 2]));
    $10 = Math_fround($5 + Math_fround(-1));
    HEAPF32[$1 + 628 >> 2] = $10;
    HEAPF32[$1 + 644 >> 2] = Math_fround(Math_fround(1) - $5) + Math_fround(Math_fround($9 * $5) * Math_fround(-.6000000238418579));
    if (($2 | 0) <= 1) {
     if (!$4) {
      break label$33;
     }
     $9 = Math_fround(-.25);
     $10 = Math_fround(0);
     break label$34;
    }
    HEAPF32[$1 + 632 >> 2] = $10;
    HEAP32[$1 + 648 >> 2] = HEAP32[$1 + 644 >> 2];
    $6 = 2;
    $9 = Math_fround(-.25);
    if (($2 | 0) == 2) {
     break label$35;
    }
    $8 = $1 + 628 | 0;
    $3 = $1 + 644 | 0;
    while (1) {
     $7 = $6 << 2;
     HEAP32[$8 + $7 >> 2] = HEAP32[$1 + 628 >> 2];
     HEAP32[$3 + $7 >> 2] = HEAP32[$1 + 644 >> 2];
     $6 = $6 + 1 | 0;
     if (($6 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   if (($13 | 0) == 2) {
    if (!$4) {
     break label$33;
    }
    $10 = Math_fround(Math_fround(Math_sqrt(HEAPF32[$0 + 10060 >> 2])) * Math_fround(Math_fround(Math_fround(Math_fround(1) - Math_fround(Math_fround(Math_fround(1) - HEAPF32[$1 + 700 >> 2]) * HEAPF32[$1 + 696 >> 2])) * Math_fround(.20000000298023224)) + Math_fround(.30000001192092896)));
    break label$34;
   }
   $10 = Math_fround(0);
   if (!$4) {
    break label$33;
   }
  }
  $4 = 0;
  while (1) {
   $5 = HEAPF32[$0 + 7172 >> 2];
   $5 = Math_fround($5 + Math_fround(Math_fround($10 - $5) * Math_fround(.4000000059604645)));
   HEAPF32[$0 + 7172 >> 2] = $5;
   $6 = ($4 << 2) + $1 | 0;
   HEAPF32[$6 + 676 >> 2] = $5;
   $5 = HEAPF32[$0 + 7176 >> 2];
   $5 = Math_fround($5 + Math_fround(Math_fround($9 - $5) * Math_fround(.4000000059604645)));
   HEAPF32[$0 + 7176 >> 2] = $5;
   HEAPF32[$6 + 660 >> 2] = $5;
   $4 = $4 + 1 | 0;
   if (($4 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $11 + 1184 | 0;
}
function silk_VAD_GetSA_Q8_c($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $4 = __stack_pointer - 48 | 0;
 $10 = $4;
 __stack_pointer = $4;
 $2 = HEAP32[$0 + 4584 >> 2];
 if (($2 | 0) < 321) {
  if (($2 & -8) == ($2 | 0)) {
   HEAP32[$10 >> 2] = 0;
   $3 = $2 >> 3;
   $6 = $2 >> 2;
   $7 = $3 + $6 | 0;
   HEAP32[$10 + 4 >> 2] = $7;
   $8 = $3 + $7 | 0;
   HEAP32[$10 + 8 >> 2] = $8;
   $9 = $6 + $8 | 0;
   HEAP32[$10 + 12 >> 2] = $9;
   $13 = $2 >> 1;
   $5 = $4 - (($13 + $9 << 1) + 15 & -16) | 0;
   __stack_pointer = $5;
   silk_ana_filt_bank_1($1, $0 + 36 | 0, $5, ($9 << 1) + $5 | 0, HEAP32[$0 + 4584 >> 2]);
   silk_ana_filt_bank_1($5, $0 + 44 | 0, $5, ($8 << 1) + $5 | 0, $13);
   silk_ana_filt_bank_1($5, $0 + 52 | 0, $5, ($7 << 1) + $5 | 0, $6);
   $4 = $3 - 1 | 0;
   $3 = ($4 << 1) + $5 | 0;
   $8 = HEAP16[$3 >> 1] >> 1;
   HEAP16[$3 >> 1] = $8;
   if (($2 | 0) >= 16) {
    $3 = $8;
    while (1) {
     $6 = $4 - 1 | 0;
     $2 = ($6 << 1) + $5 | 0;
     $1 = $2;
     $2 = HEAP16[$2 >> 1] >> 1;
     HEAP16[$1 >> 1] = $2;
     HEAP16[($4 << 1) + $5 >> 1] = $3 - $2;
     $7 = ($4 | 0) > 1;
     $3 = $2;
     $4 = $6;
     if ($7) {
      continue;
     }
     break;
    }
   }
   $4 = $0 + 92 | 0;
   HEAP16[$5 >> 1] = HEAPU16[$5 >> 1] - HEAPU16[$4 >> 1];
   HEAP16[$0 + 92 >> 1] = $8;
   while (1) {
    $2 = HEAP32[$0 + 4584 >> 2];
    $4 = $11 << 2;
    $13 = $4 + ($10 + 32 | 0) | 0;
    $16 = $0 + $4 | 0;
    $9 = $16 + 60 | 0;
    $9 = HEAP32[$9 >> 2];
    HEAP32[$13 >> 2] = $9;
    $3 = 4 - $11 | 0;
    $12 = $2 >> ($3 >>> 0 < 3 ? $3 : 3);
    $15 = ($12 | 0) > 3;
    label$6 : {
     if (!$15) {
      $1 = ($9 | 0) > -1 ? $9 : 2147483647;
      $4 = 0;
      break label$6;
     }
     $8 = $12 >> 2;
     $6 = ($8 | 0) > 1 ? $8 : 1;
     $14 = $4 + $10 | 0;
     $7 = HEAP32[$14 >> 2];
     $4 = 0;
     $2 = 0;
     while (1) {
      $3 = HEAP16[($4 + $7 << 1) + $5 >> 1] >> 3;
      $2 = Math_imul($3, $3) + $2 | 0;
      $4 = $4 + 1 | 0;
      if (($6 | 0) != ($4 | 0)) {
       continue;
      }
      break;
     }
     $4 = $2 + $9 | 0;
     $1 = ($4 | 0) > -1 ? $4 : 2147483647;
     $4 = 0;
     if (!$15) {
      break label$6;
     }
     $7 = HEAP32[$14 >> 2];
     $2 = 0;
     while (1) {
      $3 = HEAP16[(($4 + $8 | 0) + $7 << 1) + $5 >> 1] >> 3;
      $2 = Math_imul($3, $3) + $2 | 0;
      $4 = $4 + 1 | 0;
      if (($6 | 0) != ($4 | 0)) {
       continue;
      }
      break;
     }
     $4 = $1 + $2 | 0;
     $1 = ($4 | 0) > -1 ? $4 : 2147483647;
     $4 = 0;
     $12 = ($12 | 0) < 4;
     if ($12) {
      break label$6;
     }
     $7 = $8 << 1;
     $9 = HEAP32[$14 >> 2];
     $2 = 0;
     while (1) {
      $3 = HEAP16[(($4 + $7 | 0) + $9 << 1) + $5 >> 1] >> 3;
      $2 = Math_imul($3, $3) + $2 | 0;
      $4 = $4 + 1 | 0;
      if (($6 | 0) != ($4 | 0)) {
       continue;
      }
      break;
     }
     $4 = $1 + $2 | 0;
     $1 = ($4 | 0) > -1 ? $4 : 2147483647;
     $4 = 0;
     if ($12) {
      break label$6;
     }
     $7 = Math_imul($8, 3);
     $8 = HEAP32[$14 >> 2];
     $2 = 0;
     while (1) {
      $3 = HEAP16[(($2 + $7 | 0) + $8 << 1) + $5 >> 1] >> 3;
      $4 = Math_imul($3, $3) + $4 | 0;
      $2 = $2 + 1 | 0;
      if (($6 | 0) != ($2 | 0)) {
       continue;
      }
      break;
     }
    }
    $2 = ($4 >>> 1 | 0) + $1 | 0;
    HEAP32[$13 >> 2] = ($2 | 0) > -1 ? $2 : 2147483647;
    HEAP32[$16 + 60 >> 2] = $4;
    $11 = $11 + 1 | 0;
    if (($11 | 0) != 4) {
     continue;
    }
    break;
   }
   $4 = 0;
   $2 = HEAP32[$0 + 144 >> 2];
   if (($2 | 0) <= 999) {
    HEAP32[$0 + 144 >> 2] = $2 + 1;
    $4 = 32767 / (($2 >> 4) + 1 | 0) | 0;
   }
   $2 = 128;
   $12 = HEAP32[$10 + 32 >> 2];
   $3 = $12 + HEAP32[$0 + 128 >> 2] | 0;
   $6 = ($3 | 0) > -1 ? $3 : 2147483647;
   $5 = 2147483647 / ($6 | 0) | 0;
   $3 = 128;
   $7 = HEAP32[$0 + 96 >> 2];
   label$13 : {
    if ($7 << 3 < ($6 | 0)) {
     break label$13;
    }
    $3 = 1024;
    if (($6 | 0) < ($7 | 0)) {
     break label$13;
    }
    $3 = $7 << 16 >> 16;
    $3 = (Math_imul($3, $5 >> 16) + Math_imul(($7 >> 15) + 1 >> 1, $5) | 0) + (Math_imul($5 & 65535, $3) >> 16) | 0;
    $3 = $3 >> 16 << 11 | $3 >>> 5 & 2047;
   }
   $6 = $0 + 112 | 0;
   $1 = $6;
   $6 = HEAP32[$0 + 112 >> 2];
   $5 = $5 - $6 | 0;
   $3 = (($3 | 0) > ($4 | 0) ? $3 : $4) << 16 >> 16;
   $3 = (Math_imul($3, $5 >> 16) + $6 | 0) + (Math_imul($5 & 65535, $3) >> 16) | 0;
   HEAP32[$1 >> 2] = $3;
   $3 = 2147483647 / ($3 | 0) | 0;
   $5 = ($3 | 0) < 16777215 ? $3 : 16777215;
   HEAP32[$0 + 96 >> 2] = $5;
   $15 = HEAP32[$10 + 36 >> 2];
   $3 = $15 + HEAP32[$0 + 132 >> 2] | 0;
   $6 = ($3 | 0) > -1 ? $3 : 2147483647;
   $3 = 2147483647 / ($6 | 0) | 0;
   $7 = HEAP32[$0 + 100 >> 2];
   label$14 : {
    if ($7 << 3 < ($6 | 0)) {
     break label$14;
    }
    $2 = 1024;
    if (($6 | 0) < ($7 | 0)) {
     break label$14;
    }
    $2 = $7 << 16 >> 16;
    $2 = (Math_imul($2, $3 >> 16) + Math_imul(($7 >> 15) + 1 >> 1, $3) | 0) + (Math_imul($3 & 65535, $2) >> 16) | 0;
    $2 = $2 >> 16 << 11 | $2 >>> 5 & 2047;
   }
   $6 = $0 + 116 | 0;
   $1 = $6;
   $6 = HEAP32[$0 + 116 >> 2];
   $3 = $3 - $6 | 0;
   $2 = (($2 | 0) > ($4 | 0) ? $2 : $4) << 16 >> 16;
   $2 = (Math_imul($2, $3 >> 16) + $6 | 0) + (Math_imul($3 & 65535, $2) >> 16) | 0;
   HEAP32[$1 >> 2] = $2;
   $2 = 2147483647 / ($2 | 0) | 0;
   HEAP32[$0 + 100 >> 2] = ($2 | 0) < 16777215 ? $2 : 16777215;
   $14 = HEAP32[$10 + 40 >> 2];
   $2 = $14 + HEAP32[$0 + 136 >> 2] | 0;
   $7 = ($2 | 0) > -1 ? $2 : 2147483647;
   $6 = 2147483647 / ($7 | 0) | 0;
   $2 = 128;
   $3 = 128;
   $8 = HEAP32[$0 + 104 >> 2];
   label$15 : {
    if ($8 << 3 < ($7 | 0)) {
     break label$15;
    }
    $3 = 1024;
    if (($7 | 0) < ($8 | 0)) {
     break label$15;
    }
    $3 = $8 << 16 >> 16;
    $3 = (Math_imul($3, $6 >> 16) + Math_imul(($8 >> 15) + 1 >> 1, $6) | 0) + (Math_imul($6 & 65535, $3) >> 16) | 0;
    $3 = $3 >> 16 << 11 | $3 >>> 5 & 2047;
   }
   $7 = $0 + 120 | 0;
   $1 = $7;
   $7 = HEAP32[$0 + 120 >> 2];
   $6 = $6 - $7 | 0;
   $3 = (($3 | 0) > ($4 | 0) ? $3 : $4) << 16 >> 16;
   $3 = (Math_imul($3, $6 >> 16) + $7 | 0) + (Math_imul($6 & 65535, $3) >> 16) | 0;
   HEAP32[$1 >> 2] = $3;
   $3 = 2147483647 / ($3 | 0) | 0;
   HEAP32[$0 + 104 >> 2] = ($3 | 0) < 16777215 ? $3 : 16777215;
   $17 = HEAP32[$10 + 44 >> 2];
   $3 = $17 + HEAP32[$0 + 140 >> 2] | 0;
   $6 = ($3 | 0) > -1 ? $3 : 2147483647;
   $3 = 2147483647 / ($6 | 0) | 0;
   $7 = HEAP32[$0 + 108 >> 2];
   label$16 : {
    if ($7 << 3 < ($6 | 0)) {
     break label$16;
    }
    $2 = 1024;
    if (($6 | 0) < ($7 | 0)) {
     break label$16;
    }
    $2 = $7 << 16 >> 16;
    $2 = (Math_imul($2, $3 >> 16) + Math_imul(($7 >> 15) + 1 >> 1, $3) | 0) + (Math_imul($3 & 65535, $2) >> 16) | 0;
    $2 = $2 >> 16 << 11 | $2 >>> 5 & 2047;
   }
   $4 = (($2 | 0) > ($4 | 0) ? $2 : $4) << 16 >> 16;
   $2 = HEAP32[$0 + 124 >> 2];
   $3 = $3 - $2 | 0;
   $6 = $0 + 124 | 0;
   $4 = (Math_imul($3 >> 16, $4) + $2 | 0) + (Math_imul($3 & 65535, $4) >> 16) | 0;
   HEAP32[$6 >> 2] = $4;
   $4 = 2147483647 / ($4 | 0) | 0;
   HEAP32[$0 + 108 >> 2] = ($4 | 0) < 16777215 ? $4 : 16777215;
   $3 = $12;
   $7 = 0;
   $6 = 0;
   $4 = 0;
   while (1) {
    $2 = $3 - $5 | 0;
    label$18 : {
     if (($2 | 0) >= 1) {
      $8 = $4 << 2;
      $9 = $3 >>> 0 < 8388608;
      $3 = (($9 ? $3 << 8 : $3) | 0) / (($9 ? $5 : $5 >> 8) + 1 | 0) | 0;
      HEAP32[$8 + ($10 + 16 | 0) >> 2] = $3;
      $3 = (silk_lin2log($3) << 16) - 67108864 >> 16;
      $9 = Math_imul($3, $3);
      $6 = $9 + $6 | 0;
      if (($2 | 0) <= 1048575) {
       $5 = Math_clz32($2);
       $1 = 24 - $5 | 0;
       $9 = 0 - $1 | 0;
       $11 = $2;
       label$21 : {
        if (!$1) {
         break label$21;
        }
        $11 = $2 << $9 | $2 >>> 56 - $5;
        if ($2 >>> 0 <= 127) {
         break label$21;
        }
        $11 = $2 << $5 + 8 | $2 >>> $1;
       }
       $16 = Math_imul($11 & 127, 13959168) >>> 16 | 0;
       $11 = ($5 & 1 ? 32768 : 46214) >>> ($5 >>> 1) | 0;
       $13 = Math_imul($11 + (Math_imul($11, $16) >>> 16 | 0) >>> 10 | 0, $3);
       label$22 : {
        if (!$1) {
         break label$22;
        }
        if ($2 >>> 0 <= 127) {
         $2 = $2 << $9 | $2 >>> 56 - $5;
         break label$22;
        }
        $2 = $2 << $5 + 8 | $2 >>> $1;
       }
       $3 = Math_imul((Math_imul(Math_imul($2 & 127, 13959168) >>> 16 | 0, $11) >>> 16 | 0) + $11 << 6 & 65472, $3) + ($13 << 16) >> 16;
      }
      $2 = HEAP32[$8 + 1936 >> 2];
      $7 = (Math_imul($2 >> 16, $3) + $7 | 0) + (Math_imul($2 & 65535, $3) >> 16) | 0;
      break label$18;
     }
     HEAP32[($10 + 16 | 0) + ($4 << 2) >> 2] = 256;
    }
    $4 = $4 + 1 | 0;
    if (($4 | 0) != 4) {
     $2 = $4 << 2;
     $3 = HEAP32[$2 + ($10 + 32 | 0) >> 2];
     $5 = HEAP32[($0 + $2 | 0) + 96 >> 2];
     continue;
    }
    break;
   }
   $4 = ($6 | 0) / 4 | 0;
   $2 = -128;
   if (($6 | 0) >= 4) {
    $2 = Math_clz32($4);
    $3 = 24 - $2 | 0;
    label$27 : {
     if (!$3) {
      break label$27;
     }
     if ($4 >>> 0 <= 127) {
      $4 = $4 << 0 - $3 | $4 >>> 56 - $2;
      break label$27;
     }
     $4 = $4 << $2 + 8 | $4 >>> $3;
    }
    $1 = Math_imul($4 & 127, 13959168) >>> 16 | 0;
    $4 = ($2 & 1 ? 32768 : 46214) >>> ($2 >>> 1) | 0;
    $2 = (Math_imul(Math_imul($4 + (Math_imul($4, $1) >>> 16 | 0) | 0, 196608) >> 16, 45e3) >> 16) - 128 | 0;
   }
   $4 = silk_sigm_Q15($2);
   HEAP32[$0 + 4712 >> 2] = (silk_sigm_Q15($7) << 1) - 32768;
   $2 = HEAP32[$0 + 4584 >> 2];
   $3 = HEAP32[$0 + 4576 >> 2];
   $5 = ((($15 - HEAP32[$0 + 100 >> 2] >> 4 << 1) + ($12 - HEAP32[$0 + 96 >> 2] >> 4) | 0) + Math_imul($14 - HEAP32[$0 + 104 >> 2] >> 4, 3) | 0) + ($17 - HEAP32[$0 + 108 >> 2] >> 4 << 2) >> (($2 | 0) == (Math_imul($3, 20) | 0));
   label$29 : {
    if (($5 | 0) <= 0) {
     $4 = $4 >> 1;
     break label$29;
    }
    if (($5 | 0) > 16383) {
     break label$29;
    }
    $4 = $4 << 16 >> 16;
    $6 = $5 << 16;
    $5 = Math_clz32($6);
    $7 = ($5 & 1 ? 32768 : 46214) >>> ($5 >>> 1) | 0;
    $5 = ($7 + (Math_imul((wasm2js_i32$0 = 0, wasm2js_i32$1 = Math_imul(__wasm_rotl_i32($6, $5 + 8 | 0) & 127, 13959168) >>> 16 | 0, wasm2js_i32$2 = ($5 | 0) == 24, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1), $7) >>> 16 | 0) | 0) + 32768 | 0;
    $4 = (Math_imul($4, $5 & 65535) >> 16) + Math_imul($5 >>> 16 | 0, $4) | 0;
   }
   $5 = $4 >> 7;
   HEAP32[$0 + 4532 >> 2] = ($5 | 0) < 255 ? $5 : 255;
   $5 = $0 + 76 | 0;
   $1 = $5;
   $5 = HEAP32[$0 + 76 >> 2];
   $6 = HEAP32[$10 + 16 >> 2] - $5 | 0;
   $4 = Math_imul($4 << 16 >> 16, $4) >> ((Math_imul($3, 10) | 0) == ($2 | 0) ? 21 : 20);
   $2 = (Math_imul($4, $6 >> 16) + $5 | 0) + (Math_imul($6 & 65535, $4) >> 16) | 0;
   HEAP32[$1 >> 2] = $2;
   HEAP32[$0 + 4696 >> 2] = silk_sigm_Q15(Math_imul(silk_lin2log($2), 3) - 5120 >> 4);
   $2 = $0 + 80 | 0;
   $1 = $2;
   $2 = HEAP32[$0 + 80 >> 2];
   $3 = HEAP32[$10 + 20 >> 2] - $2 | 0;
   $2 = (Math_imul($3 >> 16, $4) + $2 | 0) + (Math_imul($3 & 65535, $4) >> 16) | 0;
   HEAP32[$1 >> 2] = $2;
   HEAP32[$0 + 4700 >> 2] = silk_sigm_Q15(Math_imul(silk_lin2log($2), 3) - 5120 >> 4);
   $2 = $0 + 84 | 0;
   $1 = $2;
   $2 = HEAP32[$0 + 84 >> 2];
   $3 = HEAP32[$10 + 24 >> 2] - $2 | 0;
   $2 = (Math_imul($3 >> 16, $4) + $2 | 0) + (Math_imul($3 & 65535, $4) >> 16) | 0;
   HEAP32[$1 >> 2] = $2;
   HEAP32[$0 + 4704 >> 2] = silk_sigm_Q15(Math_imul(silk_lin2log($2), 3) - 5120 >> 4);
   $2 = $0 + 88 | 0;
   $1 = $2;
   $2 = HEAP32[$0 + 88 >> 2];
   $3 = HEAP32[$10 + 28 >> 2] - $2 | 0;
   $4 = (Math_imul($3 >> 16, $4) + $2 | 0) + (Math_imul($3 & 65535, $4) >> 16) | 0;
   HEAP32[$1 >> 2] = $4;
   HEAP32[$0 + 4708 >> 2] = silk_sigm_Q15(Math_imul(silk_lin2log($4), 3) - 5120 >> 4);
   __stack_pointer = $10 + 48 | 0;
   return 0;
  }
  celt_fatal(1846, 1835, 106);
  abort();
 }
 celt_fatal(1776, 1835, 104);
 abort();
}
function opus_custom_encoder_ctl($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $2;
 $2 = -5;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     label$5 : {
      label$6 : {
       label$7 : {
        label$8 : {
         label$9 : {
          label$10 : {
           label$11 : {
            label$12 : {
             label$13 : {
              label$14 : {
               label$15 : {
                label$16 : {
                 label$17 : {
                  label$18 : {
                   label$19 : {
                    label$20 : {
                     label$21 : {
                      label$22 : {
                       label$23 : {
                        switch ($1 - 4002 | 0) {
                        default:
                         switch ($1 - 10002 | 0) {
                         case 6:
                          break label$15;
                         case 0:
                          break label$20;
                         case 10:
                          break label$21;
                         case 8:
                          break label$22;
                         case 24:
                          break label$3;
                         case 22:
                          break label$4;
                         case 13:
                          break label$6;
                         case 26:
                          break label$7;
                         case 20:
                          break label$8;
                         case 14:
                          break label$9;
                         default:
                          break label$1;
                         }
                        case 1:
                        case 2:
                        case 3:
                        case 5:
                        case 6:
                        case 7:
                        case 9:
                        case 10:
                        case 11:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 19:
                        case 20:
                        case 21:
                        case 22:
                        case 23:
                        case 24:
                        case 25:
                        case 27:
                        case 28:
                        case 30:
                        case 31:
                        case 32:
                        case 33:
                        case 36:
                        case 37:
                        case 38:
                        case 39:
                        case 40:
                        case 41:
                        case 42:
                        case 43:
                         break label$1;
                        case 26:
                         break label$10;
                        case 45:
                         break label$11;
                        case 44:
                         break label$12;
                        case 35:
                         break label$13;
                        case 34:
                         break label$14;
                        case 0:
                         break label$16;
                        case 4:
                         break label$17;
                        case 18:
                         break label$18;
                        case 12:
                         break label$19;
                        case 8:
                         break label$23;
                        case 29:
                         break label$5;
                        }
                       }
                       $1 = HEAP32[$3 + 12 >> 2];
                       HEAP32[$3 + 12 >> 2] = $1 + 4;
                       $2 = -1;
                       $1 = HEAP32[$1 >> 2];
                       if ($1 >>> 0 > 10) {
                        break label$1;
                       }
                       HEAP32[$0 + 24 >> 2] = $1;
                       break label$2;
                      }
                      $1 = HEAP32[$3 + 12 >> 2];
                      HEAP32[$3 + 12 >> 2] = $1 + 4;
                      $2 = -1;
                      $1 = HEAP32[$1 >> 2];
                      if (($1 | 0) < 0 | HEAP32[HEAP32[$0 >> 2] + 8 >> 2] <= ($1 | 0)) {
                       break label$1;
                      }
                      HEAP32[$0 + 32 >> 2] = $1;
                      break label$2;
                     }
                     $1 = HEAP32[$3 + 12 >> 2];
                     HEAP32[$3 + 12 >> 2] = $1 + 4;
                     $2 = -1;
                     $1 = HEAP32[$1 >> 2];
                     if (($1 | 0) < 1 | HEAP32[HEAP32[$0 >> 2] + 8 >> 2] < ($1 | 0)) {
                      break label$1;
                     }
                     HEAP32[$0 + 36 >> 2] = $1;
                     break label$2;
                    }
                    $1 = HEAP32[$3 + 12 >> 2];
                    HEAP32[$3 + 12 >> 2] = $1 + 4;
                    $2 = -1;
                    $1 = HEAP32[$1 >> 2];
                    if ($1 >>> 0 > 2) {
                     break label$1;
                    }
                    HEAP32[$0 + 12 >> 2] = !$1;
                    HEAP32[$0 + 20 >> 2] = ($1 | 0) != 2;
                    break label$2;
                   }
                   $1 = HEAP32[$3 + 12 >> 2];
                   HEAP32[$3 + 12 >> 2] = $1 + 4;
                   $2 = -1;
                   $1 = HEAP32[$1 >> 2];
                   if ($1 >>> 0 > 100) {
                    break label$1;
                   }
                   HEAP32[$0 + 56 >> 2] = $1;
                   break label$2;
                  }
                  $2 = HEAP32[$3 + 12 >> 2];
                  HEAP32[$3 + 12 >> 2] = $2 + 4;
                  HEAP32[$0 + 52 >> 2] = HEAP32[$2 >> 2];
                  break label$2;
                 }
                 $2 = HEAP32[$3 + 12 >> 2];
                 HEAP32[$3 + 12 >> 2] = $2 + 4;
                 HEAP32[$0 + 44 >> 2] = HEAP32[$2 >> 2];
                 break label$2;
                }
                $2 = HEAP32[$3 + 12 >> 2];
                HEAP32[$3 + 12 >> 2] = $2 + 4;
                $1 = HEAP32[$2 >> 2];
                if (($1 | 0) <= 500) {
                 $2 = -1;
                 if (($1 | 0) != -1) {
                  break label$1;
                 }
                }
                $2 = Math_imul(HEAP32[$0 + 4 >> 2], 26e4);
                HEAP32[$0 + 40 >> 2] = ($1 | 0) < ($2 | 0) ? $1 : $2;
                break label$2;
               }
               $1 = HEAP32[$3 + 12 >> 2];
               HEAP32[$3 + 12 >> 2] = $1 + 4;
               $2 = -1;
               $1 = HEAP32[$1 >> 2];
               if ($1 - 1 >>> 0 > 1) {
                break label$1;
               }
               HEAP32[$0 + 8 >> 2] = $1;
               break label$2;
              }
              $1 = HEAP32[$3 + 12 >> 2];
              HEAP32[$3 + 12 >> 2] = $1 + 4;
              $2 = -1;
              $1 = HEAP32[$1 >> 2];
              if ($1 - 8 >>> 0 > 16) {
               break label$1;
              }
              HEAP32[$0 + 60 >> 2] = $1;
              break label$2;
             }
             $2 = HEAP32[$3 + 12 >> 2];
             HEAP32[$3 + 12 >> 2] = $2 + 4;
             HEAP32[HEAP32[$2 >> 2] >> 2] = HEAP32[$0 + 60 >> 2];
             break label$2;
            }
            $1 = HEAP32[$3 + 12 >> 2];
            HEAP32[$3 + 12 >> 2] = $1 + 4;
            $2 = -1;
            $1 = HEAP32[$1 >> 2];
            if ($1 >>> 0 > 1) {
             break label$1;
            }
            HEAP32[$0 + 68 >> 2] = $1;
            break label$2;
           }
           $2 = HEAP32[$3 + 12 >> 2];
           HEAP32[$3 + 12 >> 2] = $2 + 4;
           $2 = HEAP32[$2 >> 2];
           if (!$2) {
            $2 = -1;
            break label$1;
           }
           HEAP32[$2 >> 2] = HEAP32[$0 + 68 >> 2];
           break label$2;
          }
          $2 = 0;
          $1 = HEAP32[$0 + 4 >> 2];
          $5 = HEAP32[$0 >> 2];
          $4 = HEAP32[$5 + 4 >> 2];
          $6 = HEAP32[$5 + 8 >> 2];
          memset($0 + 76 | 0, 0, Math_imul($1, (($4 << 2) + ($6 << 4) | 0) + 4096 | 0) + 168 | 0);
          $5 = Math_imul(HEAP32[$5 + 8 >> 2], $1);
          if (($5 | 0) >= 1) {
           $4 = (Math_imul($4 + 1024 | 0, $1) << 2) + $0 | 0;
           $1 = Math_imul($1, $6) << 2;
           $4 = ($4 + $1 | 0) + 244 | 0;
           $6 = $1 + $4 | 0;
           while (1) {
            $1 = $2 << 2;
            HEAP32[$6 + $1 >> 2] = -1042284544;
            HEAP32[$1 + $4 >> 2] = -1042284544;
            $2 = $2 + 1 | 0;
            if (($5 | 0) != ($2 | 0)) {
             continue;
            }
            break;
           }
          }
          $2 = 0;
          HEAP32[$0 + 216 >> 2] = 0;
          HEAP32[$0 + 96 >> 2] = 0;
          HEAP32[$0 + 100 >> 2] = 0;
          HEAP32[$0 + 88 >> 2] = 256;
          HEAP32[$0 + 80 >> 2] = 2;
          HEAP32[$0 + 84 >> 2] = 1065353216;
          break label$1;
         }
         $2 = HEAP32[$3 + 12 >> 2];
         HEAP32[$3 + 12 >> 2] = $2 + 4;
         HEAP32[$0 + 48 >> 2] = HEAP32[$2 >> 2];
         break label$2;
        }
        $1 = HEAP32[$3 + 12 >> 2];
        HEAP32[$3 + 12 >> 2] = $1 + 4;
        $2 = 0;
        $1 = HEAP32[$1 >> 2];
        if (!$1) {
         break label$1;
        }
        $5 = HEAP32[$1 + 4 >> 2];
        $4 = HEAP32[$1 >> 2];
        HEAP32[$0 + 120 >> 2] = $4;
        HEAP32[$0 + 124 >> 2] = $5;
        $4 = HEAP32[$1 + 60 >> 2];
        $5 = HEAP32[$1 + 56 >> 2];
        HEAP32[$0 + 176 >> 2] = $5;
        HEAP32[$0 + 180 >> 2] = $4;
        $5 = HEAP32[$1 + 52 >> 2];
        $4 = HEAP32[$1 + 48 >> 2];
        HEAP32[$0 + 168 >> 2] = $4;
        HEAP32[$0 + 172 >> 2] = $5;
        $4 = HEAP32[$1 + 44 >> 2];
        $5 = HEAP32[$1 + 40 >> 2];
        HEAP32[$0 + 160 >> 2] = $5;
        HEAP32[$0 + 164 >> 2] = $4;
        $5 = HEAP32[$1 + 36 >> 2];
        $4 = HEAP32[$1 + 32 >> 2];
        HEAP32[$0 + 152 >> 2] = $4;
        HEAP32[$0 + 156 >> 2] = $5;
        $4 = HEAP32[$1 + 28 >> 2];
        $5 = HEAP32[$1 + 24 >> 2];
        HEAP32[$0 + 144 >> 2] = $5;
        HEAP32[$0 + 148 >> 2] = $4;
        $5 = HEAP32[$1 + 20 >> 2];
        $4 = HEAP32[$1 + 16 >> 2];
        HEAP32[$0 + 136 >> 2] = $4;
        HEAP32[$0 + 140 >> 2] = $5;
        $4 = HEAP32[$1 + 12 >> 2];
        $5 = HEAP32[$1 + 8 >> 2];
        HEAP32[$0 + 128 >> 2] = $5;
        HEAP32[$0 + 132 >> 2] = $4;
        break label$1;
       }
       $1 = HEAP32[$3 + 12 >> 2];
       HEAP32[$3 + 12 >> 2] = $1 + 4;
       $2 = 0;
       $1 = HEAP32[$1 >> 2];
       if (!$1) {
        break label$1;
       }
       $5 = HEAP32[$1 + 4 >> 2];
       $4 = HEAP32[$1 >> 2];
       HEAP32[$0 + 184 >> 2] = $4;
       HEAP32[$0 + 188 >> 2] = $5;
       break label$1;
      }
      $2 = HEAP32[$3 + 12 >> 2];
      HEAP32[$3 + 12 >> 2] = $2 + 4;
      $2 = HEAP32[$2 >> 2];
      if (!$2) {
       $2 = -1;
       break label$1;
      }
      HEAP32[$2 >> 2] = HEAP32[$0 >> 2];
      break label$2;
     }
     $2 = HEAP32[$3 + 12 >> 2];
     HEAP32[$3 + 12 >> 2] = $2 + 4;
     $2 = HEAP32[$2 >> 2];
     if (!$2) {
      $2 = -1;
      break label$1;
     }
     HEAP32[$2 >> 2] = HEAP32[$0 + 76 >> 2];
     break label$2;
    }
    $2 = HEAP32[$3 + 12 >> 2];
    HEAP32[$3 + 12 >> 2] = $2 + 4;
    HEAP32[$0 + 64 >> 2] = HEAP32[$2 >> 2];
    break label$2;
   }
   $2 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $2 + 4;
   HEAP32[$0 + 236 >> 2] = HEAP32[$2 >> 2];
  }
  $2 = 0;
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}
function silk_resampler_private_down_FIR($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0;
 $10 = __stack_pointer;
 $20 = $10;
 $6 = HEAP32[$0 + 268 >> 2];
 $8 = HEAP32[$0 + 276 >> 2];
 $10 = $10 - (($6 + $8 << 2) + 15 & -16) | 0;
 __stack_pointer = $10;
 $17 = $0 + 24 | 0;
 $12 = memcpy($10, $17, $8 << 2);
 $10 = HEAP32[$0 + 296 >> 2];
 $18 = $10 + 4 | 0;
 $15 = HEAP32[$0 + 272 >> 2];
 $5 = $10;
 while (1) {
  $13 = ($3 | 0) < ($6 | 0) ? $3 : $6;
  silk_resampler_private_AR2($0, ($8 << 2) + $12 | 0, $2, $5, $13);
  $14 = $13 << 16;
  label$2 : {
   label$3 : {
    label$4 : {
     label$5 : {
      label$6 : {
       $16 = HEAP32[$0 + 276 >> 2];
       switch ($16 - 18 | 0) {
       case 18:
        break label$3;
       case 6:
        break label$5;
       case 0:
        break label$6;
       default:
        break label$4;
       }
      }
      if (($14 | 0) < 1) {
       break label$2;
      }
      $19 = HEAP32[$0 + 280 >> 2];
      $21 = $19 << 16 >> 16;
      $5 = 0;
      while (1) {
       $7 = Math_imul($5 & 65535, $21) >> 16;
       $8 = Math_imul($7, 18) + $18 | 0;
       $9 = HEAP16[$8 >> 1];
       $6 = ($5 >> 16 << 2) + $12 | 0;
       $4 = HEAP32[$6 >> 2];
       $11 = (Math_imul($9, $4 & 65535) >> 16) + Math_imul($4 >> 16, $9) | 0;
       $9 = HEAP16[$8 + 2 >> 1];
       $4 = HEAP32[$6 + 4 >> 2];
       $11 = ($11 + Math_imul($9, $4 >> 16) | 0) + (Math_imul($4 & 65535, $9) >> 16) | 0;
       $9 = HEAP16[$8 + 4 >> 1];
       $4 = HEAP32[$6 + 8 >> 2];
       $11 = ($11 + Math_imul($9, $4 >> 16) | 0) + (Math_imul($4 & 65535, $9) >> 16) | 0;
       $9 = HEAP16[$8 + 6 >> 1];
       $4 = HEAP32[$6 + 12 >> 2];
       $11 = ($11 + Math_imul($9, $4 >> 16) | 0) + (Math_imul($4 & 65535, $9) >> 16) | 0;
       $9 = HEAP16[$8 + 8 >> 1];
       $4 = HEAP32[$6 + 16 >> 2];
       $11 = ($11 + Math_imul($9, $4 >> 16) | 0) + (Math_imul($4 & 65535, $9) >> 16) | 0;
       $9 = HEAP16[$8 + 10 >> 1];
       $4 = HEAP32[$6 + 20 >> 2];
       $11 = ($11 + Math_imul($9, $4 >> 16) | 0) + (Math_imul($4 & 65535, $9) >> 16) | 0;
       $9 = HEAP16[$8 + 12 >> 1];
       $4 = HEAP32[$6 + 24 >> 2];
       $11 = ($11 + Math_imul($9, $4 >> 16) | 0) + (Math_imul($4 & 65535, $9) >> 16) | 0;
       $9 = HEAP16[$8 + 14 >> 1];
       $4 = HEAP32[$6 + 28 >> 2];
       $9 = ($11 + Math_imul($9, $4 >> 16) | 0) + (Math_imul($4 & 65535, $9) >> 16) | 0;
       $8 = HEAP16[$8 + 16 >> 1];
       $4 = HEAP32[$6 + 32 >> 2];
       $9 = ($9 + Math_imul($8, $4 >> 16) | 0) + (Math_imul($4 & 65535, $8) >> 16) | 0;
       $8 = Math_imul(($7 ^ -1) + $19 | 0, 18) + $18 | 0;
       $7 = HEAP16[$8 >> 1];
       $4 = HEAP32[$6 + 68 >> 2];
       $9 = ($9 + Math_imul($7, $4 >> 16) | 0) + (Math_imul($4 & 65535, $7) >> 16) | 0;
       $7 = HEAP16[$8 + 2 >> 1];
       $4 = HEAP32[$6 + 64 >> 2];
       $9 = ($9 + Math_imul($7, $4 >> 16) | 0) + (Math_imul($4 & 65535, $7) >> 16) | 0;
       $7 = HEAP16[$8 + 4 >> 1];
       $4 = HEAP32[$6 + 60 >> 2];
       $9 = ($9 + Math_imul($7, $4 >> 16) | 0) + (Math_imul($4 & 65535, $7) >> 16) | 0;
       $7 = HEAP16[$8 + 6 >> 1];
       $4 = HEAP32[$6 + 56 >> 2];
       $9 = ($9 + Math_imul($7, $4 >> 16) | 0) + (Math_imul($4 & 65535, $7) >> 16) | 0;
       $7 = HEAP16[$8 + 8 >> 1];
       $4 = HEAP32[$6 + 52 >> 2];
       $9 = ($9 + Math_imul($7, $4 >> 16) | 0) + (Math_imul($4 & 65535, $7) >> 16) | 0;
       $7 = HEAP16[$8 + 10 >> 1];
       $4 = HEAP32[$6 + 48 >> 2];
       $9 = ($9 + Math_imul($7, $4 >> 16) | 0) + (Math_imul($4 & 65535, $7) >> 16) | 0;
       $7 = HEAP16[$8 + 12 >> 1];
       $4 = HEAP32[$6 + 44 >> 2];
       $9 = ($9 + Math_imul($7, $4 >> 16) | 0) + (Math_imul($4 & 65535, $7) >> 16) | 0;
       $7 = HEAP16[$8 + 14 >> 1];
       $4 = HEAP32[$6 + 40 >> 2];
       $8 = HEAP16[$8 + 16 >> 1];
       $6 = HEAP32[$6 + 36 >> 2];
       $6 = ((($9 + Math_imul($7, $4 >> 16) | 0) + (Math_imul($4 & 65535, $7) >> 16) | 0) + Math_imul($8, $6 >> 16) | 0) + (Math_imul($6 & 65535, $8) >> 16) | 0;
       $8 = ($6 >> 5) + 1 >> 1;
       HEAP16[$1 >> 1] = ($6 | 0) > 2097119 ? 32767 : ($8 | 0) > -32768 ? $8 : -32768;
       $1 = $1 + 2 | 0;
       $5 = $5 + $15 | 0;
       if (($14 | 0) > ($5 | 0)) {
        continue;
       }
       break;
      }
      break label$2;
     }
     $8 = 0;
     if (($14 | 0) <= 0) {
      break label$2;
     }
     while (1) {
      $4 = HEAP16[$10 + 4 >> 1];
      $6 = ($8 >> 16 << 2) + $12 | 0;
      $5 = HEAP32[$6 + 92 >> 2] + HEAP32[$6 >> 2] | 0;
      $7 = (Math_imul($4, $5 & 65535) >> 16) + Math_imul($5 >> 16, $4) | 0;
      $4 = HEAP16[$10 + 6 >> 1];
      $5 = HEAP32[$6 + 88 >> 2] + HEAP32[$6 + 4 >> 2] | 0;
      $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
      $4 = HEAP16[$10 + 8 >> 1];
      $5 = HEAP32[$6 + 84 >> 2] + HEAP32[$6 + 8 >> 2] | 0;
      $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
      $4 = HEAP16[$10 + 10 >> 1];
      $5 = HEAP32[$6 + 80 >> 2] + HEAP32[$6 + 12 >> 2] | 0;
      $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
      $4 = HEAP16[$10 + 12 >> 1];
      $5 = HEAP32[$6 + 76 >> 2] + HEAP32[$6 + 16 >> 2] | 0;
      $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
      $4 = HEAP16[$10 + 14 >> 1];
      $5 = HEAP32[$6 + 72 >> 2] + HEAP32[$6 + 20 >> 2] | 0;
      $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
      $4 = HEAP16[$10 + 16 >> 1];
      $5 = HEAP32[$6 + 68 >> 2] + HEAP32[$6 + 24 >> 2] | 0;
      $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
      $4 = HEAP16[$10 + 18 >> 1];
      $5 = HEAP32[$6 + 64 >> 2] + HEAP32[$6 + 28 >> 2] | 0;
      $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
      $4 = HEAP16[$10 + 20 >> 1];
      $5 = HEAP32[$6 + 60 >> 2] + HEAP32[$6 + 32 >> 2] | 0;
      $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
      $4 = HEAP16[$10 + 22 >> 1];
      $5 = HEAP32[$6 + 56 >> 2] + HEAP32[$6 + 36 >> 2] | 0;
      $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
      $4 = HEAP16[$10 + 24 >> 1];
      $5 = HEAP32[$6 + 52 >> 2] + HEAP32[$6 + 40 >> 2] | 0;
      $4 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
      $5 = HEAP16[$10 + 26 >> 1];
      $6 = HEAP32[$6 + 48 >> 2] + HEAP32[$6 + 44 >> 2] | 0;
      $6 = ($4 + Math_imul($5, $6 >> 16) | 0) + (Math_imul($6 & 65535, $5) >> 16) | 0;
      $5 = ($6 >> 5) + 1 >> 1;
      HEAP16[$1 >> 1] = ($6 | 0) > 2097119 ? 32767 : ($5 | 0) > -32768 ? $5 : -32768;
      $1 = $1 + 2 | 0;
      $8 = $8 + $15 | 0;
      if (($14 | 0) > ($8 | 0)) {
       continue;
      }
      break;
     }
     break label$2;
    }
    celt_fatal(6400, 6420, 139);
    abort();
   }
   $8 = 0;
   if (($14 | 0) <= 0) {
    break label$2;
   }
   while (1) {
    $4 = HEAP16[$10 + 4 >> 1];
    $6 = ($8 >> 16 << 2) + $12 | 0;
    $5 = HEAP32[$6 + 140 >> 2] + HEAP32[$6 >> 2] | 0;
    $7 = (Math_imul($4, $5 & 65535) >> 16) + Math_imul($5 >> 16, $4) | 0;
    $4 = HEAP16[$10 + 6 >> 1];
    $5 = HEAP32[$6 + 136 >> 2] + HEAP32[$6 + 4 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 8 >> 1];
    $5 = HEAP32[$6 + 132 >> 2] + HEAP32[$6 + 8 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 10 >> 1];
    $5 = HEAP32[$6 + 128 >> 2] + HEAP32[$6 + 12 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 12 >> 1];
    $5 = HEAP32[$6 + 124 >> 2] + HEAP32[$6 + 16 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 14 >> 1];
    $5 = HEAP32[$6 + 120 >> 2] + HEAP32[$6 + 20 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 16 >> 1];
    $5 = HEAP32[$6 + 116 >> 2] + HEAP32[$6 + 24 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 18 >> 1];
    $5 = HEAP32[$6 + 112 >> 2] + HEAP32[$6 + 28 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 20 >> 1];
    $5 = HEAP32[$6 + 108 >> 2] + HEAP32[$6 + 32 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 22 >> 1];
    $5 = HEAP32[$6 + 104 >> 2] + HEAP32[$6 + 36 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 24 >> 1];
    $5 = HEAP32[$6 + 100 >> 2] + HEAP32[$6 + 40 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 26 >> 1];
    $5 = HEAP32[$6 + 96 >> 2] + HEAP32[$6 + 44 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 28 >> 1];
    $5 = HEAP32[$6 + 92 >> 2] + HEAP32[$6 + 48 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 30 >> 1];
    $5 = HEAP32[$6 + 88 >> 2] + HEAP32[$6 + 52 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 32 >> 1];
    $5 = HEAP32[$6 + 84 >> 2] + HEAP32[$6 + 56 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 34 >> 1];
    $5 = HEAP32[$6 + 80 >> 2] + HEAP32[$6 + 60 >> 2] | 0;
    $7 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $4 = HEAP16[$10 + 36 >> 1];
    $5 = HEAP32[$6 + 76 >> 2] + HEAP32[$6 + 64 >> 2] | 0;
    $4 = ($7 + Math_imul($4, $5 >> 16) | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
    $5 = HEAP16[$10 + 38 >> 1];
    $6 = HEAP32[$6 + 72 >> 2] + HEAP32[$6 + 68 >> 2] | 0;
    $6 = ($4 + Math_imul($5, $6 >> 16) | 0) + (Math_imul($6 & 65535, $5) >> 16) | 0;
    $5 = ($6 >> 5) + 1 >> 1;
    HEAP16[$1 >> 1] = ($6 | 0) > 2097119 ? 32767 : ($5 | 0) > -32768 ? $5 : -32768;
    $1 = $1 + 2 | 0;
    $8 = $8 + $15 | 0;
    if (($14 | 0) > ($8 | 0)) {
     continue;
    }
    break;
   }
  }
  $3 = $3 - $13 | 0;
  if (($3 | 0) >= 2) {
   memcpy($12, ($13 << 2) + $12 | 0, $16 << 2);
   $2 = ($13 << 1) + $2 | 0;
   $5 = HEAP32[$0 + 296 >> 2];
   $8 = HEAP32[$0 + 276 >> 2];
   $6 = HEAP32[$0 + 268 >> 2];
   continue;
  }
  break;
 }
 memcpy($17, ($13 << 2) + $12 | 0, $16 << 2);
 __stack_pointer = $20;
}
function silk_stereo_LR_to_MS($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0;
 $11 = __stack_pointer - 16 | 0;
 $16 = $11;
 __stack_pointer = $11;
 $23 = $1 - 4 | 0;
 $13 = $10 + 2 | 0;
 $24 = $11 - (($13 << 1) + 15 & -16) | 0;
 $18 = $24;
 __stack_pointer = $18;
 if (($10 | 0) >= -1) {
  $21 = ($13 | 0) > 1 ? $13 : 1;
  $11 = 0;
  while (1) {
   $13 = $11 << 1;
   $15 = $13 - 4 | 0;
   $12 = HEAP16[$15 + $2 >> 1];
   $15 = HEAP16[$1 + $15 >> 1];
   $14 = $15 + $12 | 0;
   HEAP16[$13 + $23 >> 1] = ($14 >>> 1 | 0) + ($14 & 1);
   $19 = $13 + $24 | 0;
   $13 = $15 - $12 | 0;
   $13 = ($13 >> 1) + ($13 & 1) | 0;
   $13 = ($13 | 0) > -32768 ? $13 : -32768;
   HEAP16[$19 >> 1] = ($13 | 0) < 32767 ? $13 : 32767;
   $11 = $11 + 1 | 0;
   if (($21 | 0) != ($11 | 0)) {
    continue;
   }
   break;
  }
 }
 $19 = HEAP32[$0 + 4 >> 2];
 HEAP16[$23 >> 1] = $19;
 HEAP16[$23 + 2 >> 1] = $19 >>> 16;
 $14 = HEAP32[$0 + 8 >> 2];
 HEAP32[$24 >> 2] = $14;
 $11 = $10 << 1;
 $19 = $23 + $11 | 0;
 HEAP32[$0 + 4 >> 2] = HEAPU16[$19 >> 1] | HEAPU16[$19 + 2 >> 1] << 16;
 $19 = $11 + $24 | 0;
 HEAP32[$0 + 8 >> 2] = HEAPU16[$19 >> 1] | HEAPU16[$19 + 2 >> 1] << 16;
 $13 = $11 + 15 & -16;
 $18 = $18 - $13 | 0;
 $15 = $18;
 __stack_pointer = $15;
 $11 = 0;
 $17 = $15 - $13 | 0;
 $20 = $17;
 __stack_pointer = $17;
 label$3 : {
  if (($10 | 0) <= 0) {
   $11 = ($10 << 1) + 15 & -16;
   $20 = $20 - $11 | 0;
   $13 = $20;
   __stack_pointer = $13;
   $22 = $13 - $11 | 0;
   __stack_pointer = $22;
   break label$3;
  }
  $21 = $14 >>> 16 | 0;
  $13 = HEAPU16[$23 >> 1];
  while (1) {
   $15 = $11 << 1;
   $19 = HEAP16[$15 + $1 >> 1] + ($13 << 16 >> 16) | 0;
   $11 = $11 + 1 | 0;
   $13 = HEAP16[($11 << 1) + $23 >> 1];
   $12 = (($13 << 1) + $19 >>> 1 | 0) + 1 >>> 1 | 0;
   HEAP16[$15 + $18 >> 1] = $12;
   HEAP16[$15 + $17 >> 1] = $13 - $12;
   if (($10 | 0) != ($11 | 0)) {
    continue;
   }
   break;
  }
  $11 = ($10 << 1) + 15 & -16;
  $20 = $20 - $11 | 0;
  $13 = $20;
  __stack_pointer = $13;
  $22 = $13 - $11 | 0;
  __stack_pointer = $22;
  if (($10 | 0) < 1) {
   break label$3;
  }
  $13 = 0;
  while (1) {
   $11 = $21;
   $15 = $13 << 1;
   $21 = HEAP16[($24 + $15 | 0) + 4 >> 1];
   $12 = (($21 + ($14 << 16 >> 16) | 0) + ($11 << 16 >> 16 << 1) >>> 1 | 0) + 1 >>> 1 | 0;
   HEAP16[$15 + $20 >> 1] = $12;
   HEAP16[$15 + $22 >> 1] = $11 - $12;
   $14 = $11;
   $13 = $13 + 1 | 0;
   if (($13 | 0) != ($10 | 0)) {
    continue;
   }
   break;
  }
 }
 $11 = (Math_imul($9, 10) | 0) == ($10 | 0);
 $13 = $11 ? 328 : 655;
 $15 = $7 << 16 >> 16;
 $15 = Math_imul($15, $15);
 $13 = (Math_imul($13, $15 & 65535) >>> 16 | 0) + Math_imul($15 >>> 16 | 0, $13) | 0;
 $7 = silk_stereo_find_predictor($16 + 4 | 0, $18, $20, $0 + 12 | 0, $10, $13);
 HEAP32[$16 + 8 >> 2] = $7;
 $26 = silk_stereo_find_predictor($16, $17, $22, $0 + 20 | 0, $10, $13);
 HEAP32[$16 + 12 >> 2] = $26;
 $21 = ($11 ? -1200 : -600) + $6 | 0;
 $15 = ($21 | 0) > 1 ? $21 : 1;
 $14 = Math_clz32($15);
 $12 = $15 << $14 - 1;
 $17 = $12;
 $11 = HEAP32[$16 >> 2] + Math_imul(HEAP16[$16 + 4 >> 1], 3) | 0;
 $22 = ($11 | 0) < 65536 ? $11 : 65536;
 $20 = Math_imul($22, 3);
 $11 = $20 + 851968 | 0;
 $18 = $11 >> 31;
 $18 = Math_clz32($18 ^ $11 + $18);
 $11 = $11 << $18 - 1;
 $27 = $11;
 $6 = $11 >> 31;
 $25 = $6;
 $11 = 536870911 / ($11 >> 16) << 16 >> 16;
 $12 = (Math_imul($11, $12 & 65535) >> 16) + Math_imul($12 >> 16, $11) | 0;
 $6 = $12 >> 31;
 $19 = $6;
 $6 = $25;
 $19 = __wasm_i64_mul($27, $6, $12, $19);
 $25 = $19;
 $6 = i64toi32_i32$HIGH_BITS;
 $17 = $17 - ((($6 & 536870911) << 3 | $25 >>> 29) & -8) | 0;
 $12 = (Math_imul($17 >> 16, $11) + $12 | 0) + (Math_imul($17 & 65535, $11) >> 16) | 0;
 $11 = Math_imul($9 << 16 >> 16, 600) + 2e3 | 0;
 $6 = $5;
 $14 = ($14 - $18 | 0) + 10 | 0;
 label$7 : {
  if (($14 | 0) <= -1) {
   $14 = 0 - $14 | 0;
   $18 = 2147483647 >>> $14 | 0;
   $17 = -2147483648 >> $14;
   $12 = (($12 | 0) > ($18 | 0) ? $18 : ($12 | 0) < ($17 | 0) ? $17 : $12) << $14;
   break label$7;
  }
  $12 = ($14 | 0) < 32 ? $12 >> $14 : 0;
 }
 HEAP32[$6 >> 2] = $12;
 label$9 : {
  if (($11 | 0) > ($12 | 0)) {
   HEAP32[$5 >> 2] = $11;
   $12 = $15 - $11 | 0;
   HEAP32[$5 + 4 >> 2] = $12;
   $12 = ($12 << 1) - $11 | 0;
   $14 = $12 >> 31;
   $18 = Math_clz32($14 ^ $12 + $14);
   $14 = $12 << $18 - 1;
   $27 = $14;
   $17 = $11 << 16 >> 16;
   $12 = $20 + 65536 | 0;
   $12 = (Math_imul($17, $12 & 65535) >> 16) + Math_imul($12 >> 16, $17) | 0;
   $17 = $12 >> 31;
   $17 = Math_clz32($17 ^ $12 + $17);
   $20 = $12 << $17 - 1;
   $12 = 536870911 / ($20 >> 16) << 16 >> 16;
   $14 = (Math_imul($12, $14 & 65535) >> 16) + Math_imul($14 >> 16, $12) | 0;
   $19 = $14 >> 31;
   $6 = $19;
   $19 = $20 >> 31;
   $25 = $19;
   $19 = $6;
   $25 = __wasm_i64_mul($14, $19, $20, $25);
   $6 = $25;
   $19 = i64toi32_i32$HIGH_BITS;
   $20 = $27 - ((($19 & 536870911) << 3 | $6 >>> 29) & -8) | 0;
   $12 = (Math_imul($20 >> 16, $12) + $14 | 0) + (Math_imul($20 & 65535, $12) >> 16) | 0;
   $14 = ($18 - $17 | 0) + 13 | 0;
   label$11 : {
    if (($14 | 0) <= -1) {
     $14 = 0 - $14 | 0;
     $18 = 2147483647 >>> $14 | 0;
     $17 = -2147483648 >> $14;
     $12 = (($12 | 0) > ($18 | 0) ? $18 : ($12 | 0) < ($17 | 0) ? $17 : $12) << $14;
     break label$11;
    }
    $12 = ($14 | 0) < 32 ? $12 >> $14 : 0;
   }
   $12 = ($12 | 0) > 0 ? $12 : 0;
   $12 = ($12 | 0) < 16384 ? $12 : 16384;
   break label$9;
  }
  HEAP32[$5 + 4 >> 2] = $15 - $12;
  $12 = 16384;
 }
 $14 = HEAP16[$0 + 28 >> 1];
 $12 = $12 - $14 | 0;
 HEAP16[$0 + 28 >> 1] = (Math_imul($12 >>> 16 | 0, $13) + (Math_imul($12 & 65535, $13 << 16 >> 16) >>> 16 | 0) | 0) + $14;
 $6 = 0;
 HEAP8[$4 | 0] = 0;
 label$13 : {
  label$14 : {
   label$15 : {
    label$16 : {
     label$17 : {
      label$18 : {
       if ($8) {
        HEAP32[$16 + 8 >> 2] = 0;
        HEAP32[$16 + 12 >> 2] = 0;
        silk_stereo_quant_pred($16 + 8 | 0, $3);
        break label$18;
       }
       $13 = $15 << 3;
       label$20 : {
        if (!HEAPU16[$0 + 30 >> 1]) {
         label$22 : {
          if ((Math_imul($11, 13) | 0) > ($13 | 0)) {
           $11 = HEAP16[$0 + 28 >> 1];
           break label$22;
          }
          $11 = HEAP16[$0 + 28 >> 1];
          if (((Math_imul($11, $22 & 65535) >> 16) + Math_imul($22 >> 16, $11) | 0) > 818) {
           break label$20;
          }
         }
         HEAP32[$16 + 12 >> 2] = Math_imul($26 << 16 >> 16, $11) >> 14;
         HEAP32[$16 + 8 >> 2] = Math_imul($7 << 16 >> 16, $11) >> 14;
         silk_stereo_quant_pred($16 + 8 | 0, $3);
         HEAP32[$16 + 8 >> 2] = 0;
         HEAP32[$16 + 12 >> 2] = 0;
         HEAP32[$5 + 4 >> 2] = 0;
         HEAP32[$5 >> 2] = $15;
         HEAP8[$4 | 0] = 1;
         break label$17;
        }
        label$24 : {
         if ((Math_imul($11, 11) | 0) > ($13 | 0)) {
          $11 = HEAP16[$0 + 28 >> 1];
          break label$24;
         }
         $11 = HEAP16[$0 + 28 >> 1];
         if (((Math_imul($11, $22 & 65535) >> 16) + Math_imul($22 >> 16, $11) | 0) > 327) {
          break label$20;
         }
        }
        HEAP32[$16 + 12 >> 2] = Math_imul($26 << 16 >> 16, $11) >> 14;
        HEAP32[$16 + 8 >> 2] = Math_imul($7 << 16 >> 16, $11) >> 14;
        silk_stereo_quant_pred($16 + 8 | 0, $3);
        HEAP32[$16 + 8 >> 2] = 0;
        HEAP32[$16 + 12 >> 2] = 0;
        break label$18;
       }
       if (($11 | 0) >= 15566) {
        silk_stereo_quant_pred($16 + 8 | 0, $3);
        $6 = 16384;
        break label$18;
       }
       HEAP32[$16 + 12 >> 2] = Math_imul($26 << 16 >> 16, $11) >> 14;
       HEAP32[$16 + 8 >> 2] = Math_imul($7 << 16 >> 16, $11) >> 14;
       silk_stereo_quant_pred($16 + 8 | 0, $3);
       $6 = HEAP16[$0 + 28 >> 1];
      }
      if (HEAPU8[$4 | 0] != 1) {
       break label$16;
      }
     }
     $11 = HEAPU16[$0 + 32 >> 1] + ($10 - ($9 << 3) | 0) | 0;
     HEAP16[$0 + 32 >> 1] = $11;
     if ((Math_imul($9, 5) | 0) > $11 << 16 >> 16) {
      HEAP8[$4 | 0] = 0;
      break label$14;
     }
     HEAP16[$0 + 32 >> 1] = 1e4;
     break label$15;
    }
    HEAP16[$0 + 32 >> 1] = 0;
   }
   if (HEAPU8[$4 | 0]) {
    break label$13;
   }
  }
  if (HEAP32[$5 + 4 >> 2] > 0) {
   break label$13;
  }
  HEAP32[$5 + 4 >> 2] = 1;
  HEAP32[$5 >> 2] = ($15 | 0) > 2 ? $21 - 1 | 0 : 1;
 }
 $11 = $9 << 3;
 $13 = 65536 / ($11 | 0) | 0;
 $7 = HEAP32[$16 + 12 >> 2];
 $8 = HEAP32[$16 + 8 >> 2];
 if (($9 | 0) >= 1) {
  $13 = $13 << 16 >> 16;
  $15 = HEAP16[$0 + 30 >> 1];
  $12 = $6 - $15 | 0;
  $22 = (Math_imul($13, $12 & 65535) >> 16) + Math_imul($12 >> 16, $13) << 10;
  $12 = HEAP16[$0 + 2 >> 1];
  $9 = (Math_imul($7 - $12 << 16 >> 16, $13) >> 15) + 1 >> 1;
  $14 = HEAP16[$0 >> 1];
  $5 = (Math_imul($8 - $14 << 16 >> 16, $13) >> 15) + 1 >> 1;
  $4 = ($11 | 0) > 1 ? $11 : 1;
  $13 = 0;
  $21 = 0 - $14 | 0;
  $18 = 0 - $12 | 0;
  $15 = $15 << 10;
  while (1) {
   $12 = $13 << 1;
   $14 = $13 + 1 | 0;
   $13 = $14 << 1;
   $17 = HEAP16[$24 + $13 >> 1];
   $15 = $15 + $22 | 0;
   $18 = $18 - $9 | 0;
   $20 = $18 << 16 >> 16;
   $13 = HEAP16[$13 + $23 >> 1];
   $19 = ((Math_imul($17, $15 >> 16) + Math_imul($20, $13 >> 5) | 0) + (Math_imul($15 & 64512, $17) >> 16) | 0) + (Math_imul($13 << 11 & 63488, $20) >> 16) | 0;
   $13 = (HEAP16[$1 + $12 >> 1] + HEAP16[$12 + $23 >> 1] | 0) + ($13 << 1) | 0;
   $3 = ($12 + $2 | 0) - 2 | 0;
   $21 = $21 - $5 | 0;
   $12 = $21 << 16 >> 16;
   $13 = (Math_imul($12, $13 >> 7) + $19 | 0) + (Math_imul($13 << 9 & 65024, $12) >> 16) | 0;
   $12 = ($13 >> 7) + 1 >> 1;
   HEAP16[$3 >> 1] = ($13 | 0) > 8388479 ? 32767 : ($12 | 0) > -32768 ? $12 : -32768;
   $13 = $14;
   if (($13 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
 }
 if (($10 | 0) > ($11 | 0)) {
  $18 = $6 >> 6;
  $17 = $6 << 10 & 64512;
  $12 = 0 - ($7 << 16) >> 16;
  $14 = 0 - ($8 << 16) >> 16;
  while (1) {
   $13 = $11 << 1;
   $3 = ($13 + $2 | 0) - 2 | 0;
   $11 = $11 + 1 | 0;
   $15 = $11 << 1;
   $21 = HEAP16[$24 + $15 >> 1];
   $15 = HEAP16[$15 + $23 >> 1];
   $13 = (HEAP16[$1 + $13 >> 1] + HEAP16[$13 + $23 >> 1] | 0) + ($15 << 1) | 0;
   $13 = ((((Math_imul($18, $21) + Math_imul($15 >> 5, $12) | 0) + (Math_imul($17, $21) >> 16) | 0) + (Math_imul($15 << 11 & 63488, $12) >> 16) | 0) + Math_imul($13 >> 7, $14) | 0) + (Math_imul($13 << 9 & 65024, $14) >> 16) | 0;
   $15 = ($13 >> 7) + 1 >> 1;
   HEAP16[$3 >> 1] = ($13 | 0) > 8388479 ? 32767 : ($15 | 0) > -32768 ? $15 : -32768;
   if (($10 | 0) != ($11 | 0)) {
    continue;
   }
   break;
  }
 }
 HEAP16[$0 + 30 >> 1] = $6;
 HEAP16[$0 + 2 >> 1] = $7;
 HEAP16[$0 >> 1] = $8;
 __stack_pointer = $16 + 16 | 0;
}
function __rem_pio2_large($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 $8 = __stack_pointer - 560 | 0;
 __stack_pointer = $8;
 $7 = ($2 - 3 | 0) / 24 | 0;
 $19 = ($7 | 0) > 0 ? $7 : 0;
 $13 = Math_imul($19, -24) + $2 | 0;
 $12 = HEAP32[($4 << 2) + 33424 >> 2];
 $15 = $3 - 1 | 0;
 if (($12 + $15 | 0) >= 0) {
  $6 = $3 + $12 | 0;
  $2 = $19 - $15 | 0;
  $7 = 0;
  while (1) {
   $5 = ($2 | 0) < 0 ? 0 : +HEAP32[($2 << 2) + 33440 >> 2];
   HEAPF64[($8 + 320 | 0) + ($7 << 3) >> 3] = $5;
   $2 = $2 + 1 | 0;
   $7 = $7 + 1 | 0;
   if (($7 | 0) != ($6 | 0)) {
    continue;
   }
   break;
  }
 }
 $18 = $13 - 24 | 0;
 $6 = 0;
 $10 = ($12 | 0) > 0 ? $12 : 0;
 $11 = ($3 | 0) < 1;
 while (1) {
  label$6 : {
   if ($11) {
    $5 = 0;
    break label$6;
   }
   $7 = $6 + $15 | 0;
   $2 = 0;
   $5 = 0;
   while (1) {
    $5 = $5 + HEAPF64[($2 << 3) + $0 >> 3] * HEAPF64[($8 + 320 | 0) + ($7 - $2 << 3) >> 3];
    $2 = $2 + 1 | 0;
    if (($3 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  HEAPF64[($6 << 3) + $8 >> 3] = $5;
  $2 = ($6 | 0) == ($10 | 0);
  $6 = $6 + 1 | 0;
  if (!$2) {
   continue;
  }
  break;
 }
 $23 = 47 - $13 | 0;
 $21 = 48 - $13 | 0;
 $24 = $13 - 25 | 0;
 $6 = $12;
 label$9 : {
  while (1) {
   $5 = HEAPF64[($6 << 3) + $8 >> 3];
   $2 = 0;
   $7 = $6;
   $15 = ($6 | 0) < 1;
   if (!$15) {
    while (1) {
     $10 = $2 << 2;
     $10 = $10 + ($8 + 480 | 0) | 0;
     $16 = $5;
     $9 = $5 * 5.960464477539063e-8;
     label$14 : {
      if (Math_abs($9) < 2147483648) {
       $11 = ~~$9;
       break label$14;
      }
      $11 = -2147483648;
     }
     $9 = +($11 | 0);
     $5 = $16 + $9 * -16777216;
     label$13 : {
      if (Math_abs($5) < 2147483648) {
       $11 = ~~$5;
       break label$13;
      }
      $11 = -2147483648;
     }
     HEAP32[$10 >> 2] = $11;
     $7 = $7 - 1 | 0;
     $5 = HEAPF64[($7 << 3) + $8 >> 3] + $9;
     $2 = $2 + 1 | 0;
     if (($6 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   $5 = scalbn($5, $18);
   $5 = $5 + floor($5 * .125) * -8;
   label$17 : {
    if (Math_abs($5) < 2147483648) {
     $17 = ~~$5;
     break label$17;
    }
    $17 = -2147483648;
   }
   $5 = $5 - +($17 | 0);
   label$19 : {
    label$20 : {
     label$21 : {
      $22 = ($18 | 0) < 1;
      label$22 : {
       if (!$22) {
        $7 = ($6 << 2) + $8 | 0;
        $2 = $7 + 476 | 0;
        $11 = $2;
        $2 = HEAP32[$7 + 476 >> 2];
        $7 = $2;
        $2 = $2 >> $21;
        $7 = $7 - ($2 << $21) | 0;
        HEAP32[$11 >> 2] = $7;
        $17 = $2 + $17 | 0;
        $14 = $7 >> $23;
        break label$22;
       }
       if ($18) {
        break label$21;
       }
       $14 = HEAP32[(($6 << 2) + $8 | 0) + 476 >> 2] >> 23;
      }
      if (($14 | 0) < 1) {
       break label$19;
      }
      break label$20;
     }
     $14 = 2;
     if (!($5 >= .5 ^ 1)) {
      break label$20;
     }
     $14 = 0;
     break label$19;
    }
    $2 = 0;
    $11 = 0;
    if (!$15) {
     while (1) {
      $15 = ($8 + 480 | 0) + ($2 << 2) | 0;
      $7 = HEAP32[$15 >> 2];
      $10 = 16777215;
      label$26 : {
       label$27 : {
        if ($11) {
         break label$27;
        }
        $10 = 16777216;
        if ($7) {
         break label$27;
        }
        $11 = 0;
        break label$26;
       }
       HEAP32[$15 >> 2] = $10 - $7;
       $11 = 1;
      }
      $2 = $2 + 1 | 0;
      if (($6 | 0) != ($2 | 0)) {
       continue;
      }
      break;
     }
    }
    label$28 : {
     if ($22) {
      break label$28;
     }
     label$29 : {
      switch ($24 | 0) {
      case 0:
       $7 = ($6 << 2) + $8 | 0;
       $2 = $7 + 476 | 0;
       HEAP32[$2 >> 2] = HEAP32[$7 + 476 >> 2] & 8388607;
       break label$28;
      case 1:
       break label$29;
      default:
       break label$28;
      }
     }
     $7 = ($6 << 2) + $8 | 0;
     $2 = $7 + 476 | 0;
     HEAP32[$2 >> 2] = HEAP32[$7 + 476 >> 2] & 4194303;
    }
    $17 = $17 + 1 | 0;
    if (($14 | 0) != 2) {
     break label$19;
    }
    $5 = 1 - $5;
    $14 = 2;
    if (!$11) {
     break label$19;
    }
    $5 = $5 - scalbn(1, $18);
   }
   if ($5 == 0) {
    $7 = 0;
    label$32 : {
     $2 = $6;
     if (($12 | 0) >= ($2 | 0)) {
      break label$32;
     }
     while (1) {
      $2 = $2 - 1 | 0;
      $7 = HEAP32[($8 + 480 | 0) + ($2 << 2) >> 2] | $7;
      if (($2 | 0) > ($12 | 0)) {
       continue;
      }
      break;
     }
     if (!$7) {
      break label$32;
     }
     $13 = $18;
     while (1) {
      $13 = $13 - 24 | 0;
      $6 = $6 - 1 | 0;
      if (!HEAP32[($8 + 480 | 0) + ($6 << 2) >> 2]) {
       continue;
      }
      break;
     }
     break label$9;
    }
    $2 = 1;
    while (1) {
     $7 = $2;
     $2 = $2 + 1 | 0;
     if (!HEAP32[($8 + 480 | 0) + ($12 - $7 << 2) >> 2]) {
      continue;
     }
     break;
    }
    $10 = $6 + $7 | 0;
    while (1) {
     $7 = $3 + $6 | 0;
     $6 = $6 + 1 | 0;
     HEAPF64[($8 + 320 | 0) + ($7 << 3) >> 3] = HEAP32[($19 + $6 << 2) + 33440 >> 2];
     $2 = 0;
     $5 = 0;
     if (($3 | 0) >= 1) {
      while (1) {
       $5 = $5 + HEAPF64[($2 << 3) + $0 >> 3] * HEAPF64[($8 + 320 | 0) + ($7 - $2 << 3) >> 3];
       $2 = $2 + 1 | 0;
       if (($3 | 0) != ($2 | 0)) {
        continue;
       }
       break;
      }
     }
     HEAPF64[($6 << 3) + $8 >> 3] = $5;
     if (($6 | 0) < ($10 | 0)) {
      continue;
     }
     break;
    }
    $6 = $10;
    continue;
   }
   break;
  }
  $5 = scalbn($5, 24 - $13 | 0);
  label$39 : {
   if (!($5 >= 16777216 ^ 1)) {
    $3 = $6 << 2;
    $3 = $3 + ($8 + 480 | 0) | 0;
    $16 = $5;
    $9 = $5 * 5.960464477539063e-8;
    label$42 : {
     if (Math_abs($9) < 2147483648) {
      $2 = ~~$9;
      break label$42;
     }
     $2 = -2147483648;
    }
    $5 = $16 + +($2 | 0) * -16777216;
    label$41 : {
     if (Math_abs($5) < 2147483648) {
      $7 = ~~$5;
      break label$41;
     }
     $7 = -2147483648;
    }
    HEAP32[$3 >> 2] = $7;
    $6 = $6 + 1 | 0;
    break label$39;
   }
   if (Math_abs($5) < 2147483648) {
    $2 = ~~$5;
   } else {
    $2 = -2147483648;
   }
   $13 = $18;
  }
  HEAP32[($8 + 480 | 0) + ($6 << 2) >> 2] = $2;
 }
 $5 = scalbn(1, $13);
 label$47 : {
  if (($6 | 0) <= -1) {
   break label$47;
  }
  $2 = $6;
  while (1) {
   HEAPF64[($2 << 3) + $8 >> 3] = $5 * +HEAP32[($8 + 480 | 0) + ($2 << 2) >> 2];
   $5 = $5 * 5.960464477539063e-8;
   $3 = ($2 | 0) > 0;
   $2 = $2 - 1 | 0;
   if ($3) {
    continue;
   }
   break;
  }
  $10 = 0;
  if (($6 | 0) < 0) {
   break label$47;
  }
  $12 = ($12 | 0) > 0 ? $12 : 0;
  $7 = $6;
  while (1) {
   $0 = $10 >>> 0 > $12 >>> 0 ? $12 : $10;
   $11 = $6 - $7 | 0;
   $2 = 0;
   $5 = 0;
   while (1) {
    $5 = $5 + HEAPF64[($2 << 3) + 36208 >> 3] * HEAPF64[($2 + $7 << 3) + $8 >> 3];
    $3 = ($0 | 0) != ($2 | 0);
    $2 = $2 + 1 | 0;
    if ($3) {
     continue;
    }
    break;
   }
   HEAPF64[($8 + 160 | 0) + ($11 << 3) >> 3] = $5;
   $7 = $7 - 1 | 0;
   $2 = ($6 | 0) != ($10 | 0);
   $10 = $10 + 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
 label$51 : {
  label$52 : {
   label$53 : {
    switch ($4 | 0) {
    case 3:
     label$56 : {
      if (($6 | 0) < 1) {
       break label$56;
      }
      $5 = HEAPF64[($8 + 160 | 0) + ($6 << 3) >> 3];
      $2 = $6;
      while (1) {
       $3 = $2 - 1 | 0;
       $7 = ($8 + 160 | 0) + ($3 << 3) | 0;
       $9 = HEAPF64[$7 >> 3];
       $16 = $9;
       $9 = $9 + $5;
       HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3] = $5 + ($16 - $9);
       HEAPF64[$7 >> 3] = $9;
       $7 = ($2 | 0) > 1;
       $5 = $9;
       $2 = $3;
       if ($7) {
        continue;
       }
       break;
      }
      if (($6 | 0) < 2) {
       break label$56;
      }
      $5 = HEAPF64[($8 + 160 | 0) + ($6 << 3) >> 3];
      $2 = $6;
      while (1) {
       $3 = $2 - 1 | 0;
       $7 = ($8 + 160 | 0) + ($3 << 3) | 0;
       $9 = HEAPF64[$7 >> 3];
       $16 = $9;
       $9 = $9 + $5;
       HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3] = $5 + ($16 - $9);
       HEAPF64[$7 >> 3] = $9;
       $7 = ($2 | 0) > 2;
       $5 = $9;
       $2 = $3;
       if ($7) {
        continue;
       }
       break;
      }
      if (($6 | 0) <= 1) {
       break label$56;
      }
      while (1) {
       $20 = $20 + HEAPF64[($8 + 160 | 0) + ($6 << 3) >> 3];
       $2 = ($6 | 0) > 2;
       $6 = $6 - 1 | 0;
       if ($2) {
        continue;
       }
       break;
      }
     }
     $5 = HEAPF64[$8 + 160 >> 3];
     if ($14) {
      break label$52;
     }
     HEAPF64[$1 >> 3] = $5;
     $5 = HEAPF64[$8 + 168 >> 3];
     HEAPF64[$1 + 16 >> 3] = $20;
     HEAPF64[$1 + 8 >> 3] = $5;
     break label$51;
    case 0:
     $5 = 0;
     if (($6 | 0) >= 0) {
      while (1) {
       $5 = $5 + HEAPF64[($8 + 160 | 0) + ($6 << 3) >> 3];
       $2 = ($6 | 0) > 0;
       $6 = $6 - 1 | 0;
       if ($2) {
        continue;
       }
       break;
      }
     }
     HEAPF64[$1 >> 3] = $14 ? -$5 : $5;
     break label$51;
    case 1:
    case 2:
     break label$53;
    default:
     break label$51;
    }
   }
   $5 = 0;
   if (($6 | 0) >= 0) {
    $2 = $6;
    while (1) {
     $5 = $5 + HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3];
     $3 = ($2 | 0) > 0;
     $2 = $2 - 1 | 0;
     if ($3) {
      continue;
     }
     break;
    }
   }
   HEAPF64[$1 >> 3] = $14 ? -$5 : $5;
   $5 = HEAPF64[$8 + 160 >> 3] - $5;
   $2 = 1;
   if (($6 | 0) >= 1) {
    while (1) {
     $5 = $5 + HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3];
     $3 = ($2 | 0) != ($6 | 0);
     $2 = $2 + 1 | 0;
     if ($3) {
      continue;
     }
     break;
    }
   }
   HEAPF64[$1 + 8 >> 3] = $14 ? -$5 : $5;
   break label$51;
  }
  HEAPF64[$1 >> 3] = -$5;
  $5 = HEAPF64[$8 + 168 >> 3];
  HEAPF64[$1 + 16 >> 3] = -$20;
  HEAPF64[$1 + 8 >> 3] = -$5;
 }
 __stack_pointer = $8 + 560 | 0;
 return $17 & 7;
}
function silk_NLSF_del_dec_quant($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 $10 = __stack_pointer - 320 | 0;
 __stack_pointer = $10;
 $16 = $6 << 16 >> 16;
 $6 = -10;
 while (1) {
  $11 = $6 << 10;
  label$2 : {
   if (($6 | 0) >= 1) {
    $13 = $11 | 922;
    $11 = $11 - 102 | 0;
    break label$2;
   }
   if (!$6) {
    $13 = $11 | 922;
    break label$2;
   }
   $12 = $11 + 1024 | 0;
   $13 = ($6 | 0) == -1 ? $12 : $12 | 102;
   $11 = $11 | 102;
  }
  $12 = ($6 << 2) + 40 | 0;
  HEAP32[$12 + $10 >> 2] = Math_imul($13 << 16 >> 16, $16) >> 16;
  HEAP32[($10 + 80 | 0) + $12 >> 2] = Math_imul($11 << 16 >> 16, $16) >> 16;
  $6 = $6 + 1 | 0;
  if (($6 | 0) != 10) {
   continue;
  }
  break;
 }
 HEAP16[$10 + 224 >> 1] = 0;
 HEAP32[$10 + 192 >> 2] = 0;
 if (($9 | 0) < 1) {
  $20 = 0;
 } else {
  $20 = $8 << 16 >> 16;
  $8 = $9;
  $16 = 1;
  while (1) {
   $24 = $8;
   $8 = $8 - 1 | 0;
   label$8 : {
    label$9 : {
     label$10 : {
      $23 = ($16 | 0) < 1;
      label$11 : {
       if ($23) {
        break label$11;
       }
       $6 = $8 << 1;
       $22 = HEAP16[$6 + $4 >> 1] + $5 | 0;
       $12 = HEAPU16[$1 + $6 >> 1];
       $21 = HEAPU8[$3 + $8 | 0];
       $15 = HEAP16[$2 + $6 >> 1];
       $6 = 0;
       while (1) {
        $17 = ($10 + 224 | 0) + ($6 << 1) | 0;
        $13 = Math_imul(HEAP16[$17 >> 1], $21) >> 8;
        $11 = Math_imul($12 - $13 << 16 >> 16, $7) >> 16;
        $11 = ($11 | 0) > -10 ? $11 : -10;
        $11 = ($11 | 0) < 9 ? $11 : 9;
        HEAP8[(($10 + 240 | 0) + ($6 << 4) | 0) + $8 | 0] = $11;
        $14 = ($11 << 2) + 40 | 0;
        $18 = HEAP32[$14 + ($10 + 80 | 0) >> 2] + $13 | 0;
        HEAP16[$17 >> 1] = $18;
        $17 = $6 + $16 | 0;
        $13 = HEAP32[$10 + $14 >> 2] + $13 | 0;
        HEAP16[($10 + 224 | 0) + ($17 << 1) >> 1] = $13;
        label$13 : {
         if (($11 | 0) >= 3) {
          if (($11 | 0) == 3) {
           $19 = 280;
           $14 = HEAPU8[$22 + 7 | 0];
           break label$13;
          }
          $11 = Math_imul($11, 43);
          $19 = $11 + 151 | 0;
          $14 = $11 + 108 | 0;
          break label$13;
         }
         if (($11 | 0) <= -4) {
          if (($11 | 0) == -4) {
           $19 = HEAPU8[$22 + 1 | 0];
           $14 = 280;
           break label$13;
          }
          $11 = Math_imul($11, -43);
          $19 = $11 + 65 | 0;
          $14 = $11 + 108 | 0;
          break label$13;
         }
         $11 = $11 + $22 | 0;
         $19 = HEAPU8[$11 + 5 | 0];
         $14 = HEAPU8[$11 + 4 | 0];
        }
        $11 = ($10 + 192 | 0) + ($6 << 2) | 0;
        $25 = $11;
        $11 = HEAP32[$11 >> 2];
        $26 = $11 + Math_imul($20, $14) | 0;
        $14 = $12 - $18 << 16 >> 16;
        HEAP32[$25 >> 2] = $26 + Math_imul(Math_imul($14, $14), $15);
        $14 = Math_imul($19, $20) + $11 | 0;
        $11 = $12 - $13 << 16 >> 16;
        HEAP32[($10 + 192 | 0) + ($17 << 2) >> 2] = $14 + Math_imul(Math_imul($11, $11), $15);
        $6 = $6 + 1 | 0;
        if (($16 | 0) != ($6 | 0)) {
         continue;
        }
        break;
       }
       if (($16 | 0) >= 3) {
        $11 = 0;
        $6 = HEAP32[$10 + 208 >> 2];
        $12 = HEAP32[$10 + 192 >> 2];
        if (($6 | 0) < ($12 | 0)) {
         break label$10;
        }
        $15 = $6;
        $6 = $12;
        break label$9;
       }
       $6 = 0;
       if ($23) {
        break label$11;
       }
       while (1) {
        HEAP8[(($10 + 240 | 0) + ($6 + $16 << 4) | 0) + $8 | 0] = HEAPU8[(($10 + 240 | 0) + ($6 << 4) | 0) + $8 | 0] + 1;
        $6 = $6 + 1 | 0;
        if (($16 | 0) != ($6 | 0)) {
         continue;
        }
        break;
       }
      }
      $16 = $16 << 1;
      $6 = $16;
      if (($6 | 0) > 3) {
       break label$8;
      }
      while (1) {
       HEAP8[(($10 + 240 | 0) + ($6 << 4) | 0) + $8 | 0] = HEAPU8[(($10 + 240 | 0) + ($6 - $16 << 4) | 0) + $8 | 0];
       $6 = $6 + 1 | 0;
       if (($6 | 0) != 4) {
        continue;
       }
       break;
      }
      break label$8;
     }
     HEAP32[$10 + 208 >> 2] = $12;
     HEAP32[$10 + 192 >> 2] = $6;
     $11 = HEAPU16[$10 + 224 >> 1];
     HEAP16[$10 + 224 >> 1] = HEAPU16[$10 + 232 >> 1];
     HEAP16[$10 + 232 >> 1] = $11;
     $11 = 4;
     $15 = $12;
    }
    HEAP32[$10 + 176 >> 2] = $6;
    HEAP32[$10 + 160 >> 2] = $15;
    HEAP32[$10 + 304 >> 2] = $11;
    $12 = 1;
    $11 = HEAP32[$10 + 212 >> 2];
    $13 = HEAP32[$10 + 196 >> 2];
    label$21 : {
     if (($11 | 0) >= ($13 | 0)) {
      $17 = $11;
      $11 = $13;
      break label$21;
     }
     HEAP32[$10 + 212 >> 2] = $13;
     HEAP32[$10 + 196 >> 2] = $11;
     $12 = HEAPU16[$10 + 226 >> 1];
     HEAP16[$10 + 226 >> 1] = HEAPU16[$10 + 234 >> 1];
     HEAP16[$10 + 234 >> 1] = $12;
     $12 = 5;
     $17 = $13;
    }
    HEAP32[$10 + 180 >> 2] = $11;
    HEAP32[$10 + 164 >> 2] = $17;
    HEAP32[$10 + 308 >> 2] = $12;
    $12 = 2;
    $13 = HEAP32[$10 + 216 >> 2];
    $14 = HEAP32[$10 + 200 >> 2];
    label$23 : {
     if (($13 | 0) >= ($14 | 0)) {
      $18 = $13;
      $13 = $14;
      break label$23;
     }
     HEAP32[$10 + 216 >> 2] = $14;
     HEAP32[$10 + 200 >> 2] = $13;
     $12 = HEAPU16[$10 + 228 >> 1];
     HEAP16[$10 + 228 >> 1] = HEAPU16[$10 + 236 >> 1];
     HEAP16[$10 + 236 >> 1] = $12;
     $12 = 6;
     $18 = $14;
    }
    HEAP32[$10 + 184 >> 2] = $13;
    HEAP32[$10 + 168 >> 2] = $18;
    HEAP32[$10 + 312 >> 2] = $12;
    $19 = 3;
    $12 = HEAP32[$10 + 220 >> 2];
    $21 = HEAP32[$10 + 204 >> 2];
    label$25 : {
     if (($12 | 0) >= ($21 | 0)) {
      $14 = $12;
      $12 = $21;
      break label$25;
     }
     HEAP32[$10 + 220 >> 2] = $21;
     HEAP32[$10 + 204 >> 2] = $12;
     $14 = HEAPU16[$10 + 230 >> 1];
     HEAP16[$10 + 230 >> 1] = HEAPU16[$10 + 238 >> 1];
     HEAP16[$10 + 238 >> 1] = $14;
     $19 = 7;
     $14 = $21;
    }
    HEAP32[$10 + 188 >> 2] = $12;
    HEAP32[$10 + 172 >> 2] = $14;
    HEAP32[$10 + 316 >> 2] = $19;
    while (1) {
     $19 = ($15 | 0) > ($17 | 0);
     $15 = $19 ? $17 : $15;
     $17 = ($18 | 0) < ($15 | 0);
     $15 = $17 ? $18 : $15;
     $18 = ($14 | 0) < ($15 | 0);
     $21 = $18 ? $14 : $15;
     $6 = ($6 | 0) > 0 ? $6 : 0;
     $15 = ($11 | 0) > ($6 | 0);
     $6 = $15 ? $11 : $6;
     $11 = ($13 | 0) > ($6 | 0);
     $6 = $11 ? $13 : $6;
     $14 = $6;
     $6 = ($6 | 0) < ($12 | 0);
     if (($21 | 0) < (($6 ? $12 : $14) | 0)) {
      $6 = $6 ? 3 : $11 ? 2 : $15;
      $11 = $6 << 2;
      $12 = $18 ? 3 : $17 ? 2 : $19;
      $13 = $12 << 2;
      HEAP32[($11 | $10 + 304) >> 2] = HEAP32[($13 | $10 + 304) >> 2] ^ 4;
      $15 = $12 | 4;
      HEAP32[($10 + 192 | $11) >> 2] = HEAP32[($10 + 192 | 0) + ($15 << 2) >> 2];
      HEAP32[($10 + 176 | $11) >> 2] = 0;
      HEAP16[($10 + 224 | $6 << 1) >> 1] = HEAPU16[($10 + 224 | $15 << 1) >> 1];
      HEAP32[($10 + 160 | $13) >> 2] = 2147483647;
      $11 = ($10 + 240 | 0) + ($12 << 4) | 0;
      $14 = HEAP32[$11 >> 2];
      $12 = HEAP32[$11 + 4 >> 2];
      $6 = ($10 + 240 | 0) + ($6 << 4) | 0;
      HEAP32[$6 >> 2] = $14;
      HEAP32[$6 + 4 >> 2] = $12;
      $14 = HEAP32[$11 + 12 >> 2];
      $12 = HEAP32[$11 + 8 >> 2];
      HEAP32[$6 + 8 >> 2] = $12;
      HEAP32[$6 + 12 >> 2] = $14;
      $12 = HEAP32[$10 + 188 >> 2];
      $14 = HEAP32[$10 + 172 >> 2];
      $13 = HEAP32[$10 + 184 >> 2];
      $18 = HEAP32[$10 + 168 >> 2];
      $11 = HEAP32[$10 + 180 >> 2];
      $17 = HEAP32[$10 + 164 >> 2];
      $6 = HEAP32[$10 + 176 >> 2];
      $15 = HEAP32[$10 + 160 >> 2];
      continue;
     }
     break;
    }
    $6 = ($10 + 240 | 0) + $8 | 0;
    HEAP8[$6 | 0] = HEAPU8[$6 | 0] + (HEAP32[$10 + 304 >> 2] >>> 2 | 0);
    $11 = $6 + 16 | 0;
    HEAP8[$11 | 0] = HEAPU8[$6 + 16 | 0] + (HEAP32[$10 + 308 >> 2] >>> 2 | 0);
    $11 = $6 + 48 | 0;
    HEAP8[$11 | 0] = HEAPU8[$6 + 48 | 0] + (HEAP32[$10 + 316 >> 2] >>> 2 | 0);
    $14 = $6;
    $6 = $6 + 32 | 0;
    HEAP8[$6 | 0] = HEAPU8[$14 + 32 | 0] + (HEAP32[$10 + 312 >> 2] >>> 2 | 0);
   }
   if (($24 | 0) > 1) {
    continue;
   }
   break;
  }
  $6 = HEAP32[$10 + 220 >> 2];
  $11 = HEAP32[$10 + 216 >> 2];
  $16 = HEAP32[$10 + 212 >> 2];
  $12 = HEAP32[$10 + 208 >> 2];
  $13 = HEAP32[$10 + 204 >> 2];
  $8 = HEAP32[$10 + 200 >> 2];
  $15 = HEAP32[$10 + 196 >> 2];
  $20 = HEAP32[$10 + 192 >> 2];
 }
 $17 = ($20 | 0) > ($15 | 0);
 $15 = $17 ? $15 : $20;
 $20 = ($15 | 0) > ($8 | 0);
 $8 = $20 ? $8 : $15;
 $15 = ($13 | 0) < ($8 | 0);
 $13 = $15 ? $13 : $8;
 $8 = ($13 | 0) > ($12 | 0);
 $12 = $8 ? $12 : $13;
 $13 = ($16 | 0) < ($12 | 0);
 $16 = $13 ? $16 : $12;
 $12 = ($16 | 0) > ($11 | 0);
 $1 = $12 ? 6 : $13 ? 5 : $8 ? 4 : $15 ? 3 : $20 ? 2 : $17;
 $16 = $12 ? $11 : $16;
 $12 = ($16 | 0) > ($6 | 0);
 $11 = $12 ? 7 : $1;
 if (($9 | 0) > 0) {
  memcpy($0, ($10 + 240 | 0) + (($11 & 3) << 4) | 0, $9);
 }
 HEAP8[$0 | 0] = HEAPU8[$0 | 0] + ($11 >>> 2 | 0);
 __stack_pointer = $10 + 320 | 0;
 return $12 ? $6 : $16;
}
function silk_control_encoder($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 HEAP32[$0 + 6076 >> 2] = HEAP32[$1 + 48 >> 2];
 HEAP32[$0 + 4676 >> 2] = HEAP32[$1 + 52 >> 2];
 $6 = HEAP32[$1 + 8 >> 2];
 HEAP32[$0 + 4556 >> 2] = $6;
 HEAP32[$0 + 4564 >> 2] = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 4568 >> 2] = HEAP32[$1 + 16 >> 2];
 HEAP32[$0 + 4572 >> 2] = HEAP32[$1 + 20 >> 2];
 HEAP32[$0 + 6088 >> 2] = HEAP32[$1 + 40 >> 2];
 HEAP32[$0 + 5752 >> 2] = HEAP32[$1 >> 2];
 $5 = HEAP32[$1 + 4 >> 2];
 HEAP32[$0 + 5760 >> 2] = $3;
 HEAP32[$0 + 4536 >> 2] = $2;
 HEAP32[$0 + 5756 >> 2] = $5;
 label$1 : {
  label$2 : {
   if (!(HEAP32[$0 + 4680 >> 2] | !HEAP32[$0 + 4668 >> 2])) {
    $1 = 0;
    if (HEAP32[$0 + 4560 >> 2] == ($6 | 0)) {
     break label$2;
    }
    $4 = HEAP32[$0 + 4576 >> 2];
    if (($4 | 0) < 1) {
     break label$2;
    }
    return silk_setup_resamplers($0, $4);
   }
   $4 = (wasm2js_i32$0 = $4, wasm2js_i32$1 = silk_control_audio_bandwidth($0, $1), wasm2js_i32$2 = $4, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
   $8 = silk_setup_resamplers($0, $4);
   $6 = 0;
   $2 = HEAP32[$1 + 24 >> 2];
   if (($2 | 0) != HEAP32[$0 + 4612 >> 2]) {
    label$5 : {
     label$6 : {
      switch ($2 - 10 | 0) {
      default:
       if (($2 | 0) == 40 | ($2 | 0) == 60) {
        break label$5;
       }
       break;
      case 0:
      case 10:
       break label$5;
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
       break label$6;
      }
     }
     $6 = -103;
    }
    label$8 : {
     if (($2 | 0) <= 10) {
      HEAP32[$0 + 5744 >> 2] = 1;
      HEAP32[$0 + 4580 >> 2] = ($2 | 0) == 10 ? 2 : 1;
      $3 = $4 << 16 >> 16;
      HEAP32[$0 + 4584 >> 2] = Math_imul($3, $2 << 16 >> 16);
      HEAP32[$0 + 4548 >> 2] = Math_imul($3, 14);
      if (HEAP32[$0 + 4576 >> 2] == 8) {
       HEAP32[$0 + 4688 >> 2] = 2169;
       break label$8;
      }
      HEAP32[$0 + 4688 >> 2] = 2157;
      break label$8;
     }
     HEAP32[$0 + 4580 >> 2] = 4;
     HEAP32[$0 + 5744 >> 2] = ($2 >>> 0) / 20;
     $3 = $4 << 16 >> 16;
     HEAP32[$0 + 4584 >> 2] = Math_imul($3, 20);
     HEAP32[$0 + 4548 >> 2] = Math_imul($3, 24);
     if (HEAP32[$0 + 4576 >> 2] == 8) {
      HEAP32[$0 + 4688 >> 2] = 2146;
      break label$8;
     }
     HEAP32[$0 + 4688 >> 2] = 2112;
    }
    HEAP32[$0 + 4608 >> 2] = 0;
    HEAP32[$0 + 4612 >> 2] = $2;
   }
   label$12 : {
    label$13 : {
     label$14 : {
      label$15 : {
       if (!(!(1 << $4 & 69888) | $4 >>> 0 > 16)) {
        label$17 : {
         label$18 : {
          $2 = HEAP32[$0 + 4580 >> 2];
          switch ($2 - 2 | 0) {
          case 0:
          case 2:
           break label$17;
          default:
           break label$18;
          }
         }
         celt_fatal(6692, 6671, 242);
         abort();
        }
        label$19 : {
         if (HEAP32[$0 + 4576 >> 2] == ($4 | 0)) {
          $5 = HEAP32[$0 + 4584 >> 2];
          $3 = HEAP32[$0 + 4588 >> 2];
          break label$19;
         }
         HEAP32[$0 + 7168 >> 2] = 0;
         HEAP32[$0 + 7172 >> 2] = 0;
         HEAP32[$0 + 5748 >> 2] = 0;
         HEAP32[$0 + 5740 >> 2] = 0;
         HEAP32[$0 + 16 >> 2] = 0;
         HEAP32[$0 + 20 >> 2] = 0;
         HEAP32[$0 + 4608 >> 2] = 0;
         HEAP32[$0 + 7176 >> 2] = 0;
         memset($0 + 148 | 0, 0, 4384);
         $3 = 10;
         HEAP8[$0 + 7168 | 0] = 10;
         HEAP32[$0 + 4664 >> 2] = 1;
         HEAP32[$0 + 4544 >> 2] = 100;
         HEAP32[$0 + 4576 >> 2] = $4;
         HEAP8[$0 + 4541 | 0] = 0;
         HEAP32[$0 + 4492 >> 2] = 65536;
         HEAP32[$0 + 4476 >> 2] = 100;
         label$21 : {
          if (($4 | 0) == 8) {
           HEAP32[$0 + 4688 >> 2] = ($2 | 0) == 4 ? 2146 : 2169;
           $5 = 3576;
           break label$21;
          }
          HEAP32[$0 + 4688 >> 2] = ($2 | 0) == 4 ? 2112 : 2157;
          $3 = ($4 | 0) == 12;
          $5 = $3 ? 3576 : 5700;
          $3 = $3 ? 10 : 16;
         }
         HEAP32[$0 + 4692 >> 2] = $5;
         HEAP32[$0 + 4640 >> 2] = $3;
         $3 = Math_imul($4, 5);
         HEAP32[$0 + 4588 >> 2] = $3;
         HEAP32[$0 + 4596 >> 2] = $4 << 1;
         HEAP32[$0 + 4592 >> 2] = Math_imul($4, 20);
         HEAP32[$0 + 4552 >> 2] = Math_imul($4, 18);
         $5 = Math_imul(Math_imul($4, 327680) >> 16, $2);
         HEAP32[$0 + 4584 >> 2] = $5;
         HEAP32[$0 + 4548 >> 2] = Math_imul(($2 | 0) == 4 ? 24 : 14, $4);
         if (($4 | 0) == 16) {
          HEAP32[$0 + 4684 >> 2] = 5872;
          $3 = 80;
          break label$19;
         }
         if (($4 | 0) == 12) {
          HEAP32[$0 + 4684 >> 2] = 5866;
          $3 = 60;
          break label$19;
         }
         HEAP32[$0 + 4684 >> 2] = 5857;
        }
        if ((Math_imul($2, $3) | 0) != ($5 | 0)) {
         break label$15;
        }
        $2 = HEAP32[$1 + 36 >> 2];
        if ($2 >>> 0 >= 11) {
         break label$14;
        }
        label$25 : {
         $3 = $0;
         label$26 : {
          if (!$2) {
           HEAP32[$0 + 4652 >> 2] = 52429;
           HEAP32[$0 + 4644 >> 2] = 0;
           HEAP32[$0 + 4648 >> 2] = 6;
           HEAP32[$0 + 4636 >> 2] = 12;
           HEAP32[$0 + 4660 >> 2] = 2;
           HEAP32[$0 + 4628 >> 2] = 1;
           HEAP32[$0 + 4632 >> 2] = 0;
           $5 = Math_imul($4, 3);
           break label$26;
          }
          if (($2 | 0) <= 1) {
           HEAP32[$0 + 4652 >> 2] = 49807;
           HEAP32[$0 + 4644 >> 2] = 1;
           HEAP32[$0 + 4648 >> 2] = 8;
           HEAP32[$0 + 4636 >> 2] = 14;
           HEAP32[$0 + 4660 >> 2] = 3;
           HEAP32[$0 + 4628 >> 2] = 1;
           HEAP32[$0 + 4632 >> 2] = 0;
           break label$13;
          }
          if (($2 | 0) != 2) {
           break label$25;
          }
          HEAP32[$0 + 4652 >> 2] = 52429;
          HEAP32[$0 + 4644 >> 2] = 0;
          HEAP32[$0 + 4648 >> 2] = 6;
          HEAP32[$0 + 4636 >> 2] = 12;
          HEAP32[$0 + 4660 >> 2] = 2;
          HEAP32[$0 + 4628 >> 2] = 2;
          HEAP32[$0 + 4632 >> 2] = 0;
          $5 = Math_imul($4, 3);
         }
         HEAP32[$3 + 4600 >> 2] = $5;
         $3 = 6;
         break label$12;
        }
        if (($2 | 0) <= 3) {
         HEAP32[$0 + 4652 >> 2] = 49807;
         HEAP32[$0 + 4644 >> 2] = 1;
         HEAP32[$0 + 4648 >> 2] = 8;
         HEAP32[$0 + 4636 >> 2] = 14;
         HEAP32[$0 + 4660 >> 2] = 4;
         HEAP32[$0 + 4628 >> 2] = 2;
         HEAP32[$0 + 4632 >> 2] = 0;
         break label$13;
        }
        if (($2 | 0) <= 5) {
         HEAP32[$0 + 4652 >> 2] = 48497;
         HEAP32[$0 + 4644 >> 2] = 1;
         HEAP32[$0 + 4648 >> 2] = 10;
         HEAP32[$0 + 4636 >> 2] = 16;
         HEAP32[$0 + 4660 >> 2] = 6;
         HEAP32[$0 + 4628 >> 2] = 2;
         HEAP32[$0 + 4632 >> 2] = 1;
         $5 = Math_imul($4, 5);
         HEAP32[$0 + 4600 >> 2] = $5;
         $7 = Math_imul($4, 983);
         $3 = 10;
         break label$12;
        }
        if (($2 | 0) <= 7) {
         HEAP32[$0 + 4652 >> 2] = 47186;
         HEAP32[$0 + 4644 >> 2] = 1;
         HEAP32[$0 + 4648 >> 2] = 12;
         HEAP32[$0 + 4636 >> 2] = 20;
         HEAP32[$0 + 4660 >> 2] = 8;
         HEAP32[$0 + 4628 >> 2] = 3;
         HEAP32[$0 + 4632 >> 2] = 1;
         $5 = Math_imul($4, 5);
         HEAP32[$0 + 4600 >> 2] = $5;
         $7 = Math_imul($4, 983);
         $3 = 12;
         break label$12;
        }
        HEAP32[$0 + 4652 >> 2] = 45875;
        HEAP32[$0 + 4644 >> 2] = 2;
        HEAP32[$0 + 4648 >> 2] = 16;
        HEAP32[$0 + 4636 >> 2] = 24;
        HEAP32[$0 + 4660 >> 2] = 16;
        HEAP32[$0 + 4628 >> 2] = 4;
        HEAP32[$0 + 4632 >> 2] = 1;
        $5 = Math_imul($4, 5);
        HEAP32[$0 + 4600 >> 2] = $5;
        $7 = Math_imul($4, 983);
        $3 = 16;
        break label$12;
       }
       celt_fatal(6609, 6671, 241);
       abort();
      }
      celt_fatal(6765, 6671, 302);
      abort();
     }
     celt_fatal(6863, 6671, 315);
     abort();
    }
    $5 = Math_imul($4, 5);
    HEAP32[$0 + 4600 >> 2] = $5;
    $3 = 8;
   }
   HEAP32[$0 + 4672 >> 2] = $7;
   HEAP32[$0 + 4624 >> 2] = $2;
   HEAP32[$0 + 4604 >> 2] = Math_imul($4, 5) + ($5 << 1);
   $4 = HEAP32[$0 + 4640 >> 2];
   $4 = ($3 | 0) < ($4 | 0) ? $3 : $4;
   HEAP32[$0 + 4648 >> 2] = $4;
   if (($4 | 0) >= 17) {
    break label$1;
   }
   $4 = HEAP32[$1 + 32 >> 2];
   HEAP32[$0 + 4616 >> 2] = $4;
   $2 = HEAP32[$0 + 6092 >> 2];
   $1 = HEAP32[$1 + 44 >> 2];
   HEAP32[$0 + 6092 >> 2] = $1;
   if ($1) {
    $3 = $0;
    if ($2) {
     $1 = (Math_imul($4 >> 16, -26214) - (Math_imul($4 & 65535, 26214) >>> 16 | 0) | 0) + 7 | 0;
     $1 = ($1 | 0) > 2 ? $1 : 2;
    } else {
     $1 = 7;
    }
    HEAP32[$3 + 6096 >> 2] = $1;
   }
   $1 = $6 + $8 | 0;
   HEAP32[$0 + 4668 >> 2] = 1;
  }
  return $1;
 }
 celt_fatal(6917, 6671, 393);
 abort();
}
function silk_encode_pulses($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 $10 = $5;
 HEAP32[$5 + 24 >> 2] = 0;
 HEAP32[$5 + 28 >> 2] = 0;
 HEAP32[$5 + 16 >> 2] = 0;
 HEAP32[$5 + 20 >> 2] = 0;
 HEAP32[$5 + 8 >> 2] = 0;
 HEAP32[$5 + 12 >> 2] = 0;
 HEAP32[$5 >> 2] = 0;
 HEAP32[$5 + 4 >> 2] = 0;
 label$1 : {
  label$2 : {
   label$3 : {
    $7 = $4 & -16;
    if (($7 | 0) < ($4 | 0)) {
     if (($4 | 0) != 120) {
      break label$3;
     }
     HEAP8[$3 + 120 | 0] = 0;
     HEAP8[$3 + 121 | 0] = 0;
     HEAP8[$3 + 122 | 0] = 0;
     HEAP8[$3 + 123 | 0] = 0;
     HEAP8[$3 + 124 | 0] = 0;
     HEAP8[$3 + 125 | 0] = 0;
     HEAP8[$3 + 126 | 0] = 0;
     HEAP8[$3 + 127 | 0] = 0;
     $7 = 128;
     HEAP8[$3 + 128 | 0] = 0;
     HEAP8[$3 + 129 | 0] = 0;
     HEAP8[$3 + 130 | 0] = 0;
     HEAP8[$3 + 131 | 0] = 0;
     HEAP8[$3 + 132 | 0] = 0;
     HEAP8[$3 + 133 | 0] = 0;
     HEAP8[$3 + 134 | 0] = 0;
     HEAP8[$3 + 135 | 0] = 0;
     $15 = $5 - 512 | 0;
     $8 = $15;
     __stack_pointer = $8;
     $17 = 8;
     break label$2;
    }
    $17 = $4 >> 4;
    $15 = $5 - ($7 << 2) | 0;
    $8 = $15;
    __stack_pointer = $8;
    if (($4 | 0) > 15) {
     break label$2;
    }
    $5 = ($17 << 2) + 15 & -16;
    $16 = $8 - $5 | 0;
    $6 = $16;
    __stack_pointer = $6;
    $19 = $6 - $5 | 0;
    __stack_pointer = $19;
    break label$1;
   }
   celt_fatal(9312, 9354, 89);
   abort();
  }
  $5 = 0;
  while (1) {
   $6 = HEAP8[$3 + $5 | 0];
   $9 = $6;
   $6 = $6 >> 31;
   HEAP32[($5 << 2) + $15 >> 2] = $6 ^ $6 + $9;
   $6 = $5 | 1;
   $11 = ($6 << 2) + $15 | 0;
   $6 = HEAP8[$3 + $6 | 0];
   $9 = $6;
   $6 = $6 >> 31;
   HEAP32[$11 >> 2] = $6 ^ $6 + $9;
   $6 = $5 | 2;
   $11 = ($6 << 2) + $15 | 0;
   $6 = HEAP8[$3 + $6 | 0];
   $9 = $6;
   $6 = $6 >> 31;
   HEAP32[$11 >> 2] = $6 ^ $6 + $9;
   $6 = $5 | 3;
   $11 = ($6 << 2) + $15 | 0;
   $6 = HEAP8[$3 + $6 | 0];
   $9 = $6;
   $6 = $6 >> 31;
   HEAP32[$11 >> 2] = $6 ^ $6 + $9;
   $5 = $5 + 4 | 0;
   if (($7 | 0) > ($5 | 0)) {
    continue;
   }
   break;
  }
  $5 = ($17 << 2) + 15 & -16;
  $16 = $8 - $5 | 0;
  $6 = $16;
  __stack_pointer = $6;
  $19 = $6 - $5 | 0;
  __stack_pointer = $19;
  $24 = HEAPU8[8120];
  $23 = HEAPU8[8119];
  $20 = HEAPU8[8118];
  $14 = HEAPU8[8117];
  $6 = 0;
  $5 = $15;
  while (1) {
   $7 = $22 << 2;
   $18 = $19 + $7 | 0;
   HEAP32[$18 >> 2] = 0;
   $25 = $7 + $16 | 0;
   $7 = HEAP32[$5 + 4 >> 2];
   $8 = HEAP32[$5 >> 2];
   while (1) {
    $13 = 1;
    label$8 : {
     label$9 : {
      $7 = $7 + $8 | 0;
      if (($14 | 0) < ($7 | 0)) {
       $9 = $12;
       $7 = $6;
       break label$9;
      }
      HEAP32[$10 >> 2] = $7;
      $9 = HEAP32[$5 + 12 >> 2] + HEAP32[$5 + 8 >> 2] | 0;
      if (($14 | 0) < ($9 | 0)) {
       $9 = $12;
       break label$9;
      }
      HEAP32[$10 + 4 >> 2] = $9;
      $6 = HEAP32[$5 + 20 >> 2] + HEAP32[$5 + 16 >> 2] | 0;
      if (($14 | 0) < ($6 | 0)) {
       break label$9;
      }
      HEAP32[$10 + 8 >> 2] = $6;
      $6 = HEAP32[$5 + 28 >> 2] + HEAP32[$5 + 24 >> 2] | 0;
      if (($14 | 0) < ($6 | 0)) {
       break label$9;
      }
      HEAP32[$10 + 12 >> 2] = $6;
      $6 = HEAP32[$5 + 36 >> 2] + HEAP32[$5 + 32 >> 2] | 0;
      if (($14 | 0) < ($6 | 0)) {
       break label$9;
      }
      HEAP32[$10 + 16 >> 2] = $6;
      $6 = HEAP32[$5 + 44 >> 2] + HEAP32[$5 + 40 >> 2] | 0;
      if (($14 | 0) < ($6 | 0)) {
       break label$9;
      }
      HEAP32[$10 + 20 >> 2] = $6;
      $6 = HEAP32[$5 + 52 >> 2] + HEAP32[$5 + 48 >> 2] | 0;
      if (($14 | 0) < ($6 | 0)) {
       break label$9;
      }
      HEAP32[$10 + 24 >> 2] = $6;
      $6 = HEAP32[$5 + 60 >> 2] + HEAP32[$5 + 56 >> 2] | 0;
      if (($14 | 0) < ($6 | 0)) {
       break label$9;
      }
      HEAP32[$10 + 28 >> 2] = $6;
      $21 = 0;
      break label$8;
     }
     $21 = 1;
    }
    $8 = $7 + $9 | 0;
    label$12 : {
     if (($20 | 0) < ($8 | 0)) {
      $11 = $9;
      $8 = $7;
      break label$12;
     }
     HEAP32[$10 >> 2] = $8;
     $11 = HEAP32[$10 + 12 >> 2] + HEAP32[$10 + 8 >> 2] | 0;
     if (($20 | 0) < ($11 | 0)) {
      $11 = $9;
      break label$12;
     }
     HEAP32[$10 + 4 >> 2] = $11;
     $6 = HEAP32[$10 + 20 >> 2] + HEAP32[$10 + 16 >> 2] | 0;
     if (($20 | 0) < ($6 | 0)) {
      break label$12;
     }
     HEAP32[$10 + 8 >> 2] = $6;
     $6 = HEAP32[$10 + 28 >> 2] + HEAP32[$10 + 24 >> 2] | 0;
     if (($20 | 0) < ($6 | 0)) {
      break label$12;
     }
     HEAP32[$10 + 12 >> 2] = $6;
     $13 = 0;
    }
    $7 = -1;
    $6 = $8 + $11 | 0;
    label$15 : {
     if (($23 | 0) < ($6 | 0)) {
      $12 = $11;
      $6 = $8;
      break label$15;
     }
     HEAP32[$10 >> 2] = $6;
     $12 = HEAP32[$10 + 12 >> 2] + HEAP32[$10 + 8 >> 2] | 0;
     if (($23 | 0) < ($12 | 0)) {
      $12 = $11;
      break label$15;
     }
     HEAP32[$10 + 4 >> 2] = $12;
     $7 = 0;
    }
    $8 = $13 + $21 | 0;
    label$18 : {
     $9 = $6 + $12 | 0;
     if (($24 | 0) >= ($9 | 0)) {
      HEAP32[$25 >> 2] = $9;
      if (($7 | 0) == ($8 | 0)) {
       break label$18;
      }
     }
     HEAP32[$18 >> 2] = HEAP32[$18 >> 2] + 1;
     $8 = HEAP32[$5 >> 2] >> 1;
     HEAP32[$5 >> 2] = $8;
     $7 = HEAP32[$5 + 4 >> 2] >> 1;
     HEAP32[$5 + 4 >> 2] = $7;
     HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] >> 1;
     HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] >> 1;
     HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] >> 1;
     HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] >> 1;
     HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 24 >> 2] >> 1;
     HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] >> 1;
     HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 32 >> 2] >> 1;
     HEAP32[$5 + 36 >> 2] = HEAP32[$5 + 36 >> 2] >> 1;
     HEAP32[$5 + 40 >> 2] = HEAP32[$5 + 40 >> 2] >> 1;
     HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 44 >> 2] >> 1;
     HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 48 >> 2] >> 1;
     HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 52 >> 2] >> 1;
     HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 56 >> 2] >> 1;
     HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 60 >> 2] >> 1;
     continue;
    }
    break;
   }
   $5 = $5 - -64 | 0;
   $18 = 1;
   $22 = $22 + 1 | 0;
   if (($22 | 0) != ($17 | 0)) {
    continue;
   }
   break;
  }
 }
 $13 = 2147483647;
 $20 = $1 >> 1;
 $14 = Math_imul($20, 9);
 $11 = 0;
 $21 = 0;
 while (1) {
  $7 = HEAPU8[($11 + $14 | 0) + 8528 | 0];
  if ($18) {
   $9 = Math_imul($11, 18);
   $12 = $9 + 8337 | 0;
   $5 = 0;
   while (1) {
    $6 = $12;
    $8 = $5 << 2;
    if (HEAP32[$19 + $8 >> 2] <= 0) {
     $6 = (HEAP32[$8 + $16 >> 2] + $9 | 0) + 8320 | 0;
    }
    $7 = HEAPU8[$6 | 0] + $7 | 0;
    $5 = $5 + 1 | 0;
    if (($17 | 0) != ($5 | 0)) {
     continue;
    }
    break;
   }
  }
  $5 = ($7 | 0) < ($13 | 0);
  $21 = $5 ? $11 : $21;
  $13 = $5 ? $7 : $13;
  $11 = $11 + 1 | 0;
  if (($11 | 0) != 9) {
   continue;
  }
  break;
 }
 ec_enc_icdf($0, $21, Math_imul($20, 9) + 8496 | 0, 8);
 label$24 : {
  if (!$18) {
   break label$24;
  }
  $12 = Math_imul($21, 18) + 8128 | 0;
  $7 = 0;
  while (1) {
   $8 = $7 << 2;
   $5 = HEAP32[$19 + $8 >> 2];
   label$26 : {
    if (!$5) {
     ec_enc_icdf($0, HEAP32[$8 + $16 >> 2], $12, 8);
     break label$26;
    }
    ec_enc_icdf($0, 17, $12, 8);
    if (($5 | 0) >= 2) {
     $6 = $5 - 1 | 0;
     $5 = 0;
     while (1) {
      ec_enc_icdf($0, 17, 8290, 8);
      $5 = $5 + 1 | 0;
      if (($6 | 0) != ($5 | 0)) {
       continue;
      }
      break;
     }
    }
    ec_enc_icdf($0, HEAP32[$8 + $16 >> 2], 8290, 8);
   }
   $7 = $7 + 1 | 0;
   if (($17 | 0) != ($7 | 0)) {
    continue;
   }
   break;
  }
  if (!$18) {
   break label$24;
  }
  $5 = 0;
  while (1) {
   if (HEAP32[($5 << 2) + $16 >> 2] >= 1) {
    silk_shell_encoder($0, ($5 << 6) + $15 | 0);
   }
   $5 = $5 + 1 | 0;
   if (($17 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
  if (!$18) {
   break label$24;
  }
  $13 = 0;
  while (1) {
   $9 = HEAP32[($13 << 2) + $19 >> 2];
   if (($9 | 0) >= 1) {
    $11 = ($13 << 4) + $3 | 0;
    $12 = 0;
    while (1) {
     $5 = HEAP8[$12 + $11 | 0];
     $6 = $5;
     $5 = $5 >> 31;
     $8 = ($5 ^ $5 + $6) << 24 >> 24;
     $5 = $9;
     if (($5 | 0) != 1) {
      while (1) {
       $6 = $5 - 1 | 0;
       ec_enc_icdf($0, $8 >>> $6 & 1, 5824, 8);
       $7 = ($5 | 0) > 2;
       $5 = $6;
       if ($7) {
        continue;
       }
       break;
      }
     }
     ec_enc_icdf($0, $8 & 1, 5824, 8);
     $12 = $12 + 1 | 0;
     if (($12 | 0) != 16) {
      continue;
     }
     break;
    }
   }
   $13 = $13 + 1 | 0;
   if (($17 | 0) != ($13 | 0)) {
    continue;
   }
   break;
  }
 }
 silk_encode_signs($0, $3, $4, $1, $2, $16);
 __stack_pointer = $10 + 32 | 0;
}
function compute_gru($0, $1, $2) {
 var $3 = Math_fround(0), $4 = 0, $5 = 0, $6 = Math_fround(0), $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = Math_fround(0), $17 = Math_fround(0);
 $9 = __stack_pointer - 512 | 0;
 __stack_pointer = $9;
 $7 = HEAP32[$0 + 16 >> 2];
 label$1 : {
  if (($7 | 0) < 1) {
   break label$1;
  }
  $10 = Math_imul($7, 3);
  $13 = HEAP32[$0 + 12 >> 2];
  $5 = HEAP32[$0 >> 2];
  while (1) {
   HEAPF32[($9 + 256 | 0) + ($4 << 2) >> 2] = HEAP8[$4 + $5 | 0];
   $4 = $4 + 1 | 0;
   if (($7 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
  if (($7 | 0) < 1) {
   break label$1;
  }
  $14 = HEAP32[$0 + 4 >> 2];
  $5 = 0;
  $8 = ($13 | 0) < 1;
  while (1) {
   if (!$8) {
    $12 = ($9 + 256 | 0) + ($5 << 2) | 0;
    $3 = HEAPF32[$12 >> 2];
    $4 = 0;
    while (1) {
     $3 = Math_fround($3 + Math_fround(HEAPF32[($4 << 2) + $2 >> 2] * Math_fround(HEAP8[(Math_imul($4, $10) + $5 | 0) + $14 | 0])));
     $4 = $4 + 1 | 0;
     if (($13 | 0) != ($4 | 0)) {
      continue;
     }
     break;
    }
    HEAPF32[$12 >> 2] = $3;
   }
   $5 = $5 + 1 | 0;
   if (($7 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
  $12 = HEAP32[$0 + 8 >> 2];
  $5 = 0;
  while (1) {
   $8 = ($9 + 256 | 0) + ($5 << 2) | 0;
   $3 = HEAPF32[$8 >> 2];
   $4 = 0;
   while (1) {
    $3 = Math_fround($3 + Math_fround(HEAPF32[($4 << 2) + $1 >> 2] * Math_fround(HEAP8[(Math_imul($4, $10) + $5 | 0) + $12 | 0])));
    $4 = $4 + 1 | 0;
    if (($7 | 0) != ($4 | 0)) {
     continue;
    }
    break;
   }
   HEAPF32[$8 >> 2] = $3;
   $5 = $5 + 1 | 0;
   if (($7 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
  $4 = 0;
  if (($7 | 0) <= 0) {
   break label$1;
  }
  while (1) {
   $3 = Math_fround(1);
   $5 = ($9 + 256 | 0) + ($4 << 2) | 0;
   $6 = Math_fround(Math_fround(HEAPF32[$5 >> 2] * Math_fround(.0078125)) * Math_fround(.5));
   label$9 : {
    if ($6 < Math_fround(8) ^ 1) {
     break label$9;
    }
    $3 = Math_fround(0);
    if ($6 > Math_fround(-8) ^ 1) {
     break label$9;
    }
    $3 = Math_fround(.5);
    if ($6 != $6) {
     break label$9;
    }
    $11 = $6 < Math_fround(0);
    $6 = $11 ? Math_fround(-$6) : $6;
    $3 = Math_fround(Math_floor(Math_fround(Math_fround($6 * Math_fround(25)) + Math_fround(.5))));
    label$10 : {
     if (Math_fround(Math_abs($3)) < Math_fround(2147483648)) {
      $8 = ~~$3;
      break label$10;
     }
     $8 = -2147483648;
    }
    $3 = HEAPF32[($8 << 2) + 48128 >> 2];
    $6 = Math_fround($6 + Math_fround(Math_fround($8 | 0) * Math_fround(-.03999999910593033)));
    $3 = Math_fround($3 + Math_fround(Math_fround(Math_fround(1) - Math_fround($3 * $6)) * Math_fround($6 * Math_fround(Math_fround(1) - Math_fround($3 * $3)))));
    $3 = Math_fround(Math_fround(($11 ? Math_fround(-$3) : $3) * Math_fround(.5)) + Math_fround(.5));
   }
   HEAPF32[$5 >> 2] = $3;
   $4 = $4 + 1 | 0;
   if (($7 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
  if (($7 | 0) < 1) {
   break label$1;
  }
  $5 = HEAP32[$0 >> 2];
  $4 = 0;
  while (1) {
   HEAPF32[($9 + 128 | 0) + ($4 << 2) >> 2] = HEAP8[($4 + $7 | 0) + $5 | 0];
   $4 = $4 + 1 | 0;
   if (($7 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
  if (($7 | 0) < 1) {
   break label$1;
  }
  $8 = $7 + $14 | 0;
  $5 = 0;
  $15 = ($13 | 0) < 1;
  while (1) {
   if (!$15) {
    $11 = ($9 + 128 | 0) + ($5 << 2) | 0;
    $3 = HEAPF32[$11 >> 2];
    $4 = 0;
    while (1) {
     $3 = Math_fround($3 + Math_fround(HEAPF32[($4 << 2) + $2 >> 2] * Math_fround(HEAP8[(Math_imul($4, $10) + $5 | 0) + $8 | 0])));
     $4 = $4 + 1 | 0;
     if (($13 | 0) != ($4 | 0)) {
      continue;
     }
     break;
    }
    HEAPF32[$11 >> 2] = $3;
   }
   $5 = $5 + 1 | 0;
   if (($7 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
  $8 = $7 + $12 | 0;
  $5 = 0;
  while (1) {
   $11 = ($9 + 128 | 0) + ($5 << 2) | 0;
   $3 = HEAPF32[$11 >> 2];
   $4 = 0;
   while (1) {
    $3 = Math_fround($3 + Math_fround(HEAPF32[($4 << 2) + $1 >> 2] * Math_fround(HEAP8[(Math_imul($4, $10) + $5 | 0) + $8 | 0])));
    $4 = $4 + 1 | 0;
    if (($7 | 0) != ($4 | 0)) {
     continue;
    }
    break;
   }
   HEAPF32[$11 >> 2] = $3;
   $5 = $5 + 1 | 0;
   if (($7 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
  $4 = 0;
  if (($7 | 0) <= 0) {
   break label$1;
  }
  while (1) {
   $3 = Math_fround(1);
   $5 = ($9 + 128 | 0) + ($4 << 2) | 0;
   $6 = Math_fround(Math_fround(HEAPF32[$5 >> 2] * Math_fround(.0078125)) * Math_fround(.5));
   label$19 : {
    if ($6 < Math_fround(8) ^ 1) {
     break label$19;
    }
    $3 = Math_fround(0);
    if ($6 > Math_fround(-8) ^ 1) {
     break label$19;
    }
    $3 = Math_fround(.5);
    if ($6 != $6) {
     break label$19;
    }
    $11 = $6 < Math_fround(0);
    $6 = $11 ? Math_fround(-$6) : $6;
    $3 = Math_fround(Math_floor(Math_fround(Math_fround($6 * Math_fround(25)) + Math_fround(.5))));
    label$20 : {
     if (Math_fround(Math_abs($3)) < Math_fround(2147483648)) {
      $8 = ~~$3;
      break label$20;
     }
     $8 = -2147483648;
    }
    $3 = HEAPF32[($8 << 2) + 48128 >> 2];
    $6 = Math_fround($6 + Math_fround(Math_fround($8 | 0) * Math_fround(-.03999999910593033)));
    $3 = Math_fround($3 + Math_fround(Math_fround(Math_fround(1) - Math_fround($3 * $6)) * Math_fround($6 * Math_fround(Math_fround(1) - Math_fround($3 * $3)))));
    $3 = Math_fround(Math_fround(($11 ? Math_fround(-$3) : $3) * Math_fround(.5)) + Math_fround(.5));
   }
   HEAPF32[$5 >> 2] = $3;
   $4 = $4 + 1 | 0;
   if (($7 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
  if (($7 | 0) < 1) {
   break label$1;
  }
  $5 = $7 << 1;
  $8 = HEAP32[$0 >> 2];
  $4 = 0;
  while (1) {
   HEAPF32[($4 << 2) + $9 >> 2] = HEAP8[($4 + $5 | 0) + $8 | 0];
   $4 = $4 + 1 | 0;
   if (($7 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
  $4 = 0;
  if (($7 | 0) <= 0) {
   break label$1;
  }
  while (1) {
   $5 = $4 << 2;
   HEAPF32[$5 + ($9 + 384 | 0) >> 2] = HEAPF32[$1 + $5 >> 2] * HEAPF32[($9 + 128 | 0) + $5 >> 2];
   $4 = $4 + 1 | 0;
   if (($7 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
  if (($7 | 0) < 1) {
   break label$1;
  }
  $0 = $7 << 1;
  $14 = $14 + $0 | 0;
  $5 = 0;
  $11 = ($13 | 0) < 1;
  while (1) {
   if (!$11) {
    $8 = ($5 << 2) + $9 | 0;
    $3 = HEAPF32[$8 >> 2];
    $4 = 0;
    while (1) {
     $3 = Math_fround($3 + Math_fround(HEAPF32[($4 << 2) + $2 >> 2] * Math_fround(HEAP8[(Math_imul($4, $10) + $5 | 0) + $14 | 0])));
     $4 = $4 + 1 | 0;
     if (($13 | 0) != ($4 | 0)) {
      continue;
     }
     break;
    }
    HEAPF32[$8 >> 2] = $3;
   }
   $5 = $5 + 1 | 0;
   if (($7 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
  $12 = $0 + $12 | 0;
  $5 = 0;
  while (1) {
   $13 = ($5 << 2) + $9 | 0;
   $3 = HEAPF32[$13 >> 2];
   $4 = 0;
   while (1) {
    $3 = Math_fround($3 + Math_fround(HEAPF32[($9 + 384 | 0) + ($4 << 2) >> 2] * Math_fround(HEAP8[(Math_imul($4, $10) + $5 | 0) + $12 | 0])));
    $4 = $4 + 1 | 0;
    if (($7 | 0) != ($4 | 0)) {
     continue;
    }
    break;
   }
   HEAPF32[$13 >> 2] = $3;
   $5 = $5 + 1 | 0;
   if (($7 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
  $4 = 0;
  if (($7 | 0) <= 0) {
   break label$1;
  }
  while (1) {
   $10 = $4 << 2;
   $3 = HEAPF32[$10 + ($9 + 256 | 0) >> 2];
   $16 = Math_fround($3 * HEAPF32[$1 + $10 >> 2]);
   $17 = Math_fround(Math_fround(1) - $3);
   $3 = Math_fround(1);
   $10 = $9 + $10 | 0;
   $6 = Math_fround(HEAPF32[$10 >> 2] * Math_fround(.0078125));
   label$30 : {
    if ($6 < Math_fround(8) ^ 1) {
     break label$30;
    }
    $3 = Math_fround(-1);
    if ($6 > Math_fround(-8) ^ 1) {
     break label$30;
    }
    $3 = Math_fround(0);
    if ($6 != $6) {
     break label$30;
    }
    $12 = $6 < Math_fround(0);
    $6 = $12 ? Math_fround(-$6) : $6;
    $3 = Math_fround(Math_floor(Math_fround(Math_fround($6 * Math_fround(25)) + Math_fround(.5))));
    label$31 : {
     if (Math_fround(Math_abs($3)) < Math_fround(2147483648)) {
      $5 = ~~$3;
      break label$31;
     }
     $5 = -2147483648;
    }
    $3 = HEAPF32[($5 << 2) + 48128 >> 2];
    $6 = Math_fround($6 + Math_fround(Math_fround($5 | 0) * Math_fround(-.03999999910593033)));
    $3 = Math_fround($3 + Math_fround(Math_fround(Math_fround(1) - Math_fround($3 * $6)) * Math_fround($6 * Math_fround(Math_fround(1) - Math_fround($3 * $3)))));
    $3 = $12 ? Math_fround(-$3) : $3;
   }
   HEAPF32[$10 >> 2] = $16 + Math_fround($17 * $3);
   $4 = $4 + 1 | 0;
   if (($7 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
  if (($7 | 0) < 1) {
   break label$1;
  }
  memcpy($1, $9, $7 << 2);
 }
 __stack_pointer = $9 + 512 | 0;
}
function quant_band($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = Math_fround(0), $17 = Math_fround(0), $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 $22 = ($2 >>> 0) / ($4 >>> 0) | 0;
 $24 = HEAP32[$0 >> 2];
 label$1 : {
  if (($2 | 0) == 1) {
   $5 = 0;
   if (HEAP32[$0 + 32 >> 2] >= 8) {
    $9 = HEAP32[$0 + 28 >> 2];
    label$4 : {
     if ($24) {
      $5 = HEAPF32[$1 >> 2] < Math_fround(0);
      ec_enc_bits($9, $5, 1);
      break label$4;
     }
     $5 = ec_dec_bits($9, 1);
    }
    HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 32 >> 2] - 8;
   }
   if (HEAP32[$0 + 4 >> 2]) {
    HEAPF32[$1 >> 2] = $5 ? Math_fround(-1) : Math_fround(1);
   }
   $10 = 1;
   if (!$7) {
    break label$1;
   }
   HEAP32[$7 >> 2] = HEAP32[$1 >> 2];
   return 1;
  }
  $21 = HEAP32[$0 + 24 >> 2];
  $11 = ($21 | 0) > 0;
  label$7 : {
   if (!$5) {
    $9 = $5;
    break label$7;
   }
   if (!$9) {
    $9 = $5;
    break label$7;
   }
   if (!(!($22 & 1) & ($21 | 0) != 0 | (($21 | 0) > 0 | ($4 | 0) > 1))) {
    $9 = $5;
    break label$7;
   }
   memcpy($9, $5, $2 << 2);
  }
  $19 = $11 ? $21 : 0;
  if (($21 | 0) >= 1) {
   while (1) {
    label$13 : {
     if ($24) {
      if (($12 | 0) == 31) {
       break label$13;
      }
      $15 = $2 >> $12;
      $5 = $15 >> 1;
      $20 = ($5 | 0) > 1 ? $5 : 1;
      $14 = 1 << $12;
      $18 = $14 << 1;
      $11 = 0;
      while (1) {
       $5 = 0;
       if (($15 | 0) >= 2) {
        while (1) {
         $13 = (Math_imul($5, $18) + $11 << 2) + $1 | 0;
         $23 = $13;
         $16 = Math_fround(HEAPF32[$13 >> 2] * Math_fround(.7071067690849304));
         $13 = ((($5 << 1 | 1) << $12) + $11 << 2) + $1 | 0;
         $17 = Math_fround(HEAPF32[$13 >> 2] * Math_fround(.7071067690849304));
         HEAPF32[$23 >> 2] = $16 + $17;
         HEAPF32[$13 >> 2] = $16 - $17;
         $5 = $5 + 1 | 0;
         if (($20 | 0) != ($5 | 0)) {
          continue;
         }
         break;
        }
       }
       $11 = $11 + 1 | 0;
       if (($14 | 0) != ($11 | 0)) {
        continue;
       }
       break;
      }
     }
     if (!$9 | ($12 | 0) == 31) {
      break label$13;
     }
     $15 = $2 >> $12;
     $5 = $15 >> 1;
     $20 = ($5 | 0) > 1 ? $5 : 1;
     $14 = 1 << $12;
     $18 = $14 << 1;
     $11 = 0;
     while (1) {
      $5 = 0;
      if (($15 | 0) >= 2) {
       while (1) {
        $13 = (Math_imul($5, $18) + $11 << 2) + $9 | 0;
        $23 = $13;
        $16 = Math_fround(HEAPF32[$13 >> 2] * Math_fround(.7071067690849304));
        $13 = ((($5 << 1 | 1) << $12) + $11 << 2) + $9 | 0;
        $17 = Math_fround(HEAPF32[$13 >> 2] * Math_fround(.7071067690849304));
        HEAPF32[$23 >> 2] = $16 + $17;
        HEAPF32[$13 >> 2] = $16 - $17;
        $5 = $5 + 1 | 0;
        if (($20 | 0) != ($5 | 0)) {
         continue;
        }
        break;
       }
      }
      $11 = $11 + 1 | 0;
      if (($14 | 0) != ($11 | 0)) {
       continue;
      }
      break;
     }
    }
    $10 = HEAPU8[($10 & 15) + 41920 | 0] | HEAPU8[($10 >> 4) + 41920 | 0] << 2;
    $12 = $12 + 1 | 0;
    if (($19 | 0) != ($12 | 0)) {
     continue;
    }
    break;
   }
  }
  $12 = $4 >> $19;
  $15 = $22 << $19;
  label$21 : {
   if (!($15 & 1 | ($21 | 0) > -1)) {
    $22 = $21;
    while (1) {
     if (!(!$24 | ($12 | 0) < 1)) {
      $5 = $15 >> 1;
      $20 = ($5 | 0) > 1 ? $5 : 1;
      $18 = $12 << 1;
      $11 = 0;
      while (1) {
       $5 = 0;
       if (($15 | 0) >= 2) {
        while (1) {
         $13 = (Math_imul($5, $18) + $11 << 2) + $1 | 0;
         $14 = $13;
         $16 = Math_fround(HEAPF32[$13 >> 2] * Math_fround(.7071067690849304));
         $13 = (Math_imul($5 << 1 | 1, $12) + $11 << 2) + $1 | 0;
         $17 = Math_fround(HEAPF32[$13 >> 2] * Math_fround(.7071067690849304));
         HEAPF32[$14 >> 2] = $16 + $17;
         HEAPF32[$13 >> 2] = $16 - $17;
         $5 = $5 + 1 | 0;
         if (($20 | 0) != ($5 | 0)) {
          continue;
         }
         break;
        }
       }
       $11 = $11 + 1 | 0;
       if (($12 | 0) != ($11 | 0)) {
        continue;
       }
       break;
      }
     }
     $14 = $15 >> 1;
     if (!(!$9 | ($12 | 0) < 1)) {
      $20 = ($14 | 0) > 1 ? $14 : 1;
      $18 = $12 << 1;
      $11 = 0;
      while (1) {
       $5 = 0;
       if (($15 | 0) >= 2) {
        while (1) {
         $13 = (Math_imul($5, $18) + $11 << 2) + $9 | 0;
         $23 = $13;
         $16 = Math_fround(HEAPF32[$13 >> 2] * Math_fround(.7071067690849304));
         $13 = (Math_imul($5 << 1 | 1, $12) + $11 << 2) + $9 | 0;
         $17 = Math_fround(HEAPF32[$13 >> 2] * Math_fround(.7071067690849304));
         HEAPF32[$23 >> 2] = $16 + $17;
         HEAPF32[$13 >> 2] = $16 - $17;
         $5 = $5 + 1 | 0;
         if (($20 | 0) != ($5 | 0)) {
          continue;
         }
         break;
        }
       }
       $11 = $11 + 1 | 0;
       if (($12 | 0) != ($11 | 0)) {
        continue;
       }
       break;
      }
     }
     $25 = $25 + 1 | 0;
     $5 = $12 << 1;
     $10 = $10 << $12 | $10;
     if ($15 & 2) {
      break label$21;
     }
     $11 = ($22 | 0) < -1;
     $22 = $22 + 1 | 0;
     $12 = $5;
     $15 = $14;
     if ($11) {
      continue;
     }
     break;
    }
    break label$21;
   }
   $14 = $15;
   $5 = $12;
  }
  $11 = ($4 | 0) == 1;
  label$32 : {
   if (($5 | 0) < 2) {
    break label$32;
   }
   if ($24) {
    deinterleave_hadamard($1, $14 >> $19, $5 << $19, $11);
   }
   if (!$9) {
    break label$32;
   }
   deinterleave_hadamard($9, $14 >> $19, $5 << $19, $11);
  }
  $10 = quant_partition($0, $1, $2, $3, $5, $9, $6, $8, $10);
  if (!HEAP32[$0 + 4 >> 2]) {
   break label$1;
  }
  if (($5 | 0) >= 2) {
   interleave_hadamard($1, $14 >> $19, $5 << $19, $11);
  }
  label$35 : {
   if (!$25) {
    $13 = $5;
    break label$35;
   }
   $18 = 0;
   while (1) {
    $14 = $14 << 1;
    $13 = $5 >> 1;
    $15 = $10 >>> $13 | 0;
    if (($5 | 0) >= 2) {
     $9 = $14 >> 1;
     $12 = ($9 | 0) > 1 ? $9 : 1;
     $20 = $5 & -2;
     $9 = 0;
     while (1) {
      $5 = 0;
      if (($14 | 0) >= 2) {
       while (1) {
        $11 = (Math_imul($5, $20) + $9 << 2) + $1 | 0;
        $0 = $11;
        $16 = Math_fround(HEAPF32[$11 >> 2] * Math_fround(.7071067690849304));
        $11 = (Math_imul($5 << 1 | 1, $13) + $9 << 2) + $1 | 0;
        $17 = Math_fround(HEAPF32[$11 >> 2] * Math_fround(.7071067690849304));
        HEAPF32[$0 >> 2] = $16 + $17;
        HEAPF32[$11 >> 2] = $16 - $17;
        $5 = $5 + 1 | 0;
        if (($12 | 0) != ($5 | 0)) {
         continue;
        }
        break;
       }
      }
      $9 = $9 + 1 | 0;
      if (($13 | 0) != ($9 | 0)) {
       continue;
      }
      break;
     }
    }
    $10 = $10 | $15;
    $5 = $13;
    $18 = $18 + 1 | 0;
    if (($25 | 0) != ($18 | 0)) {
     continue;
    }
    break;
   }
  }
  $12 = 0;
  if (($21 | 0) > 0) {
   while (1) {
    $10 = HEAPU8[$10 + 41936 | 0];
    if (($12 | 0) != 31) {
     $15 = $2 >> $12;
     $5 = $15 >> 1;
     $20 = ($5 | 0) > 1 ? $5 : 1;
     $14 = 1 << $12;
     $18 = $14 << 1;
     $9 = 0;
     while (1) {
      $5 = 0;
      if (($15 | 0) >= 2) {
       while (1) {
        $11 = (Math_imul($5, $18) + $9 << 2) + $1 | 0;
        $0 = $11;
        $16 = Math_fround(HEAPF32[$11 >> 2] * Math_fround(.7071067690849304));
        $11 = ((($5 << 1 | 1) << $12) + $9 << 2) + $1 | 0;
        $17 = Math_fround(HEAPF32[$11 >> 2] * Math_fround(.7071067690849304));
        HEAPF32[$0 >> 2] = $16 + $17;
        HEAPF32[$11 >> 2] = $16 - $17;
        $5 = $5 + 1 | 0;
        if (($20 | 0) != ($5 | 0)) {
         continue;
        }
        break;
       }
      }
      $9 = $9 + 1 | 0;
      if (($14 | 0) != ($9 | 0)) {
       continue;
      }
      break;
     }
    }
    $12 = $12 + 1 | 0;
    if (($19 | 0) != ($12 | 0)) {
     continue;
    }
    break;
   }
  }
  $11 = $13 << $19;
  if (!(!$7 | ($2 | 0) < 1)) {
   $16 = Math_fround(Math_sqrt(+($2 | 0)));
   $5 = 0;
   while (1) {
    $9 = $5 << 2;
    HEAPF32[$9 + $7 >> 2] = HEAPF32[$1 + $9 >> 2] * $16;
    $5 = $5 + 1 | 0;
    if (($5 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  $10 = (-1 << $11 ^ -1) & $10;
 }
 return $10;
}
function update_filter($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = Math_fround(0), $14 = Math_fround(0), $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0;
 $2 = HEAP32[$0 + 8 >> 2];
 $1 = HEAP32[$0 + 12 >> 2];
 $5 = ($2 >>> 0) / ($1 >>> 0) | 0;
 HEAP32[$0 + 36 >> 2] = $5;
 $3 = Math_imul(HEAP32[$0 + 16 >> 2], 20);
 $6 = HEAP32[$3 + 50884 >> 2];
 HEAP32[$0 + 48 >> 2] = $6;
 $11 = HEAP32[$0 + 24 >> 2];
 $4 = HEAP32[$3 + 50880 >> 2];
 HEAP32[$0 + 24 >> 2] = $4;
 HEAP32[$0 + 40 >> 2] = $2 - Math_imul($1, $5);
 $17 = HEAP32[$0 + 28 >> 2];
 label$1 : {
  label$2 : {
   label$3 : {
    if ($1 >>> 0 < $2 >>> 0) {
     HEAPF32[$0 + 44 >> 2] = Math_fround(HEAPF32[$3 + 50888 >> 2] * Math_fround($1 >>> 0)) / Math_fround($2 >>> 0);
     $3 = ($4 >>> 0) / ($1 >>> 0) | 0;
     $5 = $4 - Math_imul($3, $1) | 0;
     $4 = 4294967295 / ($2 >>> 0) | 0;
     if ($5 >>> 0 > $4 >>> 0 | $3 >>> 0 > $4 >>> 0) {
      break label$2;
     }
     $4 = Math_imul($2, $3);
     $3 = (Math_imul($2, $5) >>> 0) / ($1 >>> 0) | 0;
     if ($4 >>> 0 > ($3 ^ -1) >>> 0) {
      break label$2;
     }
     $4 = ($3 + $4 | 0) + 7 & -8;
     HEAP32[$0 + 24 >> 2] = $4;
     $3 = $1 << 1 >>> 0 < $2 >>> 0;
     $5 = $1 << 2 >>> 0 < $2 >>> 0;
     $7 = $1 << 3;
     $6 = $6 >>> $3 >>> $5 >>> ($7 >>> 0 < $2 >>> 0) | 0;
     if (!($2 >>> 0 <= $7 >>> 0 ? !($3 | $5) : 0)) {
      HEAP32[$0 + 48 >> 2] = $6;
     }
     $3 = $1 << 4 >>> 0 < $2 >>> 0;
     $2 = $6 >>> $3 | 0;
     if ($2 ? !$3 : 0) {
      break label$3;
     }
     $6 = $2 ? $2 : 1;
     HEAP32[$0 + 48 >> 2] = $6;
     break label$3;
    }
    HEAP32[$0 + 44 >> 2] = HEAP32[$3 + 50892 >> 2];
   }
   $2 = Math_imul($1, $4);
   $5 = Math_imul($4, $6) + 8 | 0;
   label$7 : {
    if ($2 >>> 0 <= $5 >>> 0) {
     $3 = 1;
     if (536870911 / ($1 >>> 0) >>> 0 >= $4 >>> 0) {
      break label$7;
     }
    }
    $3 = 0;
    $2 = $5;
    if (536870903 / ($6 >>> 0) >>> 0 < $4 >>> 0) {
     break label$2;
    }
   }
   if (HEAPU32[$0 + 80 >> 2] < $2 >>> 0) {
    $1 = dlrealloc(HEAP32[$0 + 76 >> 2], $2 << 2);
    if (!$1) {
     break label$2;
    }
    HEAP32[$0 + 80 >> 2] = $2;
    HEAP32[$0 + 76 >> 2] = $1;
   }
   $9 = $0;
   label$10 : {
    label$11 : {
     label$12 : {
      if (!$3) {
       $1 = -4;
       $2 = HEAP32[$0 + 24 >> 2];
       $6 = HEAP32[$0 + 48 >> 2];
       $4 = Math_imul($2, $6) + 4 | 0;
       if (($4 | 0) > -4) {
        break label$12;
       }
       $5 = HEAP32[$0 + 16 >> 2];
       break label$11;
      }
      $2 = HEAP32[$0 + 24 >> 2];
      $8 = HEAP32[$0 + 12 >> 2];
      if ($8) {
       $5 = ($2 | 0) / -2 | 0;
       $13 = Math_fround($8 >>> 0);
       $7 = 0;
       while (1) {
        if ($2) {
         $4 = Math_imul($2, $7);
         $14 = Math_fround(Math_fround($7 >>> 0) / $13);
         $3 = HEAP32[Math_imul(HEAP32[$0 + 16 >> 2], 20) + 50896 >> 2];
         $6 = HEAP32[$0 + 76 >> 2];
         $1 = 0;
         while (1) {
          $10 = ($1 + $4 << 2) + $6 | 0;
          $1 = $1 + 1 | 0;
          HEAPF32[$10 >> 2] = sinc(HEAPF32[$0 + 44 >> 2], Math_fround(Math_fround($5 + $1 | 0) - $14), $2, $3);
          if (($1 | 0) != ($2 | 0)) {
           continue;
          }
          break;
         }
        }
        $7 = $7 + 1 | 0;
        if (($8 | 0) != ($7 | 0)) {
         continue;
        }
        break;
       }
      }
      $1 = HEAP32[$0 + 16 >> 2] > 8 ? 5 : 6;
      break label$10;
     }
     $14 = Math_fround($2 >>> 1 >>> 0);
     $5 = HEAP32[$0 + 16 >> 2];
     $3 = HEAP32[Math_imul($5, 20) + 50896 >> 2];
     $13 = Math_fround($6 >>> 0);
     $6 = HEAP32[$0 + 76 >> 2];
     while (1) {
      HEAPF32[(($1 << 2) + $6 | 0) + 16 >> 2] = sinc(HEAPF32[$0 + 44 >> 2], Math_fround(Math_fround(Math_fround($1 | 0) / $13) - $14), $2, $3);
      $1 = $1 + 1 | 0;
      if (($4 | 0) != ($1 | 0)) {
       continue;
      }
      break;
     }
    }
    $1 = ($5 | 0) > 8 ? 7 : 8;
   }
   HEAP32[$9 + 84 >> 2] = $1;
   $1 = (HEAP32[$0 + 32 >> 2] + $2 | 0) - 1 | 0;
   $2 = HEAP32[$0 + 28 >> 2];
   if ($1 >>> 0 > $2 >>> 0) {
    $2 = HEAP32[$0 + 20 >> 2];
    if (536870911 / ($2 >>> 0) >>> 0 < $1 >>> 0) {
     break label$2;
    }
    $2 = dlrealloc(HEAP32[$0 + 72 >> 2], Math_imul($1, $2) << 2);
    if (!$2) {
     break label$2;
    }
    HEAP32[$0 + 28 >> 2] = $1;
    HEAP32[$0 + 72 >> 2] = $2;
    $2 = $1;
   }
   if (!HEAP32[$0 + 56 >> 2]) {
    $1 = Math_imul(HEAP32[$0 + 20 >> 2], $2);
    if (!$1) {
     return 0;
    }
    memset(HEAP32[$0 + 72 >> 2], 0, $1 << 2);
    return 0;
   }
   $2 = HEAP32[$0 + 24 >> 2];
   if ($11 >>> 0 < $2 >>> 0) {
    $8 = HEAP32[$0 + 20 >> 2];
    if (!$8) {
     return 0;
    }
    $18 = $11 - 1 | 0;
    $19 = ($8 << 2) - 4 | 0;
    $20 = HEAP32[$0 + 68 >> 2];
    while (1) {
     $7 = $12 << 2;
     $8 = $8 - 1 | 0;
     $15 = $8 << 2;
     $5 = $15 + $20 | 0;
     $4 = HEAP32[$5 >> 2];
     $9 = $4 << 1;
     $1 = $4 + $18 | 0;
     if ($1) {
      $3 = Math_imul($8, $17);
      $6 = Math_imul(HEAP32[$0 + 28 >> 2], $8);
      $2 = HEAP32[$0 + 72 >> 2];
      while (1) {
       $1 = $1 - 1 | 0;
       HEAP32[(($4 + $1 | 0) + $6 << 2) + $2 >> 2] = HEAP32[($1 + $3 << 2) + $2 >> 2];
       if ($1) {
        continue;
       }
       break;
      }
     }
     $16 = $19 - $7 | 0;
     $9 = $9 + $11 | 0;
     if ($4) {
      memset(HEAP32[$0 + 72 >> 2] + Math_imul(HEAP32[$0 + 28 >> 2], $16) | 0, 0, $4 << 2);
     }
     HEAP32[$5 >> 2] = 0;
     $10 = HEAP32[$0 + 24 >> 2];
     label$28 : {
      if ($10 >>> 0 > $9 >>> 0) {
       $6 = $9 - 1 | 0;
       if ($6) {
        $5 = $10 - 2 | 0;
        $7 = $9 - 2 | 0;
        $4 = Math_imul(HEAP32[$0 + 28 >> 2], $8);
        $3 = HEAP32[$0 + 72 >> 2];
        $1 = 0;
        $2 = 0;
        while (1) {
         HEAP32[(($1 + $5 | 0) + $4 << 2) + $3 >> 2] = HEAP32[(($1 + $7 | 0) + $4 << 2) + $3 >> 2];
         $1 = $2 ^ -1;
         $2 = $2 + 1 | 0;
         if (($6 | 0) != ($2 | 0)) {
          continue;
         }
         break;
        }
       }
       $1 = $10 - 1 | 0;
       if ($6 >>> 0 < $1 >>> 0) {
        memset(HEAP32[$0 + 72 >> 2] + Math_imul(HEAP32[$0 + 28 >> 2], $16) | 0, 0, $1 - $6 << 2);
       }
       $1 = HEAP32[$0 + 60 >> 2] + $15 | 0;
       HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + ($10 - $9 >>> 1 | 0);
       break label$28;
      }
      $3 = $9 - $10 >>> 1 | 0;
      HEAP32[$5 >> 2] = $3;
      $1 = $3 - 1 | 0;
      $2 = HEAP32[$0 + 24 >> 2];
      if (($1 | 0) == (0 - $2 | 0)) {
       break label$28;
      }
      $1 = $1 + $2 | 0;
      $6 = $1 >>> 0 > 1 ? $1 : 1;
      $5 = Math_imul(HEAP32[$0 + 28 >> 2], $8);
      $2 = HEAP32[$0 + 72 >> 2];
      $1 = 0;
      while (1) {
       $4 = $1 + $5 | 0;
       HEAP32[($4 << 2) + $2 >> 2] = HEAP32[($3 + $4 << 2) + $2 >> 2];
       $1 = $1 + 1 | 0;
       if (($6 | 0) != ($1 | 0)) {
        continue;
       }
       break;
      }
     }
     $12 = $12 + 1 | 0;
     if ($8) {
      continue;
     }
     break;
    }
    return 0;
   }
   $1 = 0;
   if (!HEAP32[$0 + 20 >> 2] | $2 >>> 0 >= $11 >>> 0) {
    break label$1;
   }
   $12 = HEAP32[$0 + 68 >> 2];
   $7 = 0;
   while (1) {
    $8 = ($7 << 2) + $12 | 0;
    $1 = HEAP32[$8 >> 2];
    $3 = $11 - $2 >>> 1 | 0;
    HEAP32[$8 >> 2] = $3;
    $9 = $1 + $3 | 0;
    $1 = $9 - 1 | 0;
    $2 = HEAP32[$0 + 24 >> 2];
    if (($1 | 0) != (0 - $2 | 0)) {
     $1 = $1 + $2 | 0;
     $6 = $1 >>> 0 > 1 ? $1 : 1;
     $5 = Math_imul(HEAP32[$0 + 28 >> 2], $7);
     $2 = HEAP32[$0 + 72 >> 2];
     $1 = 0;
     while (1) {
      $4 = $1 + $5 | 0;
      HEAP32[($4 << 2) + $2 >> 2] = HEAP32[($3 + $4 << 2) + $2 >> 2];
      $1 = $1 + 1 | 0;
      if (($6 | 0) != ($1 | 0)) {
       continue;
      }
      break;
     }
    }
    HEAP32[$8 >> 2] = $9;
    $7 = $7 + 1 | 0;
    if ($7 >>> 0 >= HEAPU32[$0 + 20 >> 2]) {
     return 0;
    } else {
     $2 = HEAP32[$0 + 24 >> 2];
     continue;
    }
   }
  }
  HEAP32[$0 + 24 >> 2] = $11;
  HEAP32[$0 + 84 >> 2] = 9;
  $1 = 1;
 }
 return $1;
}
function dlfree($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1 : {
  label$2 : {
   if (!$0) {
    break label$2;
   }
   $3 = $0 - 8 | 0;
   $1 = HEAP32[$0 - 4 >> 2];
   $0 = $1 & -8;
   $5 = $3 + $0 | 0;
   label$3 : {
    if ($1 & 1) {
     break label$3;
    }
    if (!($1 & 3)) {
     break label$2;
    }
    $1 = HEAP32[$3 >> 2];
    $3 = $3 - $1 | 0;
    $4 = HEAP32[13236];
    if ($3 >>> 0 < $4 >>> 0) {
     break label$2;
    }
    $0 = $0 + $1 | 0;
    if (HEAP32[13237] != ($3 | 0)) {
     if ($1 >>> 0 <= 255) {
      $7 = $1 >>> 3 | 0;
      $1 = ($7 << 3) + 52968 | 0;
      $6 = HEAP32[$3 + 8 >> 2];
      $2 = HEAP32[$3 + 12 >> 2];
      if (($6 | 0) == ($2 | 0)) {
       HEAP32[13232] = HEAP32[13232] & __wasm_rotl_i32(-2, $7);
       break label$3;
      }
      HEAP32[$6 + 12 >> 2] = $2;
      HEAP32[$2 + 8 >> 2] = $6;
      break label$3;
     }
     $7 = HEAP32[$3 + 24 >> 2];
     $2 = HEAP32[$3 + 12 >> 2];
     label$7 : {
      if (($2 | 0) != ($3 | 0)) {
       $1 = HEAP32[$3 + 8 >> 2];
       HEAP32[$1 + 12 >> 2] = $2;
       HEAP32[$2 + 8 >> 2] = $1;
       break label$7;
      }
      label$10 : {
       $1 = $3 + 20 | 0;
       $4 = HEAP32[$1 >> 2];
       if ($4) {
        break label$10;
       }
       $1 = $3 + 16 | 0;
       $4 = HEAP32[$1 >> 2];
       if ($4) {
        break label$10;
       }
       $2 = 0;
       break label$7;
      }
      while (1) {
       $6 = $1;
       $2 = $4;
       $1 = $2 + 20 | 0;
       $4 = HEAP32[$1 >> 2];
       if ($4) {
        continue;
       }
       $1 = $2 + 16 | 0;
       $4 = HEAP32[$2 + 16 >> 2];
       if ($4) {
        continue;
       }
       break;
      }
      HEAP32[$6 >> 2] = 0;
     }
     if (!$7) {
      break label$3;
     }
     $4 = HEAP32[$3 + 28 >> 2];
     $1 = ($4 << 2) + 53232 | 0;
     label$12 : {
      if (HEAP32[$1 >> 2] == ($3 | 0)) {
       HEAP32[$1 >> 2] = $2;
       if ($2) {
        break label$12;
       }
       HEAP32[13233] = HEAP32[13233] & __wasm_rotl_i32(-2, $4);
       break label$3;
      }
      HEAP32[(HEAP32[$7 + 16 >> 2] == ($3 | 0) ? 16 : 20) + $7 >> 2] = $2;
      if (!$2) {
       break label$3;
      }
     }
     HEAP32[$2 + 24 >> 2] = $7;
     $1 = HEAP32[$3 + 16 >> 2];
     if ($1) {
      HEAP32[$2 + 16 >> 2] = $1;
      HEAP32[$1 + 24 >> 2] = $2;
     }
     $1 = HEAP32[$3 + 20 >> 2];
     if (!$1) {
      break label$3;
     }
     HEAP32[$2 + 20 >> 2] = $1;
     HEAP32[$1 + 24 >> 2] = $2;
     break label$3;
    }
    $1 = HEAP32[$5 + 4 >> 2];
    if (($1 & 3) != 3) {
     break label$3;
    }
    HEAP32[13234] = $0;
    HEAP32[$5 + 4 >> 2] = $1 & -2;
    break label$1;
   }
   if ($3 >>> 0 >= $5 >>> 0) {
    break label$2;
   }
   $1 = HEAP32[$5 + 4 >> 2];
   if (!($1 & 1)) {
    break label$2;
   }
   label$15 : {
    if (!($1 & 2)) {
     if (HEAP32[13238] == ($5 | 0)) {
      HEAP32[13238] = $3;
      $0 = HEAP32[13235] + $0 | 0;
      HEAP32[13235] = $0;
      HEAP32[$3 + 4 >> 2] = $0 | 1;
      if (HEAP32[13237] != ($3 | 0)) {
       break label$2;
      }
      HEAP32[13234] = 0;
      HEAP32[13237] = 0;
      return;
     }
     if (HEAP32[13237] == ($5 | 0)) {
      HEAP32[13237] = $3;
      $0 = HEAP32[13234] + $0 | 0;
      HEAP32[13234] = $0;
      break label$1;
     }
     $0 = ($1 & -8) + $0 | 0;
     label$19 : {
      if ($1 >>> 0 <= 255) {
       $4 = HEAP32[$5 + 12 >> 2];
       $2 = HEAP32[$5 + 8 >> 2];
       $5 = $1 >>> 3 | 0;
       if (($2 | 0) == ($4 | 0)) {
        HEAP32[13232] = HEAP32[13232] & __wasm_rotl_i32(-2, $5);
        break label$19;
       }
       HEAP32[$2 + 12 >> 2] = $4;
       HEAP32[$4 + 8 >> 2] = $2;
       break label$19;
      }
      $7 = HEAP32[$5 + 24 >> 2];
      $2 = HEAP32[$5 + 12 >> 2];
      label$24 : {
       if (($5 | 0) != ($2 | 0)) {
        $1 = HEAP32[$5 + 8 >> 2];
        HEAP32[$1 + 12 >> 2] = $2;
        HEAP32[$2 + 8 >> 2] = $1;
        break label$24;
       }
       label$27 : {
        $1 = $5 + 20 | 0;
        $4 = HEAP32[$1 >> 2];
        if ($4) {
         break label$27;
        }
        $1 = $5 + 16 | 0;
        $4 = HEAP32[$1 >> 2];
        if ($4) {
         break label$27;
        }
        $2 = 0;
        break label$24;
       }
       while (1) {
        $6 = $1;
        $2 = $4;
        $1 = $2 + 20 | 0;
        $4 = HEAP32[$1 >> 2];
        if ($4) {
         continue;
        }
        $1 = $2 + 16 | 0;
        $4 = HEAP32[$2 + 16 >> 2];
        if ($4) {
         continue;
        }
        break;
       }
       HEAP32[$6 >> 2] = 0;
      }
      if (!$7) {
       break label$19;
      }
      $4 = HEAP32[$5 + 28 >> 2];
      $1 = ($4 << 2) + 53232 | 0;
      label$29 : {
       if (HEAP32[$1 >> 2] == ($5 | 0)) {
        HEAP32[$1 >> 2] = $2;
        if ($2) {
         break label$29;
        }
        HEAP32[13233] = HEAP32[13233] & __wasm_rotl_i32(-2, $4);
        break label$19;
       }
       HEAP32[(HEAP32[$7 + 16 >> 2] == ($5 | 0) ? 16 : 20) + $7 >> 2] = $2;
       if (!$2) {
        break label$19;
       }
      }
      HEAP32[$2 + 24 >> 2] = $7;
      $1 = HEAP32[$5 + 16 >> 2];
      if ($1) {
       HEAP32[$2 + 16 >> 2] = $1;
       HEAP32[$1 + 24 >> 2] = $2;
      }
      $1 = HEAP32[$5 + 20 >> 2];
      if (!$1) {
       break label$19;
      }
      HEAP32[$2 + 20 >> 2] = $1;
      HEAP32[$1 + 24 >> 2] = $2;
     }
     HEAP32[$3 + 4 >> 2] = $0 | 1;
     HEAP32[$0 + $3 >> 2] = $0;
     if (HEAP32[13237] != ($3 | 0)) {
      break label$15;
     }
     HEAP32[13234] = $0;
     return;
    }
    HEAP32[$5 + 4 >> 2] = $1 & -2;
    HEAP32[$3 + 4 >> 2] = $0 | 1;
    HEAP32[$0 + $3 >> 2] = $0;
   }
   if ($0 >>> 0 <= 255) {
    $1 = $0 >>> 3 | 0;
    $0 = ($1 << 3) + 52968 | 0;
    $1 = 1 << $1;
    $4 = HEAP32[13232];
    label$33 : {
     if (!($1 & $4)) {
      HEAP32[13232] = $1 | $4;
      $1 = $0;
      break label$33;
     }
     $1 = HEAP32[$0 + 8 >> 2];
    }
    HEAP32[$0 + 8 >> 2] = $3;
    HEAP32[$1 + 12 >> 2] = $3;
    HEAP32[$3 + 12 >> 2] = $0;
    HEAP32[$3 + 8 >> 2] = $1;
    return;
   }
   $1 = 31;
   HEAP32[$3 + 16 >> 2] = 0;
   HEAP32[$3 + 20 >> 2] = 0;
   if ($0 >>> 0 <= 16777215) {
    $1 = $0 >>> 8 | 0;
    $2 = $1;
    $1 = $1 + 1048320 >>> 16 & 8;
    $4 = $2 << $1;
    $2 = $4;
    $4 = $4 + 520192 >>> 16 & 4;
    $2 = $2 << $4;
    $6 = $2;
    $2 = $2 + 245760 >>> 16 & 2;
    $1 = ($6 << $2 >>> 15 | 0) - ($1 | $4 | $2) | 0;
    $1 = ($1 << 1 | $0 >>> $1 + 21 & 1) + 28 | 0;
   }
   HEAP32[$3 + 28 >> 2] = $1;
   $4 = ($1 << 2) + 53232 | 0;
   label$36 : {
    label$37 : {
     $2 = HEAP32[13233];
     $5 = 1 << $1;
     label$38 : {
      if (!($2 & $5)) {
       HEAP32[13233] = $2 | $5;
       HEAP32[$4 >> 2] = $3;
       break label$38;
      }
      $1 = $0 << (($1 | 0) == 31 ? 0 : 25 - ($1 >>> 1 | 0) | 0);
      $2 = HEAP32[$4 >> 2];
      while (1) {
       $4 = $2;
       if ((HEAP32[$2 + 4 >> 2] & -8) == ($0 | 0)) {
        break label$37;
       }
       $2 = $1 >>> 29 | 0;
       $1 = $1 << 1;
       $6 = ($2 & 4) + $4 | 0;
       $5 = $6 + 16 | 0;
       $2 = HEAP32[$5 >> 2];
       if ($2) {
        continue;
       }
       break;
      }
      HEAP32[$6 + 16 >> 2] = $3;
     }
     HEAP32[$3 + 24 >> 2] = $4;
     HEAP32[$3 + 12 >> 2] = $3;
     HEAP32[$3 + 8 >> 2] = $3;
     break label$36;
    }
    $0 = HEAP32[$4 + 8 >> 2];
    HEAP32[$0 + 12 >> 2] = $3;
    HEAP32[$4 + 8 >> 2] = $3;
    HEAP32[$3 + 24 >> 2] = 0;
    HEAP32[$3 + 12 >> 2] = $4;
    HEAP32[$3 + 8 >> 2] = $0;
   }
   $3 = HEAP32[13240] - 1 | 0;
   HEAP32[13240] = $3 ? $3 : -1;
  }
  return;
 }
 HEAP32[$3 + 4 >> 2] = $0 | 1;
 HEAP32[$0 + $3 >> 2] = $0;
}
function dispose_chunk($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = $0 + $1 | 0;
 label$1 : {
  label$2 : {
   $2 = HEAP32[$0 + 4 >> 2];
   if ($2 & 1) {
    break label$2;
   }
   if (!($2 & 3)) {
    break label$1;
   }
   $2 = HEAP32[$0 >> 2];
   $1 = $2 + $1 | 0;
   $0 = $0 - $2 | 0;
   if (($0 | 0) != HEAP32[13237]) {
    if ($2 >>> 0 <= 255) {
     $6 = $2 >>> 3 | 0;
     $2 = ($6 << 3) + 52968 | 0;
     $3 = HEAP32[$0 + 8 >> 2];
     $4 = HEAP32[$0 + 12 >> 2];
     if (($4 | 0) == ($3 | 0)) {
      HEAP32[13232] = HEAP32[13232] & __wasm_rotl_i32(-2, $6);
      break label$2;
     }
     HEAP32[$3 + 12 >> 2] = $4;
     HEAP32[$4 + 8 >> 2] = $3;
     break label$2;
    }
    $6 = HEAP32[$0 + 24 >> 2];
    $3 = HEAP32[$0 + 12 >> 2];
    label$6 : {
     if (($3 | 0) != ($0 | 0)) {
      $2 = HEAP32[$0 + 8 >> 2];
      HEAP32[$2 + 12 >> 2] = $3;
      HEAP32[$3 + 8 >> 2] = $2;
      break label$6;
     }
     label$9 : {
      $2 = $0 + 20 | 0;
      $4 = HEAP32[$2 >> 2];
      if ($4) {
       break label$9;
      }
      $2 = $0 + 16 | 0;
      $4 = HEAP32[$2 >> 2];
      if ($4) {
       break label$9;
      }
      $3 = 0;
      break label$6;
     }
     while (1) {
      $7 = $2;
      $3 = $4;
      $2 = $3 + 20 | 0;
      $4 = HEAP32[$2 >> 2];
      if ($4) {
       continue;
      }
      $2 = $3 + 16 | 0;
      $4 = HEAP32[$3 + 16 >> 2];
      if ($4) {
       continue;
      }
      break;
     }
     HEAP32[$7 >> 2] = 0;
    }
    if (!$6) {
     break label$2;
    }
    $4 = HEAP32[$0 + 28 >> 2];
    $2 = ($4 << 2) + 53232 | 0;
    label$11 : {
     if (HEAP32[$2 >> 2] == ($0 | 0)) {
      HEAP32[$2 >> 2] = $3;
      if ($3) {
       break label$11;
      }
      HEAP32[13233] = HEAP32[13233] & __wasm_rotl_i32(-2, $4);
      break label$2;
     }
     HEAP32[(HEAP32[$6 + 16 >> 2] == ($0 | 0) ? 16 : 20) + $6 >> 2] = $3;
     if (!$3) {
      break label$2;
     }
    }
    HEAP32[$3 + 24 >> 2] = $6;
    $2 = HEAP32[$0 + 16 >> 2];
    if ($2) {
     HEAP32[$3 + 16 >> 2] = $2;
     HEAP32[$2 + 24 >> 2] = $3;
    }
    $2 = HEAP32[$0 + 20 >> 2];
    if (!$2) {
     break label$2;
    }
    HEAP32[$3 + 20 >> 2] = $2;
    HEAP32[$2 + 24 >> 2] = $3;
    break label$2;
   }
   $2 = HEAP32[$5 + 4 >> 2];
   if (($2 & 3) != 3) {
    break label$2;
   }
   HEAP32[13234] = $1;
   HEAP32[$5 + 4 >> 2] = $2 & -2;
   HEAP32[$0 + 4 >> 2] = $1 | 1;
   HEAP32[$5 >> 2] = $1;
   return;
  }
  $2 = HEAP32[$5 + 4 >> 2];
  label$14 : {
   if (!($2 & 2)) {
    if (HEAP32[13238] == ($5 | 0)) {
     HEAP32[13238] = $0;
     $1 = HEAP32[13235] + $1 | 0;
     HEAP32[13235] = $1;
     HEAP32[$0 + 4 >> 2] = $1 | 1;
     if (HEAP32[13237] != ($0 | 0)) {
      break label$1;
     }
     HEAP32[13234] = 0;
     HEAP32[13237] = 0;
     return;
    }
    if (HEAP32[13237] == ($5 | 0)) {
     HEAP32[13237] = $0;
     $1 = HEAP32[13234] + $1 | 0;
     HEAP32[13234] = $1;
     HEAP32[$0 + 4 >> 2] = $1 | 1;
     HEAP32[$0 + $1 >> 2] = $1;
     return;
    }
    $1 = ($2 & -8) + $1 | 0;
    label$18 : {
     if ($2 >>> 0 <= 255) {
      $4 = HEAP32[$5 + 12 >> 2];
      $3 = HEAP32[$5 + 8 >> 2];
      $5 = $2 >>> 3 | 0;
      if (($3 | 0) == ($4 | 0)) {
       HEAP32[13232] = HEAP32[13232] & __wasm_rotl_i32(-2, $5);
       break label$18;
      }
      HEAP32[$3 + 12 >> 2] = $4;
      HEAP32[$4 + 8 >> 2] = $3;
      break label$18;
     }
     $6 = HEAP32[$5 + 24 >> 2];
     $3 = HEAP32[$5 + 12 >> 2];
     label$21 : {
      if (($5 | 0) != ($3 | 0)) {
       $2 = HEAP32[$5 + 8 >> 2];
       HEAP32[$2 + 12 >> 2] = $3;
       HEAP32[$3 + 8 >> 2] = $2;
       break label$21;
      }
      label$24 : {
       $4 = $5 + 20 | 0;
       $2 = HEAP32[$4 >> 2];
       if ($2) {
        break label$24;
       }
       $4 = $5 + 16 | 0;
       $2 = HEAP32[$4 >> 2];
       if ($2) {
        break label$24;
       }
       $3 = 0;
       break label$21;
      }
      while (1) {
       $7 = $4;
       $3 = $2;
       $4 = $2 + 20 | 0;
       $2 = HEAP32[$4 >> 2];
       if ($2) {
        continue;
       }
       $4 = $3 + 16 | 0;
       $2 = HEAP32[$3 + 16 >> 2];
       if ($2) {
        continue;
       }
       break;
      }
      HEAP32[$7 >> 2] = 0;
     }
     if (!$6) {
      break label$18;
     }
     $4 = HEAP32[$5 + 28 >> 2];
     $2 = ($4 << 2) + 53232 | 0;
     label$26 : {
      if (HEAP32[$2 >> 2] == ($5 | 0)) {
       HEAP32[$2 >> 2] = $3;
       if ($3) {
        break label$26;
       }
       HEAP32[13233] = HEAP32[13233] & __wasm_rotl_i32(-2, $4);
       break label$18;
      }
      HEAP32[(HEAP32[$6 + 16 >> 2] == ($5 | 0) ? 16 : 20) + $6 >> 2] = $3;
      if (!$3) {
       break label$18;
      }
     }
     HEAP32[$3 + 24 >> 2] = $6;
     $2 = HEAP32[$5 + 16 >> 2];
     if ($2) {
      HEAP32[$3 + 16 >> 2] = $2;
      HEAP32[$2 + 24 >> 2] = $3;
     }
     $2 = HEAP32[$5 + 20 >> 2];
     if (!$2) {
      break label$18;
     }
     HEAP32[$3 + 20 >> 2] = $2;
     HEAP32[$2 + 24 >> 2] = $3;
    }
    HEAP32[$0 + 4 >> 2] = $1 | 1;
    HEAP32[$0 + $1 >> 2] = $1;
    if (HEAP32[13237] != ($0 | 0)) {
     break label$14;
    }
    HEAP32[13234] = $1;
    return;
   }
   HEAP32[$5 + 4 >> 2] = $2 & -2;
   HEAP32[$0 + 4 >> 2] = $1 | 1;
   HEAP32[$0 + $1 >> 2] = $1;
  }
  if ($1 >>> 0 <= 255) {
   $2 = $1 >>> 3 | 0;
   $1 = ($2 << 3) + 52968 | 0;
   $2 = 1 << $2;
   $4 = HEAP32[13232];
   label$30 : {
    if (!($2 & $4)) {
     HEAP32[13232] = $2 | $4;
     $2 = $1;
     break label$30;
    }
    $2 = HEAP32[$1 + 8 >> 2];
   }
   HEAP32[$1 + 8 >> 2] = $0;
   HEAP32[$2 + 12 >> 2] = $0;
   HEAP32[$0 + 12 >> 2] = $1;
   HEAP32[$0 + 8 >> 2] = $2;
   return;
  }
  $2 = 31;
  HEAP32[$0 + 16 >> 2] = 0;
  HEAP32[$0 + 20 >> 2] = 0;
  if ($1 >>> 0 <= 16777215) {
   $2 = $1 >>> 8 | 0;
   $3 = $2;
   $2 = $2 + 1048320 >>> 16 & 8;
   $4 = $3 << $2;
   $3 = $4;
   $4 = $4 + 520192 >>> 16 & 4;
   $3 = $3 << $4;
   $7 = $3;
   $3 = $3 + 245760 >>> 16 & 2;
   $2 = ($7 << $3 >>> 15 | 0) - ($2 | $4 | $3) | 0;
   $2 = ($2 << 1 | $1 >>> $2 + 21 & 1) + 28 | 0;
  }
  HEAP32[$0 + 28 >> 2] = $2;
  $4 = ($2 << 2) + 53232 | 0;
  label$33 : {
   $3 = HEAP32[13233];
   $5 = 1 << $2;
   label$34 : {
    if (!($3 & $5)) {
     HEAP32[13233] = $3 | $5;
     HEAP32[$4 >> 2] = $0;
     break label$34;
    }
    $2 = $1 << (($2 | 0) == 31 ? 0 : 25 - ($2 >>> 1 | 0) | 0);
    $3 = HEAP32[$4 >> 2];
    while (1) {
     $4 = $3;
     if ((HEAP32[$3 + 4 >> 2] & -8) == ($1 | 0)) {
      break label$33;
     }
     $3 = $2 >>> 29 | 0;
     $2 = $2 << 1;
     $7 = ($3 & 4) + $4 | 0;
     $5 = $7 + 16 | 0;
     $3 = HEAP32[$5 >> 2];
     if ($3) {
      continue;
     }
     break;
    }
    HEAP32[$7 + 16 >> 2] = $0;
   }
   HEAP32[$0 + 24 >> 2] = $4;
   HEAP32[$0 + 12 >> 2] = $0;
   HEAP32[$0 + 8 >> 2] = $0;
   return;
  }
  $1 = HEAP32[$4 + 8 >> 2];
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $0;
  HEAP32[$0 + 24 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = $4;
  HEAP32[$0 + 8 >> 2] = $1;
 }
}
function tf_analysis($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = Math_fround(0), $24 = 0, $25 = 0, $26 = 0, $27 = Math_fround(0), $28 = 0, $29 = 0, $30 = Math_fround(0), $31 = 0, $32 = 0, $33 = 0, $34 = Math_fround(0);
 $11 = __stack_pointer;
 $28 = $11;
 $20 = 1;
 $12 = ($1 << 2) + 15 & -16;
 $21 = $11 - $12 | 0;
 $13 = $21;
 __stack_pointer = $13;
 $11 = HEAP32[$0 + 32 >> 2];
 $24 = $1 - 1 | 0;
 $14 = (HEAP16[$11 + ($1 << 1) >> 1] - HEAP16[($24 << 1) + $11 >> 1] << $7 << 2) + 15 & -16;
 $22 = $13 - $14 | 0;
 $13 = $22;
 __stack_pointer = $13;
 $29 = $13 - $14 | 0;
 $13 = $29;
 __stack_pointer = $13;
 $25 = $13 - $12 | 0;
 $13 = $25;
 __stack_pointer = $13;
 $26 = $13 - $12 | 0;
 __stack_pointer = $26;
 if (($1 | 0) >= 1) {
  $27 = Math_fround(Math_fround(Math_max(Math_fround(Math_fround(.5) - $8), Math_fround(-.25))) * Math_fround(.03999999910593033));
  $30 = Math_fround($27 * Math_fround(($2 ? $7 : 0) | 0));
  $31 = 1 << $7;
  $32 = Math_imul($6, $9);
  $33 = 0 - ($7 << 1) | 0;
  $34 = Math_fround($27 * Math_fround($7 + 1 | 0));
  while (1) {
   $12 = HEAP16[($16 << 1) + $11 >> 1];
   $6 = (($12 << $7) + $32 << 2) + $5 | 0;
   $18 = $16 + 1 | 0;
   $9 = HEAP16[($18 << 1) + $11 >> 1] - $12 | 0;
   $12 = $9 << $7;
   $14 = $12 << 2;
   $13 = memcpy($22, $6, $14);
   $8 = Math_fround(0);
   $11 = 0;
   $15 = ($12 | 0) < 1;
   if (!$15) {
    while (1) {
     $8 = Math_fround($8 + Math_fround(Math_abs(HEAPF32[($11 << 2) + $13 >> 2])));
     $11 = $11 + 1 | 0;
     if (($12 | 0) != ($11 | 0)) {
      continue;
     }
     break;
    }
   }
   $23 = Math_fround($8 + Math_fround($30 * $8));
   $11 = 0;
   $6 = 0;
   label$5 : {
    if (!$2) {
     break label$5;
    }
    $6 = 0;
    if (($9 | 0) == 1) {
     break label$5;
    }
    $6 = memcpy($29, $13, $14);
    haar1($6, $12 >> $7, $31);
    $14 = 0;
    $8 = Math_fround(0);
    if (!$15) {
     while (1) {
      $8 = Math_fround($8 + Math_fround(Math_abs(HEAPF32[($14 << 2) + $6 >> 2])));
      $14 = $14 + 1 | 0;
      if (($14 | 0) != ($12 | 0)) {
       continue;
      }
      break;
     }
    }
    $8 = Math_fround($8 + Math_fround($34 * $8));
    $6 = 0;
    if ($23 > $8 ^ 1) {
     break label$5;
    }
    $23 = $8;
    $6 = -1;
   }
   $19 = ($9 | 0) != 1;
   $17 = ($19 & !$2) + $7 | 0;
   if (($17 | 0) >= 1) {
    while (1) {
     haar1($13, $12 >> $11, 1 << $11);
     $14 = $11 + 1 | 0;
     $9 = $2 ? ($11 ^ -1) + $7 | 0 : $14;
     $11 = 0;
     $8 = Math_fround(0);
     if (!$15) {
      while (1) {
       $8 = Math_fround($8 + Math_fround(Math_abs(HEAPF32[($11 << 2) + $13 >> 2])));
       $11 = $11 + 1 | 0;
       if (($12 | 0) != ($11 | 0)) {
        continue;
       }
       break;
      }
     }
     $8 = Math_fround($8 + Math_fround(Math_fround($27 * Math_fround($9 | 0)) * $8));
     $11 = $23 > $8;
     $23 = $11 ? $8 : $23;
     $6 = $11 ? $14 : $6;
     $11 = $14;
     if (($17 | 0) != ($11 | 0)) {
      continue;
     }
     break;
    }
   }
   $12 = ($16 << 2) + $21 | 0;
   $11 = $6 << 1;
   $11 = $2 ? $11 : 0 - $11 | 0;
   HEAP32[$12 >> 2] = $11;
   if (!((($11 | 0) != ($33 | 0) ? $11 : 0) | $19)) {
    HEAP32[$12 >> 2] = $11 - 1;
   }
   if (($1 | 0) != ($18 | 0)) {
    $11 = HEAP32[$0 + 32 >> 2];
    $16 = $18;
    continue;
   }
   break;
  }
  $18 = HEAP32[$21 >> 2];
 }
 $0 = $2 << 2;
 $16 = ($7 << 3) + 1744 | 0;
 $15 = HEAP8[$0 + $16 | 0] << 1;
 $11 = $18 - $15 | 0;
 $5 = $11;
 $19 = HEAP32[$10 >> 2];
 $11 = $11 >> 31;
 $11 = Math_imul($19, $11 ^ $11 + $5);
 $17 = HEAP8[($0 | 1) + $16 | 0] << 1;
 $12 = $18 - $17 | 0;
 $6 = $12;
 $5 = $2 ? 0 : $4;
 $12 = $12 >> 31;
 $12 = $5 + Math_imul($12 ^ $12 + $6, $19) | 0;
 label$14 : {
  if (($1 | 0) <= 1) {
   $6 = $12;
   break label$14;
  }
  while (1) {
   $13 = $4 + $11 | 0;
   $14 = $20 << 2;
   $6 = HEAP32[$21 + $14 >> 2];
   $9 = $6 - $15 | 0;
   $22 = $9;
   $14 = HEAP32[$10 + $14 >> 2];
   $9 = $9 >> 31;
   $22 = Math_imul($14, $9 ^ $9 + $22);
   $9 = $4 + $12 | 0;
   $11 = $22 + (($9 | 0) > ($11 | 0) ? $11 : $9) | 0;
   $6 = $6 - $17 | 0;
   $9 = $6;
   $6 = $6 >> 31;
   $6 = Math_imul($6 ^ $6 + $9, $14) + (($12 | 0) > ($13 | 0) ? $13 : $12) | 0;
   $12 = $6;
   $20 = $20 + 1 | 0;
   if (($20 | 0) != ($1 | 0)) {
    continue;
   }
   break;
  }
 }
 $14 = 1;
 $17 = HEAP8[($0 | 2) + $16 | 0] << 1;
 $12 = $18 - $17 | 0;
 $9 = $12;
 $12 = $12 >> 31;
 $12 = Math_imul($12 ^ $12 + $9, $19);
 $16 = HEAP8[($0 | 3) + $16 | 0] << 1;
 $13 = $18 - $16 | 0;
 $9 = $13;
 $13 = $13 >> 31;
 $13 = Math_imul($13 ^ $13 + $9, $19) + $5 | 0;
 $20 = ($6 | 0) > ($11 | 0) ? $11 : $6;
 label$17 : {
  if (($1 | 0) <= 1) {
   $11 = $13;
   break label$17;
  }
  while (1) {
   $11 = $4 + $12 | 0;
   $6 = $14 << 2;
   $9 = HEAP32[$21 + $6 >> 2];
   $15 = $9 - $17 | 0;
   $5 = $15;
   $6 = HEAP32[$6 + $10 >> 2];
   $15 = $15 >> 31;
   $5 = Math_imul($6, $15 ^ $15 + $5);
   $15 = $4 + $13 | 0;
   $12 = $5 + (($12 | 0) < ($15 | 0) ? $12 : $15) | 0;
   $9 = $9 - $16 | 0;
   $5 = $9;
   $9 = $9 >> 31;
   $11 = Math_imul($9 ^ $9 + $5, $6) + (($11 | 0) < ($13 | 0) ? $11 : $13) | 0;
   $13 = $11;
   $14 = $14 + 1 | 0;
   if (($14 | 0) != ($1 | 0)) {
    continue;
   }
   break;
  }
 }
 $14 = 1;
 $16 = ($2 | 0) != 0 & ((($11 | 0) > ($12 | 0) ? $12 : $11) | 0) < ($20 | 0);
 $12 = ($16 ? 2 : 0) | $0;
 $13 = ($7 << 3) + 1744 | 0;
 $15 = HEAP8[$12 + $13 | 0] << 1;
 $11 = $18 - $15 | 0;
 $0 = $11;
 $11 = $11 >> 31;
 $11 = Math_imul($11 ^ $11 + $0, $19);
 $17 = HEAP8[($12 | 1) + $13 | 0] << 1;
 $12 = $18 - $17 | 0;
 $0 = $12;
 $12 = $12 >> 31;
 $12 = Math_imul($12 ^ $12 + $0, $19) + ($2 ? 0 : $4) | 0;
 if (($1 | 0) <= 1) {
  HEAP32[($24 << 2) + $3 >> 2] = ($11 | 0) >= ($12 | 0);
  __stack_pointer = $28;
  return $16;
 }
 while (1) {
  $13 = $14 << 2;
  $6 = $4 + $12 | 0;
  HEAP32[$25 + $13 >> 2] = ($11 | 0) >= ($6 | 0);
  $9 = $4 + $11 | 0;
  HEAP32[$13 + $26 >> 2] = ($12 | 0) <= ($9 | 0);
  $7 = HEAP32[$13 + $21 >> 2];
  $2 = $7 - $17 | 0;
  $0 = $2;
  $13 = HEAP32[$10 + $13 >> 2];
  $2 = $2 >> 31;
  $12 = Math_imul($13, $2 ^ $2 + $0) + (($9 | 0) < ($12 | 0) ? $9 : $12) | 0;
  $9 = $7 - $15 | 0;
  $0 = $9;
  $9 = $9 >> 31;
  $11 = Math_imul($9 ^ $9 + $0, $13) + (($6 | 0) > ($11 | 0) ? $11 : $6) | 0;
  $14 = $14 + 1 | 0;
  if (($14 | 0) != ($1 | 0)) {
   continue;
  }
  break;
 }
 $12 = ($11 | 0) >= ($12 | 0);
 HEAP32[($24 << 2) + $3 >> 2] = $12;
 if (($1 | 0) >= 2) {
  $11 = $1 - 2 | 0;
  while (1) {
   $13 = $11 << 2;
   $12 = HEAP32[($13 + (($12 | 0) == 1 ? $26 : $25) | 0) + 4 >> 2];
   HEAP32[$3 + $13 >> 2] = $12;
   $13 = ($11 | 0) > 0;
   $11 = $11 - 1 | 0;
   if ($13) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $28;
 return $16;
}
function silk_burg_modified_FLP($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = Math_fround(0), $27 = Math_fround(0), $28 = Math_fround(0), $29 = 0;
 $7 = __stack_pointer - 992 | 0;
 __stack_pointer = $7;
 $6 = Math_imul($3, $4);
 if (($6 | 0) < 385) {
  $19 = silk_energy_FLP($1, $6);
  memset($7 + 800 | 0, 0, 192);
  if (($4 | 0) >= 1) {
   while (1) {
    $6 = 1;
    if (($5 | 0) >= 1) {
     $9 = (Math_imul($3, $14) << 2) + $1 | 0;
     while (1) {
      $13 = ($6 << 3) + $7 | 0;
      $11 = $13 + 792 | 0;
      HEAPF64[$11 >> 3] = silk_inner_product_FLP($9, ($6 << 2) + $9 | 0, $3 - $6 | 0) + HEAPF64[$13 + 792 >> 3];
      $11 = ($5 | 0) != ($6 | 0);
      $6 = $6 + 1 | 0;
      if ($11) {
       continue;
      }
      break;
     }
    }
    $14 = $14 + 1 | 0;
    if (($14 | 0) != ($4 | 0)) {
     continue;
    }
    break;
   }
  }
  memcpy($7 + 608 | 0, $7 + 800 | 0, 192);
  $24 = $19 * 9999999747378752e-21;
  $10 = $19 + $24 + 9.999999717180685e-10;
  HEAPF64[$7 + 192 >> 3] = $10;
  HEAPF64[$7 + 400 >> 3] = $10;
  label$6 : {
   label$7 : {
    if (($5 | 0) < 1) {
     $12 = 1;
     break label$7;
    }
    $25 = +$2;
    $11 = 0;
    $21 = 2;
    $20 = 1;
    $22 = 1;
    while (1) {
     if (($4 | 0) >= 1) {
      $17 = $3 - $11 | 0;
      $18 = $17 - 1 | 0;
      $16 = 0;
      while (1) {
       $9 = (Math_imul($3, $16) << 2) + $1 | 0;
       $26 = HEAPF32[$9 + ($18 << 2) >> 2];
       $8 = +$26;
       $27 = HEAPF32[($11 << 2) + $9 >> 2];
       $10 = +$27;
       $6 = 0;
       if ($11) {
        while (1) {
         $14 = $6 << 3;
         $13 = $14 + ($7 + 800 | 0) | 0;
         $2 = HEAPF32[(($6 ^ -1) + $11 << 2) + $9 >> 2];
         HEAPF64[$13 >> 3] = HEAPF64[$13 >> 3] - +Math_fround($27 * $2);
         $13 = ($7 + 608 | 0) + $14 | 0;
         $28 = HEAPF32[($6 + $17 << 2) + $9 >> 2];
         HEAPF64[$13 >> 3] = HEAPF64[$13 >> 3] - +Math_fround($26 * $28);
         $12 = HEAPF64[$7 + $14 >> 3];
         $10 = $10 + $12 * +$2;
         $8 = $8 + $12 * +$28;
         $6 = $6 + 1 | 0;
         if (($11 | 0) != ($6 | 0)) {
          continue;
         }
         break;
        }
       }
       $6 = 0;
       while (1) {
        $14 = $6 << 3;
        $13 = $14 + ($7 + 400 | 0) | 0;
        HEAPF64[$13 >> 3] = HEAPF64[$13 >> 3] - $10 * +HEAPF32[($11 - $6 << 2) + $9 >> 2];
        $14 = ($7 + 192 | 0) + $14 | 0;
        HEAPF64[$14 >> 3] = HEAPF64[$14 >> 3] - $8 * +HEAPF32[($6 + $18 << 2) + $9 >> 2];
        $6 = $6 + 1 | 0;
        if (($20 | 0) != ($6 | 0)) {
         continue;
        }
        break;
       }
       $16 = $16 + 1 | 0;
       if (($16 | 0) != ($4 | 0)) {
        continue;
       }
       break;
      }
     }
     $18 = $11 << 3;
     $10 = HEAPF64[$18 + ($7 + 608 | 0) >> 3];
     $8 = HEAPF64[($7 + 800 | 0) + $18 >> 3];
     $6 = 0;
     if ($11) {
      while (1) {
       $12 = HEAPF64[($6 << 3) + $7 >> 3];
       $9 = ($6 ^ -1) + $11 << 3;
       $10 = $10 + $12 * HEAPF64[$9 + ($7 + 800 | 0) >> 3];
       $8 = $8 + $12 * HEAPF64[($7 + 608 | 0) + $9 >> 3];
       $6 = $6 + 1 | 0;
       if (($11 | 0) != ($6 | 0)) {
        continue;
       }
       break;
      }
     }
     $13 = $11 + 1 | 0;
     $6 = $13 << 3;
     HEAPF64[$6 + ($7 + 400 | 0) >> 3] = $8;
     $17 = ($7 + 192 | 0) + $6 | 0;
     HEAPF64[$17 >> 3] = $10;
     $6 = 0;
     $12 = HEAPF64[$7 + 192 >> 3];
     $23 = HEAPF64[$7 + 400 >> 3];
     $15 = $23;
     if ($11) {
      while (1) {
       $8 = HEAPF64[($6 << 3) + $7 >> 3];
       $9 = $6 + 1 | 0;
       $14 = $9 << 3;
       $15 = $15 + $8 * HEAPF64[$14 + ($7 + 400 | 0) >> 3];
       $12 = $12 + $8 * HEAPF64[($7 + 192 | 0) + $14 >> 3];
       $10 = $10 + $8 * HEAPF64[($7 + 192 | 0) + ($11 - $6 << 3) >> 3];
       $6 = $9;
       if (($11 | 0) != ($6 | 0)) {
        continue;
       }
       break;
      }
     }
     $16 = 1;
     $8 = $10 * -2 / ($15 + $12);
     $15 = $22 * (1 - $8 * $8);
     if (!($25 >= $15 ^ 1)) {
      $16 = 0;
      $15 = $25;
      $8 = Math_sqrt(1 - $15 / $22);
      $8 = $10 > 0 ? -$8 : $8;
     }
     if ($13 & 2147483646) {
      $14 = $20 >>> 1 | 0;
      $6 = 0;
      while (1) {
       $9 = ($6 << 3) + $7 | 0;
       $29 = $9;
       $10 = HEAPF64[$9 >> 3];
       $9 = (($6 ^ -1) + $11 << 3) + $7 | 0;
       $12 = HEAPF64[$9 >> 3];
       HEAPF64[$29 >> 3] = $10 + $8 * $12;
       HEAPF64[$9 >> 3] = $12 + $8 * $10;
       $6 = $6 + 1 | 0;
       if (($14 | 0) != ($6 | 0)) {
        continue;
       }
       break;
      }
     }
     HEAPF64[$7 + $18 >> 3] = $8;
     label$22 : {
      if ($16) {
       $10 = HEAPF64[$17 >> 3];
       HEAPF64[$17 >> 3] = $10 + $8 * $23;
       HEAPF64[$7 + 400 >> 3] = $23 + $8 * $10;
       $6 = 1;
       while (1) {
        $9 = ($7 + 192 | 0) + ($13 - $6 << 3) | 0;
        $11 = $9;
        $10 = HEAPF64[$9 >> 3];
        $9 = ($7 + 400 | 0) + ($6 << 3) | 0;
        $12 = HEAPF64[$9 >> 3];
        HEAPF64[$11 >> 3] = $10 + $8 * $12;
        HEAPF64[$9 >> 3] = $12 + $8 * $10;
        $6 = $6 + 1 | 0;
        if (($21 | 0) != ($6 | 0)) {
         continue;
        }
        break;
       }
       break label$22;
      }
      if (($5 | 0) > ($13 | 0)) {
       memset(($13 << 3) + $7 | 0, 0, $5 - $13 << 3);
      }
      $6 = 0;
      while (1) {
       HEAPF32[($6 << 2) + $0 >> 2] = -Math_fround(HEAPF64[($6 << 3) + $7 >> 3]);
       $6 = $6 + 1 | 0;
       if (($6 | 0) != ($5 | 0)) {
        continue;
       }
       break;
      }
      $6 = 0;
      if (($4 | 0) > 0) {
       while (1) {
        $19 = $19 - silk_energy_FLP((Math_imul($3, $6) << 2) + $1 | 0, $5);
        $6 = $6 + 1 | 0;
        if (($6 | 0) != ($4 | 0)) {
         continue;
        }
        break;
       }
      }
      $8 = $15 * $19;
      break label$6;
     }
     $21 = $21 + 1 | 0;
     $20 = $20 + 1 | 0;
     $22 = $15;
     $11 = $13;
     if (($11 | 0) != ($5 | 0)) {
      continue;
     }
     break;
    }
    $12 = 1;
    $10 = HEAPF64[$7 + 400 >> 3];
    if (($5 | 0) < 1) {
     break label$7;
    }
    $6 = 0;
    while (1) {
     $9 = $6 + 1 | 0;
     $15 = HEAPF64[($7 + 400 | 0) + ($9 << 3) >> 3];
     $8 = HEAPF64[($6 << 3) + $7 >> 3];
     HEAPF32[($6 << 2) + $0 >> 2] = -Math_fround($8);
     $10 = $10 + $8 * $15;
     $12 = $12 + $8 * $8;
     $6 = $9;
     if (($6 | 0) != ($5 | 0)) {
      continue;
     }
     break;
    }
   }
   $8 = $10 - $24 * $12;
  }
  __stack_pointer = $7 + 992 | 0;
  return Math_fround($8);
 }
 celt_fatal(16463, 16523, 55);
 abort();
}
function quant_coarse_energy($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16) {
 var $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = Math_fround(0), $24 = 0, $25 = 0, $26 = 0, $27 = Math_fround(0), $28 = 0, $29 = 0, $30 = Math_fround(0), $31 = 0, $32 = 0, $33 = 0;
 $25 = __stack_pointer - 96 | 0;
 $21 = $25;
 __stack_pointer = $21;
 $26 = 1;
 label$1 : {
  if ($12) {
   break label$1;
  }
  $26 = 0;
  if ($14) {
   break label$1;
  }
  $12 = Math_imul($2 - $1 | 0, $9);
  if (HEAPF32[$13 >> 2] > Math_fround($12 << 1) ^ 1) {
   break label$1;
  }
  $26 = ($11 | 0) > ($12 | 0);
 }
 $30 = Math_fround(Math_fround(Math_fround(HEAPF32[$13 >> 2] * Math_fround($6 >>> 0)) * Math_fround($15 | 0)) / Math_fround($9 << 9));
 $18 = ($9 | 0) > 1 ? $9 : 1;
 $22 = HEAP32[$0 + 8 >> 2];
 while (1) {
  if (($1 | 0) < ($3 | 0)) {
   $24 = Math_imul($20, $22);
   $12 = $1;
   while (1) {
    $15 = $12 + $24 << 2;
    $23 = Math_fround(HEAPF32[$15 + $4 >> 2] - HEAPF32[$5 + $15 >> 2]);
    $27 = Math_fround($27 + Math_fround($23 * $23));
    $12 = $12 + 1 | 0;
    if (($12 | 0) != ($3 | 0)) {
     continue;
    }
    break;
   }
  }
  $20 = $20 + 1 | 0;
  if (($18 | 0) != ($20 | 0)) {
   continue;
  }
  break;
 }
 $24 = HEAP32[$8 + 20 >> 2];
 $20 = HEAP32[$8 + 28 >> 2];
 $19 = $8;
 $18 = HEAP32[$19 + 16 >> 2];
 $17 = HEAP32[$19 + 20 >> 2];
 $3 = $18;
 $18 = $21;
 HEAP32[$18 + 88 >> 2] = $3;
 HEAP32[$18 + 92 >> 2] = $17;
 $18 = HEAP32[$19 + 12 >> 2];
 $17 = HEAP32[$19 + 8 >> 2];
 $3 = $17;
 $17 = $21;
 HEAP32[$17 + 80 >> 2] = $3;
 HEAP32[$17 + 84 >> 2] = $18;
 $17 = HEAP32[$19 + 4 >> 2];
 $18 = HEAP32[$19 >> 2];
 $3 = $18;
 $18 = $21;
 HEAP32[$18 + 72 >> 2] = $3;
 HEAP32[$18 + 76 >> 2] = $17;
 $3 = HEAP32[$19 + 24 >> 2];
 $18 = HEAP32[$19 + 40 >> 2];
 $17 = HEAP32[$19 + 36 >> 2];
 $12 = $17;
 $17 = $21;
 HEAP32[$17 + 56 >> 2] = $12;
 HEAP32[$17 + 60 >> 2] = $18;
 HEAP32[$17 - -64 >> 2] = HEAP32[$19 + 44 >> 2];
 $17 = HEAP32[$19 + 32 >> 2];
 $18 = HEAP32[$19 + 28 >> 2];
 $12 = $18;
 $18 = $21;
 HEAP32[$18 + 48 >> 2] = $12;
 HEAP32[$18 + 52 >> 2] = $17;
 $15 = $25 - ((Math_imul($9, $22) << 2) + 15 & -16) | 0;
 $12 = $15;
 __stack_pointer = $12;
 $22 = Math_imul(HEAP32[$0 + 8 >> 2], $9) << 2;
 $12 = $12 - ($22 + 15 & -16) | 0;
 $28 = $12;
 __stack_pointer = $12;
 $15 = memcpy($15, $5, $22);
 $23 = ($2 - $1 | 0) > 10 ? Math_fround(Math_min(Math_fround(Math_fround($11 | 0) * Math_fround(.125)), Math_fround(16))) : Math_fround(16);
 $25 = 0;
 $24 = Math_clz32($20) + $24 | 0;
 $20 = $24 - 29 >>> 0 > $6 >>> 0;
 $14 = $20 ? 0 : $14;
 $20 = $20 ? 0 : $26;
 $22 = $14 | $20;
 if (Math_fround(Math_abs($30)) < Math_fround(2147483648)) {
  $26 = ~~$30;
 } else {
  $26 = -2147483648;
 }
 $23 = $16 ? Math_fround(3) : $23;
 $24 = $24 - 32 | 0;
 if ($22) {
  $25 = quant_coarse_energy_impl($0, $1, $2, $4, $15, $6, $24, Math_imul($10, 84) + 33082 | 0, $12, $8, $9, $10, 1, $23, $16);
 }
 $27 = Math_fround(Math_min($27, Math_fround(200)));
 label$8 : {
  label$9 : {
   if (!$20) {
    $33 = ec_tell_frac($8);
    $11 = HEAP32[$8 >> 2];
    HEAP32[$21 + 40 >> 2] = HEAP32[$8 + 20 >> 2];
    $17 = HEAP32[$8 + 12 >> 2];
    $18 = HEAP32[$19 + 16 >> 2];
    $20 = $17;
    $17 = $21;
    HEAP32[$17 + 32 >> 2] = $20;
    HEAP32[$17 + 36 >> 2] = $18;
    $17 = HEAP32[$19 + 8 >> 2];
    $18 = HEAP32[$19 + 4 >> 2];
    $20 = $18;
    $18 = $21;
    HEAP32[$18 + 24 >> 2] = $20;
    HEAP32[$18 + 28 >> 2] = $17;
    $31 = HEAP32[$19 + 24 >> 2];
    $20 = $19 + 28 | 0;
    $19 = $20 + 8 | 0;
    $17 = HEAP32[$19 >> 2];
    $18 = HEAP32[$19 + 4 >> 2];
    $19 = $17;
    $17 = $21;
    HEAP32[$17 + 8 >> 2] = $19;
    HEAP32[$17 + 12 >> 2] = $18;
    HEAP32[$17 + 16 >> 2] = HEAP32[$20 + 16 >> 2];
    $19 = $20;
    $18 = HEAP32[$19 >> 2];
    $17 = HEAP32[$19 + 4 >> 2];
    $19 = $18;
    $18 = $21;
    HEAP32[$18 >> 2] = $19;
    HEAP32[$18 + 4 >> 2] = $17;
    $22 = $31 - $3 | 0;
    $28 = $28 - (($22 ? $22 : 1) + 15 & -16) | 0;
    __stack_pointer = $28;
    $32 = $3 + $11 | 0;
    $28 = memcpy($28, $32, $22);
    $19 = $18;
    $17 = HEAP32[$19 + 88 >> 2];
    $18 = HEAP32[$19 + 92 >> 2];
    $29 = $17;
    $17 = $8;
    HEAP32[$17 + 16 >> 2] = $29;
    HEAP32[$17 + 20 >> 2] = $18;
    $17 = HEAP32[$19 + 84 >> 2];
    $18 = HEAP32[$19 + 80 >> 2];
    $29 = $18;
    $18 = $8;
    HEAP32[$18 + 8 >> 2] = $29;
    HEAP32[$18 + 12 >> 2] = $17;
    $18 = HEAP32[$19 + 76 >> 2];
    $17 = HEAP32[$19 + 72 >> 2];
    $29 = $17;
    $17 = $8;
    HEAP32[$17 >> 2] = $29;
    HEAP32[$17 + 4 >> 2] = $18;
    HEAP32[$17 + 24 >> 2] = $3;
    HEAP32[$20 + 16 >> 2] = HEAP32[$19 - -64 >> 2];
    $17 = HEAP32[$19 + 60 >> 2];
    $18 = HEAP32[$19 + 56 >> 2];
    $3 = $18;
    $18 = $20;
    HEAP32[$18 + 8 >> 2] = $3;
    HEAP32[$18 + 12 >> 2] = $17;
    $18 = HEAP32[$19 + 52 >> 2];
    $17 = HEAP32[$19 + 48 >> 2];
    $3 = $17;
    $17 = $20;
    HEAP32[$17 >> 2] = $3;
    HEAP32[$17 + 4 >> 2] = $18;
    $3 = quant_coarse_energy_impl($0, $1, $2, $4, $5, $6, $24, Math_imul($10, 84) + 33040 | 0, $7, $8, $9, $10, 0, $23, $16);
    if (!$14) {
     break label$9;
    }
    if (($3 | 0) <= ($25 | 0)) {
     if (($3 | 0) != ($25 | 0)) {
      break label$9;
     }
     if ((ec_tell_frac($8) + $26 | 0) <= ($33 | 0)) {
      break label$9;
     }
    }
    HEAP32[$8 >> 2] = $11;
    $3 = $8 + 4 | 0;
    HEAP32[$3 + 16 >> 2] = HEAP32[$21 + 40 >> 2];
    $18 = HEAP32[$21 + 32 >> 2];
    $17 = HEAP32[$19 + 36 >> 2];
    $1 = $18;
    $18 = $8;
    HEAP32[$18 + 12 >> 2] = $1;
    HEAP32[$18 + 16 >> 2] = $17;
    $18 = HEAP32[$19 + 28 >> 2];
    $17 = HEAP32[$19 + 24 >> 2];
    $1 = $17;
    $17 = $8;
    HEAP32[$17 + 4 >> 2] = $1;
    HEAP32[$17 + 8 >> 2] = $18;
    HEAP32[$17 + 24 >> 2] = $31;
    HEAP32[$20 + 16 >> 2] = HEAP32[$19 + 16 >> 2];
    $17 = HEAP32[$19 + 12 >> 2];
    $18 = HEAP32[$19 + 8 >> 2];
    $1 = $18;
    $18 = $20;
    HEAP32[$18 + 8 >> 2] = $1;
    HEAP32[$18 + 12 >> 2] = $17;
    $18 = HEAP32[$19 + 4 >> 2];
    $17 = HEAP32[$19 >> 2];
    $1 = $17;
    $17 = $20;
    HEAP32[$17 >> 2] = $1;
    HEAP32[$17 + 4 >> 2] = $18;
    memcpy($32, $28, $22);
    $3 = $9 << 2;
    memcpy($5, $15, Math_imul($3, HEAP32[$0 + 8 >> 2]));
    memcpy($7, $12, Math_imul(HEAP32[$0 + 8 >> 2], $3));
    break label$8;
   }
   $3 = $9 << 2;
   memcpy($5, $15, Math_imul($3, HEAP32[$0 + 8 >> 2]));
   memcpy($7, $12, Math_imul(HEAP32[$0 + 8 >> 2], $3));
   break label$8;
  }
  $23 = HEAPF32[($10 << 2) + 33376 >> 2];
  $27 = Math_fround($27 + Math_fround(Math_fround($23 * $23) * HEAPF32[$13 >> 2]));
 }
 HEAPF32[$13 >> 2] = $27;
 __stack_pointer = $21 + 96 | 0;
}
function tonality_get_info($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = Math_fround(0), $6 = 0, $7 = 0, $8 = Math_fround(0), $9 = Math_fround(0), $10 = 0, $11 = 0, $12 = 0, $13 = Math_fround(0), $14 = Math_fround(0), $15 = Math_fround(0), $16 = 0, $17 = Math_fround(0), $18 = Math_fround(0);
 $4 = HEAP32[$0 + 8 >> 2];
 $3 = HEAP32[$0 + 7452 >> 2] + (($2 | 0) / (($4 | 0) / 400 | 0) | 0) | 0;
 HEAP32[$0 + 7452 >> 2] = $3;
 $10 = HEAP32[$0 + 7444 >> 2];
 $12 = HEAP32[$0 + 7448 >> 2];
 $7 = $12;
 if (($3 | 0) >= 8) {
  $11 = ($3 - (($3 | 0) < 15 ? $3 : 15) | 0) + 7 | 0;
  $7 = (($11 >>> 3 | 0) + $12 | 0) + 1 | 0;
  HEAP32[$0 + 7448 >> 2] = $7;
  HEAP32[$0 + 7452 >> 2] = ($3 - ($11 & -8) | 0) - 8;
 }
 if (($7 | 0) >= 100) {
  HEAP32[$0 + 7448 >> 2] = $7 - 100;
 }
 $11 = 6;
 $3 = $12 + 1 | 0;
 $3 = ($10 | 0) == ($12 | 0) ? $12 : (($4 | 0) / 50 | 0) >= ($2 | 0) ? $12 : ($3 | 0) == 100 ? 0 : $3;
 $3 = $3 - (($3 | 0) == ($10 | 0)) | 0;
 $2 = ($3 | 0) < 0 ? 99 : $3;
 $3 = ($2 << 6) + $0 | 0;
 $6 = $3 + 7660 | 0;
 $7 = HEAP32[$6 >> 2];
 $4 = HEAP32[$6 + 4 >> 2];
 HEAP32[$1 + 56 >> 2] = $7;
 HEAP32[$1 + 60 >> 2] = $4;
 $6 = $3 + 7652 | 0;
 $4 = HEAP32[$6 >> 2];
 $7 = HEAP32[$6 + 4 >> 2];
 HEAP32[$1 + 48 >> 2] = $4;
 HEAP32[$1 + 52 >> 2] = $7;
 $6 = $3 + 7644 | 0;
 $7 = HEAP32[$6 >> 2];
 $4 = HEAP32[$6 + 4 >> 2];
 HEAP32[$1 + 40 >> 2] = $7;
 HEAP32[$1 + 44 >> 2] = $4;
 $6 = $3 + 7636 | 0;
 $4 = HEAP32[$6 >> 2];
 $7 = HEAP32[$6 + 4 >> 2];
 HEAP32[$1 + 32 >> 2] = $4;
 HEAP32[$1 + 36 >> 2] = $7;
 $6 = $3 + 7628 | 0;
 $7 = HEAP32[$6 >> 2];
 $4 = HEAP32[$6 + 4 >> 2];
 HEAP32[$1 + 24 >> 2] = $7;
 HEAP32[$1 + 28 >> 2] = $4;
 $6 = $3 + 7620 | 0;
 $4 = HEAP32[$6 >> 2];
 $7 = HEAP32[$6 + 4 >> 2];
 HEAP32[$1 + 16 >> 2] = $4;
 HEAP32[$1 + 20 >> 2] = $7;
 $6 = $3 + 7612 | 0;
 $7 = HEAP32[$6 >> 2];
 $4 = HEAP32[$6 + 4 >> 2];
 HEAP32[$1 + 8 >> 2] = $7;
 HEAP32[$1 + 12 >> 2] = $4;
 $6 = $3 + 7604 | 0;
 $4 = HEAP32[$6 >> 2];
 $7 = HEAP32[$6 + 4 >> 2];
 HEAP32[$1 >> 2] = $4;
 HEAP32[$1 + 4 >> 2] = $7;
 if ($4) {
  $3 = $10 - $12 | 0;
  $10 = ($3 | 0) < 0;
  $7 = $3 + 100 | 0;
  $5 = HEAPF32[$1 + 4 >> 2];
  $8 = Math_fround(1);
  $16 = $2 + 1 | 0;
  $4 = ($16 | 0) == 100 ? 0 : $16;
  $12 = HEAP32[$0 + 7444 >> 2];
  label$4 : {
   if (($4 | 0) == ($12 | 0)) {
    $9 = $5;
    break label$4;
   }
   $11 = ($4 << 6) + $0 | 0;
   $8 = HEAPF32[$11 + 7608 >> 2];
   $6 = HEAP32[$1 + 32 >> 2];
   $11 = HEAP32[$11 + 7636 >> 2];
   $11 = ($11 | 0) < ($6 | 0) ? $6 : $11;
   HEAP32[$1 + 32 >> 2] = $11;
   $9 = $5 > $8 ? $5 : $8;
   $5 = Math_fround($5 + $8);
   $4 = $4 + 1 | 0;
   $4 = ($4 | 0) == 100 ? 0 : $4;
   if (($12 | 0) == ($4 | 0)) {
    $11 = 5;
    $8 = Math_fround(2);
    break label$4;
   }
   $6 = ($4 << 6) + $0 | 0;
   $8 = HEAPF32[$6 + 7608 >> 2];
   $6 = HEAP32[$6 + 7636 >> 2];
   $11 = ($11 | 0) > ($6 | 0) ? $11 : $6;
   HEAP32[$1 + 32 >> 2] = $11;
   $9 = $8 < $9 ? $9 : $8;
   $5 = Math_fround($5 + $8);
   $4 = $4 + 1 | 0;
   $4 = ($4 | 0) == 100 ? 0 : $4;
   if (($12 | 0) == ($4 | 0)) {
    $11 = 4;
    $8 = Math_fround(3);
    break label$4;
   }
   $4 = ($4 << 6) + $0 | 0;
   $8 = HEAPF32[$4 + 7608 >> 2];
   $4 = HEAP32[$4 + 7636 >> 2];
   HEAP32[$1 + 32 >> 2] = ($4 | 0) < ($11 | 0) ? $11 : $4;
   $9 = $8 < $9 ? $9 : $8;
   $5 = Math_fround($5 + $8);
   $11 = 3;
   $8 = Math_fround(4);
  }
  $6 = $10 ? $7 : $3;
  $10 = 0;
  $3 = $2;
  while (1) {
   $3 = ($3 | 0) < 1 ? 99 : $3 - 1 | 0;
   if (($12 | 0) != ($3 | 0)) {
    $7 = HEAP32[$1 + 32 >> 2];
    $4 = HEAP32[(($3 << 6) + $0 | 0) + 7636 >> 2];
    HEAP32[$1 + 32 >> 2] = ($4 | 0) < ($7 | 0) ? $7 : $4;
    $10 = $10 + 1 | 0;
    if (($11 | 0) != ($10 | 0)) {
     continue;
    }
   }
   break;
  }
  $5 = Math_fround($5 / $8);
  $9 = Math_fround($9 + Math_fround(-.20000000298023224));
  HEAPF32[$1 + 4 >> 2] = $5 > $9 ? $5 : $9;
  $10 = $2;
  $3 = $10;
  if (($6 | 0) >= 16) {
   $10 = (($2 | 0) > 94 ? -95 : 5) + $2 | 0;
   $16 = $10 + 1 | 0;
   $3 = (($2 | 0) > 98 ? -99 : 1) + $2 | 0;
  }
  $7 = $0 + 7604 | 0;
  $17 = HEAPF32[($7 + ($3 << 6) | 0) + 36 >> 2];
  $5 = Math_fround(Math_max($17, Math_fround(.10000000149011612)));
  $9 = Math_fround(HEAPF32[(($10 << 6) + $7 | 0) + 20 >> 2] * $5);
  $10 = ($16 | 0) == 100 ? 0 : $16;
  label$11 : {
   if (($12 | 0) == ($10 | 0)) {
    $8 = Math_fround(1);
    break label$11;
   }
   $8 = Math_fround(1);
   while (1) {
    $3 = $3 + 1 | 0;
    $3 = ($3 | 0) == 100 ? 0 : $3;
    if (($12 | 0) == ($3 | 0)) {
     break label$11;
    }
    $13 = HEAPF32[(($3 << 6) + $7 | 0) + 36 >> 2];
    $15 = Math_fround(Math_fround($17 - $13) * Math_fround(10));
    $18 = Math_fround(Math_fround($9 + $15) / $5);
    $14 = $14 < $18 ? $18 : $14;
    $15 = Math_fround(Math_fround($9 - $15) / $5);
    $8 = $8 > $15 ? $15 : $8;
    $13 = Math_fround(Math_max($13, Math_fround(.10000000149011612)));
    $9 = Math_fround($9 + Math_fround(HEAPF32[(($10 << 6) + $7 | 0) + 20 >> 2] * $13));
    $5 = Math_fround($5 + $13);
    $10 = $10 + 1 | 0;
    $10 = ($10 | 0) == 100 ? 0 : $10;
    if (($12 | 0) != ($10 | 0)) {
     continue;
    }
    break;
   }
  }
  $5 = Math_fround($9 / $5);
  HEAPF32[$1 + 20 >> 2] = $5;
  $9 = $5 > $14 ? $5 : $14;
  $14 = $9 < Math_fround(1) ? $9 : Math_fround(1);
  $5 = $5 < $8 ? $5 : $8;
  $13 = $5 > Math_fround(0) ? $5 : Math_fround(0);
  if (($6 | 0) <= 9) {
   $9 = $13;
   $8 = $14;
   $3 = HEAP32[$0 + 7436 >> 2];
   if (($3 | 0) >= 2) {
    $3 = ($3 | 0) > 15 ? 15 : $3 - 1 | 0;
    $12 = ($3 | 0) > 1 ? $3 : 1;
    $3 = 0;
    while (1) {
     $2 = ($2 | 0) < 1 ? 99 : $2 - 1 | 0;
     $5 = HEAPF32[(($2 << 6) + $0 | 0) + 7624 >> 2];
     $8 = $5 < $8 ? $8 : $5;
     $9 = $5 > $9 ? $9 : $5;
     $3 = $3 + 1 | 0;
     if (($12 | 0) != ($3 | 0)) {
      continue;
     }
     break;
    }
   }
   $5 = Math_fround(Math_fround(1) - Math_fround(Math_fround($6 | 0) * Math_fround(.10000000149011612)));
   $15 = Math_fround($17 * Math_fround(.10000000149011612));
   $14 = Math_fround($14 + Math_fround($5 * Math_fround(Math_fround(Math_min(Math_fround($15 + $8), Math_fround(1))) - $14)));
   $13 = Math_fround($13 + Math_fround($5 * Math_fround(Math_fround(Math_max(Math_fround($9 - $15), Math_fround(0))) - $13)));
  }
  HEAPF32[$1 + 28 >> 2] = $14;
  HEAPF32[$1 + 24 >> 2] = $13;
 }
}
function silk_NLSF2A($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0;
 $6 = __stack_pointer - 320 | 0;
 __stack_pointer = $6;
 label$1 : {
  switch ($2 - 10 | 0) {
  default:
   celt_fatal(15418, 15451, 89);
   abort();
  case 0:
  case 6:
   break label$1;
  }
 }
 $12 = ($2 | 0) == 16 ? 15392 : 15408;
 while (1) {
  $8 = HEAP16[($5 << 1) + $1 >> 1];
  $7 = $8 >> 8 << 1;
  $3 = HEAP16[$7 + 15122 >> 1];
  $7 = HEAP16[$7 + 15120 >> 1];
  HEAP32[($6 + 224 | 0) + (HEAPU8[$5 + $12 | 0] << 2) >> 2] = (Math_imul($3 - $7 | 0, $8 & 255) + ($7 << 8) >> 3) + 1 >> 1;
  $5 = $5 + 1 | 0;
  if (($5 | 0) != ($2 | 0)) {
   continue;
  }
  break;
 }
 $7 = 65536;
 HEAP32[$6 + 160 >> 2] = 65536;
 $1 = 0 - HEAP32[$6 + 224 >> 2] | 0;
 HEAP32[$6 + 164 >> 2] = $1;
 $5 = 1;
 $19 = $2 >> 1;
 label$4 : {
  $20 = ($2 | 0) < 4;
  if ($20) {
   break label$4;
  }
  while (1) {
   $17 = HEAP32[($6 + 224 | 0) + ($5 << 3) >> 2];
   $3 = $17;
   $4 = $3 >> 31;
   $14 = $3;
   $15 = $4;
   $3 = $1;
   $4 = $3 >> 31;
   $3 = $4;
   $13 = $5 + 1 | 0;
   $18 = ($6 + 160 | 0) + ($13 << 2) | 0;
   $4 = $15;
   $3 = __wasm_i64_mul($14, $4, $1, $3);
   $9 = $3;
   $4 = i64toi32_i32$HIGH_BITS;
   $3 = $4 >>> 15 | 0;
   $4 = ($4 & 32767) << 17 | $9 >>> 15;
   $10 = $4 + 1 | 0;
   $11 = $10 >>> 0 < 1 ? $3 + 1 | 0 : $3;
   $3 = $10;
   HEAP32[$18 >> 2] = ($7 << 1) - (($11 & 1) << 31 | $3 >>> 1);
   $8 = $5 << 2;
   $16 = $8 + ($6 + 160 | 0) | 0;
   label$6 : {
    if ($5 >>> 0 < 2) {
     break label$6;
    }
    $8 = HEAP32[($6 + $8 | 0) + 152 >> 2];
    $1 = $8 + $1 | 0;
    $3 = $7;
    $4 = $3 >> 31;
    $3 = $15;
    $3 = __wasm_i64_mul($7, $4, $14, $3);
    $11 = $3;
    $4 = i64toi32_i32$HIGH_BITS;
    $3 = $4 >>> 15 | 0;
    $4 = ($4 & 32767) << 17 | $11 >>> 15;
    $9 = $4 + 1 | 0;
    $10 = $9 >>> 0 < 1 ? $3 + 1 | 0 : $3;
    $3 = $9;
    HEAP32[$16 >> 2] = $1 - (($10 & 1) << 31 | $3 >>> 1);
    if (($5 | 0) == 2) {
     break label$6;
    }
    while (1) {
     $7 = $5 - 1 | 0;
     $1 = ($6 + 160 | 0) + ($7 << 2) | 0;
     $12 = HEAP32[(($5 << 2) + $6 | 0) + 148 >> 2];
     $21 = $12 + HEAP32[$1 >> 2] | 0;
     $3 = $8;
     $4 = $3 >> 31;
     $3 = $15;
     $3 = __wasm_i64_mul($8, $4, $14, $3);
     $10 = $3;
     $4 = i64toi32_i32$HIGH_BITS;
     $3 = $4 >>> 15 | 0;
     $4 = ($4 & 32767) << 17 | $10 >>> 15;
     $11 = $4 + 1 | 0;
     $9 = $11 >>> 0 < 1 ? $3 + 1 | 0 : $3;
     $3 = $11;
     HEAP32[$1 >> 2] = $21 - (($9 & 1) << 31 | $3 >>> 1);
     $1 = ($5 | 0) > 3;
     $5 = $7;
     $8 = $12;
     if ($1) {
      continue;
     }
     break;
    }
   }
   HEAP32[$6 + 164 >> 2] = HEAP32[$6 + 164 >> 2] - $17;
   if (($13 | 0) == ($19 | 0)) {
    break label$4;
   }
   $1 = HEAP32[$18 >> 2];
   $7 = HEAP32[$16 >> 2];
   $5 = $13;
   continue;
  }
 }
 $7 = 65536;
 HEAP32[$6 + 96 >> 2] = 65536;
 $1 = 0 - HEAP32[$6 + 228 >> 2] | 0;
 HEAP32[$6 + 100 >> 2] = $1;
 label$8 : {
  if ($20) {
   break label$8;
  }
  $20 = $6 + 224 | 4;
  $5 = 1;
  while (1) {
   $17 = HEAP32[($5 << 3) + $20 >> 2];
   $3 = $17;
   $4 = $3 >> 31;
   $14 = $3;
   $15 = $4;
   $3 = $1;
   $4 = $3 >> 31;
   $3 = $4;
   $13 = $5 + 1 | 0;
   $18 = ($6 + 96 | 0) + ($13 << 2) | 0;
   $4 = $15;
   $3 = __wasm_i64_mul($14, $4, $1, $3);
   $9 = $3;
   $4 = i64toi32_i32$HIGH_BITS;
   $3 = $4 >>> 15 | 0;
   $4 = ($4 & 32767) << 17 | $9 >>> 15;
   $10 = $4 + 1 | 0;
   $11 = $10 >>> 0 < 1 ? $3 + 1 | 0 : $3;
   $3 = $10;
   HEAP32[$18 >> 2] = ($7 << 1) - (($11 & 1) << 31 | $3 >>> 1);
   $8 = $5 << 2;
   $16 = $8 + ($6 + 96 | 0) | 0;
   label$10 : {
    if ($5 >>> 0 < 2) {
     break label$10;
    }
    $8 = HEAP32[($6 + $8 | 0) + 88 >> 2];
    $1 = $8 + $1 | 0;
    $3 = $7;
    $4 = $3 >> 31;
    $3 = $15;
    $3 = __wasm_i64_mul($7, $4, $14, $3);
    $11 = $3;
    $4 = i64toi32_i32$HIGH_BITS;
    $3 = $4 >>> 15 | 0;
    $4 = ($4 & 32767) << 17 | $11 >>> 15;
    $9 = $4 + 1 | 0;
    $10 = $9 >>> 0 < 1 ? $3 + 1 | 0 : $3;
    $3 = $9;
    HEAP32[$16 >> 2] = $1 - (($10 & 1) << 31 | $3 >>> 1);
    if (($5 | 0) == 2) {
     break label$10;
    }
    while (1) {
     $7 = $5 - 1 | 0;
     $1 = ($6 + 96 | 0) + ($7 << 2) | 0;
     $12 = HEAP32[(($5 << 2) + $6 | 0) + 84 >> 2];
     $21 = $12 + HEAP32[$1 >> 2] | 0;
     $3 = $8;
     $4 = $3 >> 31;
     $3 = $15;
     $3 = __wasm_i64_mul($8, $4, $14, $3);
     $10 = $3;
     $4 = i64toi32_i32$HIGH_BITS;
     $3 = $4 >>> 15 | 0;
     $4 = ($4 & 32767) << 17 | $10 >>> 15;
     $11 = $4 + 1 | 0;
     $9 = $11 >>> 0 < 1 ? $3 + 1 | 0 : $3;
     $3 = $11;
     HEAP32[$1 >> 2] = $21 - (($9 & 1) << 31 | $3 >>> 1);
     $1 = ($5 | 0) > 3;
     $5 = $7;
     $8 = $12;
     if ($1) {
      continue;
     }
     break;
    }
   }
   HEAP32[$6 + 100 >> 2] = HEAP32[$6 + 100 >> 2] - $17;
   if (($13 | 0) == ($19 | 0)) {
    break label$8;
   }
   $1 = HEAP32[$18 >> 2];
   $7 = HEAP32[$16 >> 2];
   $5 = $13;
   continue;
  }
 }
 if (($2 | 0) >= 2) {
  $16 = ($19 | 0) > 1 ? $19 : 1;
  $7 = HEAP32[$6 + 96 >> 2];
  $1 = HEAP32[$6 + 160 >> 2];
  $5 = 0;
  while (1) {
   $8 = $5 + 1 | 0;
   $12 = $8 << 2;
   $13 = HEAP32[$12 + ($6 + 96 | 0) >> 2];
   $7 = $13 - $7 | 0;
   $12 = HEAP32[($6 + 160 | 0) + $12 >> 2];
   $1 = $12 + $1 | 0;
   HEAP32[($5 << 2) + $6 >> 2] = 0 - ($7 + $1 | 0);
   HEAP32[(($5 ^ -1) + $2 << 2) + $6 >> 2] = $7 - $1;
   $7 = $13;
   $1 = $12;
   $5 = $8;
   if (($16 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
 }
 silk_LPC_fit($0, $6, 12, 17, $2);
 label$14 : {
  if (silk_LPC_inverse_pred_gain_c($0, $2)) {
   break label$14;
  }
  $8 = 0;
  while (1) {
   silk_bwexpander_32($6, $2, (-2 << $8) + 65536 | 0);
   $5 = 0;
   while (1) {
    HEAP16[($5 << 1) + $0 >> 1] = (HEAP32[($5 << 2) + $6 >> 2] >>> 4 | 0) + 1 >>> 1;
    $5 = $5 + 1 | 0;
    if (($5 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
   $5 = silk_LPC_inverse_pred_gain_c($0, $2);
   if ($8 >>> 0 > 14) {
    break label$14;
   }
   $8 = $8 + 1 | 0;
   if (!$5) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $6 + 320 | 0;
}
function celt_pitch_xcorr_c($0, $1, $2, $3, $4, $5) {
 var $6 = Math_fround(0), $7 = 0, $8 = Math_fround(0), $9 = 0, $10 = 0, $11 = 0, $12 = Math_fround(0), $13 = 0, $14 = 0, $15 = 0, $16 = Math_fround(0), $17 = 0, $18 = Math_fround(0), $19 = 0, $20 = Math_fround(0), $21 = Math_fround(0), $22 = Math_fround(0), $23 = Math_fround(0), $24 = Math_fround(0), $25 = Math_fround(0), $26 = Math_fround(0), $27 = Math_fround(0), $28 = Math_fround(0), $29 = 0, $30 = 0, $31 = Math_fround(0), $32 = 0, $33 = 0, $34 = 0;
 if (($4 | 0) >= 1) {
  label$2 : {
   if (($4 | 0) < 4) {
    break label$2;
   }
   if (($3 | 0) >= 3) {
    $32 = $4 - 3 | 0;
    $19 = $3 - 3 | 0;
    $33 = ($3 | 0) == 3;
    $29 = $3 & -4;
    $30 = $29 | 1;
    $34 = ($30 + 1 | 0) >= ($3 | 0);
    while (1) {
     $17 = $11 << 2;
     $5 = $17 + $1 | 0;
     $7 = $5 + 12 | 0;
     $8 = HEAPF32[$5 + 8 >> 2];
     $18 = HEAPF32[$5 + 4 >> 2];
     $16 = HEAPF32[$5 >> 2];
     $12 = Math_fround(0);
     $25 = Math_fround(0);
     $26 = Math_fround(0);
     $27 = Math_fround(0);
     $5 = $0;
     $10 = 0;
     $9 = 0;
     $13 = 0;
     $14 = 0;
     $15 = 0;
     if (!$33) {
      while (1) {
       $20 = HEAPF32[$5 >> 2];
       $6 = HEAPF32[$7 >> 2];
       $21 = HEAPF32[$5 + 4 >> 2];
       $22 = HEAPF32[$7 + 4 >> 2];
       $23 = HEAPF32[$5 + 8 >> 2];
       $28 = HEAPF32[$7 + 8 >> 2];
       $24 = HEAPF32[$5 + 12 >> 2];
       $31 = HEAPF32[$7 + 12 >> 2];
       $12 = Math_fround(Math_fround(Math_fround(Math_fround($12 + Math_fround($20 * $6)) + Math_fround($21 * $22)) + Math_fround($23 * $28)) + Math_fround($24 * $31));
       $25 = Math_fround(Math_fround(Math_fround(Math_fround($25 + Math_fround($8 * $20)) + Math_fround($6 * $21)) + Math_fround($22 * $23)) + Math_fround($28 * $24));
       $26 = Math_fround(Math_fround(Math_fround(Math_fround($26 + Math_fround($18 * $20)) + Math_fround($8 * $21)) + Math_fround($6 * $23)) + Math_fround($22 * $24));
       $27 = Math_fround(Math_fround(Math_fround(Math_fround($27 + Math_fround($16 * $20)) + Math_fround($18 * $21)) + Math_fround($8 * $23)) + Math_fround($6 * $24));
       $7 = $7 + 16 | 0;
       $5 = $5 + 16 | 0;
       $16 = $22;
       $8 = $31;
       $18 = $28;
       $10 = $10 + 4 | 0;
       if (($19 | 0) > ($10 | 0)) {
        continue;
       }
       break;
      }
      $13 = (wasm2js_scratch_store_f32($26), wasm2js_scratch_load_i32(2));
      $14 = (wasm2js_scratch_store_f32($25), wasm2js_scratch_load_i32(2));
      $15 = (wasm2js_scratch_store_f32($12), wasm2js_scratch_load_i32(2));
      $12 = $6;
      $9 = (wasm2js_scratch_store_f32($27), wasm2js_scratch_load_i32(2));
     }
     label$7 : {
      if (($3 | 0) <= ($29 | 0)) {
       break label$7;
      }
      $6 = HEAPF32[$5 >> 2];
      $12 = HEAPF32[$7 >> 2];
      $15 = (wasm2js_scratch_store_f32(Math_fround(Math_fround($6 * $12) + (wasm2js_scratch_store_i32(2, $15), wasm2js_scratch_load_f32()))), wasm2js_scratch_load_i32(2));
      $14 = (wasm2js_scratch_store_f32(Math_fround(Math_fround($8 * $6) + (wasm2js_scratch_store_i32(2, $14), wasm2js_scratch_load_f32()))), wasm2js_scratch_load_i32(2));
      $13 = (wasm2js_scratch_store_f32(Math_fround(Math_fround($18 * $6) + (wasm2js_scratch_store_i32(2, $13), wasm2js_scratch_load_f32()))), wasm2js_scratch_load_i32(2));
      $9 = (wasm2js_scratch_store_f32(Math_fround(Math_fround($16 * $6) + (wasm2js_scratch_store_i32(2, $9), wasm2js_scratch_load_f32()))), wasm2js_scratch_load_i32(2));
      $7 = $7 + 4 | 0;
      $5 = $5 + 4 | 0;
     }
     $10 = $7;
     label$9 : {
      if (($3 | 0) <= ($30 | 0)) {
       $7 = $10;
       break label$9;
      }
      $6 = HEAPF32[$5 >> 2];
      $16 = HEAPF32[$10 >> 2];
      $15 = (wasm2js_scratch_store_f32(Math_fround(Math_fround($6 * $16) + (wasm2js_scratch_store_i32(2, $15), wasm2js_scratch_load_f32()))), wasm2js_scratch_load_i32(2));
      $14 = (wasm2js_scratch_store_f32(Math_fround(Math_fround($12 * $6) + (wasm2js_scratch_store_i32(2, $14), wasm2js_scratch_load_f32()))), wasm2js_scratch_load_i32(2));
      $13 = (wasm2js_scratch_store_f32(Math_fround(Math_fround($8 * $6) + (wasm2js_scratch_store_i32(2, $13), wasm2js_scratch_load_f32()))), wasm2js_scratch_load_i32(2));
      $9 = (wasm2js_scratch_store_f32(Math_fround(Math_fround($18 * $6) + (wasm2js_scratch_store_i32(2, $9), wasm2js_scratch_load_f32()))), wasm2js_scratch_load_i32(2));
      $5 = $5 + 4 | 0;
      $7 = $10 + 4 | 0;
     }
     if (!$34) {
      $6 = HEAPF32[$5 >> 2];
      $15 = (wasm2js_scratch_store_f32(Math_fround(Math_fround($6 * HEAPF32[$7 >> 2]) + (wasm2js_scratch_store_i32(2, $15), wasm2js_scratch_load_f32()))), wasm2js_scratch_load_i32(2));
      $14 = (wasm2js_scratch_store_f32(Math_fround(Math_fround($16 * $6) + (wasm2js_scratch_store_i32(2, $14), wasm2js_scratch_load_f32()))), wasm2js_scratch_load_i32(2));
      $13 = (wasm2js_scratch_store_f32(Math_fround(Math_fround($12 * $6) + (wasm2js_scratch_store_i32(2, $13), wasm2js_scratch_load_f32()))), wasm2js_scratch_load_i32(2));
      $9 = (wasm2js_scratch_store_f32(Math_fround(Math_fround($8 * $6) + (wasm2js_scratch_store_i32(2, $9), wasm2js_scratch_load_f32()))), wasm2js_scratch_load_i32(2));
     }
     HEAP32[$2 + $17 >> 2] = $9;
     HEAP32[($17 | 4) + $2 >> 2] = $13;
     HEAP32[($17 | 8) + $2 >> 2] = $14;
     HEAP32[($17 | 12) + $2 >> 2] = $15;
     $11 = $11 + 4 | 0;
     if (($32 | 0) > ($11 | 0)) {
      continue;
     }
     break;
    }
    break label$2;
   }
   celt_fatal(9872, 9897, 69);
   abort();
  }
  if (($4 | 0) > ($11 | 0)) {
   $9 = ($3 | 0) < 1;
   while (1) {
    $19 = $11 << 2;
    $8 = Math_fround(0);
    if (!$9) {
     $10 = $1 + $19 | 0;
     $7 = 0;
     while (1) {
      $5 = $7 << 2;
      $8 = Math_fround($8 + Math_fround(HEAPF32[$5 + $0 >> 2] * HEAPF32[$5 + $10 >> 2]));
      $7 = $7 + 1 | 0;
      if (($7 | 0) != ($3 | 0)) {
       continue;
      }
      break;
     }
    }
    HEAPF32[$2 + $19 >> 2] = $8;
    $11 = $11 + 1 | 0;
    if (($11 | 0) != ($4 | 0)) {
     continue;
    }
    break;
   }
  }
  return;
 }
 celt_fatal(9738, 9768, 251);
 abort();
}
function quant_band_stereo($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = Math_fround(0), $12 = 0, $13 = 0, $14 = 0, $15 = Math_fround(0), $16 = 0, $17 = 0, $18 = Math_fround(0), $19 = Math_fround(0), $20 = 0, $21 = 0, $22 = 0, $23 = Math_fround(0);
 $12 = __stack_pointer - 32 | 0;
 __stack_pointer = $12;
 HEAP32[$12 + 24 >> 2] = $10;
 HEAP32[$12 + 28 >> 2] = $4;
 $4 = HEAP32[$0 + 28 >> 2];
 $16 = HEAP32[$0 >> 2];
 label$1 : {
  if (($3 | 0) == 1) {
   $3 = 0;
   $10 = HEAP32[$0 + 32 >> 2];
   if (($10 | 0) >= 8) {
    label$4 : {
     if ($16) {
      $3 = HEAPF32[$1 >> 2] < Math_fround(0);
      ec_enc_bits($4, $3, 1);
      break label$4;
     }
     $3 = ec_dec_bits($4, 1);
    }
    $10 = HEAP32[$0 + 32 >> 2] - 8 | 0;
    HEAP32[$0 + 32 >> 2] = $10;
   }
   if (HEAP32[$0 + 4 >> 2]) {
    HEAPF32[$1 >> 2] = $3 ? Math_fround(-1) : Math_fround(1);
   }
   if ($2) {
    $3 = $2 ? 2 : 1;
    $7 = $3 >>> 0 > 1 ? $3 : 1;
    $5 = 1;
    while (1) {
     $3 = 0;
     if (($10 | 0) >= 8) {
      label$10 : {
       if ($16) {
        $3 = HEAPF32[$2 >> 2] < Math_fround(0);
        ec_enc_bits($4, $3, 1);
        break label$10;
       }
       $3 = ec_dec_bits($4, 1);
      }
      $10 = HEAP32[$0 + 32 >> 2] - 8 | 0;
      HEAP32[$0 + 32 >> 2] = $10;
     }
     if (HEAP32[$0 + 4 >> 2]) {
      HEAPF32[$2 >> 2] = $3 ? Math_fround(-1) : Math_fround(1);
     }
     $5 = $5 + 1 | 0;
     if (($7 | 0) != ($5 | 0)) {
      continue;
     }
     break;
    }
   }
   $7 = 1;
   if (!$8) {
    break label$1;
   }
   HEAP32[$8 >> 2] = HEAP32[$1 >> 2];
   break label$1;
  }
  compute_theta($0, $12, $1, $2, $3, $12 + 28 | 0, $5, $5, $7, 1, $12 + 24 | 0);
  $11 = Math_fround(Math_fround(HEAP32[$12 + 8 >> 2]) * Math_fround(30517578125e-15));
  $19 = Math_fround(Math_fround(HEAP32[$12 + 4 >> 2]) * Math_fround(30517578125e-15));
  $14 = HEAP32[$12 + 28 >> 2];
  $17 = HEAP32[$12 + 20 >> 2];
  $13 = HEAP32[$12 + 16 >> 2];
  $22 = HEAP32[$12 >> 2];
  label$13 : {
   if (($3 | 0) == 2) {
    $21 = $13 & -16385;
    $20 = (($21 | 0) != 0) << 3;
    HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 32 >> 2] - ($20 + $17 | 0);
    $13 = ($13 | 0) > 8192;
    $17 = $13 ? $1 : $2;
    $13 = $13 ? $2 : $1;
    $20 = $14 - $20 | 0;
    $14 = 0;
    label$15 : {
     if (!$21) {
      break label$15;
     }
     if ($16) {
      $14 = Math_fround(Math_fround(HEAPF32[$13 >> 2] * HEAPF32[$17 + 4 >> 2]) - Math_fround(HEAPF32[$13 + 4 >> 2] * HEAPF32[$17 >> 2])) < Math_fround(0);
      ec_enc_bits($4, $14, 1);
      break label$15;
     }
     $14 = ec_dec_bits($4, 1);
    }
    $7 = quant_band($0, $13, 2, $20, $5, $6, $7, $8, Math_fround(1), $9, $10);
    $5 = 1 - ($14 << 1) | 0;
    HEAPF32[$17 >> 2] = HEAPF32[$13 + 4 >> 2] * Math_fround(0 - $5 | 0);
    HEAPF32[$17 + 4 >> 2] = HEAPF32[$13 >> 2] * Math_fround($5 | 0);
    if (!HEAP32[$0 + 4 >> 2]) {
     break label$13;
    }
    HEAPF32[$1 >> 2] = $19 * HEAPF32[$1 >> 2];
    HEAPF32[$1 + 4 >> 2] = $19 * HEAPF32[$1 + 4 >> 2];
    $15 = Math_fround($11 * HEAPF32[$2 >> 2]);
    HEAPF32[$2 >> 2] = $15;
    HEAPF32[$2 + 4 >> 2] = $11 * HEAPF32[$2 + 4 >> 2];
    $11 = HEAPF32[$1 >> 2];
    HEAPF32[$1 >> 2] = $11 - $15;
    HEAPF32[$2 >> 2] = $11 + HEAPF32[$2 >> 2];
    $11 = HEAPF32[$1 + 4 >> 2];
    HEAPF32[$1 + 4 >> 2] = $11 - HEAPF32[$2 + 4 >> 2];
    HEAPF32[$2 + 4 >> 2] = $11 + HEAPF32[$2 + 4 >> 2];
    break label$13;
   }
   $10 = HEAP32[$12 + 12 >> 2];
   $17 = HEAP32[$0 + 32 >> 2] - $17 | 0;
   HEAP32[$0 + 32 >> 2] = $17;
   $4 = HEAP32[$12 + 24 >> 2];
   $10 = ($14 - $10 | 0) / 2 | 0;
   $10 = ($10 | 0) > ($14 | 0) ? $14 : $10;
   $10 = ($10 | 0) > 0 ? $10 : 0;
   $16 = $14 - $10 | 0;
   if (($10 | 0) >= ($16 | 0)) {
    $6 = quant_band($0, $1, $3, $10, $5, $6, $7, $8, Math_fround(1), $9, $4);
    $10 = (HEAP32[$0 + 32 >> 2] - $17 | 0) + $10 | 0;
    $7 = $6 | quant_band($0, $2, $3, ($13 ? ($10 | 0) > 24 ? $10 - 24 | 0 : 0 : 0) + $16 | 0, $5, 0, $7, 0, $11, 0, $4 >> $5);
    break label$13;
   }
   $14 = quant_band($0, $2, $3, $16, $5, 0, $7, 0, $11, 0, $4 >> $5);
   $16 = (HEAP32[$0 + 32 >> 2] - $17 | 0) + $16 | 0;
   $7 = $14 | quant_band($0, $1, $3, (($13 | 0) != 16384 ? ($16 | 0) > 24 ? $16 - 24 | 0 : 0 : 0) + $10 | 0, $5, $6, $7, $8, Math_fround(1), $9, $4);
  }
  if (!HEAP32[$0 + 4 >> 2]) {
   break label$1;
  }
  label$18 : {
   if (($3 | 0) == 2) {
    break label$18;
   }
   $15 = Math_fround(0);
   if (($3 | 0) >= 1) {
    $0 = 0;
    while (1) {
     $5 = $0 << 2;
     $11 = HEAPF32[$5 + $2 >> 2];
     $18 = Math_fround($18 + Math_fround($11 * HEAPF32[$1 + $5 >> 2]));
     $15 = Math_fround($15 + Math_fround($11 * $11));
     $0 = $0 + 1 | 0;
     if (($3 | 0) != ($0 | 0)) {
      continue;
     }
     break;
    }
   }
   label$22 : {
    $15 = Math_fround(Math_fround($19 * $19) + $15);
    $11 = Math_fround($19 * $18);
    $11 = Math_fround($11 + $11);
    $18 = Math_fround($15 + $11);
    if (!($18 < Math_fround(.0006000000284984708))) {
     $11 = Math_fround($15 - $11);
     if ($11 < Math_fround(.0006000000284984708) ^ 1) {
      break label$22;
     }
    }
    memcpy($2, $1, $3 << 2);
    break label$18;
   }
   if (($3 | 0) < 1) {
    break label$1;
   }
   $18 = Math_fround(Math_fround(1) / Math_fround(Math_sqrt($18)));
   $23 = Math_fround(Math_fround(1) / Math_fround(Math_sqrt($11)));
   $0 = 0;
   while (1) {
    $5 = $0 << 2;
    $10 = $5 + $1 | 0;
    $11 = Math_fround($19 * HEAPF32[$10 >> 2]);
    $5 = $2 + $5 | 0;
    $15 = HEAPF32[$5 >> 2];
    HEAPF32[$10 >> 2] = $23 * Math_fround($11 - $15);
    HEAPF32[$5 >> 2] = $18 * Math_fround($11 + $15);
    $0 = $0 + 1 | 0;
    if (($3 | 0) != ($0 | 0)) {
     continue;
    }
    break;
   }
  }
  if (!$22 | ($3 | 0) < 1) {
   break label$1;
  }
  $0 = 0;
  while (1) {
   $5 = ($0 << 2) + $2 | 0;
   HEAPF32[$5 >> 2] = -HEAPF32[$5 >> 2];
   $0 = $0 + 1 | 0;
   if (($3 | 0) != ($0 | 0)) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $12 + 32 | 0;
 return $7;
}
function silk_LPC_inverse_pred_gain_c($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 $13 = __stack_pointer - 96 | 0;
 label$1 : {
  if (($1 | 0) >= 1) {
   while (1) {
    $8 = HEAP16[($6 << 1) + $0 >> 1];
    HEAP32[($6 << 2) + $13 >> 2] = $8 << 12;
    $10 = $8 + $10 | 0;
    $6 = $6 + 1 | 0;
    if (($6 | 0) != ($1 | 0)) {
     continue;
    }
    break;
   }
   if (($10 | 0) > 4095) {
    break label$1;
   }
  }
  $10 = $1 - 1 | 0;
  $8 = HEAP32[($10 << 2) + $13 >> 2];
  $6 = $8 + 16773022 >>> 0 > 33546044;
  $9 = 1073741824;
  if (($1 | 0) >= 2) {
   while (1) {
    if ($6 & 1) {
     return 0;
    }
    $7 = 0 - ($8 << 7) | 0;
    $3 = $7 >> 31;
    $12 = $7;
    $17 = $3;
    $7 = __wasm_i64_mul($12, $3, $12, $3);
    $3 = i64toi32_i32$HIGH_BITS;
    $6 = 1073741824 - $3 | 0;
    $2 = $6;
    $7 = $2 >> 31;
    $2 = $7;
    $7 = $11;
    $2 = __wasm_i64_mul($9, $7, $6, $2);
    $3 = $2;
    $7 = i64toi32_i32$HIGH_BITS;
    $18 = (($7 & 1073741823) << 2 | $3 >>> 30) & -4;
    if (($18 | 0) < 107374) {
     break label$1;
    }
    $15 = $10;
    $10 = 0;
    $8 = $6 >> 31;
    $16 = Math_clz32($8 ^ $6 + $8);
    $8 = $6 << $16 - 1;
    $0 = $8 >> 16;
    $6 = 536870911 / ($0 | 0) | 0;
    $3 = ($6 >> 15) + 1 >> 1;
    $14 = $6 << 16;
    $6 = $14 >> 16;
    $8 = 0 - ((Math_imul($6, $8 & 65535) >> 16) + Math_imul($0, $6) << 3) | 0;
    $3 = ((Math_imul($8, $3) + $14 | 0) + Math_imul($8 >> 16, $6) | 0) + (Math_imul($8 & 65528, $6) >> 16) | 0;
    $2 = $3 >> 31;
    $19 = $3;
    $20 = $2;
    $6 = $1 >>> 1 | 0;
    $23 = $6 >>> 0 > 1 ? $6 : 1;
    $21 = 31 - $16 | 0;
    while (1) {
     $14 = ($10 << 2) + $13 | 0;
     $6 = HEAP32[$14 >> 2];
     $22 = (($10 ^ -1) + $15 << 2) + $13 | 0;
     $8 = HEAP32[$22 >> 2];
     $3 = $8;
     $2 = $3 >> 31;
     $3 = $17;
     $3 = __wasm_i64_mul($8, $2, $12, $3);
     $7 = $3;
     $2 = i64toi32_i32$HIGH_BITS;
     $3 = $2 >>> 30 | 0;
     $2 = ($2 & 1073741823) << 2 | $7 >>> 30;
     $4 = $2 + 1 | 0;
     $1 = $4 >>> 0 < 1 ? $3 + 1 | 0 : $3;
     $3 = $4;
     $1 = ($1 & 1) << 31 | $3 >>> 1;
     $0 = $6 - $1 | 0;
     $3 = $0;
     $0 = ($0 | 0) > -1;
     $3 = ((($0 ? $1 : $6) ^ -2147483648) & ($0 ? $6 : $1)) > -1 ? $3 : $0 ? -2147483648 : 2147483647;
     $2 = $3 >> 31;
     $0 = $3;
     $3 = $20;
     $3 = __wasm_i64_mul($0, $2, $19, $3);
     $9 = $3;
     $2 = i64toi32_i32$HIGH_BITS;
     $11 = $2;
     $1 = $3;
     $7 = $3 & 1;
     $3 = 0;
     $4 = $3;
     $3 = $2;
     $2 = $1;
     $5 = ($3 & 1) << 31 | $2 >>> 1;
     $0 = ($16 | 0) != 31;
     $1 = $3 >> 1;
     $2 = $1;
     $1 = $4;
     $4 = $2 + $1 | 0;
     $3 = $7;
     $7 = $3 + $5 | 0;
     $4 = $7 >>> 0 < $5 >>> 0 ? $4 + 1 | 0 : $4;
     $1 = $7;
     label$8 : {
      if (!$0) {
       break label$8;
      }
      $4 = $11;
      $1 = $9;
      $5 = $21;
      $2 = $5 & 31;
      if (($5 & 63) >>> 0 >= 32) {
       $3 = $4 >> 31;
       $4 = $4 >> $2;
      } else {
       $3 = $4 >> $2;
       $4 = ((1 << $2) - 1 & $4) << 32 - $2 | $1 >>> $2;
      }
      $2 = $4 + 1 | 0;
      $7 = $2 >>> 0 < 1 ? $3 + 1 | 0 : $3;
      $3 = $2;
      $1 = ($7 & 1) << 31 | $3 >>> 1;
      $4 = $7 >> 1;
     }
     $2 = $4;
     $9 = $1;
     $7 = $9;
     $1 = $7 - -2147483648 | 0;
     $2 = $1 >>> 0 < 2147483648 ? $2 + 1 | 0 : $2;
     if ($2) {
      break label$1;
     }
     HEAP32[$14 >> 2] = $9;
     $2 = $6;
     $4 = $2 >> 31;
     $2 = $17;
     $2 = __wasm_i64_mul($6, $4, $12, $2);
     $5 = $2;
     $4 = i64toi32_i32$HIGH_BITS;
     $2 = $4 >>> 30 | 0;
     $4 = ($4 & 1073741823) << 2 | $5 >>> 30;
     $3 = $4 + 1 | 0;
     $1 = $3 >>> 0 < 1 ? $2 + 1 | 0 : $2;
     $2 = $3;
     $6 = ($1 & 1) << 31 | $2 >>> 1;
     $1 = $8 - $6 | 0;
     $3 = $1;
     $1 = ($1 | 0) > -1;
     $2 = ((($1 ? $6 : $8) ^ -2147483648) & ($1 ? $8 : $6)) > -1 ? $3 : $1 ? -2147483648 : 2147483647;
     $4 = $2 >> 31;
     $1 = $2;
     $2 = $20;
     $2 = __wasm_i64_mul($1, $4, $19, $2);
     $9 = $2;
     $4 = i64toi32_i32$HIGH_BITS;
     $11 = $4;
     if ($0) {
      $4 = $11;
      $1 = $9;
      $7 = $21;
      $5 = $7 & 31;
      if (($7 & 63) >>> 0 >= 32) {
       $2 = $4 >> 31;
       $4 = $4 >> $5;
      } else {
       $2 = $4 >> $5;
       $4 = ((1 << $5) - 1 & $4) << 32 - $5 | $1 >>> $5;
      }
      $5 = $4 + 1 | 0;
      $3 = $5 >>> 0 < 1 ? $2 + 1 | 0 : $2;
      $2 = $5;
      $9 = ($3 & 1) << 31 | $2 >>> 1;
      $4 = $3 >> 1;
      $5 = $4;
     } else {
      $3 = $9;
      $1 = $3 & 1;
      $2 = 0;
      $0 = $2;
      $4 = $11;
      $2 = $4;
      $7 = ($2 & 1) << 31 | $3 >>> 1;
      $3 = $2 >> 1;
      $4 = $3;
      $3 = $0;
      $5 = $3 + $4 | 0;
      $2 = $1;
      $1 = $7 + $2 | 0;
      $9 = $1;
      $5 = $1 >>> 0 < $7 >>> 0 ? $5 + 1 | 0 : $5;
     }
     $11 = $5;
     $3 = $9;
     $4 = $3 - -2147483648 | 0;
     $1 = $4 >>> 0 < 2147483648 ? $5 + 1 | 0 : $5;
     $3 = 0;
     if ($1) {
      break label$1;
     }
     HEAP32[$22 >> 2] = $9;
     $10 = $10 + 1 | 0;
     if (($23 | 0) != ($10 | 0)) {
      continue;
     }
     break;
    }
    $10 = $15 - 1 | 0;
    $8 = HEAP32[($10 << 2) + $13 >> 2];
    $6 = $8 + 16773022 >>> 0 > 33546044;
    $1 = $18;
    $5 = $1 >> 31;
    $9 = $1;
    $11 = $5;
    $1 = $15;
    if (($1 | 0) > 1) {
     continue;
    }
    break;
   }
  }
  if ($6) {
   break label$1;
  }
  $1 = 0 - (HEAP32[$13 >> 2] << 7) | 0;
  $5 = $1 >> 31;
  $12 = $1;
  $1 = __wasm_i64_mul($12, $5, $12, $5);
  $2 = 0 - 0 | 0;
  $5 = i64toi32_i32$HIGH_BITS;
  $1 = $5 & 2147483647;
  $4 = $1 + (($3 | 0) != 0) | 0;
  $4 = 1073741824 - $4 | 0;
  $5 = $4 >> 31;
  $1 = $11;
  $1 = __wasm_i64_mul($4, $5, $9, $1);
  $4 = $1;
  $5 = i64toi32_i32$HIGH_BITS;
  $6 = (($5 & 1073741823) << 2 | $4 >>> 30) & -4;
  $24 = ($6 | 0) < 107374 ? 0 : $6;
 }
 return $24;
}
function opus_packet_parse_impl($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
 $15 = -1;
 label$1 : {
  if (!$5 | ($1 | 0) < 0) {
   break label$1;
  }
  $15 = -4;
  if (!$1) {
   break label$1;
  }
  $16 = HEAPU8[$0 | 0];
  label$2 : {
   if ($16 & 128) {
    $11 = (48e3 << ($16 >>> 3 & 3) >>> 0) / 400 | 0;
    break label$2;
   }
   $11 = $16 & 8 ? 960 : 480;
   if (($16 & 96) == 96) {
    break label$2;
   }
   $9 = $16 >>> 3 & 3;
   $11 = 2880;
   if (($9 | 0) == 3) {
    break label$2;
   }
   $11 = (48e3 << $9 >>> 0) / 100 | 0;
  }
  $10 = 1;
  $9 = $0 + 1 | 0;
  $8 = $1 - 1 | 0;
  $12 = $8;
  $13 = $16 & 3;
  $17 = $13;
  label$4 : {
   label$5 : {
    label$6 : {
     label$7 : {
      label$8 : {
       switch ($13 | 0) {
       case 1:
        if ($2) {
         $10 = 2;
         $13 = 1;
         $17 = 0;
         $12 = $8;
         break label$6;
        }
        if ($8 & 1) {
         break label$1;
        }
        $12 = $8 >>> 1 | 0;
        HEAP16[$5 >> 1] = $12;
        $10 = 2;
        $17 = 0;
        break label$5;
       case 2:
        if (($1 | 0) <= 1) {
         HEAP16[$5 >> 1] = 65535;
         return -4;
        }
        $13 = HEAPU8[$9 | 0];
        if ($13 >>> 0 >= 252) {
         $10 = 2;
         if (($1 | 0) <= 2) {
          HEAP16[$5 >> 1] = 65535;
          return -4;
         }
         $13 = (HEAPU8[$0 + 2 | 0] << 2) + $13 | 0;
        }
        HEAP16[$5 >> 1] = $13;
        $8 = $8 - $10 | 0;
        if (($13 | 0) > ($8 | 0)) {
         break label$1;
        }
        $12 = $8 - $13 | 0;
        $9 = $9 + $10 | 0;
        $13 = 0;
        $10 = 2;
        $17 = 0;
        break label$7;
       case 0:
        break label$7;
       default:
        break label$8;
       }
      }
      if (($1 | 0) < 2) {
       break label$1;
      }
      $14 = HEAPU8[$0 + 1 | 0];
      $10 = $14 & 63;
      if (!$10 | Math_imul($10, $11) >>> 0 > 5760) {
       break label$1;
      }
      $13 = $0 + 2 | 0;
      $1 = $1 - 2 | 0;
      $17 = 0;
      label$15 : {
       if (!($14 & 64)) {
        $9 = $13;
        break label$15;
       }
       while (1) {
        if (($1 | 0) < 1) {
         break label$1;
        }
        $9 = HEAPU8[$13 | 0];
        $12 = ($9 | 0) == 255;
        $9 = ($12 ? -2 : $9) & 255;
        $17 = $17 + $9 | 0;
        $1 = ($9 ^ -1) + $1 | 0;
        $9 = $13 + 1 | 0;
        $13 = $9;
        if ($12) {
         continue;
        }
        break;
       }
       if (($1 | 0) < 0) {
        break label$1;
       }
      }
      $13 = $14 >>> 7 ^ 1;
      if ($14 & 128) {
       if ($10 >>> 0 < 2) {
        $8 = $1;
        $12 = $1;
        break label$7;
       }
       $19 = $10 - 1 | 0;
       $14 = 0;
       $12 = $1;
       $8 = $1;
       while (1) {
        $18 = ($14 << 1) + $5 | 0;
        if (($8 | 0) <= 0) {
         HEAP16[$18 >> 1] = 65535;
         return -4;
        }
        $11 = 1;
        $1 = HEAPU8[$9 | 0];
        if ($1 >>> 0 >= 252) {
         if (($8 | 0) <= 1) {
          HEAP16[$18 >> 1] = 65535;
          return -4;
         }
         $11 = 2;
         $1 = (HEAPU8[$9 + 1 | 0] << 2) + $1 | 0;
        }
        HEAP16[$18 >> 1] = $1;
        $8 = $8 - $11 | 0;
        if (($8 | 0) < ($1 | 0)) {
         break label$1;
        }
        $9 = $9 + $11 | 0;
        $12 = ($12 - $11 | 0) - $1 | 0;
        $14 = $14 + 1 | 0;
        if (($19 | 0) != ($14 | 0)) {
         continue;
        }
        break;
       }
       if (($12 | 0) >= 0) {
        break label$7;
       }
       break label$1;
      }
      if ($2) {
       $12 = $8;
       $8 = $1;
       break label$6;
      }
      $12 = ($1 | 0) / ($10 | 0) | 0;
      if ((Math_imul($12, $10) | 0) != ($1 | 0)) {
       break label$1;
      }
      if ($10 >>> 0 < 2) {
       break label$5;
      }
      $11 = $10 - 1 | 0;
      $8 = 0;
      while (1) {
       HEAP16[($8 << 1) + $5 >> 1] = $12;
       $8 = $8 + 1 | 0;
       if (($11 | 0) != ($8 | 0)) {
        continue;
       }
       break;
      }
      $8 = $1;
     }
     if (!$2) {
      break label$5;
     }
    }
    $11 = (($10 << 1) + $5 | 0) - 2 | 0;
    $1 = 65535;
    $2 = -1;
    label$26 : {
     if (($8 | 0) < 1) {
      break label$26;
     }
     $14 = HEAPU8[$9 | 0];
     if ($14 >>> 0 < 252) {
      $1 = $14;
      $2 = 1;
      break label$26;
     }
     $2 = -1;
     if (($8 | 0) < 2) {
      break label$26;
     }
     $1 = (HEAPU8[$9 + 1 | 0] << 2) + $14 | 0;
     $2 = 2;
    }
    HEAP16[$11 >> 1] = $1;
    $11 = $1 << 16 >> 16;
    if (($11 | 0) < 0) {
     break label$1;
    }
    $8 = $8 - $2 | 0;
    if (($11 | 0) > ($8 | 0)) {
     break label$1;
    }
    $9 = $2 + $9 | 0;
    if ($13) {
     if ((Math_imul($10, $11) | 0) > ($8 | 0)) {
      break label$1;
     }
     if ($10 >>> 0 < 2) {
      break label$4;
     }
     HEAP16[$5 >> 1] = $1;
     $1 = 1;
     $15 = $10 - 1 | 0;
     if (($15 | 0) == 1) {
      break label$4;
     }
     $2 = ($15 << 1) + $5 | 0;
     while (1) {
      HEAP16[($1 << 1) + $5 >> 1] = HEAPU16[$2 >> 1];
      $1 = $1 + 1 | 0;
      if (($15 | 0) != ($1 | 0)) {
       continue;
      }
      break;
     }
     break label$4;
    }
    if (($2 + $11 | 0) > ($12 | 0)) {
     break label$1;
    }
    break label$4;
   }
   if (($12 | 0) > 1275) {
    break label$1;
   }
   HEAP16[(($10 << 1) + $5 | 0) - 2 >> 1] = $12;
  }
  if ($6) {
   HEAP32[$6 >> 2] = $9 - $0;
  }
  if ($10) {
   $1 = 0;
   while (1) {
    if ($4) {
     HEAP32[($1 << 2) + $4 >> 2] = $9;
    }
    $9 = HEAP16[($1 << 1) + $5 >> 1] + $9 | 0;
    $1 = $1 + 1 | 0;
    if (($10 | 0) != ($1 | 0)) {
     continue;
    }
    break;
   }
  }
  if ($7) {
   HEAP32[$7 >> 2] = ($17 - $0 | 0) + $9;
  }
  if ($3) {
   HEAP8[$3 | 0] = $16;
  }
  $15 = $10;
 }
 return $15;
}
function silk_LPC_analysis_filter_FLP($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 label$1 : {
  if (($3 | 0) >= ($4 | 0)) {
   label$3 : {
    label$4 : {
     switch ($4 - 6 | 0) {
     case 0:
      if (($3 | 0) < 7) {
       break label$3;
      }
      $6 = 6;
      while (1) {
       $5 = $6 << 2;
       $7 = $5 + $0 | 0;
       $5 = $2 + $5 | 0;
       HEAPF32[$7 >> 2] = HEAPF32[$5 >> 2] - Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(HEAPF32[$5 - 4 >> 2] * HEAPF32[$1 >> 2]) + Math_fround(HEAPF32[$5 - 8 >> 2] * HEAPF32[$1 + 4 >> 2])) + Math_fround(HEAPF32[$5 - 12 >> 2] * HEAPF32[$1 + 8 >> 2])) + Math_fround(HEAPF32[$5 - 16 >> 2] * HEAPF32[$1 + 12 >> 2])) + Math_fround(HEAPF32[$5 - 20 >> 2] * HEAPF32[$1 + 16 >> 2])) + Math_fround(HEAPF32[$5 - 24 >> 2] * HEAPF32[$1 + 20 >> 2]));
       $6 = $6 + 1 | 0;
       if (($6 | 0) != ($3 | 0)) {
        continue;
       }
       break;
      }
      break label$3;
     case 2:
      if (($3 | 0) < 9) {
       break label$3;
      }
      $6 = 8;
      while (1) {
       $5 = $6 << 2;
       $7 = $5 + $0 | 0;
       $5 = $2 + $5 | 0;
       HEAPF32[$7 >> 2] = HEAPF32[$5 >> 2] - Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(HEAPF32[$5 - 4 >> 2] * HEAPF32[$1 >> 2]) + Math_fround(HEAPF32[$5 - 8 >> 2] * HEAPF32[$1 + 4 >> 2])) + Math_fround(HEAPF32[$5 - 12 >> 2] * HEAPF32[$1 + 8 >> 2])) + Math_fround(HEAPF32[$5 - 16 >> 2] * HEAPF32[$1 + 12 >> 2])) + Math_fround(HEAPF32[$5 - 20 >> 2] * HEAPF32[$1 + 16 >> 2])) + Math_fround(HEAPF32[$5 - 24 >> 2] * HEAPF32[$1 + 20 >> 2])) + Math_fround(HEAPF32[$5 - 28 >> 2] * HEAPF32[$1 + 24 >> 2])) + Math_fround(HEAPF32[$5 - 32 >> 2] * HEAPF32[$1 + 28 >> 2]));
       $6 = $6 + 1 | 0;
       if (($6 | 0) != ($3 | 0)) {
        continue;
       }
       break;
      }
      break label$3;
     case 4:
      if (($3 | 0) < 11) {
       break label$3;
      }
      $6 = 10;
      while (1) {
       $5 = $6 << 2;
       $7 = $5 + $0 | 0;
       $5 = $2 + $5 | 0;
       HEAPF32[$7 >> 2] = HEAPF32[$5 >> 2] - Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(HEAPF32[$5 - 4 >> 2] * HEAPF32[$1 >> 2]) + Math_fround(HEAPF32[$5 - 8 >> 2] * HEAPF32[$1 + 4 >> 2])) + Math_fround(HEAPF32[$5 - 12 >> 2] * HEAPF32[$1 + 8 >> 2])) + Math_fround(HEAPF32[$5 - 16 >> 2] * HEAPF32[$1 + 12 >> 2])) + Math_fround(HEAPF32[$5 - 20 >> 2] * HEAPF32[$1 + 16 >> 2])) + Math_fround(HEAPF32[$5 - 24 >> 2] * HEAPF32[$1 + 20 >> 2])) + Math_fround(HEAPF32[$5 - 28 >> 2] * HEAPF32[$1 + 24 >> 2])) + Math_fround(HEAPF32[$5 - 32 >> 2] * HEAPF32[$1 + 28 >> 2])) + Math_fround(HEAPF32[$5 - 36 >> 2] * HEAPF32[$1 + 32 >> 2])) + Math_fround(HEAPF32[$5 - 40 >> 2] * HEAPF32[$1 + 36 >> 2]));
       $6 = $6 + 1 | 0;
       if (($6 | 0) != ($3 | 0)) {
        continue;
       }
       break;
      }
      break label$3;
     case 6:
      if (($3 | 0) < 13) {
       break label$3;
      }
      $6 = 12;
      while (1) {
       $5 = $6 << 2;
       $7 = $5 + $0 | 0;
       $5 = $2 + $5 | 0;
       HEAPF32[$7 >> 2] = HEAPF32[$5 >> 2] - Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(HEAPF32[$5 - 4 >> 2] * HEAPF32[$1 >> 2]) + Math_fround(HEAPF32[$5 - 8 >> 2] * HEAPF32[$1 + 4 >> 2])) + Math_fround(HEAPF32[$5 - 12 >> 2] * HEAPF32[$1 + 8 >> 2])) + Math_fround(HEAPF32[$5 - 16 >> 2] * HEAPF32[$1 + 12 >> 2])) + Math_fround(HEAPF32[$5 - 20 >> 2] * HEAPF32[$1 + 16 >> 2])) + Math_fround(HEAPF32[$5 - 24 >> 2] * HEAPF32[$1 + 20 >> 2])) + Math_fround(HEAPF32[$5 - 28 >> 2] * HEAPF32[$1 + 24 >> 2])) + Math_fround(HEAPF32[$5 - 32 >> 2] * HEAPF32[$1 + 28 >> 2])) + Math_fround(HEAPF32[$5 - 36 >> 2] * HEAPF32[$1 + 32 >> 2])) + Math_fround(HEAPF32[$5 - 40 >> 2] * HEAPF32[$1 + 36 >> 2])) + Math_fround(HEAPF32[$5 - 44 >> 2] * HEAPF32[$1 + 40 >> 2])) + Math_fround(HEAPF32[$5 - 48 >> 2] * HEAPF32[$1 + 44 >> 2]));
       $6 = $6 + 1 | 0;
       if (($6 | 0) != ($3 | 0)) {
        continue;
       }
       break;
      }
      break label$3;
     case 10:
      break label$4;
     default:
      break label$1;
     }
    }
    if (($3 | 0) < 17) {
     break label$3;
    }
    $6 = 16;
    while (1) {
     $5 = $6 << 2;
     $7 = $5 + $0 | 0;
     $5 = $2 + $5 | 0;
     HEAPF32[$7 >> 2] = HEAPF32[$5 >> 2] - Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(HEAPF32[$5 - 4 >> 2] * HEAPF32[$1 >> 2]) + Math_fround(HEAPF32[$5 - 8 >> 2] * HEAPF32[$1 + 4 >> 2])) + Math_fround(HEAPF32[$5 - 12 >> 2] * HEAPF32[$1 + 8 >> 2])) + Math_fround(HEAPF32[$5 - 16 >> 2] * HEAPF32[$1 + 12 >> 2])) + Math_fround(HEAPF32[$5 - 20 >> 2] * HEAPF32[$1 + 16 >> 2])) + Math_fround(HEAPF32[$5 - 24 >> 2] * HEAPF32[$1 + 20 >> 2])) + Math_fround(HEAPF32[$5 - 28 >> 2] * HEAPF32[$1 + 24 >> 2])) + Math_fround(HEAPF32[$5 - 32 >> 2] * HEAPF32[$1 + 28 >> 2])) + Math_fround(HEAPF32[$5 - 36 >> 2] * HEAPF32[$1 + 32 >> 2])) + Math_fround(HEAPF32[$5 - 40 >> 2] * HEAPF32[$1 + 36 >> 2])) + Math_fround(HEAPF32[$5 - 44 >> 2] * HEAPF32[$1 + 40 >> 2])) + Math_fround(HEAPF32[$5 - 48 >> 2] * HEAPF32[$1 + 44 >> 2])) + Math_fround(HEAPF32[$5 - 52 >> 2] * HEAPF32[$1 + 48 >> 2])) + Math_fround(HEAPF32[$5 - 56 >> 2] * HEAPF32[$1 + 52 >> 2])) + Math_fround(HEAPF32[$5 - 60 >> 2] * HEAPF32[$1 + 56 >> 2])) + Math_fround(HEAPF32[$5 + -64 >> 2] * HEAPF32[$1 + 60 >> 2]));
     $6 = $6 + 1 | 0;
     if (($6 | 0) != ($3 | 0)) {
      continue;
     }
     break;
    }
   }
   memset($0, 0, $4 << 2);
   return;
  }
  celt_fatal(9580, 9614, 218);
  abort();
 }
 celt_fatal(9651, 9614, 242);
 abort();
}
function remove_doubling($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = Math_fround(0), $9 = Math_fround(0), $10 = Math_fround(0), $11 = 0, $12 = 0, $13 = 0, $14 = Math_fround(0), $15 = 0, $16 = 0, $17 = Math_fround(0), $18 = 0, $19 = Math_fround(0), $20 = 0, $21 = 0, $22 = Math_fround(0), $23 = Math_fround(0), $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = Math_fround(0), $29 = 0, $30 = 0, $31 = 0, $32 = Math_fround(0), $33 = Math_fround(0), $34 = Math_fround(0), $35 = Math_fround(0), $36 = Math_fround(0);
 $11 = HEAP32[$4 >> 2] / 2 | 0;
 $20 = ($1 | 0) / 2 | 0;
 $15 = ($11 | 0) < ($20 | 0) ? $11 : $20 - 1 | 0;
 HEAP32[$4 >> 2] = $15;
 $12 = $20 << 2;
 $11 = $12 + $0 | 0;
 $18 = ($3 | 0) / 2 | 0;
 $29 = ($5 | 0) / -2 | 0;
 $13 = __stack_pointer;
 $21 = $13 - ($12 + 19 & -16) | 0;
 if (($3 | 0) >= 2) {
  $13 = $11 - ($15 << 2) | 0;
  $5 = 0;
  while (1) {
   $0 = $5 << 2;
   $8 = HEAPF32[$11 + $0 >> 2];
   $22 = Math_fround($22 + Math_fround($8 * HEAPF32[$0 + $13 >> 2]));
   $14 = Math_fround($14 + Math_fround($8 * $8));
   $5 = $5 + 1 | 0;
   if (($18 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
 }
 HEAPF32[$21 >> 2] = $14;
 if (($1 | 0) >= 2) {
  $5 = 1;
  $8 = $14;
  while (1) {
   $0 = $5 << 2;
   $9 = HEAPF32[$11 - $0 >> 2];
   $10 = Math_fround($8 + Math_fround($9 * $9));
   $8 = HEAPF32[($18 - $5 << 2) + $11 >> 2];
   $8 = Math_fround($10 - Math_fround($8 * $8));
   HEAPF32[$0 + $21 >> 2] = Math_max($8, Math_fround(0));
   $0 = ($5 | 0) != ($20 | 0);
   $5 = $5 + 1 | 0;
   if ($0) {
    continue;
   }
   break;
  }
 }
 $24 = ($2 | 0) / 2 | 0;
 $30 = $24 << 1;
 $31 = Math_imul($24, 3);
 $32 = Math_fround($6 * Math_fround(.5));
 $25 = $15 << 1;
 $23 = HEAPF32[($15 << 2) + $21 >> 2];
 $19 = Math_fround($22 / Math_fround(Math_sqrt(Math_fround(Math_fround($14 * $23) + Math_fround(1)))));
 $33 = Math_fround($19 * Math_fround(.8500000238418579));
 $34 = Math_fround($19 * Math_fround(.8999999761581421));
 $35 = Math_fround($19 * Math_fround(.699999988079071));
 $12 = 2;
 $7 = $15;
 while (1) {
  $5 = $12 << 1;
  $16 = ($12 + $25 >>> 0) / ($5 >>> 0) | 0;
  if (($24 | 0) <= ($16 | 0)) {
   label$8 : {
    if (($12 | 0) == 2) {
     $5 = $15 + $16 | 0;
     $5 = ($5 | 0) > ($20 | 0) ? $15 : $5;
     break label$8;
    }
    $5 = (Math_imul(HEAP32[($12 << 2) + 9808 >> 2], $25) + $12 >>> 0) / ($5 >>> 0) | 0;
   }
   $26 = $5 << 2;
   $27 = $16 << 2;
   $8 = Math_fround(0);
   label$10 : {
    if (($3 | 0) < 2) {
     $9 = Math_fround(0);
     break label$10;
    }
    $13 = $11 - $26 | 0;
    $1 = $11 - $27 | 0;
    $5 = 0;
    $9 = Math_fround(0);
    while (1) {
     $0 = $5 << 2;
     $10 = HEAPF32[$11 + $0 >> 2];
     $8 = Math_fround($8 + Math_fround($10 * HEAPF32[$0 + $13 >> 2]));
     $9 = Math_fround($9 + Math_fround($10 * HEAPF32[$0 + $1 >> 2]));
     $5 = $5 + 1 | 0;
     if (($18 | 0) != ($5 | 0)) {
      continue;
     }
     break;
    }
   }
   $9 = Math_fround(Math_fround($9 + $8) * Math_fround(.5));
   $28 = Math_fround(Math_fround(HEAPF32[$21 + $27 >> 2] + HEAPF32[$21 + $26 >> 2]) * Math_fround(.5));
   $10 = Math_fround(Math_sqrt(Math_fround(Math_fround($14 * $28) + Math_fround(1))));
   $10 = Math_fround($9 / $10);
   $36 = $10;
   $17 = $33;
   $5 = $16 + $29 | 0;
   $0 = $5;
   $8 = $6;
   $5 = $5 >> 31;
   $5 = $5 ^ $5 + $0;
   label$13 : {
    if (($5 | 0) < 2) {
     break label$13;
    }
    $8 = Math_fround(0);
    if (($5 | 0) != 2) {
     break label$13;
    }
    $8 = (Math_imul(Math_imul($12, $12), 5) | 0) < ($15 | 0) ? $32 : Math_fround(0);
   }
   $17 = Math_fround(Math_max(Math_fround($17 - $8), Math_fround(.4000000059604645)));
   label$14 : {
    if (($16 | 0) < ($31 | 0)) {
     break label$14;
    }
    $17 = Math_fround(Math_max(Math_fround($35 - $8), Math_fround(.30000001192092896)));
    if (($16 | 0) >= ($30 | 0)) {
     break label$14;
    }
    $17 = Math_fround(Math_max(Math_fround($34 - $8), Math_fround(.5)));
   }
   $8 = $17;
   if (!($36 > $8 ^ 1)) {
    $7 = $16;
    $23 = $28;
    $22 = $9;
    $19 = $10;
   }
   $12 = $12 + 1 | 0;
   if (($12 | 0) != 16) {
    continue;
   }
  }
  break;
 }
 $8 = Math_fround(0);
 $14 = Math_fround(1);
 $9 = Math_fround(Math_max($22, Math_fround(0)));
 if (!($23 <= $9)) {
  $14 = Math_fround($9 / Math_fround($23 + Math_fround(1)));
 }
 label$17 : {
  if (($3 | 0) < 2) {
   $9 = Math_fround(0);
   $10 = Math_fround(0);
   break label$17;
  }
  $13 = ($11 - ($7 << 2) | 0) + 4 | 0;
  $5 = 0;
  while (1) {
   $0 = $5 << 2;
   $8 = Math_fround($8 + Math_fround(HEAPF32[$11 + $0 >> 2] * HEAPF32[$0 + $13 >> 2]));
   $5 = $5 + 1 | 0;
   if (($18 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
  $9 = Math_fround(0);
  if (($3 | 0) <= 1) {
   $10 = Math_fround(0);
   break label$17;
  }
  $13 = $11 - ($7 << 2) | 0;
  $5 = 0;
  while (1) {
   $0 = $5 << 2;
   $9 = Math_fround($9 + Math_fround(HEAPF32[$11 + $0 >> 2] * HEAPF32[$0 + $13 >> 2]));
   $5 = $5 + 1 | 0;
   if (($18 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
  $10 = Math_fround(0);
  if (($3 | 0) < 2) {
   break label$17;
  }
  $13 = (($7 ^ -1) << 2) + $11 | 0;
  $5 = 0;
  while (1) {
   $0 = $5 << 2;
   $10 = Math_fround($10 + Math_fround(HEAPF32[$11 + $0 >> 2] * HEAPF32[$0 + $13 >> 2]));
   $5 = $5 + 1 | 0;
   if (($18 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
 }
 $5 = 1;
 $5 = Math_fround($10 - $8) > Math_fround(Math_fround($9 - $8) * Math_fround(.699999988079071)) ? $5 : Math_fround($8 - $10) > Math_fround(Math_fround($9 - $10) * Math_fround(.699999988079071)) ? -1 : 0;
 $5 = $5 + ($7 << 1) | 0;
 HEAP32[$4 >> 2] = ($2 | 0) > ($5 | 0) ? $2 : $5;
 return $14 > $19 ? $19 : $14;
}
function quant_partition($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = Math_fround(0), $17 = Math_fround(0), $18 = 0, $19 = 0, $20 = 0, $21 = 0;
 $13 = __stack_pointer - 32 | 0;
 __stack_pointer = $13;
 HEAP32[$13 + 24 >> 2] = $8;
 HEAP32[$13 + 28 >> 2] = $3;
 $9 = HEAP32[$0 + 8 >> 2];
 $10 = HEAP32[$9 + 100 >> 2] + HEAP16[HEAP32[$9 + 96 >> 2] + (HEAP32[$0 + 12 >> 2] + Math_imul(HEAP32[$9 + 8 >> 2], $6 + 1 | 0) << 1) >> 1] | 0;
 $9 = HEAPU8[$10 | 0];
 $15 = -1;
 $18 = HEAP32[$0 + 28 >> 2];
 $19 = HEAP32[$0 + 20 >> 2];
 $20 = HEAP32[$0 >> 2];
 label$1 : {
  if (!(($6 | 0) == -1 | ($2 | 0) < 3 | (HEAPU8[$9 + $10 | 0] + 12 | 0) >= ($3 | 0))) {
   $9 = $6 - 1 | 0;
   $3 = $2 >>> 1 | 0;
   $2 = ($3 << 2) + $1 | 0;
   if (($4 | 0) == 1) {
    HEAP32[$13 + 24 >> 2] = $8 & 1 | $8 << 1;
   }
   $14 = $4 + 1 >> 1;
   compute_theta($0, $13, $1, $2, $3, $13 + 28 | 0, $14, $4, $9, 0, $13 + 24 | 0);
   $16 = Math_fround(HEAP32[$13 + 8 >> 2]);
   $17 = Math_fround(HEAP32[$13 + 4 >> 2]);
   $8 = HEAP32[$13 + 20 >> 2];
   $10 = HEAP32[$13 + 12 >> 2];
   $15 = HEAP32[$13 + 16 >> 2];
   $11 = $10;
   label$4 : {
    if (!($15 & 16383) | ($4 | 0) < 2) {
     break label$4;
    }
    $11 = $10 - ($10 >> 5 - $6) | 0;
    if (($15 | 0) >= 8193) {
     break label$4;
    }
    $6 = ($3 << 3 >> 6 - $6) + $10 | 0;
    $11 = $6 & $6 >> 31;
   }
   $10 = $11;
   $16 = Math_fround($16 * Math_fround(30517578125e-15));
   $17 = Math_fround($17 * Math_fround(30517578125e-15));
   $6 = HEAP32[$13 + 28 >> 2];
   $8 = HEAP32[$0 + 32 >> 2] - $8 | 0;
   HEAP32[$0 + 32 >> 2] = $8;
   $12 = $5 ? ($3 << 2) + $5 | 0 : 0;
   $10 = ($6 - $10 | 0) / 2 | 0;
   $10 = ($6 | 0) < ($10 | 0) ? $6 : $10;
   $10 = ($10 | 0) > 0 ? $10 : 0;
   $6 = $6 - $10 | 0;
   if (($6 | 0) <= ($10 | 0)) {
    $11 = HEAP32[$13 + 24 >> 2];
    $1 = quant_partition($0, $1, $3, $10, $14, $5, $9, Math_fround($17 * $7), $11);
    $10 = (HEAP32[$0 + 32 >> 2] - $8 | 0) + $10 | 0;
    $9 = $1 | quant_partition($0, $2, $3, ($15 ? ($10 | 0) > 24 ? $10 - 24 | 0 : 0 : 0) + $6 | 0, $14, $12, $9, Math_fround($16 * $7), $11 >> $14) << ($4 >> 1);
    break label$1;
   }
   $11 = HEAP32[$13 + 24 >> 2];
   $2 = quant_partition($0, $2, $3, $6, $14, $12, $9, Math_fround($16 * $7), $11 >> $14);
   $6 = (HEAP32[$0 + 32 >> 2] - $8 | 0) + $6 | 0;
   $9 = quant_partition($0, $1, $3, (($15 | 0) != 16384 ? ($6 | 0) > 24 ? $6 - 24 | 0 : 0 : 0) + $10 | 0, $14, $5, $9, Math_fround($17 * $7), $11) | $2 << ($4 >> 1);
   break label$1;
  }
  $6 = $3 - 1 | 0;
  $12 = $9 + 1 >>> 1 | 0;
  $3 = ($6 | 0) > HEAPU8[$12 + $10 | 0];
  $9 = $3 ? $9 : $12;
  $11 = $9;
  $12 = $3 ? $12 : 0;
  $3 = ($12 + $9 | 0) + 1 >>> 1 | 0;
  $9 = HEAPU8[$10 + $3 | 0] < ($6 | 0);
  $11 = $9 ? $11 : $3;
  $9 = $9 ? $3 : $12;
  $3 = ($11 + $9 | 0) + 1 >>> 1 | 0;
  $12 = HEAPU8[$10 + $3 | 0] < ($6 | 0);
  $9 = $12 ? $3 : $9;
  $11 = $12 ? $11 : $3;
  $3 = ($9 + $11 | 0) + 1 >>> 1 | 0;
  $12 = HEAPU8[$10 + $3 | 0] < ($6 | 0);
  $9 = $12 ? $3 : $9;
  $11 = $12 ? $11 : $3;
  $3 = ($9 + $11 | 0) + 1 >> 1;
  $12 = HEAPU8[$10 + $3 | 0] < ($6 | 0);
  $11 = $12 ? $11 : $3;
  $21 = $11;
  $12 = $12 ? $3 : $9;
  $3 = ($11 + $12 | 0) + 1 >> 1;
  $11 = HEAPU8[$10 + $3 | 0] < ($6 | 0);
  $9 = $11 ? $21 : $3;
  $3 = $11 ? $3 : $12;
  if ($3) {
   $15 = HEAPU8[$3 + $10 | 0];
  }
  $3 = ($6 - $15 | 0) > (HEAPU8[$9 + $10 | 0] - $6 | 0) ? $9 : $3;
  if ($3) {
   $14 = HEAPU8[$3 + $10 | 0] + 1 | 0;
  }
  $9 = HEAP32[$0 + 32 >> 2] - $14 | 0;
  HEAP32[$0 + 32 >> 2] = $9;
  label$9 : {
   label$10 : {
    if (($9 | 0) > -1) {
     $6 = $3;
     break label$10;
    }
    if (($3 | 0) < 1) {
     $6 = $3;
     break label$10;
    }
    while (1) {
     $9 = $9 + $14 | 0;
     HEAP32[$0 + 32 >> 2] = $9;
     $6 = $3 - 1 | 0;
     if (!$6) {
      HEAP32[$0 + 32 >> 2] = $9;
      break label$9;
     }
     $14 = HEAPU8[$6 + $10 | 0] + 1 | 0;
     $9 = $9 - $14 | 0;
     HEAP32[$0 + 32 >> 2] = $9;
     if (($9 | 0) > -1) {
      break label$10;
     }
     $15 = ($3 | 0) > 1;
     $3 = $6;
     if ($15) {
      continue;
     }
     break;
    }
   }
   if (!$6) {
    break label$9;
   }
   $6 = ($6 | 0) >= 8 ? ($6 & 7 | 8) << ($6 >>> 3 | 0) - 1 : $6;
   if ($20) {
    $9 = alg_quant($1, $2, $6, $19, $4, $18, $7, HEAP32[$0 + 4 >> 2], HEAP32[$0 + 44 >> 2]);
    break label$1;
   }
   $9 = alg_unquant($1, $2, $6, $19, $4, $18, $7);
   break label$1;
  }
  if (!HEAP32[$0 + 4 >> 2]) {
   $9 = 0;
   break label$1;
  }
  $9 = -1 << $4 ^ -1;
  $14 = $9 & $8;
  HEAP32[$13 + 24 >> 2] = $14;
  if (!$14) {
   $9 = 0;
   memset($1, 0, $2 << 2);
   break label$1;
  }
  label$19 : {
   if ($5) {
    if (($2 | 0) >= 1) {
     $3 = HEAP32[$0 + 40 >> 2];
     $6 = 0;
     while (1) {
      $9 = $6 << 2;
      $3 = Math_imul($3, 1664525) + 1013904223 | 0;
      HEAPF32[$9 + $1 >> 2] = HEAPF32[$5 + $9 >> 2] + ($3 & 32768 ? Math_fround(.00390625) : Math_fround(-.00390625));
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($2 | 0)) {
       continue;
      }
      break;
     }
     HEAP32[$0 + 40 >> 2] = $3;
    }
    $9 = $14;
    break label$19;
   }
   if (($2 | 0) < 1) {
    break label$19;
   }
   $3 = HEAP32[$0 + 40 >> 2];
   $6 = 0;
   while (1) {
    $3 = Math_imul($3, 1664525) + 1013904223 | 0;
    HEAPF32[($6 << 2) + $1 >> 2] = $3 >> 20;
    $6 = $6 + 1 | 0;
    if (($6 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
   HEAP32[$0 + 40 >> 2] = $3;
  }
  renormalise_vector($1, $2, $7, HEAP32[$0 + 44 >> 2]);
 }
 __stack_pointer = $13 + 32 | 0;
 return $9;
}
function pitch_search($0, $1, $2, $3, $4, $5) {
 var $6 = Math_fround(0), $7 = Math_fround(0), $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = Math_fround(0), $13 = Math_fround(0), $14 = Math_fround(0), $15 = 0, $16 = 0, $17 = Math_fround(0), $18 = 0, $19 = 0, $20 = Math_fround(0), $21 = 0;
 $5 = __stack_pointer;
 $21 = $5;
 label$1 : {
  if (($2 | 0) > 0) {
   if (($3 | 0) <= 0) {
    break label$1;
   }
   $11 = $2 >>> 2 | 0;
   $8 = $5 - (($11 << 2) + 15 & -16) | 0;
   $5 = $8;
   __stack_pointer = $5;
   $9 = $2 + $3 | 0;
   $10 = $5 - (($9 & -4) + 15 & -16) | 0;
   $5 = $10;
   __stack_pointer = $5;
   $15 = $3 >>> 1 | 0;
   $16 = $5 - (($15 << 2) + 15 & -16) | 0;
   __stack_pointer = $16;
   if ($11) {
    $5 = 0;
    while (1) {
     HEAP32[($5 << 2) + $8 >> 2] = HEAP32[($5 << 3) + $0 >> 2];
     $5 = $5 + 1 | 0;
     if (($11 | 0) != ($5 | 0)) {
      continue;
     }
     break;
    }
   }
   if (($9 | 0) >= 4) {
    $5 = $9 >> 2;
    $9 = ($5 | 0) > 1 ? $5 : 1;
    $5 = 0;
    while (1) {
     HEAP32[($5 << 2) + $10 >> 2] = HEAP32[($5 << 3) + $1 >> 2];
     $5 = $5 + 1 | 0;
     if (($9 | 0) != ($5 | 0)) {
      continue;
     }
     break;
    }
   }
   $9 = $3 >> 2;
   celt_pitch_xcorr_c($8, $10, $16, $11, $9, $5);
   $7 = Math_fround(1);
   if ($11) {
    $5 = 0;
    while (1) {
     $6 = HEAPF32[($5 << 2) + $10 >> 2];
     $7 = Math_fround($7 + Math_fround($6 * $6));
     $5 = $5 + 1 | 0;
     if (($11 | 0) != ($5 | 0)) {
      continue;
     }
     break;
    }
   }
   $18 = 1;
   if (($3 | 0) > 3) {
    $13 = Math_fround(-1);
    $5 = 0;
    $14 = Math_fround(-1);
    while (1) {
     $8 = $5 << 2;
     $6 = HEAPF32[$16 + $8 >> 2];
     label$11 : {
      if ($6 > Math_fround(0) ^ 1) {
       break label$11;
      }
      $6 = Math_fround($6 * Math_fround(9.999999960041972e-13));
      $6 = Math_fround($6 * $6);
      if (Math_fround($12 * $6) > Math_fround($14 * $7) ^ 1) {
       break label$11;
      }
      if (Math_fround($17 * $6) > Math_fround($13 * $7)) {
       $18 = $19;
       $19 = $5;
       $14 = $13;
       $13 = $6;
       $12 = $17;
       $17 = $7;
       break label$11;
      }
      $18 = $5;
      $14 = $6;
      $12 = $7;
     }
     $6 = HEAPF32[($5 + $11 << 2) + $10 >> 2];
     $20 = Math_fround($6 * $6);
     $6 = HEAPF32[$10 + $8 >> 2];
     $7 = Math_fround(Math_max(Math_fround($7 + Math_fround($20 - Math_fround($6 * $6))), Math_fround(1)));
     $5 = $5 + 1 | 0;
     if (($9 | 0) != ($5 | 0)) {
      continue;
     }
     break;
    }
   }
   label$13 : {
    if (!$15) {
     $11 = $2 >> 1;
     break label$13;
    }
    $11 = $2 >> 1;
    $18 = $18 << 1;
    $19 = $19 << 1;
    $9 = 0;
    while (1) {
     $10 = $9 << 2;
     $3 = $16 + $10 | 0;
     HEAP32[$3 >> 2] = 0;
     $5 = $9 - $19 | 0;
     $8 = $5;
     $5 = $5 >> 31;
     label$16 : {
      if (($5 ^ $5 + $8) >= 3) {
       $5 = $9 - $18 | 0;
       $8 = $5;
       $5 = $5 >> 31;
       if (($5 ^ $5 + $8) > 2) {
        break label$16;
       }
      }
      $7 = Math_fround(0);
      if (($2 | 0) >= 2) {
       $8 = $1 + $10 | 0;
       $5 = 0;
       while (1) {
        $10 = $5 << 2;
        $7 = Math_fround($7 + Math_fround(HEAPF32[$10 + $0 >> 2] * HEAPF32[$10 + $8 >> 2]));
        $5 = $5 + 1 | 0;
        if (($11 | 0) != ($5 | 0)) {
         continue;
        }
        break;
       }
      }
      HEAPF32[$3 >> 2] = Math_max($7, Math_fround(-1));
     }
     $9 = $9 + 1 | 0;
     if (($15 | 0) != ($9 | 0)) {
      continue;
     }
     break;
    }
   }
   $7 = Math_fround(1);
   if (($2 | 0) > 1) {
    $5 = 0;
    while (1) {
     $6 = HEAPF32[($5 << 2) + $1 >> 2];
     $7 = Math_fround($7 + Math_fround($6 * $6));
     $5 = $5 + 1 | 0;
     if (($11 | 0) != ($5 | 0)) {
      continue;
     }
     break;
    }
   }
   $8 = 0;
   label$22 : {
    if (!$15) {
     $0 = 0;
     break label$22;
    }
    $13 = Math_fround(-1);
    $17 = Math_fround(0);
    $0 = 0;
    $5 = 0;
    $12 = Math_fround(0);
    $14 = Math_fround(-1);
    while (1) {
     $10 = $5 << 2;
     $6 = HEAPF32[$16 + $10 >> 2];
     label$25 : {
      if ($6 > Math_fround(0) ^ 1) {
       break label$25;
      }
      $6 = Math_fround($6 * Math_fround(9.999999960041972e-13));
      $6 = Math_fround($6 * $6);
      if (Math_fround($12 * $6) > Math_fround($14 * $7) ^ 1) {
       break label$25;
      }
      if (Math_fround($17 * $6) > Math_fround($13 * $7)) {
       $0 = $5;
       $14 = $13;
       $13 = $6;
       $12 = $17;
       $17 = $7;
       break label$25;
      }
      $14 = $6;
      $12 = $7;
     }
     $6 = HEAPF32[($5 + $11 << 2) + $1 >> 2];
     $20 = Math_fround($6 * $6);
     $6 = HEAPF32[$1 + $10 >> 2];
     $7 = Math_fround(Math_max(Math_fround($7 + Math_fround($20 - Math_fround($6 * $6))), Math_fround(1)));
     $5 = $5 + 1 | 0;
     if (($15 | 0) != ($5 | 0)) {
      continue;
     }
     break;
    }
    if (($0 | 0) < 1 | ($15 - 1 | 0) <= ($0 | 0)) {
     break label$22;
    }
    $8 = -1;
    $5 = ($0 << 2) + $16 | 0;
    $6 = HEAPF32[$5 + 4 >> 2];
    $7 = HEAPF32[$5 - 4 >> 2];
    $12 = HEAPF32[$5 >> 2];
    if (Math_fround($6 - $7) > Math_fround(Math_fround($12 - $7) * Math_fround(.699999988079071))) {
     break label$22;
    }
    $8 = Math_fround($7 - $6) > Math_fround(Math_fround($12 - $6) * Math_fround(.699999988079071));
   }
   HEAP32[$4 >> 2] = ($0 << 1) + $8;
   __stack_pointer = $21;
   return;
  }
  celt_fatal(9781, 9768, 302);
  abort();
 }
 celt_fatal(9738, 9768, 303);
 abort();
}
function exp_rotation($0, $1, $2, $3, $4, $5) {
 var $6 = Math_fround(0), $7 = 0, $8 = Math_fround(0), $9 = Math_fround(0), $10 = Math_fround(0), $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0;
 label$1 : {
  if (!$5 | $4 << 1 >= ($1 | 0)) {
   break label$1;
  }
  $9 = Math_fround(Math_fround($1 | 0) / Math_fround(Math_imul(HEAP32[($5 << 2) + 41524 >> 2], $4) + $1 | 0));
  $9 = Math_fround(Math_fround($9 * $9) * Math_fround(.5));
  $18 = cos(+Math_fround($9 * Math_fround(1.5707963705062866)));
  $19 = cos(+Math_fround(Math_fround(Math_fround(1) - $9) * Math_fround(1.5707963705062866)));
  $5 = 0;
  if ($3 << 3 <= ($1 | 0)) {
   $7 = $3 >> 2;
   $4 = 1;
   while (1) {
    $5 = $4;
    $4 = $4 + 1 | 0;
    if ((Math_imul(Math_imul($5, $5) + $5 | 0, $3) + $7 | 0) < ($1 | 0)) {
     continue;
    }
    break;
   }
  }
  if (($3 | 0) < 1) {
   break label$1;
  }
  $9 = Math_fround($18);
  $10 = Math_fround($19);
  $14 = ($1 >>> 0) / ($3 >>> 0) | 0;
  $15 = $14 - $5 | 0;
  $12 = $14 - 3 | 0;
  $16 = $14 - 1 | 0;
  $13 = ($5 << 1 ^ -1) + $14 | 0;
  $20 = ($2 | 0) > -1;
  $2 = 0;
  while (1) {
   $11 = Math_imul($2, $14);
   label$5 : {
    if (!$20) {
     label$7 : {
      if (!$5) {
       break label$7;
      }
      $1 = 0;
      $17 = ($11 << 2) + $0 | 0;
      $4 = $17;
      if (($15 | 0) >= 1) {
       while (1) {
        $7 = ($5 << 2) + $4 | 0;
        $8 = HEAPF32[$7 >> 2];
        $6 = HEAPF32[$4 >> 2];
        HEAPF32[$7 >> 2] = Math_fround($6 * $9) + Math_fround($8 * $10);
        HEAPF32[$4 >> 2] = Math_fround($6 * $10) - Math_fround($8 * $9);
        $4 = $4 + 4 | 0;
        $1 = $1 + 1 | 0;
        if (($15 | 0) != ($1 | 0)) {
         continue;
        }
        break;
       }
      }
      if (($13 | 0) < 0) {
       break label$7;
      }
      $4 = ($13 << 2) + $17 | 0;
      $1 = $13;
      while (1) {
       $7 = ($5 << 2) + $4 | 0;
       $8 = HEAPF32[$7 >> 2];
       $6 = HEAPF32[$4 >> 2];
       HEAPF32[$7 >> 2] = Math_fround($6 * $9) + Math_fround($8 * $10);
       HEAPF32[$4 >> 2] = Math_fround($6 * $10) - Math_fround($8 * $9);
       $4 = $4 - 4 | 0;
       $7 = ($1 | 0) > 0;
       $1 = $1 - 1 | 0;
       if ($7) {
        continue;
       }
       break;
      }
     }
     $7 = ($11 << 2) + $0 | 0;
     if (($16 | 0) >= 1) {
      $6 = HEAPF32[$7 >> 2];
      $1 = 0;
      $4 = $7;
      while (1) {
       $8 = HEAPF32[$4 + 4 >> 2];
       HEAPF32[$4 >> 2] = Math_fround($6 * $9) - Math_fround($8 * $10);
       $6 = Math_fround(Math_fround($6 * $10) + Math_fround($8 * $9));
       HEAPF32[$4 + 4 >> 2] = $6;
       $4 = $4 + 4 | 0;
       $1 = $1 + 1 | 0;
       if (($16 | 0) != ($1 | 0)) {
        continue;
       }
       break;
      }
     }
     if (($12 | 0) < 0) {
      break label$5;
     }
     $4 = ($12 << 2) + $7 | 0;
     $1 = $12;
     while (1) {
      $6 = HEAPF32[$4 >> 2];
      $8 = HEAPF32[$4 + 4 >> 2];
      HEAPF32[$4 + 4 >> 2] = Math_fround($6 * $10) + Math_fround($8 * $9);
      HEAPF32[$4 >> 2] = Math_fround($6 * $9) - Math_fround($8 * $10);
      $4 = $4 - 4 | 0;
      $7 = ($1 | 0) > 0;
      $1 = $1 - 1 | 0;
      if ($7) {
       continue;
      }
      break;
     }
     break label$5;
    }
    $11 = ($11 << 2) + $0 | 0;
    if (($16 | 0) >= 1) {
     $6 = HEAPF32[$11 >> 2];
     $1 = 0;
     $4 = $11;
     while (1) {
      $8 = HEAPF32[$4 + 4 >> 2];
      HEAPF32[$4 >> 2] = Math_fround($6 * $9) + Math_fround($8 * $10);
      $6 = Math_fround(Math_fround($8 * $9) - Math_fround($6 * $10));
      HEAPF32[$4 + 4 >> 2] = $6;
      $4 = $4 + 4 | 0;
      $1 = $1 + 1 | 0;
      if (($16 | 0) != ($1 | 0)) {
       continue;
      }
      break;
     }
    }
    if (($12 | 0) >= 0) {
     $4 = ($12 << 2) + $11 | 0;
     $1 = $12;
     while (1) {
      $6 = HEAPF32[$4 + 4 >> 2];
      $8 = HEAPF32[$4 >> 2];
      HEAPF32[$4 + 4 >> 2] = Math_fround($6 * $9) - Math_fround($8 * $10);
      HEAPF32[$4 >> 2] = Math_fround($8 * $9) + Math_fround($6 * $10);
      $4 = $4 - 4 | 0;
      $7 = ($1 | 0) > 0;
      $1 = $1 - 1 | 0;
      if ($7) {
       continue;
      }
      break;
     }
    }
    if (!$5) {
     break label$5;
    }
    $1 = 0;
    $4 = $11;
    if (($15 | 0) >= 1) {
     while (1) {
      $7 = ($5 << 2) + $4 | 0;
      $6 = HEAPF32[$7 >> 2];
      $8 = HEAPF32[$4 >> 2];
      HEAPF32[$7 >> 2] = Math_fround($6 * $10) - Math_fround($8 * $9);
      HEAPF32[$4 >> 2] = Math_fround($8 * $10) + Math_fround($6 * $9);
      $4 = $4 + 4 | 0;
      $1 = $1 + 1 | 0;
      if (($15 | 0) != ($1 | 0)) {
       continue;
      }
      break;
     }
    }
    if (($13 | 0) < 0) {
     break label$5;
    }
    $4 = ($13 << 2) + $11 | 0;
    $1 = $13;
    while (1) {
     $7 = ($5 << 2) + $4 | 0;
     $6 = HEAPF32[$7 >> 2];
     $8 = HEAPF32[$4 >> 2];
     HEAPF32[$7 >> 2] = Math_fround($6 * $10) - Math_fround($8 * $9);
     HEAPF32[$4 >> 2] = Math_fround($8 * $10) + Math_fround($6 * $9);
     $4 = $4 - 4 | 0;
     $7 = ($1 | 0) > 0;
     $1 = $1 - 1 | 0;
     if ($7) {
      continue;
     }
     break;
    }
   }
   $2 = $2 + 1 | 0;
   if (($3 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
 }
}
function __rem_pio2($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $6 = __stack_pointer - 48 | 0;
 __stack_pointer = $6;
 label$1 : {
  label$2 : {
   wasm2js_scratch_store_f64(+$0);
   $4 = wasm2js_scratch_load_i32(1) | 0;
   $8 = wasm2js_scratch_load_i32(0) | 0;
   $3 = $4;
   $7 = $4 & 2147483647;
   label$3 : {
    if ($7 >>> 0 <= 1074752122) {
     if (($3 & 1048575) == 598523) {
      break label$3;
     }
     if ($7 >>> 0 <= 1073928572) {
      if (($4 | 0) > 0 ? 1 : ($4 | 0) >= 0) {
       $0 = $0 + -1.5707963267341256;
       $2 = $0 + -6.077100506506192e-11;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + -6.077100506506192e-11;
       $3 = 1;
       break label$1;
      }
      $0 = $0 + 1.5707963267341256;
      $2 = $0 + 6.077100506506192e-11;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + 6.077100506506192e-11;
      $3 = -1;
      break label$1;
     }
     if (($4 | 0) > 0 ? 1 : ($4 | 0) >= 0) {
      $0 = $0 + -3.1415926534682512;
      $2 = $0 + -1.2154201013012384e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + -1.2154201013012384e-10;
      $3 = 2;
      break label$1;
     }
     $0 = $0 + 3.1415926534682512;
     $2 = $0 + 1.2154201013012384e-10;
     HEAPF64[$1 >> 3] = $2;
     HEAPF64[$1 + 8 >> 3] = $0 - $2 + 1.2154201013012384e-10;
     $3 = -2;
     break label$1;
    }
    if ($7 >>> 0 <= 1075594811) {
     if ($7 >>> 0 <= 1075183036) {
      if (($7 | 0) == 1074977148) {
       break label$3;
      }
      if (($4 | 0) > 0 ? 1 : ($4 | 0) >= 0) {
       $0 = $0 + -4.712388980202377;
       $2 = $0 + -1.8231301519518578e-10;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + -1.8231301519518578e-10;
       $3 = 3;
       break label$1;
      }
      $0 = $0 + 4.712388980202377;
      $2 = $0 + 1.8231301519518578e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + 1.8231301519518578e-10;
      $3 = -3;
      break label$1;
     }
     if (($7 | 0) == 1075388923) {
      break label$3;
     }
     if (($4 | 0) > 0 ? 1 : ($4 | 0) >= 0) {
      $0 = $0 + -6.2831853069365025;
      $2 = $0 + -2.430840202602477e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + -2.430840202602477e-10;
      $3 = 4;
      break label$1;
     }
     $0 = $0 + 6.2831853069365025;
     $2 = $0 + 2.430840202602477e-10;
     HEAPF64[$1 >> 3] = $2;
     HEAPF64[$1 + 8 >> 3] = $0 - $2 + 2.430840202602477e-10;
     $3 = -4;
     break label$1;
    }
    if ($7 >>> 0 > 1094263290) {
     break label$2;
    }
   }
   $2 = $0 * .6366197723675814 + 6755399441055744 + -6755399441055744;
   $9 = $0 + $2 * -1.5707963267341256;
   $11 = $2 * 6.077100506506192e-11;
   $0 = $9 - $11;
   HEAPF64[$1 >> 3] = $0;
   $10 = $7 >>> 20 | 0;
   wasm2js_scratch_store_f64(+$0);
   $5 = wasm2js_scratch_load_i32(1) | 0;
   wasm2js_scratch_load_i32(0) | 0;
   $5 = ($10 - ($5 >>> 20 & 2047) | 0) < 17;
   if (Math_abs($2) < 2147483648) {
    $3 = ~~$2;
   } else {
    $3 = -2147483648;
   }
   label$14 : {
    if ($5) {
     break label$14;
    }
    $0 = $2 * 6.077100506303966e-11;
    $12 = $9 - $0;
    $11 = $2 * 2.0222662487959506e-21 - ($9 - $12 - $0);
    $0 = $12 - $11;
    HEAPF64[$1 >> 3] = $0;
    wasm2js_scratch_store_f64(+$0);
    $5 = wasm2js_scratch_load_i32(1) | 0;
    wasm2js_scratch_load_i32(0) | 0;
    if (($10 - ($5 >>> 20 & 2047) | 0) < 50) {
     $9 = $12;
     break label$14;
    }
    $0 = $2 * 2.0222662487111665e-21;
    $9 = $12 - $0;
    $11 = $2 * 8.4784276603689e-32 - ($12 - $9 - $0);
    $0 = $9 - $11;
    HEAPF64[$1 >> 3] = $0;
   }
   HEAPF64[$1 + 8 >> 3] = $9 - $0 - $11;
   break label$1;
  }
  if ($7 >>> 0 >= 2146435072) {
   $0 = $0 - $0;
   HEAPF64[$1 >> 3] = $0;
   HEAPF64[$1 + 8 >> 3] = $0;
   $3 = 0;
   break label$1;
  }
  $5 = $4 & 1048575;
  $5 = $5 | 1096810496;
  wasm2js_scratch_store_i32(0, $8 | 0);
  wasm2js_scratch_store_i32(1, $5 | 0);
  $0 = +wasm2js_scratch_load_f64();
  $3 = 0;
  $5 = 1;
  while (1) {
   $3 = ($6 + 16 | 0) + ($3 << 3) | 0;
   if (Math_abs($0) < 2147483648) {
    $10 = ~~$0;
   } else {
    $10 = -2147483648;
   }
   $2 = +($10 | 0);
   HEAPF64[$3 >> 3] = $2;
   $0 = ($0 - $2) * 16777216;
   $3 = 1;
   $10 = $5 & 1;
   $5 = 0;
   if ($10) {
    continue;
   }
   break;
  }
  HEAPF64[$6 + 32 >> 3] = $0;
  label$20 : {
   if ($0 != 0) {
    $3 = 2;
    break label$20;
   }
   $5 = 1;
   while (1) {
    $3 = $5;
    $5 = $3 - 1 | 0;
    if (HEAPF64[($6 + 16 | 0) + ($3 << 3) >> 3] == 0) {
     continue;
    }
    break;
   }
  }
  $3 = __rem_pio2_large($6 + 16 | 0, $6, ($7 >>> 20 | 0) - 1046 | 0, $3 + 1 | 0, 1);
  $0 = HEAPF64[$6 >> 3];
  if (($4 | 0) < -1 ? 1 : ($4 | 0) <= -1) {
   HEAPF64[$1 >> 3] = -$0;
   HEAPF64[$1 + 8 >> 3] = -HEAPF64[$6 + 8 >> 3];
   $3 = 0 - $3 | 0;
   break label$1;
  }
  HEAPF64[$1 >> 3] = $0;
  HEAPF64[$1 + 8 >> 3] = HEAPF64[$6 + 8 >> 3];
 }
 __stack_pointer = $6 + 48 | 0;
 return $3;
}
function silk_stereo_find_predictor($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $13 = __stack_pointer - 16 | 0;
 __stack_pointer = $13;
 silk_sum_sqr_shift($13 + 4 | 0, $13 + 12 | 0, $1, $4);
 silk_sum_sqr_shift($13, $13 + 8 | 0, $2, $4);
 $6 = HEAP32[$13 + 12 >> 2];
 $11 = HEAP32[$13 + 8 >> 2];
 $9 = ($6 | 0) > ($11 | 0) ? $6 : $11;
 $9 = $9 + ($9 & 1) | 0;
 HEAP32[$13 >> 2] = HEAP32[$13 >> 2] >> $9 - $11;
 $6 = HEAP32[$13 + 4 >> 2] >> $9 - $6;
 HEAP32[$13 + 4 >> 2] = ($6 | 0) > 1 ? $6 : 1;
 $1 = silk_inner_prod_aligned_scale($1, $2, $9, $4);
 $4 = $1 >> 31;
 $11 = Math_clz32($4 ^ $1 + $4);
 $6 = $1 << $11 - 1;
 $15 = $6;
 $4 = HEAP32[$13 + 4 >> 2];
 $2 = $4 >> 31;
 $8 = Math_clz32($2 ^ $2 + $4);
 $12 = $4 << $8 - 1;
 $2 = 536870911 / ($12 >> 16) << 16 >> 16;
 $6 = (Math_imul($2, $6 & 65535) >> 16) + Math_imul($6 >> 16, $2) | 0;
 $10 = $6 >> 31;
 $7 = $10;
 $10 = $12 >> 31;
 $14 = $10;
 $10 = $7;
 $7 = $14;
 $7 = __wasm_i64_mul($6, $10, $12, $7);
 $14 = $7;
 $10 = i64toi32_i32$HIGH_BITS;
 $12 = $15 - ((($10 & 536870911) << 3 | $14 >>> 29) & -8) | 0;
 $2 = (Math_imul($12 >> 16, $2) + $6 | 0) + (Math_imul($12 & 65535, $2) >> 16) | 0;
 $7 = $5;
 $6 = ($11 - $8 | 0) + 16 | 0;
 label$1 : {
  if (($6 | 0) <= -1) {
   $6 = 0 - $6 | 0;
   $11 = 2147483647 >>> $6 | 0;
   $8 = -2147483648 >> $6;
   $2 = (($2 | 0) > ($11 | 0) ? $11 : ($2 | 0) < ($8 | 0) ? $8 : $2) << $6;
   break label$1;
  }
  $2 = ($6 | 0) < 32 ? $2 >> $6 : 0;
 }
 $2 = ($2 | 0) > -16384 ? $2 : -16384;
 $2 = ($2 | 0) < 16384 ? $2 : 16384;
 $11 = (Math_imul($2, $2 & 65535) >> 16) + Math_imul($2 >> 16, $2) | 0;
 $6 = $11 >> 31;
 $6 = $6 ^ $6 + $11;
 $7 = ($5 | 0) > ($6 | 0) ? $7 : $6;
 $5 = $9 >> 1;
 $8 = 0;
 $6 = HEAP32[$3 >> 2];
 $14 = $3;
 $15 = $6;
 label$3 : {
  if (($4 | 0) <= 0) {
   $9 = $7 << 16 >> 16;
   $10 = Math_imul($9, 0 - $6 >> 16);
   break label$3;
  }
  $8 = Math_clz32($4);
  $10 = 24 - $8 | 0;
  $17 = 0 - $10 | 0;
  $12 = ($8 & 1 ? 32768 : 46214) >>> ($8 >>> 1) | 0;
  $16 = $12;
  $9 = $4;
  label$5 : {
   if (!$10) {
    break label$5;
   }
   $9 = $4 << $17 | $4 >>> 56 - $8;
   if ($4 >>> 0 <= 127) {
    break label$5;
   }
   $9 = $4 << $8 + 8 | $4 >>> $10;
  }
  $16 = ((Math_imul(Math_imul($9 & 127, 13959168) >>> 16 | 0, $16) >>> 16 | 0) + $12 << $5) - $6 >> 16;
  $9 = $7 << 16 >> 16;
  $7 = $4;
  label$6 : {
   if (!$10) {
    break label$6;
   }
   $7 = $4 << $17 | $4 >>> 56 - $8;
   if ($4 >>> 0 <= 127) {
    break label$6;
   }
   $7 = $4 << $8 + 8 | $4 >>> $10;
  }
  $8 = (Math_imul(Math_imul($7 & 127, 13959168) >>> 16 | 0, $12) >>> 16 | 0) + $12 | 0;
  $10 = Math_imul($9, $16);
 }
 $6 = ($15 + $10 | 0) + (Math_imul(($8 << $5) - $6 & 65535, $9) >> 16) | 0;
 HEAP32[$14 >> 2] = $6;
 $7 = HEAP32[$13 >> 2] - (Math_imul($1 >> 16, $2) + (Math_imul($1 & 65535, $2) >> 16) << 4) | 0;
 $1 = $11 << 16 >> 16;
 $4 = $7 + ((Math_imul($1, $4 & 65535) >> 16) + Math_imul($4 >> 16, $1) << 6) | 0;
 HEAP32[$13 >> 2] = $4;
 $14 = $3;
 $1 = HEAP32[$3 + 4 >> 2];
 $3 = $1;
 label$7 : {
  if (($4 | 0) < 1) {
   $11 = 0;
   break label$7;
  }
  $11 = Math_clz32($4);
  $12 = 24 - $11 | 0;
  $7 = 0 - $12 | 0;
  $8 = $4;
  label$9 : {
   if (!$12) {
    break label$9;
   }
   $8 = $4 << $7 | $4 >>> 56 - $11;
   if ($4 >>> 0 <= 127) {
    break label$9;
   }
   $8 = $4 << $11 + 8 | $4 >>> $12;
  }
  $10 = Math_imul($8 & 127, 13959168) >>> 16 | 0;
  $8 = ($11 & 1 ? 32768 : 46214) >>> ($11 >>> 1) | 0;
  $10 = $8 + (Math_imul($8, $10) >>> 16 | 0) | 0;
  label$10 : {
   if (!$12) {
    break label$10;
   }
   if ($4 >>> 0 <= 127) {
    $4 = $4 << $7 | $4 >>> 56 - $11;
    break label$10;
   }
   $4 = $4 << $11 + 8 | $4 >>> $12;
  }
  $18 = (Math_imul(Math_imul($4 & 127, 13959168) >>> 16 | 0, $8) >>> 16 | 0) + $8 | 0;
  $11 = $10 << $5;
 }
 $4 = $18;
 $4 = ($3 + Math_imul($11 - $1 >> 16, $9) | 0) + (Math_imul(($4 << $5) - $1 & 65535, $9) >> 16) | 0;
 HEAP32[$14 + 4 >> 2] = $4;
 $3 = $4 >> 31;
 $1 = Math_clz32($3 ^ $3 + $4);
 $3 = $4 << $1 - 1;
 $8 = $3;
 $4 = ($6 | 0) > 1 ? $6 : 1;
 $9 = Math_clz32($4);
 $5 = $4 << $9 - 1;
 $4 = 536870911 / ($5 >> 16) << 16 >> 16;
 $3 = (Math_imul($4, $3 & 65535) >> 16) + Math_imul($3 >> 16, $4) | 0;
 $7 = $3 >> 31;
 $10 = $7;
 $7 = $5 >> 31;
 $14 = $7;
 $7 = $10;
 $14 = __wasm_i64_mul($3, $7, $5, $14);
 $10 = $14;
 $7 = i64toi32_i32$HIGH_BITS;
 $5 = $8 - ((($7 & 536870911) << 3 | $10 >>> 29) & -8) | 0;
 $4 = (Math_imul($5 >> 16, $4) + $3 | 0) + (Math_imul($5 & 65535, $4) >> 16) | 0;
 $3 = ($1 - $9 | 0) + 15 | 0;
 label$12 : {
  if (($3 | 0) <= -1) {
   $3 = 0 - $3 | 0;
   $1 = 2147483647 >>> $3 | 0;
   $9 = -2147483648 >> $3;
   $4 = (($1 | 0) < ($4 | 0) ? $1 : ($4 | 0) < ($9 | 0) ? $9 : $4) << $3;
   break label$12;
  }
  $4 = ($3 | 0) < 32 ? $4 >> $3 : 0;
 }
 $4 = ($4 | 0) > 0 ? $4 : 0;
 HEAP32[$0 >> 2] = ($4 | 0) < 32767 ? $4 : 32767;
 __stack_pointer = $13 + 16 | 0;
 return $2;
}
function transient_analysis($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = Math_fround(0), $9 = Math_fround(0), $10 = 0, $11 = 0, $12 = 0, $13 = Math_fround(0), $14 = Math_fround(0), $15 = Math_fround(0), $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = Math_fround(0), $21 = 0, $22 = Math_fround(0), $23 = 0, $24 = 0, $25 = Math_fround(0), $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0;
 $10 = __stack_pointer;
 $21 = $10;
 $10 = $10 - (($1 << 2) + 15 & -16) | 0;
 __stack_pointer = $10;
 HEAP32[$6 >> 2] = 0;
 $16 = ($1 | 0) / 2 | 0;
 label$1 : {
  label$2 : {
   label$3 : {
    if (($2 | 0) < 1) {
     break label$3;
    }
    $22 = $5 ? Math_fround(.03125) : Math_fround(.0625);
    $23 = $16 - 5 | 0;
    $24 = Math_imul($16, 6) - 102 | 0;
    $25 = Math_fround($16 | 0);
    $26 = +($16 | 0);
    $27 = ($1 | 0) < 1;
    $28 = $10;
    $29 = $10;
    $30 = $10;
    $31 = $10;
    $32 = $10;
    $33 = ($1 | 0) < 36;
    while (1) {
     if (!$27) {
      $12 = Math_imul($1, $18);
      $13 = Math_fround(0);
      $7 = 0;
      $14 = Math_fround(0);
      while (1) {
       $9 = HEAPF32[($7 + $12 << 2) + $0 >> 2];
       $8 = Math_fround($13 + $9);
       HEAPF32[($7 << 2) + $10 >> 2] = $8;
       $13 = Math_fround(Math_fround($14 + $8) - Math_fround($9 + $9));
       $14 = Math_fround($9 + Math_fround($8 * Math_fround(-.5)));
       $7 = $7 + 1 | 0;
       if (($7 | 0) != ($1 | 0)) {
        continue;
       }
       break;
      }
     }
     HEAP32[$10 >> 2] = 0;
     HEAP32[$10 + 4 >> 2] = 0;
     $7 = $28;
     HEAP32[$7 + 40 >> 2] = 0;
     HEAP32[$7 + 44 >> 2] = 0;
     HEAP32[$29 + 32 >> 2] = 0;
     HEAP32[$7 + 36 >> 2] = 0;
     HEAP32[$30 + 24 >> 2] = 0;
     HEAP32[$7 + 28 >> 2] = 0;
     HEAP32[$31 + 16 >> 2] = 0;
     HEAP32[$7 + 20 >> 2] = 0;
     HEAP32[$32 + 8 >> 2] = 0;
     HEAP32[$7 + 12 >> 2] = 0;
     $7 = 0;
     $13 = Math_fround(0);
     $9 = Math_fround(0);
     $20 = Math_fround(0);
     $8 = Math_fround(0);
     $11 = ($1 | 0) > 1;
     $15 = $8;
     label$7 : {
      if (!$11) {
       break label$7;
      }
      while (1) {
       $12 = $7 << 3;
       $8 = HEAPF32[$12 + $10 >> 2];
       $15 = Math_fround($8 * $8);
       $8 = HEAPF32[($12 | 4) + $10 >> 2];
       $8 = Math_fround($15 + Math_fround($8 * $8));
       $9 = Math_fround($9 + Math_fround($22 * Math_fround($8 - $9)));
       HEAPF32[($7 << 2) + $10 >> 2] = $9;
       $13 = Math_fround($13 + $8);
       $7 = $7 + 1 | 0;
       if (($16 | 0) != ($7 | 0)) {
        continue;
       }
       break;
      }
      $7 = $16;
      $14 = Math_fround(0);
      $20 = $13;
      $8 = Math_fround(0);
      $15 = $8;
      if (!$11) {
       break label$7;
      }
      while (1) {
       $12 = $7 - 1 | 0;
       $11 = ($12 << 2) + $10 | 0;
       $8 = Math_fround($8 + Math_fround(Math_fround(HEAPF32[$11 >> 2] - $8) * Math_fround(.125)));
       HEAPF32[$11 >> 2] = $8;
       $14 = $8 < $14 ? $14 : $8;
       $11 = ($7 | 0) > 1;
       $7 = $12;
       if ($11) {
        continue;
       }
       break;
      }
      $15 = $14;
     }
     $8 = $15;
     $9 = $20;
     $13 = HEAPF32[$10 >> 2];
     if ($13 != $13) {
      break label$2;
     }
     $9 = Math_fround($25 / Math_fround(Math_fround(Math_sqrt(+Math_fround($9 * $8) * .5 * $26)) + Math_fround(1.0000000036274937e-15)));
     if ($9 != $9) {
      break label$1;
     }
     $12 = 0;
     if (!$33) {
      $8 = Math_fround($9 * Math_fround(64));
      $7 = 12;
      while (1) {
       $9 = Math_fround(Math_floor(Math_fround($8 * Math_fround(HEAPF32[($7 << 2) + $10 >> 2] + Math_fround(1.0000000036274937e-15)))));
       $11 = Math_fround(Math_min($9, Math_fround(127))) < Math_fround(0);
       $17 = $11 ? 0 : 127;
       $17 = $9 > Math_fround(127) ? $17 : $11 ? $17 : +$9;
       label$12 : {
        if (Math_abs($17) < 2147483648) {
         $11 = ~~$17;
         break label$12;
        }
        $11 = -2147483648;
       }
       $12 = HEAPU8[$11 + 42832 | 0] + $12 | 0;
       $7 = $7 + 4 | 0;
       if (($23 | 0) > ($7 | 0)) {
        continue;
       }
       break;
      }
     }
     $7 = ($12 << 8) / ($24 | 0) | 0;
     if (($19 | 0) < ($7 | 0)) {
      HEAP32[$4 >> 2] = $18;
      $19 = $7;
     }
     $18 = $18 + 1 | 0;
     if (($18 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
    $7 = ($19 | 0) > 200;
    if (!$5 | $19 - 201 >>> 0 > 398) {
     break label$3;
    }
    HEAP32[$6 >> 2] = 1;
    $7 = 0;
   }
   HEAPF32[$3 >> 2] = Math_sqrt(Math_max(+Math_fround(Math_fround(Math_min(Math_fround(Math_max(Math_fround(Math_fround(Math_sqrt(+(Math_imul($19, 27) | 0))) + Math_fround(-42)), Math_fround(0))), Math_fround(163))) * Math_fround(.006899999920278788)) + -.139, 0));
   __stack_pointer = $21;
   return $7;
  }
  celt_fatal(42960, 42508, 369);
  abort();
 }
 celt_fatal(42998, 42508, 370);
 abort();
}
function run_prefilter($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) {
 var $12 = 0, $13 = Math_fround(0), $14 = 0, $15 = 0, $16 = 0, $17 = Math_fround(0), $18 = 0, $19 = Math_fround(0), $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = Math_fround(0), $27 = 0, $28 = 0, $29 = 0;
 $12 = __stack_pointer - 16 | 0;
 __stack_pointer = $12;
 $21 = HEAP32[$0 >> 2];
 $20 = HEAP32[$21 + 4 >> 2];
 $15 = $4 + 1024 | 0;
 $14 = $12 - ((Math_imul($15, $3) << 2) + 15 & -16) | 0;
 $18 = $14;
 __stack_pointer = $14;
 $16 = $12;
 HEAP32[$12 + 12 >> 2] = ($15 << 2) + $14;
 HEAP32[$12 + 8 >> 2] = $14;
 $23 = ($3 | 0) > 1 ? $3 : 1;
 $22 = $4 << 2;
 $24 = $4 + $20 | 0;
 $14 = ($20 << 2) + $1 | 0;
 $12 = 0;
 while (1) {
  memcpy(memcpy(HEAP32[($16 + 8 | 0) + ($12 << 2) >> 2], ($12 << 12) + $2 | 0, 4096) + 4096 | 0, (Math_imul($12, $24) << 2) + $14 | 0, $22);
  $12 = $12 + 1 | 0;
  if (($23 | 0) != ($12 | 0)) {
   continue;
  }
  break;
 }
 label$2 : {
  if ($9) {
   $14 = $18;
   $12 = $14 - (($15 << 1 & -4) + 15 & -16) | 0;
   __stack_pointer = $12;
   pitch_downsample($16 + 8 | 0, $12, $15, $3, HEAP32[$0 + 72 >> 2]);
   pitch_search($12 + 2048 | 0, $12, $4, 979, $16 + 4 | 0, HEAP32[$0 + 72 >> 2]);
   HEAP32[$16 + 4 >> 2] = 1024 - HEAP32[$16 + 4 >> 2];
   $13 = remove_doubling($12, 1024, 15, $4, $16 + 4 | 0, HEAP32[$0 + 104 >> 2], HEAPF32[$0 + 108 >> 2], HEAP32[$0 + 72 >> 2]);
   if (HEAP32[$16 + 4 >> 2] >= 1023) {
    HEAP32[$16 + 4 >> 2] = 1022;
   }
   $13 = Math_fround($13 * Math_fround(.699999988079071));
   $12 = HEAP32[$0 + 56 >> 2];
   $13 = ($12 | 0) > 2 ? Math_fround($13 * Math_fround(.5)) : $13;
   $13 = ($12 | 0) > 8 ? Math_fround(0) : ($12 | 0) > 4 ? Math_fround($13 * Math_fround(.5)) : $13;
   break label$2;
  }
  HEAP32[$16 + 4 >> 2] = 15;
  $13 = Math_fround(0);
 }
 $12 = HEAP32[$16 + 4 >> 2];
 $3 = HEAP32[$0 + 104 >> 2];
 $14 = $12 - $3 | 0;
 $9 = $14;
 $13 = HEAP32[$11 >> 2] ? Math_fround($13 * HEAPF32[$11 + 40 >> 2]) : $13;
 $14 = $14 >> 31;
 $17 = (Math_imul($14 ^ $14 + $9, 10) | 0) > ($12 | 0) ? Math_fround(.4000000059604645) : Math_fround(.20000000298023224);
 $17 = ($10 | 0) < 25 ? Math_fround($17 + Math_fround(.10000000149011612)) : $17;
 $19 = ($10 | 0) < 35 ? Math_fround($17 + Math_fround(.10000000149011612)) : $17;
 $17 = HEAPF32[$0 + 108 >> 2];
 $19 = $17 > Math_fround(.4000000059604645) ? Math_fround($19 + Math_fround(-.10000000149011612)) : $19;
 $19 = $17 > Math_fround(.550000011920929) ? Math_fround($19 + Math_fround(-.10000000149011612)) : $19;
 if (!($13 < ($19 > Math_fround(.20000000298023224) ? $19 : Math_fround(.20000000298023224)))) {
  $27 = 1;
  $13 = Math_fround(Math_floor(Math_fround(Math_fround(Math_fround((Math_fround(Math_abs(Math_fround($13 - $17))) < Math_fround(.10000000149011612) ? $17 : $13) * Math_fround(32)) / Math_fround(3)) + Math_fround(.5))));
  label$8 : {
   if (Math_fround(Math_abs($13)) < Math_fround(2147483648)) {
    $12 = ~~$13;
    break label$8;
   }
   $12 = -2147483648;
  }
  $12 = ($12 | 0) > 7 ? 7 : $12 - 1 | 0;
  $25 = ($12 | 0) > 0 ? $12 : 0;
  $26 = Math_fround(Math_fround($25 + 1 | 0) * Math_fround(.09375));
 }
 $28 = 4096 - $22 | 0;
 $14 = $20 << 2;
 $17 = Math_fround(-$26);
 $9 = ($4 | 0) < 1025;
 $29 = 0 - $4 << 2;
 $12 = 0;
 while (1) {
  $15 = HEAP32[$21 + 44 >> 2];
  HEAP32[$0 + 104 >> 2] = ($3 | 0) > 15 ? $3 : 15;
  $10 = ((Math_imul($12, $20) << 2) + $0 | 0) + 244 | 0;
  $3 = memcpy((Math_imul($12, $24) << 2) + $1 | 0, $10, $14);
  $15 = $15 - $20 | 0;
  if ($15) {
   $11 = HEAP32[$0 + 104 >> 2];
   $13 = Math_fround(-HEAPF32[$0 + 108 >> 2]);
   $18 = HEAP32[$0 + 112 >> 2];
   comb_filter($3 + $14 | 0, HEAP32[($16 + 8 | 0) + ($12 << 2) >> 2] + 4096 | 0, $11, $11, $15, $13, $13, $18, $18, 0, 0, HEAP32[$0 + 72 >> 2]);
  }
  $11 = $15 << 2;
  $18 = ($16 + 8 | 0) + ($12 << 2) | 0;
  comb_filter($11 + ($3 + $14 | 0) | 0, (HEAP32[$18 >> 2] + $11 | 0) + 4096 | 0, HEAP32[$0 + 104 >> 2], HEAP32[$16 + 4 >> 2], $4 - $15 | 0, Math_fround(-HEAPF32[$0 + 108 >> 2]), $17, HEAP32[$0 + 112 >> 2], $5, HEAP32[$21 + 60 >> 2], $20, HEAP32[$0 + 72 >> 2]);
  $15 = $4 << 2;
  memcpy($10, $15 + $3 | 0, $14);
  $3 = ($12 << 12) + $2 | 0;
  label$12 : {
   if (!$9) {
    memcpy($3, HEAP32[$18 >> 2] + $15 | 0, 4096);
    break label$12;
   }
   memcpy((memmove($3, $3 + $15 | 0, $28) + $29 | 0) + 4096 | 0, HEAP32[$18 >> 2] + 4096 | 0, $22);
  }
  $12 = $12 + 1 | 0;
  if (($23 | 0) != ($12 | 0)) {
   $3 = HEAP32[$0 + 104 >> 2];
   continue;
  }
  break;
 }
 HEAPF32[$7 >> 2] = $26;
 HEAP32[$6 >> 2] = HEAP32[$16 + 4 >> 2];
 HEAP32[$8 >> 2] = $25;
 __stack_pointer = $16 + 16 | 0;
 return $27;
}
function opus_repacketizer_out_range_impl($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $7 = -1;
 label$1 : {
  if (($1 | 0) < 0 | ($1 | 0) >= ($2 | 0) | HEAP32[$0 + 4 >> 2] < ($2 | 0)) {
   break label$1;
  }
  $10 = $2 - $1 | 0;
  $11 = (($1 << 1) + $0 | 0) + 200 | 0;
  $8 = $5 ? HEAP16[(($10 << 1) + $11 | 0) - 2 >> 1] > 251 ? 2 : 1 : 0;
  label$4 : {
   label$5 : {
    label$6 : {
     label$7 : {
      switch ($10 - 1 | 0) {
      case 0:
       $7 = -2;
       $8 = (HEAP16[$11 >> 1] + $8 | 0) + 1 | 0;
       if (($8 | 0) > ($4 | 0)) {
        break label$1;
       }
       HEAP8[$3 | 0] = HEAPU8[$0 | 0] & 252;
       $7 = $3 + 1 | 0;
       break label$6;
      case 1:
       $7 = HEAPU16[$11 >> 1];
       $9 = $7 << 16 >> 16;
       $12 = HEAPU16[$11 + 2 >> 1];
       if (($12 | 0) == ($7 | 0)) {
        $7 = -2;
        $8 = ($9 << 1 | 1) + $8 | 0;
        if (($8 | 0) > ($4 | 0)) {
         break label$1;
        }
        HEAP8[$3 | 0] = HEAPU8[$0 | 0] & 252 | 1;
        $7 = $3 + 1 | 0;
        break label$6;
       }
       $7 = -2;
       $8 = (((($12 << 16 >> 16) + $8 | 0) + $9 | 0) + (($9 | 0) > 251) | 0) + 2 | 0;
       if (($8 | 0) > ($4 | 0)) {
        break label$1;
       }
       HEAP8[$3 | 0] = HEAPU8[$0 | 0] & 252 | 2;
       $7 = $3 + 1 | 0;
       $7 = $7 + encode_size(HEAP16[$11 >> 1], $7) | 0;
       break label$6;
      default:
       break label$7;
      }
     }
     $7 = $3;
     if (($10 | 0) > 2) {
      break label$5;
     }
    }
    if (!$6 | ($4 | 0) <= ($8 | 0)) {
     break label$4;
    }
   }
   $12 = $5 ? HEAP16[(($10 << 1) + $11 | 0) - 2 >> 1] > 251 ? 4 : 3 : 2;
   $7 = 1;
   $9 = HEAP16[$11 >> 1];
   label$13 : {
    label$14 : {
     if (($10 | 0) <= 1) {
      break label$14;
     }
     $8 = $9 & 65535;
     while (1) {
      if (HEAPU16[($7 << 1) + $11 >> 1] == ($8 | 0)) {
       $7 = $7 + 1 | 0;
       if (($10 | 0) != ($7 | 0)) {
        continue;
       }
       break label$14;
      }
      break;
     }
     $7 = 1;
     $8 = ($9 + $12 | 0) + (($9 | 0) > 251 ? 2 : 1) | 0;
     $13 = $10 - 1 | 0;
     $12 = ($1 ^ -1) + $2 | 0;
     if (($12 | 0) >= 2) {
      while (1) {
       $9 = HEAP16[($7 << 1) + $11 >> 1];
       $8 = ($9 + $8 | 0) + (($9 | 0) > 251 ? 2 : 1) | 0;
       $7 = $7 + 1 | 0;
       if (($12 | 0) != ($7 | 0)) {
        continue;
       }
       break;
      }
     }
     $7 = -2;
     $8 = HEAP16[($13 << 1) + $11 >> 1] + $8 | 0;
     if (($8 | 0) > ($4 | 0)) {
      break label$1;
     }
     $7 = HEAPU8[$0 | 0];
     $9 = $10 | -128;
     HEAP8[$3 + 1 | 0] = $9;
     HEAP8[$3 | 0] = $7 | 3;
     $7 = 0;
     break label$13;
    }
    $7 = -2;
    $8 = Math_imul($9, $10) + $12 | 0;
    if (($8 | 0) > ($4 | 0)) {
     break label$1;
    }
    $7 = HEAPU8[$0 | 0];
    HEAP8[$3 + 1 | 0] = $10;
    HEAP8[$3 | 0] = $7 | 3;
    $9 = $10;
    $7 = 1;
   }
   $13 = $7;
   $7 = $3 + 2 | 0;
   label$19 : {
    if (!$6) {
     break label$19;
    }
    $12 = $4 - $8 | 0;
    if (!$12) {
     break label$19;
    }
    HEAP8[$3 + 1 | 0] = $9 | 64;
    $14 = ($12 - 1 | 0) / 255 | 0;
    if (($12 | 0) >= 256) {
     $9 = ($14 | 0) > 1 ? $14 : 1;
     memset($7, 255, $9);
     $8 = 0;
     while (1) {
      $7 = $7 + 1 | 0;
      $8 = $8 + 1 | 0;
      if (($9 | 0) != ($8 | 0)) {
       continue;
      }
      break;
     }
    }
    HEAP8[$7 | 0] = (Math_imul($14, -255) + $12 | 0) - 1;
    $7 = $7 + 1 | 0;
    $8 = $4;
   }
   if (($10 | 0) < 2 | $13) {
    break label$4;
   }
   $2 = ($1 ^ -1) + $2 | 0;
   $9 = ($2 | 0) > 1 ? $2 : 1;
   $2 = 0;
   while (1) {
    $7 = encode_size(HEAP16[($2 << 1) + $11 >> 1], $7) + $7 | 0;
    $2 = $2 + 1 | 0;
    if (($9 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  if ($5) {
   $7 = encode_size(HEAP16[(($10 << 1) + $11 | 0) - 2 >> 1], $7) + $7 | 0;
  }
  if (($10 | 0) >= 1) {
   $0 = (($1 << 2) + $0 | 0) + 8 | 0;
   $1 = 0;
   while (1) {
    $2 = ($1 << 1) + $11 | 0;
    $7 = memmove($7, HEAP32[($1 << 2) + $0 >> 2], HEAP16[$2 >> 1]) + HEAP16[$2 >> 1] | 0;
    $1 = $1 + 1 | 0;
    if (($10 | 0) != ($1 | 0)) {
     continue;
    }
    break;
   }
  }
  if (!(!$6 | $3 + $4 >>> 0 <= $7 >>> 0)) {
   memset($7, 0, ($4 - $7 | 0) + $3 | 0);
  }
  $7 = $8;
 }
 return $7;
}
function try_realloc_chunk($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $6 = HEAP32[$0 + 4 >> 2];
 $3 = $6 & 3;
 $5 = $6 & -8;
 $2 = $5 + $0 | 0;
 label$2 : {
  if (!$3) {
   $3 = 0;
   if ($1 >>> 0 < 256) {
    break label$2;
   }
   if ($1 + 4 >>> 0 <= $5 >>> 0) {
    $3 = $0;
    if ($5 - $1 >>> 0 <= HEAP32[13352] << 1 >>> 0) {
     break label$2;
    }
   }
   return 0;
  }
  label$5 : {
   if ($1 >>> 0 <= $5 >>> 0) {
    $3 = $5 - $1 | 0;
    if ($3 >>> 0 < 16) {
     break label$5;
    }
    HEAP32[$0 + 4 >> 2] = $6 & 1 | $1 | 2;
    $1 = $0 + $1 | 0;
    HEAP32[$1 + 4 >> 2] = $3 | 3;
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 1;
    dispose_chunk($1, $3);
    break label$5;
   }
   $3 = 0;
   if (HEAP32[13238] == ($2 | 0)) {
    $2 = HEAP32[13235] + $5 | 0;
    if ($2 >>> 0 <= $1 >>> 0) {
     break label$2;
    }
    HEAP32[$0 + 4 >> 2] = $6 & 1 | $1 | 2;
    $3 = $0 + $1 | 0;
    $1 = $2 - $1 | 0;
    HEAP32[$3 + 4 >> 2] = $1 | 1;
    HEAP32[13235] = $1;
    HEAP32[13238] = $3;
    break label$5;
   }
   if (HEAP32[13237] == ($2 | 0)) {
    $2 = HEAP32[13234] + $5 | 0;
    if ($2 >>> 0 < $1 >>> 0) {
     break label$2;
    }
    $3 = $2 - $1 | 0;
    label$9 : {
     if ($3 >>> 0 >= 16) {
      HEAP32[$0 + 4 >> 2] = $6 & 1 | $1 | 2;
      $1 = $0 + $1 | 0;
      HEAP32[$1 + 4 >> 2] = $3 | 1;
      $2 = $0 + $2 | 0;
      HEAP32[$2 >> 2] = $3;
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] & -2;
      break label$9;
     }
     HEAP32[$0 + 4 >> 2] = $6 & 1 | $2 | 2;
     $1 = $0 + $2 | 0;
     HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 1;
     $3 = 0;
     $1 = 0;
    }
    HEAP32[13237] = $1;
    HEAP32[13234] = $3;
    break label$5;
   }
   $4 = HEAP32[$2 + 4 >> 2];
   if ($4 & 2) {
    break label$2;
   }
   $7 = ($4 & -8) + $5 | 0;
   if ($7 >>> 0 < $1 >>> 0) {
    break label$2;
   }
   $9 = $7 - $1 | 0;
   label$11 : {
    if ($4 >>> 0 <= 255) {
     $3 = HEAP32[$2 + 12 >> 2];
     $2 = HEAP32[$2 + 8 >> 2];
     $4 = $4 >>> 3 | 0;
     $5 = ($4 << 3) + 52968 | 0;
     if (($2 | 0) == ($3 | 0)) {
      HEAP32[13232] = HEAP32[13232] & __wasm_rotl_i32(-2, $4);
      break label$11;
     }
     HEAP32[$2 + 12 >> 2] = $3;
     HEAP32[$3 + 8 >> 2] = $2;
     break label$11;
    }
    $8 = HEAP32[$2 + 24 >> 2];
    $4 = HEAP32[$2 + 12 >> 2];
    label$14 : {
     if (($4 | 0) != ($2 | 0)) {
      $3 = HEAP32[$2 + 8 >> 2];
      HEAP32[$3 + 12 >> 2] = $4;
      HEAP32[$4 + 8 >> 2] = $3;
      break label$14;
     }
     label$17 : {
      $3 = $2 + 20 | 0;
      $5 = HEAP32[$3 >> 2];
      if ($5) {
       break label$17;
      }
      $3 = $2 + 16 | 0;
      $5 = HEAP32[$3 >> 2];
      if ($5) {
       break label$17;
      }
      $4 = 0;
      break label$14;
     }
     while (1) {
      $10 = $3;
      $4 = $5;
      $3 = $4 + 20 | 0;
      $5 = HEAP32[$3 >> 2];
      if ($5) {
       continue;
      }
      $3 = $4 + 16 | 0;
      $5 = HEAP32[$4 + 16 >> 2];
      if ($5) {
       continue;
      }
      break;
     }
     HEAP32[$10 >> 2] = 0;
    }
    if (!$8) {
     break label$11;
    }
    $5 = HEAP32[$2 + 28 >> 2];
    $3 = ($5 << 2) + 53232 | 0;
    label$19 : {
     if (HEAP32[$3 >> 2] == ($2 | 0)) {
      HEAP32[$3 >> 2] = $4;
      if ($4) {
       break label$19;
      }
      HEAP32[13233] = HEAP32[13233] & __wasm_rotl_i32(-2, $5);
      break label$11;
     }
     HEAP32[(HEAP32[$8 + 16 >> 2] == ($2 | 0) ? 16 : 20) + $8 >> 2] = $4;
     if (!$4) {
      break label$11;
     }
    }
    HEAP32[$4 + 24 >> 2] = $8;
    $3 = HEAP32[$2 + 16 >> 2];
    if ($3) {
     HEAP32[$4 + 16 >> 2] = $3;
     HEAP32[$3 + 24 >> 2] = $4;
    }
    $2 = HEAP32[$2 + 20 >> 2];
    if (!$2) {
     break label$11;
    }
    HEAP32[$4 + 20 >> 2] = $2;
    HEAP32[$2 + 24 >> 2] = $4;
   }
   if ($9 >>> 0 <= 15) {
    HEAP32[$0 + 4 >> 2] = $6 & 1 | $7 | 2;
    $1 = $0 + $7 | 0;
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 1;
    break label$5;
   }
   HEAP32[$0 + 4 >> 2] = $6 & 1 | $1 | 2;
   $1 = $0 + $1 | 0;
   HEAP32[$1 + 4 >> 2] = $9 | 3;
   $2 = $0 + $7 | 0;
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 1;
   dispose_chunk($1, $9);
  }
  $3 = $0;
 }
 return $3;
}
function silk_A2NLSF($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
 $6 = __stack_pointer - 144 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 12 >> 2] = $6 + 16;
 HEAP32[$6 + 8 >> 2] = $6 + 80;
 $10 = $2 >> 1;
 silk_A2NLSF_init($1, $6 + 80 | 0, $6 + 16 | 0, $10);
 $13 = $6 + 80 | 0;
 $15 = HEAP16[7560];
 $3 = silk_A2NLSF_eval_poly($6 + 80 | 0, $15, $10);
 if (($3 | 0) <= -1) {
  HEAP16[$0 >> 1] = 0;
  $13 = $6 + 16 | 0;
  $3 = silk_A2NLSF_eval_poly($6 + 16 | 0, $15, $10);
  $14 = 1;
 }
 label$2 : while (1) {
  $8 = 1;
  $9 = $15;
  while (1) {
   label$4 : {
    $19 = $8 << 1;
    $4 = HEAP16[$19 + 15120 >> 1];
    $16 = silk_A2NLSF_eval_poly($13, $4, $10);
    label$5 : {
     label$6 : {
      $7 = ($3 | 0) > 0;
      if (!(($3 | 0) < 0 | (0 - $5 | 0) < ($16 | 0) ? !(($5 | 0) <= ($16 | 0) ? !$7 : 0) : 0)) {
       $5 = $4 + $9 | 0;
       $11 = ($5 >> 1) + ($5 & 1) | 0;
       $12 = silk_A2NLSF_eval_poly($13, $11, $10);
       label$9 : {
        label$10 : {
         if ($7) {
          break label$10;
         }
         $5 = -256;
         if (($12 | 0) <= -1) {
          break label$10;
         }
         $7 = $11;
         $17 = $12;
         break label$9;
        }
        $5 = ($12 | 0) < 1 & ($3 | 0) > -1;
        $17 = $5 ? $12 : $16;
        $3 = $5 ? $3 : $12;
        $7 = $5 ? $11 : $4;
        $9 = $5 ? $9 : $11;
        $5 = $5 ? -256 : -128;
       }
       $4 = $7 + $9 | 0;
       $12 = ($4 >> 1) + ($4 & 1) | 0;
       $4 = silk_A2NLSF_eval_poly($13, $12, $10);
       if (($4 | 0) <= -1 | ($3 | 0) > 0) {
        break label$6;
       }
       $17 = $4;
       $7 = $12;
       break label$5;
      }
      $7 = ($8 | 0) < 128;
      $5 = 0;
      $9 = $4;
      $3 = $16;
      $8 = $8 + 1 | 0;
      if ($7) {
       continue;
      }
      if ($18 >>> 0 >= 16) {
       $3 = 32768 / ($2 + 1 | 0) | 0;
       HEAP16[$0 >> 1] = $3;
       $8 = 2;
       if (($2 | 0) < 2) {
        break label$4;
       }
       $3 = $3 << 1;
       HEAP16[$0 + 2 >> 1] = $3;
       if (($2 | 0) == 2) {
        break label$4;
       }
       while (1) {
        $3 = HEAPU16[$0 >> 1] + $3 | 0;
        HEAP16[($8 << 1) + $0 >> 1] = $3;
        $8 = $8 + 1 | 0;
        if (($8 | 0) != ($2 | 0)) {
         continue;
        }
        break;
       }
       break label$4;
      }
      silk_bwexpander_32($1, $2, (-2 << $18) + 65536 | 0);
      silk_A2NLSF_init($1, $6 + 80 | 0, $6 + 16 | 0, $10);
      $14 = 0;
      $13 = $6 + 80 | 0;
      $8 = $18 + 1 | 0;
      $18 = $8;
      $3 = silk_A2NLSF_eval_poly($6 + 80 | 0, $15, $10);
      if (($3 | 0) > -1) {
       continue label$2;
      }
      HEAP16[$0 >> 1] = 0;
      $14 = 1;
      $13 = $6 + 16 | 0;
      $3 = silk_A2NLSF_eval_poly($6 + 16 | 0, $15, $10);
      $18 = $8;
      continue label$2;
     }
     $11 = ($4 | 0) < 1 & ($3 | 0) > -1;
     $17 = $11 ? $4 : $17;
     $3 = $11 ? $3 : $4;
     $9 = $11 ? $9 : $12;
     $5 = $11 ? $5 : $5 | 64;
     $7 = $11 ? $12 : $7;
    }
    $4 = $9 + $7 | 0;
    $4 = silk_A2NLSF_eval_poly($13, ($4 >> 1) + ($4 & 1) | 0, $10);
    label$13 : {
     if (!(($4 | 0) <= -1 | ($3 | 0) > 0)) {
      $7 = $4;
      break label$13;
     }
     $9 = ($4 | 0) < 1 & ($3 | 0) > -1;
     $7 = $9 ? $4 : $17;
     $3 = $9 ? $3 : $4;
     $5 = $9 ? $5 : $5 + 32 | 0;
    }
    $4 = $3 - $7 | 0;
    $7 = $3 >> 31;
    label$15 : {
     if (($7 ^ $3 + $7) >= 65536) {
      $5 = (($3 | 0) / ($4 >> 5) | 0) + $5 | 0;
      break label$15;
     }
     if (!$4) {
      break label$15;
     }
     $5 = ((($3 << 5) + ($4 >> 1) | 0) / ($4 | 0) | 0) + $5 | 0;
    }
    $3 = ($8 << 8) + $5 | 0;
    HEAP16[($14 << 1) + $0 >> 1] = ($3 | 0) < 32767 ? $3 : 32767;
    $14 = $14 + 1 | 0;
    if (($14 | 0) >= ($2 | 0)) {
     break label$4;
    }
    $5 = !$16;
    $3 = 4096 - ($14 << 12 & 8192) | 0;
    $9 = HEAP16[$19 + 15118 >> 1];
    $13 = HEAP32[($6 + 8 | 0) + (($14 & 1) << 2) >> 2];
    continue;
   }
   break;
  }
  break;
 }
 __stack_pointer = $6 + 144 | 0;
}
function ec_enc_done($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $2 = HEAP32[$0 + 28 >> 2];
 $4 = Math_clz32($2);
 $1 = 2147483647 >>> $4 | 0;
 $3 = HEAP32[$0 + 32 >> 2];
 $5 = $1 + $3 & -2147483648 >> $4;
 label$1 : {
  label$2 : {
   if ($2 + $3 >>> 0 <= ($1 | $5) >>> 0) {
    $1 = $1 >>> 1 | 0;
    $5 = $3 + $1 & ($1 ^ -1);
    $4 = $4 + 1 | 0;
    break label$2;
   }
   if (!$4) {
    break label$1;
   }
  }
  $6 = $4;
  while (1) {
   $7 = $5 >>> 23 | 0;
   label$5 : {
    if (($7 | 0) != 255) {
     $3 = $5 >>> 31 | 0;
     $2 = HEAP32[$0 + 40 >> 2];
     if (($2 | 0) >= 0) {
      $1 = -1;
      $4 = HEAP32[$0 + 24 >> 2];
      if (HEAPU32[$0 + 4 >> 2] > $4 + HEAP32[$0 + 8 >> 2] >>> 0) {
       HEAP32[$0 + 24 >> 2] = $4 + 1;
       HEAP8[HEAP32[$0 >> 2] + $4 | 0] = $2 + $3;
       $1 = 0;
      }
      HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] | $1;
     }
     $1 = HEAP32[$0 + 36 >> 2];
     if ($1) {
      $4 = $3 - 1 | 0;
      while (1) {
       $3 = -1;
       $2 = HEAP32[$0 + 24 >> 2];
       if (HEAPU32[$0 + 4 >> 2] > $2 + HEAP32[$0 + 8 >> 2] >>> 0) {
        HEAP32[$0 + 24 >> 2] = $2 + 1;
        HEAP8[HEAP32[$0 >> 2] + $2 | 0] = $4;
        $3 = 0;
        $1 = HEAP32[$0 + 36 >> 2];
       }
       $1 = $1 - 1 | 0;
       HEAP32[$0 + 36 >> 2] = $1;
       HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] | $3;
       if ($1) {
        continue;
       }
       break;
      }
     }
     HEAP32[$0 + 40 >> 2] = $7 & 255;
     break label$5;
    }
    HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
   }
   $5 = $5 << 8 & 2147483392;
   $1 = ($6 | 0) > 8;
   $4 = $6 - 8 | 0;
   $6 = $4;
   if ($1) {
    continue;
   }
   break;
  }
 }
 $1 = -1;
 $3 = HEAP32[$0 + 40 >> 2];
 label$12 : {
  label$13 : {
   label$14 : {
    if (($3 | 0) <= -1) {
     $1 = HEAP32[$0 + 36 >> 2];
     if ($1) {
      break label$14;
     }
     break label$12;
    }
    $2 = HEAP32[$0 + 24 >> 2];
    if (HEAPU32[$0 + 4 >> 2] > $2 + HEAP32[$0 + 8 >> 2] >>> 0) {
     HEAP32[$0 + 24 >> 2] = $2 + 1;
     HEAP8[HEAP32[$0 >> 2] + $2 | 0] = $3;
     $1 = 0;
    }
    HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] | $1;
    $1 = HEAP32[$0 + 36 >> 2];
    if (!$1) {
     break label$13;
    }
   }
   while (1) {
    $3 = -1;
    $2 = HEAP32[$0 + 24 >> 2];
    if (HEAPU32[$0 + 4 >> 2] > $2 + HEAP32[$0 + 8 >> 2] >>> 0) {
     HEAP32[$0 + 24 >> 2] = $2 + 1;
     HEAP8[HEAP32[$0 >> 2] + $2 | 0] = 255;
     $3 = 0;
     $1 = HEAP32[$0 + 36 >> 2];
    }
    $1 = $1 - 1 | 0;
    HEAP32[$0 + 36 >> 2] = $1;
    HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] | $3;
    if ($1) {
     continue;
    }
    break;
   }
  }
  HEAP32[$0 + 40 >> 2] = 0;
 }
 $3 = HEAP32[$0 + 12 >> 2];
 $5 = HEAP32[$0 + 16 >> 2];
 label$19 : {
  if (($5 | 0) <= 7) {
   $6 = HEAP32[$0 + 44 >> 2];
   break label$19;
  }
  $1 = $5;
  while (1) {
   $2 = -1;
   $6 = HEAP32[$0 + 4 >> 2];
   $5 = HEAP32[$0 + 8 >> 2];
   if ($6 >>> 0 > $5 + HEAP32[$0 + 24 >> 2] >>> 0) {
    $2 = $5 + 1 | 0;
    HEAP32[$0 + 8 >> 2] = $2;
    HEAP8[HEAP32[$0 >> 2] + ($6 - $2 | 0) | 0] = $3;
    $2 = 0;
   }
   $6 = HEAP32[$0 + 44 >> 2] | $2;
   HEAP32[$0 + 44 >> 2] = $6;
   $3 = $3 >>> 8 | 0;
   $2 = ($1 | 0) > 15;
   $5 = $1 - 8 | 0;
   $1 = $5;
   if ($2) {
    continue;
   }
   break;
  }
 }
 label$23 : {
  if ($6) {
   break label$23;
  }
  $1 = HEAP32[$0 + 24 >> 2];
  memset($1 + HEAP32[$0 >> 2] | 0, 0, (HEAP32[$0 + 4 >> 2] - $1 | 0) - HEAP32[$0 + 8 >> 2] | 0);
  if (($5 | 0) < 1) {
   break label$23;
  }
  $1 = HEAP32[$0 + 8 >> 2];
  $2 = HEAP32[$0 + 4 >> 2];
  if ($1 >>> 0 >= $2 >>> 0) {
   HEAP32[$0 + 44 >> 2] = -1;
   return;
  }
  $4 = 0 - $4 | 0;
  if (!(HEAP32[$0 + 24 >> 2] + $1 >>> 0 < $2 >>> 0 | ($5 | 0) <= ($4 | 0))) {
   HEAP32[$0 + 44 >> 2] = -1;
   $3 = (-1 << $4 ^ -1) & $3;
  }
  $0 = HEAP32[$0 >> 2] + (($1 ^ -1) + $2 | 0) | 0;
  HEAP8[$0 | 0] = HEAPU8[$0 | 0] | $3;
 }
}
function silk_encode_indices($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $7 = __stack_pointer - 48 | 0;
 __stack_pointer = $7;
 label$1 : {
  label$2 : {
   $2 = $3 ? (Math_imul($2, 36) + $0 | 0) + 6100 | 0 : $0 + 4736 | 0;
   $5 = (HEAP8[$2 + 29 | 0] << 1) + HEAP8[$2 + 30 | 0] | 0;
   if ($5 >>> 0 < 6) {
    if (($5 | 0) <= 1 ? $3 : 0) {
     break label$2;
    }
    label$4 : {
     if (!(($5 | 0) < 2 ? !$3 : 0)) {
      ec_enc_icdf($1, $5 - 2 | 0, 5829, 8);
      break label$4;
     }
     ec_enc_icdf($1, $5, 5833, 8);
    }
    $3 = HEAP8[$2 | 0];
    label$6 : {
     if (($4 | 0) == 2) {
      ec_enc_icdf($1, $3, 7328, 8);
      break label$6;
     }
     ec_enc_icdf($1, $3 >> 3, (HEAP8[$2 + 29 | 0] << 3) + 7296 | 0, 8);
     ec_enc_icdf($1, HEAPU8[$2 | 0] & 7, 5872, 8);
    }
    if (HEAP32[$0 + 4580 >> 2] >= 2) {
     $3 = 1;
     while (1) {
      ec_enc_icdf($1, HEAP8[$2 + $3 | 0], 7328, 8);
      $3 = $3 + 1 | 0;
      if (($3 | 0) < HEAP32[$0 + 4580 >> 2]) {
       continue;
      }
      break;
     }
    }
    $3 = HEAP32[$0 + 4692 >> 2];
    ec_enc_icdf($1, HEAP8[$2 + 8 | 0], HEAP32[$3 + 16 >> 2] + Math_imul(HEAP16[$3 >> 1], HEAP8[$2 + 29 | 0] >> 1) | 0, 8);
    silk_NLSF_unpack($7 + 16 | 0, $7, HEAP32[$0 + 4692 >> 2], HEAP8[$2 + 8 | 0]);
    $5 = HEAP32[$0 + 4692 >> 2];
    $6 = HEAP16[$5 + 2 >> 1];
    if (($6 | 0) != HEAP32[$0 + 4640 >> 2]) {
     break label$1;
    }
    $3 = 0;
    if (($6 | 0) > 0) {
     while (1) {
      $6 = $3;
      $3 = $3 + 1 | 0;
      $8 = $3 + $2 | 0;
      $9 = HEAP8[$8 + 8 | 0];
      label$12 : {
       if (($9 | 0) >= 4) {
        ec_enc_icdf($1, 8, HEAP32[$5 + 28 >> 2] + HEAP16[($7 + 16 | 0) + ($6 << 1) >> 1] | 0, 8);
        ec_enc_icdf($1, HEAP8[$8 + 8 | 0] - 4 | 0, 5880, 8);
        break label$12;
       }
       if (($9 | 0) <= -4) {
        ec_enc_icdf($1, 0, HEAP32[$5 + 28 >> 2] + HEAP16[($7 + 16 | 0) + ($6 << 1) >> 1] | 0, 8);
        ec_enc_icdf($1, -4 - HEAP8[$8 + 8 | 0] | 0, 5880, 8);
        break label$12;
       }
       ec_enc_icdf($1, $9 + 4 | 0, HEAP32[$5 + 28 >> 2] + HEAP16[($7 + 16 | 0) + ($6 << 1) >> 1] | 0, 8);
      }
      $5 = HEAP32[$0 + 4692 >> 2];
      if (HEAP16[$5 + 2 >> 1] > ($3 | 0)) {
       continue;
      }
      break;
     }
    }
    if (HEAP32[$0 + 4580 >> 2] == 4) {
     ec_enc_icdf($1, HEAP8[$2 + 31 | 0], 5835, 8);
    }
    label$16 : {
     if (HEAPU8[$2 + 29 | 0] != 2) {
      break label$16;
     }
     label$17 : {
      if (!(($4 | 0) != 2 | HEAP32[$0 + 5768 >> 2] != 2)) {
       $3 = HEAP16[$2 + 26 >> 1] - HEAP16[$0 + 5772 >> 1] | 0;
       $6 = $3 + 9 | 0;
       $3 = $3 + 8 | 0;
       ec_enc_icdf($1, $3 >>> 0 > 19 ? 0 : $6, 2080, 8);
       if ($3 >>> 0 < 20) {
        break label$17;
       }
      }
      $3 = HEAP16[$2 + 26 >> 1];
      $5 = HEAP32[$0 + 4576 >> 2] >> 1;
      $6 = ($3 | 0) / ($5 | 0) | 0;
      ec_enc_icdf($1, $6, 2048, 8);
      ec_enc_icdf($1, $3 - Math_imul($6 << 16 >> 16, $5 << 16 >> 16) | 0, HEAP32[$0 + 4684 >> 2], 8);
     }
     HEAP16[$0 + 5772 >> 1] = HEAPU16[$2 + 26 >> 1];
     ec_enc_icdf($1, HEAP8[$2 + 28 | 0], HEAP32[$0 + 4688 >> 2], 8);
     ec_enc_icdf($1, HEAP8[$2 + 32 | 0], 7369, 8);
     if (HEAP32[$0 + 4580 >> 2] >= 1) {
      $3 = 0;
      while (1) {
       ec_enc_icdf($1, HEAP8[($2 + $3 | 0) + 4 | 0], HEAP32[(HEAP8[$2 + 32 | 0] << 2) + 7440 >> 2], 8);
       $3 = $3 + 1 | 0;
       if (($3 | 0) < HEAP32[$0 + 4580 >> 2]) {
        continue;
       }
       break;
      }
     }
     if ($4) {
      break label$16;
     }
     ec_enc_icdf($1, HEAP8[$2 + 33 | 0], 5826, 8);
    }
    HEAP32[$0 + 5768 >> 2] = HEAP8[$2 + 29 | 0];
    ec_enc_icdf($1, HEAP8[$2 + 34 | 0], 5857, 8);
    __stack_pointer = $7 + 48 | 0;
    return;
   }
   celt_fatal(7919, 7971, 59);
   abort();
  }
  celt_fatal(7993, 7971, 60);
  abort();
 }
 celt_fatal(8047, 7971, 93);
 abort();
}
function pitch_downsample($0, $1, $2, $3, $4) {
 var $5 = Math_fround(0), $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = Math_fround(0), $11 = Math_fround(0), $12 = Math_fround(0), $13 = 0, $14 = 0, $15 = 0, $16 = Math_fround(0), $17 = Math_fround(0), $18 = Math_fround(0), $19 = Math_fround(0), $20 = Math_fround(0), $21 = Math_fround(0), $22 = Math_fround(0);
 $6 = __stack_pointer - 48 | 0;
 __stack_pointer = $6;
 $13 = $2 >> 1;
 $8 = HEAP32[$0 >> 2];
 if (($2 | 0) >= 4) {
  $15 = ($13 | 0) > 2 ? $13 : 2;
  $7 = 1;
  while (1) {
   $9 = $7 << 3;
   $14 = $9 + $8 | 0;
   HEAPF32[($7 << 2) + $1 >> 2] = Math_fround(HEAPF32[$14 >> 2] + Math_fround(Math_fround(HEAPF32[$14 - 4 >> 2] + HEAPF32[($9 | 4) + $8 >> 2]) * Math_fround(.5))) * Math_fround(.5);
   $7 = $7 + 1 | 0;
   if (($15 | 0) != ($7 | 0)) {
    continue;
   }
   break;
  }
 }
 $5 = Math_fround(Math_fround(Math_fround(HEAPF32[$8 + 4 >> 2] * Math_fround(.5)) + HEAPF32[$8 >> 2]) * Math_fround(.5));
 HEAPF32[$1 >> 2] = $5;
 if (($3 | 0) == 2) {
  $8 = HEAP32[$0 + 4 >> 2];
  if (($2 | 0) >= 4) {
   $15 = ($13 | 0) > 2 ? $13 : 2;
   $7 = 1;
   while (1) {
    $9 = ($7 << 2) + $1 | 0;
    $0 = $9;
    $5 = HEAPF32[$9 >> 2];
    $9 = $7 << 3;
    $14 = $9 + $8 | 0;
    HEAPF32[$0 >> 2] = $5 + Math_fround(Math_fround(HEAPF32[$14 >> 2] + Math_fround(Math_fround(HEAPF32[$14 - 4 >> 2] + HEAPF32[($9 | 4) + $8 >> 2]) * Math_fround(.5))) * Math_fround(.5));
    $7 = $7 + 1 | 0;
    if (($15 | 0) != ($7 | 0)) {
     continue;
    }
    break;
   }
   $5 = HEAPF32[$1 >> 2];
  }
  HEAPF32[$1 >> 2] = $5 + Math_fround(Math_fround(Math_fround(HEAPF32[$8 + 4 >> 2] * Math_fround(.5)) + HEAPF32[$8 >> 2]) * Math_fround(.5));
 }
 $7 = 0;
 _celt_autocorr($1, $6 + 16 | 0, 0, 0, 4, $13, $4);
 HEAPF32[$6 + 16 >> 2] = HEAPF32[$6 + 16 >> 2] * Math_fround(1.000100016593933);
 $5 = HEAPF32[$6 + 20 >> 2];
 HEAPF32[$6 + 20 >> 2] = $5 - Math_fround(Math_fround($5 * Math_fround(.00800000037997961)) * Math_fround(.00800000037997961));
 $5 = HEAPF32[$6 + 24 >> 2];
 HEAPF32[$6 + 24 >> 2] = $5 - Math_fround(Math_fround($5 * Math_fround(.01600000075995922)) * Math_fround(.01600000075995922));
 $5 = HEAPF32[$6 + 28 >> 2];
 HEAPF32[$6 + 28 >> 2] = $5 - Math_fround(Math_fround($5 * Math_fround(.024000000208616257)) * Math_fround(.024000000208616257));
 $5 = HEAPF32[$6 + 32 >> 2];
 HEAPF32[$6 + 32 >> 2] = $5 - Math_fround(Math_fround($5 * Math_fround(.03200000151991844)) * Math_fround(.03200000151991844));
 _celt_lpc($6, $6 + 16 | 0, 4);
 $5 = Math_fround(HEAPF32[$6 + 8 >> 2] * Math_fround(.7289999127388));
 HEAPF32[$6 + 8 >> 2] = $5;
 $10 = Math_fround(HEAPF32[$6 + 12 >> 2] * Math_fround(.6560999155044556));
 HEAPF32[$6 + 12 >> 2] = $10;
 $11 = Math_fround(HEAPF32[$6 + 4 >> 2] * Math_fround(.809999942779541));
 HEAPF32[$6 + 4 >> 2] = $11;
 $12 = Math_fround(HEAPF32[$6 >> 2] * Math_fround(.8999999761581421));
 HEAPF32[$6 >> 2] = $12;
 if (($2 | 0) >= 2) {
  $17 = Math_fround($10 + Math_fround($5 * Math_fround(.800000011920929)));
  $18 = Math_fround($5 + Math_fround($11 * Math_fround(.800000011920929)));
  $19 = Math_fround($11 + Math_fround($12 * Math_fround(.800000011920929)));
  $20 = Math_fround($10 * Math_fround(.800000011920929));
  $21 = Math_fround($12 + Math_fround(.800000011920929));
  $5 = Math_fround(0);
  $10 = Math_fround(0);
  $11 = Math_fround(0);
  $12 = Math_fround(0);
  while (1) {
   $8 = ($7 << 2) + $1 | 0;
   $16 = HEAPF32[$8 >> 2];
   HEAPF32[$8 >> 2] = Math_fround($20 * $22) + Math_fround(Math_fround($17 * $5) + Math_fround(Math_fround($18 * $10) + Math_fround(Math_fround($19 * $11) + Math_fround(Math_fround($21 * $12) + $16))));
   $22 = $5;
   $5 = $10;
   $10 = $11;
   $11 = $12;
   $12 = $16;
   $7 = $7 + 1 | 0;
   if (($13 | 0) != ($7 | 0)) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $6 + 48 | 0;
}
function quant_coarse_energy_impl($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) {
 var $15 = 0, $16 = Math_fround(0), $17 = Math_fround(0), $18 = 0, $19 = Math_fround(0), $20 = Math_fround(0), $21 = Math_fround(0), $22 = 0, $23 = Math_fround(0), $24 = Math_fround(0), $25 = 0, $26 = Math_fround(0), $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0;
 $15 = __stack_pointer - 16 | 0;
 __stack_pointer = $15;
 HEAP32[$15 + 8 >> 2] = 0;
 HEAP32[$15 + 12 >> 2] = 0;
 if (($6 + 3 | 0) <= ($5 | 0)) {
  ec_enc_bit_logp($9, $12, 3);
 }
 if ($12) {
  $19 = Math_fround(.149993896484375);
 } else {
  $12 = $11 << 2;
  $26 = HEAPF32[$12 + 33376 >> 2];
  $19 = HEAPF32[$12 + 33392 >> 2];
 }
 if (($1 | 0) < ($2 | 0)) {
  $27 = ($10 | 0) > 1 ? $10 : 1;
  $28 = Math_imul($10, 3);
  $29 = $5 + 32 | 0;
  $5 = HEAP32[$0 + 8 >> 2];
  $11 = $1;
  while (1) {
   $30 = ($14 | 0) != 0 & ($11 | 0) > 1;
   $31 = Math_imul($11 - $2 | 0, $28);
   $12 = (($11 | 0) < 20 ? $11 : 20) << 1;
   $32 = $12 + $7 | 0;
   $33 = ($12 | 1) + $7 | 0;
   $10 = 0;
   while (1) {
    $12 = Math_imul($5, $10) + $11 << 2;
    $16 = HEAPF32[$12 + $3 >> 2];
    $17 = HEAPF32[$4 + $12 >> 2];
    $20 = Math_fround(Math_fround(Math_max($17, Math_fround(-28))) - $13);
    $5 = $16 < $20 ^ 1;
    $21 = Math_fround($26 * Math_fround(Math_max($17, Math_fround(-9))));
    $22 = ($15 + 8 | 0) + ($10 << 2) | 0;
    $17 = HEAPF32[$22 >> 2];
    $23 = Math_fround(Math_fround($16 - $21) - $17);
    $24 = Math_fround(Math_floor(Math_fround($23 + Math_fround(.5))));
    label$7 : {
     if (Math_fround(Math_abs($24)) < Math_fround(2147483648)) {
      $12 = ~~$24;
      break label$7;
     }
     $12 = -2147483648;
    }
    if (!($5 | ($12 | 0) > -1)) {
     $16 = Math_fround($20 - $16);
     label$10 : {
      if (Math_fround(Math_abs($16)) < Math_fround(2147483648)) {
       $5 = ~~$16;
       break label$10;
      }
      $5 = -2147483648;
     }
     $12 = $12 + $5 | 0;
     $12 = $12 & $12 >> 31;
    }
    HEAP32[$15 + 4 >> 2] = $12;
    $6 = ($29 - HEAP32[$9 + 20 >> 2] | 0) - Math_clz32(HEAP32[$9 + 28 >> 2]) | 0;
    $5 = $12;
    label$12 : {
     if (($1 | 0) == ($11 | 0)) {
      break label$12;
     }
     $18 = $6 + $31 | 0;
     if (($18 | 0) > 23) {
      break label$12;
     }
     $5 = ($12 | 0) < 1 ? $12 : 1;
     HEAP32[$15 + 4 >> 2] = $5;
     if (($18 | 0) > 15) {
      break label$12;
     }
     $5 = ($5 | 0) > -1 ? $5 : -1;
     HEAP32[$15 + 4 >> 2] = $5;
    }
    if ($30) {
     $5 = $5 >> 31 & $5;
     HEAP32[$15 + 4 >> 2] = $5;
    }
    label$14 : {
     if (($6 | 0) >= 15) {
      ec_laplace_encode($9, $15 + 4 | 0, HEAPU8[$32 | 0] << 7, HEAPU8[$33 | 0] << 6);
      break label$14;
     }
     if (($6 | 0) >= 2) {
      $5 = ($5 | 0) < 1 ? $5 : 1;
      $5 = ($5 | 0) > -1 ? $5 : -1;
      HEAP32[$15 + 4 >> 2] = $5;
      ec_enc_icdf($9, $5 << 1 ^ $5 >> 31, 33408, 2);
      break label$14;
     }
     if (($6 | 0) == 1) {
      $5 = $5 >> 31 & $5;
      HEAP32[$15 + 4 >> 2] = $5;
      ec_enc_bit_logp($9, 0 - $5 | 0, 1);
      break label$14;
     }
     HEAP32[$15 + 4 >> 2] = -1;
    }
    $5 = HEAP32[$0 + 8 >> 2];
    $6 = Math_imul($10, $5) + $11 << 2;
    $18 = HEAP32[$15 + 4 >> 2];
    $16 = Math_fround($18 | 0);
    HEAPF32[$8 + $6 >> 2] = $23 - $16;
    HEAPF32[$4 + $6 >> 2] = Math_fround($17 + $21) + $16;
    HEAPF32[$22 >> 2] = Math_fround($17 + $16) - Math_fround($19 * $16);
    $12 = $12 - $18 | 0;
    $6 = $12;
    $12 = $12 >> 31;
    $25 = ($12 ^ $12 + $6) + $25 | 0;
    $10 = $10 + 1 | 0;
    if (($27 | 0) != ($10 | 0)) {
     continue;
    }
    break;
   }
   $11 = $11 + 1 | 0;
   if (($11 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $15 + 16 | 0;
 return $14 ? 0 : $25;
}
function compute_dense($0, $1, $2) {
 var $3 = Math_fround(0), $4 = Math_fround(0), $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $7 = HEAP32[$0 + 12 >> 2];
 label$1 : {
  if (($7 | 0) < 1) {
   break label$1;
  }
  $9 = HEAP32[$0 + 8 >> 2];
  $6 = HEAP32[$0 >> 2];
  while (1) {
   HEAPF32[($5 << 2) + $1 >> 2] = HEAP8[$5 + $6 | 0];
   $5 = $5 + 1 | 0;
   if (($7 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
  if (($7 | 0) < 1) {
   break label$1;
  }
  $10 = HEAP32[$0 + 4 >> 2];
  $6 = 0;
  $11 = ($9 | 0) < 1;
  while (1) {
   if (!$11) {
    $8 = ($6 << 2) + $1 | 0;
    $3 = HEAPF32[$8 >> 2];
    $5 = 0;
    while (1) {
     $3 = Math_fround($3 + Math_fround(HEAPF32[($5 << 2) + $2 >> 2] * Math_fround(HEAP8[(Math_imul($5, $7) + $6 | 0) + $10 | 0])));
     HEAPF32[$8 >> 2] = $3;
     $5 = $5 + 1 | 0;
     if (($9 | 0) != ($5 | 0)) {
      continue;
     }
     break;
    }
   }
   $6 = $6 + 1 | 0;
   if (($7 | 0) != ($6 | 0)) {
    continue;
   }
   break;
  }
  if (($7 | 0) < 1) {
   break label$1;
  }
  $5 = 0;
  while (1) {
   $6 = ($5 << 2) + $1 | 0;
   HEAPF32[$6 >> 2] = HEAPF32[$6 >> 2] * Math_fround(.0078125);
   $5 = $5 + 1 | 0;
   if (($7 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
 }
 label$7 : {
  if (HEAP32[$0 + 16 >> 2]) {
   $5 = 0;
   if (($7 | 0) <= 0) {
    break label$7;
   }
   while (1) {
    $3 = Math_fround(1);
    $6 = ($5 << 2) + $1 | 0;
    $4 = Math_fround(HEAPF32[$6 >> 2] * Math_fround(.5));
    label$10 : {
     if ($4 < Math_fround(8) ^ 1) {
      break label$10;
     }
     $3 = Math_fround(0);
     if ($4 > Math_fround(-8) ^ 1) {
      break label$10;
     }
     $3 = Math_fround(.5);
     if ($4 != $4) {
      break label$10;
     }
     $9 = $4 < Math_fround(0);
     $4 = $9 ? Math_fround(-$4) : $4;
     $3 = Math_fround(Math_floor(Math_fround(Math_fround($4 * Math_fround(25)) + Math_fround(.5))));
     label$11 : {
      if (Math_fround(Math_abs($3)) < Math_fround(2147483648)) {
       $8 = ~~$3;
       break label$11;
      }
      $8 = -2147483648;
     }
     $3 = HEAPF32[($8 << 2) + 48128 >> 2];
     $4 = Math_fround($4 + Math_fround(Math_fround($8 | 0) * Math_fround(-.03999999910593033)));
     $3 = Math_fround($3 + Math_fround(Math_fround(Math_fround(1) - Math_fround($3 * $4)) * Math_fround($4 * Math_fround(Math_fround(1) - Math_fround($3 * $3)))));
     $3 = Math_fround(Math_fround(($9 ? Math_fround(-$3) : $3) * Math_fround(.5)) + Math_fround(.5));
    }
    HEAPF32[$6 >> 2] = $3;
    $5 = $5 + 1 | 0;
    if (($7 | 0) != ($5 | 0)) {
     continue;
    }
    break;
   }
   break label$7;
  }
  $5 = 0;
  if (($7 | 0) <= 0) {
   break label$7;
  }
  while (1) {
   $3 = Math_fround(1);
   $6 = ($5 << 2) + $1 | 0;
   $4 = HEAPF32[$6 >> 2];
   label$14 : {
    if ($4 < Math_fround(8) ^ 1) {
     break label$14;
    }
    $3 = Math_fround(-1);
    if ($4 > Math_fround(-8) ^ 1) {
     break label$14;
    }
    $3 = Math_fround(0);
    if ($4 != $4) {
     break label$14;
    }
    $9 = $4 < Math_fround(0);
    $4 = $9 ? Math_fround(-$4) : $4;
    $3 = Math_fround(Math_floor(Math_fround(Math_fround($4 * Math_fround(25)) + Math_fround(.5))));
    label$15 : {
     if (Math_fround(Math_abs($3)) < Math_fround(2147483648)) {
      $8 = ~~$3;
      break label$15;
     }
     $8 = -2147483648;
    }
    $3 = HEAPF32[($8 << 2) + 48128 >> 2];
    $4 = Math_fround($4 + Math_fround(Math_fround($8 | 0) * Math_fround(-.03999999910593033)));
    $3 = Math_fround($3 + Math_fround(Math_fround(Math_fround(1) - Math_fround($3 * $4)) * Math_fround($4 * Math_fround(Math_fround(1) - Math_fround($3 * $3)))));
    $3 = $9 ? Math_fround(-$3) : $3;
   }
   HEAPF32[$6 >> 2] = $3;
   $5 = $5 + 1 | 0;
   if (($7 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
 }
}
function silk_NLSF_stabilize($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $12 = ($2 << 1) + $1 | 0;
 $13 = $2 - 1 | 0;
 $11 = ($13 << 1) + $0 | 0;
 $16 = ($2 | 0) < 2;
 label$1 : {
  while (1) {
   $5 = HEAP16[$0 >> 1];
   $9 = HEAP16[$1 >> 1];
   $3 = $5 - $9 | 0;
   $4 = 1;
   $6 = 0;
   if (!$16) {
    while (1) {
     $7 = $5 << 16;
     $10 = $4 << 1;
     $5 = HEAP16[$10 + $0 >> 1];
     $7 = ($5 - ($7 >> 16) | 0) - HEAP16[$1 + $10 >> 1] | 0;
     $8 = $7;
     $7 = ($3 | 0) > ($7 | 0);
     $3 = $7 ? $8 : $3;
     $6 = $7 ? $4 : $6;
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   $5 = HEAP16[$12 >> 1];
   $4 = 32768 - ($5 + HEAP16[$11 >> 1] | 0) | 0;
   $8 = $4;
   $4 = ($3 | 0) > ($4 | 0);
   if ((($4 ? $8 : $3) | 0) > -1) {
    break label$1;
   }
   $3 = $4 ? $2 : $6;
   label$5 : {
    if (!$3) {
     HEAP16[$0 >> 1] = $9;
     break label$5;
    }
    label$7 : {
     label$8 : {
      if (($2 | 0) != ($3 | 0)) {
       if (($3 | 0) >= 1) {
        break label$8;
       }
       $9 = 0;
       break label$7;
      }
      HEAP16[$11 >> 1] = -32768 - $5;
      break label$5;
     }
     $4 = 1;
     if (($3 | 0) == 1) {
      break label$7;
     }
     while (1) {
      $9 = HEAP16[($4 << 1) + $1 >> 1] + $9 | 0;
      $4 = $4 + 1 | 0;
      if (($4 | 0) != ($3 | 0)) {
       continue;
      }
      break;
     }
    }
    $8 = $3 << 1;
    $14 = $8 + $1 | 0;
    $10 = HEAP16[$14 >> 1] >> 1;
    $7 = $10 + $9 | 0;
    $6 = 32768;
    label$11 : {
     if (($2 | 0) <= ($3 | 0)) {
      break label$11;
     }
     $6 = 32768 - $5 | 0;
     $4 = $13;
     if (($4 | 0) <= ($3 | 0)) {
      break label$11;
     }
     while (1) {
      $6 = $6 - HEAP16[($4 << 1) + $1 >> 1] | 0;
      $4 = $4 - 1 | 0;
      if (($4 | 0) > ($3 | 0)) {
       continue;
      }
      break;
     }
    }
    $4 = $0 + $8 | 0;
    $9 = $4 - 2 | 0;
    $3 = HEAP16[$4 >> 1] + HEAP16[$9 >> 1] | 0;
    $3 = ($3 >> 1) + ($3 & 1) | 0;
    $6 = $6 - $10 | 0;
    label$13 : {
     if (($7 | 0) > ($6 | 0)) {
      $5 = $7;
      $8 = $5;
      if (($3 | 0) > ($5 | 0)) {
       break label$13;
      }
      $8 = ($3 | 0) < ($6 | 0) ? $6 : $3;
      break label$13;
     }
     $5 = $6;
     $8 = $5;
     if (($3 | 0) > ($5 | 0)) {
      break label$13;
     }
     $8 = ($3 | 0) < ($7 | 0) ? $7 : $3;
    }
    $5 = $8;
    $3 = $5 - $10 | 0;
    HEAP16[$9 >> 1] = $3;
    HEAP16[$4 >> 1] = HEAPU16[$14 >> 1] + $3;
   }
   $15 = $15 + 1 | 0;
   if (($15 | 0) != 20) {
    continue;
   }
   break;
  }
  silk_insertion_sort_increasing_all_values_int16($0, $2);
  $4 = HEAP16[$0 >> 1];
  $3 = HEAP16[$1 >> 1];
  $3 = ($3 | 0) < ($4 | 0) ? $4 : $3;
  HEAP16[$0 >> 1] = $3;
  $7 = ($2 | 0) < 2;
  if (!$7) {
   $4 = 1;
   while (1) {
    $6 = $4 << 1;
    $5 = $6 + $0 | 0;
    $8 = $5;
    $5 = HEAP16[$5 >> 1];
    $3 = HEAP16[$1 + $6 >> 1] + ($3 << 16 >> 16) | 0;
    $3 = ($3 | 0) < 32767 ? $3 : 32767;
    $3 = ($3 | 0) > -32768 ? $3 : -32768;
    $3 = ($3 | 0) < ($5 | 0) ? $5 : $3;
    HEAP16[$8 >> 1] = $3;
    $4 = $4 + 1 | 0;
    if (($4 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  $4 = HEAP16[$11 >> 1];
  $3 = 32768 - HEAP16[$12 >> 1] | 0;
  $3 = ($3 | 0) > ($4 | 0) ? $4 : $3;
  HEAP16[$11 >> 1] = $3;
  if ($7) {
   break label$1;
  }
  $4 = $2 - 2 | 0;
  while (1) {
   $6 = $4 << 1;
   $5 = $6 + $0 | 0;
   $2 = $5;
   $5 = HEAP16[$5 >> 1];
   $3 = ($3 << 16 >> 16) - HEAP16[($1 + $6 | 0) + 2 >> 1] | 0;
   $3 = ($3 | 0) > ($5 | 0) ? $5 : $3;
   HEAP16[$2 >> 1] = $3;
   $6 = ($4 | 0) > 0;
   $4 = $4 - 1 | 0;
   if ($6) {
    continue;
   }
   break;
  }
 }
}
function clt_mdct_forward_c($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = Math_fround(0), $14 = Math_fround(0), $15 = 0, $16 = 0, $17 = Math_fround(0), $18 = 0, $19 = Math_fround(0), $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = Math_fround(0), $25 = 0;
 $7 = __stack_pointer;
 $22 = $7;
 $15 = HEAP32[$0 >> 2];
 $9 = $15 >> 1;
 $20 = HEAP32[(($5 << 2) + $0 | 0) + 8 >> 2];
 $17 = HEAPF32[$20 + 4 >> 2];
 $16 = HEAP32[$0 + 24 >> 2];
 if (($5 | 0) >= 1) {
  $0 = 0;
  while (1) {
   $15 = $9;
   $9 = $9 >> 1;
   $16 = ($15 << 2) + $16 | 0;
   $0 = $0 + 1 | 0;
   if (($5 | 0) != ($0 | 0)) {
    continue;
   }
   break;
  }
 }
 $0 = $4 << 1 & -4;
 $10 = $9 << 2;
 $5 = ($0 + ($10 + $1 | 0) | 0) - 4 | 0;
 $10 = $7 - ($10 + 15 & -16) | 0;
 $7 = $10;
 __stack_pointer = $7;
 $21 = $4 + 3 >> 2;
 $1 = $0 + $1 | 0;
 $11 = $15 >> 2;
 $12 = $7 - (($11 << 3) + 15 & -16) | 0;
 __stack_pointer = $12;
 label$3 : {
  if (($4 | 0) < 1) {
   $7 = 0;
   $0 = $10;
   break label$3;
  }
  $7 = ($21 | 0) > 1 ? $21 : 1;
  $8 = $0 + $3 | 0;
  $18 = $8 - 4 | 0;
  $25 = 0 - $9 << 2;
  $0 = $10;
  while (1) {
   $13 = HEAPF32[$18 >> 2];
   $14 = HEAPF32[$8 >> 2];
   HEAPF32[$0 >> 2] = Math_fround($13 * HEAPF32[($9 << 2) + $1 >> 2]) + Math_fround($14 * HEAPF32[$5 >> 2]);
   HEAPF32[$0 + 4 >> 2] = Math_fround($14 * HEAPF32[$1 >> 2]) - Math_fround($13 * HEAPF32[$5 + $25 >> 2]);
   $18 = $18 - 8 | 0;
   $8 = $8 + 8 | 0;
   $5 = $5 - 8 | 0;
   $1 = $1 + 8 | 0;
   $0 = $0 + 8 | 0;
   $23 = $23 + 1 | 0;
   if (($23 | 0) != ($7 | 0)) {
    continue;
   }
   break;
  }
 }
 $8 = $11 - $21 | 0;
 if (($8 | 0) > ($7 | 0)) {
  while (1) {
   HEAP32[$0 >> 2] = HEAP32[$5 >> 2];
   HEAP32[$0 + 4 >> 2] = HEAP32[$1 >> 2];
   $5 = $5 - 8 | 0;
   $1 = $1 + 8 | 0;
   $0 = $0 + 8 | 0;
   $7 = $7 + 1 | 0;
   if (($8 | 0) > ($7 | 0)) {
    continue;
   }
   break;
  }
  $7 = $8;
 }
 if (($7 | 0) < ($11 | 0)) {
  $8 = (($4 << 2) + $3 | 0) - 4 | 0;
  $18 = 0 - $9 << 2;
  while (1) {
   HEAPF32[$0 >> 2] = Math_fround(HEAPF32[$8 >> 2] * HEAPF32[$5 >> 2]) - Math_fround(HEAPF32[$3 >> 2] * HEAPF32[$1 + $18 >> 2]);
   HEAPF32[$0 + 4 >> 2] = Math_fround(HEAPF32[$8 >> 2] * HEAPF32[$1 >> 2]) + Math_fround(HEAPF32[$3 >> 2] * HEAPF32[($9 << 2) + $5 >> 2]);
   $8 = $8 - 8 | 0;
   $3 = $3 + 8 | 0;
   $5 = $5 - 8 | 0;
   $1 = $1 + 8 | 0;
   $0 = $0 + 8 | 0;
   $7 = $7 + 1 | 0;
   if (($11 | 0) != ($7 | 0)) {
    continue;
   }
   break;
  }
 }
 if (($15 | 0) <= 3) {
  opus_fft_impl($20, $12);
  __stack_pointer = $22;
  return;
 }
 $1 = ($11 | 0) > 1 ? $11 : 1;
 $0 = 0;
 while (1) {
  $5 = (HEAP16[HEAP32[$20 + 44 >> 2] + ($0 << 1) >> 1] << 3) + $12 | 0;
  $13 = HEAPF32[($0 + $11 << 2) + $16 >> 2];
  $14 = HEAPF32[$10 >> 2];
  $19 = HEAPF32[($0 << 2) + $16 >> 2];
  $24 = HEAPF32[$10 + 4 >> 2];
  HEAPF32[$5 + 4 >> 2] = $17 * Math_fround(Math_fround($13 * $14) + Math_fround($19 * $24));
  HEAPF32[$5 >> 2] = $17 * Math_fround(Math_fround($19 * $14) - Math_fround($13 * $24));
  $10 = $10 + 8 | 0;
  $0 = $0 + 1 | 0;
  if (($1 | 0) != ($0 | 0)) {
   continue;
  }
  break;
 }
 opus_fft_impl($20, $12);
 if (($15 | 0) >= 4) {
  $1 = ($11 | 0) > 1 ? $11 : 1;
  $0 = 0;
  $5 = (Math_imul($9 - 1 | 0, $6) << 2) + $2 | 0;
  $7 = $6 << 1;
  $9 = 0 - $7 << 2;
  while (1) {
   $13 = HEAPF32[$12 + 4 >> 2];
   $14 = HEAPF32[($0 + $11 << 2) + $16 >> 2];
   $17 = HEAPF32[$12 >> 2];
   $19 = HEAPF32[($0 << 2) + $16 >> 2];
   HEAPF32[$2 >> 2] = Math_fround($13 * $14) - Math_fround($17 * $19);
   HEAPF32[$5 >> 2] = Math_fround($14 * $17) + Math_fround($13 * $19);
   $12 = $12 + 8 | 0;
   $5 = $5 + $9 | 0;
   $2 = ($7 << 2) + $2 | 0;
   $0 = $0 + 1 | 0;
   if (($1 | 0) != ($0 | 0)) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $22;
}
function speex_resampler_process_float($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 $16 = HEAP32[$0 + 24 >> 2];
 $17 = $16 - 1 | 0;
 $13 = HEAP32[$0 + 72 >> 2];
 $18 = HEAP32[$0 + 28 >> 2];
 $19 = Math_imul($18, $1);
 $14 = $13 + ($19 << 2) | 0;
 $20 = HEAP32[$0 + 88 >> 2];
 $11 = HEAP32[$5 >> 2];
 $12 = HEAP32[$3 >> 2];
 $6 = $1 << 2;
 $7 = $6 + HEAP32[$0 + 68 >> 2] | 0;
 label$1 : {
  if (HEAP32[$7 >> 2]) {
   HEAP32[$8 + 12 >> 2] = $11;
   HEAP32[$8 + 8 >> 2] = HEAP32[$7 >> 2];
   HEAP32[$0 + 56 >> 2] = 1;
   $9 = FUNCTION_TABLE[HEAP32[$0 + 84 >> 2]]($0, $1, $14, $8 + 8 | 0, $4, $8 + 12 | 0) | 0;
   $7 = HEAP32[$8 + 8 >> 2];
   $6 = HEAP32[$0 + 60 >> 2] + $6 | 0;
   $10 = HEAP32[$6 >> 2];
   if (($7 | 0) > ($10 | 0)) {
    HEAP32[$8 + 8 >> 2] = $10;
    $7 = $10;
   }
   HEAP32[$8 + 12 >> 2] = $9;
   HEAP32[$6 >> 2] = HEAP32[$6 >> 2] - $7;
   $7 = HEAP32[$8 + 8 >> 2];
   if (($16 | 0) >= 2) {
    $6 = 0;
    while (1) {
     HEAP32[($6 << 2) + $14 >> 2] = HEAP32[($6 + $7 << 2) + $14 >> 2];
     $6 = $6 + 1 | 0;
     if (($17 | 0) != ($6 | 0)) {
      continue;
     }
     break;
    }
   }
   $15 = HEAP32[$0 + 68 >> 2] + ($1 << 2) | 0;
   $9 = HEAP32[$15 >> 2] - $7 | 0;
   HEAP32[$15 >> 2] = $9;
   if ($9) {
    $6 = 0;
    $10 = HEAP32[$8 + 8 >> 2];
    while (1) {
     $7 = $6 + $17 | 0;
     HEAP32[($7 << 2) + $14 >> 2] = HEAP32[($7 + $10 << 2) + $14 >> 2];
     $6 = $6 + 1 | 0;
     if (($9 | 0) != ($6 | 0)) {
      continue;
     }
     break;
    }
   }
   $6 = HEAP32[$8 + 12 >> 2];
   $11 = $11 - $6 | 0;
   if (HEAP32[$15 >> 2]) {
    break label$1;
   }
   $4 = (Math_imul(HEAP32[$0 + 92 >> 2], $6) << 2) + $4 | 0;
  }
  if (!$11 | !$12) {
   break label$1;
  }
  $15 = $18 - $17 | 0;
  $18 = (($16 + $19 << 2) + $13 | 0) - 4 | 0;
  while (1) {
   $7 = $12 >>> 0 > $15 >>> 0 ? $15 : $12;
   HEAP32[$8 + 12 >> 2] = $7;
   HEAP32[$8 + 8 >> 2] = $11;
   label$9 : {
    if ($2) {
     $6 = 0;
     if (!$7) {
      break label$9;
     }
     while (1) {
      HEAP32[($6 + $17 << 2) + $14 >> 2] = HEAP32[(Math_imul($6, $20) << 2) + $2 >> 2];
      $6 = $6 + 1 | 0;
      if (($7 | 0) != ($6 | 0)) {
       continue;
      }
      break;
     }
     break label$9;
    }
    if (!$7) {
     break label$9;
    }
    memset($18, 0, $7 << 2);
   }
   HEAP32[$0 + 56 >> 2] = 1;
   $10 = HEAP32[$0 + 24 >> 2];
   $7 = HEAP32[$0 + 72 >> 2] + (Math_imul(HEAP32[$0 + 28 >> 2], $1) << 2) | 0;
   $16 = FUNCTION_TABLE[HEAP32[$0 + 84 >> 2]]($0, $1, $7, $8 + 12 | 0, $4, $8 + 8 | 0) | 0;
   $9 = HEAP32[$8 + 12 >> 2];
   $6 = HEAP32[$0 + 60 >> 2] + ($1 << 2) | 0;
   $13 = HEAP32[$6 >> 2];
   if (($9 | 0) > ($13 | 0)) {
    HEAP32[$8 + 12 >> 2] = $13;
    $9 = $13;
   }
   HEAP32[$8 + 8 >> 2] = $16;
   HEAP32[$6 >> 2] = HEAP32[$6 >> 2] - $9;
   $9 = HEAP32[$8 + 12 >> 2];
   $6 = $9;
   if (($10 | 0) >= 2) {
    $10 = $10 - 1 | 0;
    $6 = 0;
    while (1) {
     HEAP32[($6 << 2) + $7 >> 2] = HEAP32[($6 + $9 << 2) + $7 >> 2];
     $6 = $6 + 1 | 0;
     if (($10 | 0) != ($6 | 0)) {
      continue;
     }
     break;
    }
    $6 = HEAP32[$8 + 12 >> 2];
   }
   $12 = $12 - $9 | 0;
   $7 = HEAP32[$8 + 8 >> 2];
   $11 = $11 - $7 | 0;
   if (!$11) {
    break label$1;
   }
   $2 = $2 ? (Math_imul($6, $20) << 2) + $2 | 0 : 0;
   $4 = (Math_imul(HEAP32[$0 + 92 >> 2], $7) << 2) + $4 | 0;
   if ($12) {
    continue;
   }
   break;
  }
 }
 HEAP32[$3 >> 2] = HEAP32[$3 >> 2] - $12;
 HEAP32[$5 >> 2] = HEAP32[$5 >> 2] - $11;
 __stack_pointer = $8 + 16 | 0;
 $6 = HEAP32[$0 + 84 >> 2];
 return ($6 | 0) == 9;
}
function check_control_input($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     label$5 : {
      label$6 : {
       label$7 : {
        label$8 : {
         label$9 : {
          label$10 : {
           if ($0) {
            $1 = HEAP32[$0 + 8 >> 2];
            label$12 : {
             if (($1 | 0) <= 23999) {
              if (($1 | 0) == 8e3 | ($1 | 0) == 12e3) {
               break label$12;
              }
              if (($1 | 0) != 16e3) {
               break label$1;
              }
              break label$12;
             }
             if (($1 | 0) <= 44099) {
              if (($1 | 0) == 24e3 | ($1 | 0) == 32e3) {
               break label$12;
              }
              break label$1;
             }
             if (($1 | 0) == 48e3) {
              break label$12;
             }
             if (($1 | 0) != 44100) {
              break label$1;
             }
            }
            $1 = HEAP32[$0 + 20 >> 2];
            if (($1 | 0) != 12e3 ? !(($1 | 0) == 8e3 | ($1 | 0) == 16e3) : 0) {
             break label$1;
            }
            $2 = HEAP32[$0 + 12 >> 2];
            if (($2 | 0) != 12e3 ? !(($2 | 0) == 8e3 | ($2 | 0) == 16e3) : 0) {
             break label$1;
            }
            $3 = HEAP32[$0 + 16 >> 2];
            if ((($3 | 0) != 12e3 ? !(($3 | 0) == 8e3 | ($3 | 0) == 16e3) : 0) | (($1 | 0) < ($3 | 0) | ($1 | 0) > ($2 | 0))) {
             break label$1;
            }
            if (($2 | 0) < ($3 | 0)) {
             break label$1;
            }
            label$18 : {
             label$19 : {
              $1 = HEAP32[$0 + 24 >> 2];
              switch ($1 - 10 | 0) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
               break label$10;
              case 0:
              case 10:
               break label$18;
              default:
               break label$19;
              }
             }
             if (($1 | 0) == 40) {
              break label$18;
             }
             if (($1 | 0) != 60) {
              break label$10;
             }
            }
            if (HEAPU32[$0 + 32 >> 2] >= 101) {
             break label$9;
            }
            if (HEAPU32[$0 + 48 >> 2] >= 2) {
             break label$8;
            }
            if (HEAPU32[$0 + 52 >> 2] >= 2) {
             break label$7;
            }
            if (HEAPU32[$0 + 40 >> 2] >= 2) {
             break label$6;
            }
            $1 = HEAP32[$0 >> 2];
            if ($1 - 1 >>> 0 >= 2) {
             break label$5;
            }
            $2 = HEAP32[$0 + 4 >> 2];
            if ($2 - 1 >>> 0 >= 2) {
             break label$4;
            }
            if (($1 | 0) < ($2 | 0)) {
             break label$3;
            }
            if (HEAPU32[$0 + 36 >> 2] >= 11) {
             break label$2;
            }
            return 0;
           }
           celt_fatal(1952, 1989, 41);
           abort();
          }
          celt_fatal(2016, 1989, 69);
          abort();
         }
         celt_fatal(2016, 1989, 73);
         abort();
        }
        celt_fatal(2016, 1989, 77);
        abort();
       }
       celt_fatal(2016, 1989, 81);
       abort();
      }
      celt_fatal(2016, 1989, 85);
      abort();
     }
     celt_fatal(2016, 1989, 89);
     abort();
    }
    celt_fatal(2016, 1989, 93);
    abort();
   }
   celt_fatal(2016, 1989, 97);
   abort();
  }
  celt_fatal(2016, 1989, 101);
  abort();
 }
 celt_fatal(2016, 1989, 62);
 abort();
}
function silk_NLSF_encode($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0;
 $7 = __stack_pointer - 128 | 0;
 $10 = $7;
 __stack_pointer = $7;
 if ($6 >>> 0 < 3) {
  silk_NLSF_stabilize($1, HEAP32[$2 + 36 >> 2], HEAP16[$2 + 2 >> 1]);
  $7 = $7 - ((HEAPU16[$2 >> 1] << 2) + 15 & 524272) | 0;
  __stack_pointer = $7;
  silk_NLSF_VQ($7, $1, HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2], HEAP16[$2 >> 1], HEAP16[$2 + 2 >> 1]);
  $9 = ($5 << 2) + 15 & -16;
  $18 = $7 - $9 | 0;
  $8 = $18;
  __stack_pointer = $8;
  silk_insertion_sort_increasing($7, $8, HEAP16[$2 >> 1], $5);
  $15 = $8 - $9 | 0;
  $7 = $15;
  __stack_pointer = $7;
  $19 = $7 - ($5 << 4) | 0;
  __stack_pointer = $19;
  if (($5 | 0) >= 1) {
   $23 = $6 >>> 1 | 0;
   $24 = $4 << 14 >> 16;
   while (1) {
    $22 = $16 << 2;
    $17 = HEAP32[$22 + $18 >> 2];
    $20 = HEAP16[$2 + 2 >> 1];
    if (($20 | 0) >= 1) {
     $7 = Math_imul($17, $20);
     $25 = $7 + HEAP32[$2 + 8 >> 2] | 0;
     $26 = HEAP32[$2 + 12 >> 2] + ($7 << 1) | 0;
     $6 = 0;
     while (1) {
      $7 = $6 << 1;
      $8 = HEAP16[$26 + $7 >> 1];
      HEAP16[($10 + 80 | 0) + $7 >> 1] = Math_imul(HEAPU16[$1 + $7 >> 1] - (HEAPU8[$6 + $25 | 0] << 7) << 16 >> 16, $8) >>> 14;
      $9 = HEAP16[$3 + $7 >> 1];
      $11 = $9 >> 31;
      $11 = Math_clz32($11 ^ $9 + $11);
      $9 = $9 << $11 - 1;
      $27 = $9;
      $8 = Math_imul($8, $8);
      $14 = Math_clz32($8);
      $13 = $8 << $14 - 1;
      $8 = 536870911 / ($13 >> 16) << 16 >> 16;
      $9 = (Math_imul($8, $9 & 65535) >> 16) + Math_imul($9 >> 16, $8) | 0;
      $12 = $9 >> 31;
      $21 = $12;
      $12 = $13 >> 31;
      $28 = $12;
      $12 = $21;
      $21 = __wasm_i64_mul($9, $12, $13, $28);
      $12 = i64toi32_i32$HIGH_BITS;
      $13 = $27 - ((($12 & 536870911) << 3 | $21 >>> 29) & -8) | 0;
      $8 = (Math_imul($13 >> 16, $8) + $9 | 0) + (Math_imul($13 & 65535, $8) >> 16) | 0;
      $9 = $11 - $14 | 0;
      $11 = $9 + 8 | 0;
      $7 = ($10 + 48 | 0) + $7 | 0;
      $9 = $9 + 29 | 0;
      label$6 : {
       if (($9 | 0) <= 20) {
        $9 = 0 - $11 | 0;
        $11 = 2147483647 >>> $9 | 0;
        $14 = -2147483648 >> $9;
        $8 = (($8 | 0) > ($11 | 0) ? $11 : ($8 | 0) < ($14 | 0) ? $14 : $8) << $9;
        break label$6;
       }
       $8 = ($9 | 0) < 53 ? $8 >> $11 : 0;
      }
      HEAP16[$7 >> 1] = $8;
      $6 = $6 + 1 | 0;
      if (($20 | 0) != ($6 | 0)) {
       continue;
      }
      break;
     }
    }
    silk_NLSF_unpack($10, $10 + 32 | 0, $2, $17);
    $6 = $15 + $22 | 0;
    HEAP32[$6 >> 2] = silk_NLSF_del_dec_quant(($16 << 4) + $19 | 0, $10 + 80 | 0, $10 + 48 | 0, $10 + 32 | 0, $10, HEAP32[$2 + 32 >> 2], HEAP16[$2 + 4 >> 1], HEAP16[$2 + 6 >> 1], $4, HEAP16[$2 + 2 >> 1]);
    $7 = HEAP32[$2 + 16 >> 2] + Math_imul(HEAP16[$2 >> 1], $23) | 0;
    $12 = $6;
    if ($17) {
     $7 = $7 + $17 | 0;
     $8 = HEAPU8[$7 - 1 | 0];
    } else {
     $8 = 256;
    }
    HEAP32[$12 >> 2] = Math_imul(67108864 - (silk_lin2log($8 - HEAPU8[$7 | 0] | 0) << 16) >> 16, $24) + HEAP32[$6 >> 2];
    $16 = $16 + 1 | 0;
    if (($16 | 0) != ($5 | 0)) {
     continue;
    }
    break;
   }
  }
  silk_insertion_sort_increasing($15, $10 + 124 | 0, $5, 1);
  $7 = HEAP32[$10 + 124 >> 2];
  HEAP8[$0 | 0] = HEAP32[($7 << 2) + $18 >> 2];
  memcpy($0 + 1 | 0, ($7 << 4) + $19 | 0, HEAP16[$2 + 2 >> 1]);
  silk_NLSF_decode($1, $0, $2);
  __stack_pointer = $10 + 128 | 0;
  $7 = HEAP32[$15 >> 2];
  return $7;
 }
 celt_fatal(15776, 15829, 63);
 abort();
}
function _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     label$5 : {
      label$6 : {
       label$7 : {
        label$8 : {
         label$9 : {
          label$11 : {
           $5 = $1;
           if ($5) {
            $7 = $2;
            if (!$7) {
             break label$11;
            }
            $4 = $3;
            if (!$4) {
             break label$9;
            }
            $5 = Math_clz32($4) - Math_clz32($5) | 0;
            if ($5 >>> 0 <= 31) {
             break label$8;
            }
            break label$2;
           }
           $4 = $3;
           if (($4 | 0) == 1 | $4 >>> 0 > 1) {
            break label$2;
           }
           $5 = $0;
           $7 = $2;
           $5 = ($5 >>> 0) / ($7 >>> 0) | 0;
           i64toi32_i32$HIGH_BITS = 0;
           return $5;
          }
          $7 = $3;
          if (!$0) {
           break label$7;
          }
          if (!$7) {
           break label$6;
          }
          $4 = $7 - 1 | 0;
          if ($4 & $7) {
           break label$6;
          }
          $9 = $5 >>> __wasm_ctz_i32($7) | 0;
          i64toi32_i32$HIGH_BITS = 0;
          return $9;
         }
         if (!($7 - 1 & $7)) {
          break label$5;
         }
         $5 = (Math_clz32($7) + 33 | 0) - Math_clz32($5) | 0;
         $7 = 0 - $5 | 0;
         break label$3;
        }
        $7 = 63 - $5 | 0;
        $5 = $5 + 1 | 0;
        break label$3;
       }
       $4 = ($5 >>> 0) / ($7 >>> 0) | 0;
       i64toi32_i32$HIGH_BITS = 0;
       return $4;
      }
      $5 = Math_clz32($7) - Math_clz32($5) | 0;
      if ($5 >>> 0 < 31) {
       break label$4;
      }
      break label$2;
     }
     if (($7 | 0) == 1) {
      break label$1;
     }
     $4 = $1;
     $9 = $0;
     $10 = 0;
     $8 = __wasm_ctz_i32($7);
     $6 = $8 & 31;
     if (($8 & 63) >>> 0 >= 32) {
      $9 = $4 >>> $6 | 0;
     } else {
      $10 = $4 >>> $6 | 0;
      $9 = ((1 << $6) - 1 & $4) << 32 - $6 | $9 >>> $6;
     }
     i64toi32_i32$HIGH_BITS = $10;
     return $9;
    }
    $7 = 63 - $5 | 0;
    $5 = $5 + 1 | 0;
   }
   $9 = $1;
   $4 = $0;
   $10 = 0;
   $8 = $5 & 63;
   $6 = $8 & 31;
   if (($8 & 63) >>> 0 >= 32) {
    $12 = $9 >>> $6 | 0;
   } else {
    $10 = $9 >>> $6 | 0;
    $12 = ((1 << $6) - 1 & $9) << 32 - $6 | $4 >>> $6;
   }
   $13 = $10;
   $10 = $1;
   $9 = $0;
   $8 = $7 & 63;
   $6 = $8 & 31;
   if (($8 & 63) >>> 0 >= 32) {
    $4 = $9 << $6;
    $0 = 0;
   } else {
    $4 = (1 << $6) - 1 & $9 >>> 32 - $6 | $10 << $6;
    $0 = $9 << $6;
   }
   $1 = $4;
   if ($5) {
    $4 = $3 - 1 | 0;
    $6 = $2 - 1 | 0;
    $4 = ($6 | 0) != -1 ? $4 + 1 | 0 : $4;
    $7 = $6;
    $9 = $4;
    while (1) {
     $4 = $12;
     $8 = $4 << 1;
     $4 = $13 << 1 | $4 >>> 31;
     $12 = $8 | $1 >>> 31;
     $11 = $12;
     $10 = $4;
     $4 = $7;
     $8 = $11;
     $6 = $9 - (($4 >>> 0 < $8 >>> 0) + $10 | 0) | 0;
     $13 = $3 & $6 >> 31;
     $4 = $8;
     $11 = $6 >> 31;
     $8 = $11 & $2;
     $12 = $4 - $8 | 0;
     $13 = $10 - (($4 >>> 0 < $8 >>> 0) + $13 | 0) | 0;
     $4 = $1 << 1 | $0 >>> 31;
     $0 = $0 << 1 | $14;
     $1 = $4 | $16;
     $15 = 0;
     $11 = $11 & 1;
     $14 = $11;
     $5 = $5 - 1 | 0;
     if ($5) {
      continue;
     }
     break;
    }
   }
   i64toi32_i32$HIGH_BITS = $15 | ($1 << 1 | $0 >>> 31);
   return $0 << 1 | $11;
  }
  $0 = 0;
  $1 = 0;
 }
 i64toi32_i32$HIGH_BITS = $1;
 return $0;
}
function silk_NSQ_wrapper_FLP($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $7 = __stack_pointer - 1008 | 0;
 __stack_pointer = $7;
 label$1 : {
  label$2 : {
   $10 = HEAP32[$0 + 4580 >> 2];
   if (($10 | 0) < 1) {
    break label$2;
   }
   $11 = HEAP32[$0 + 4636 >> 2];
   $13 = ($11 | 0) < 1;
   while (1) {
    if (!$13) {
     $9 = Math_imul($12, 24);
     $6 = 0;
     while (1) {
      $8 = $6 + $9 | 0;
      HEAP16[($7 + 48 | 0) + ($8 << 1) >> 1] = lrintf(Math_fround(HEAPF32[(($8 << 2) + $1 | 0) + 244 >> 2] * Math_fround(8192)));
      $6 = $6 + 1 | 0;
      if (($11 | 0) != ($6 | 0)) {
       continue;
      }
      break;
     }
    }
    $12 = $12 + 1 | 0;
    if (($12 | 0) != ($10 | 0)) {
     continue;
    }
    break;
   }
   $9 = 0;
   if (($10 | 0) <= 0) {
    break label$2;
   }
   while (1) {
    $6 = $9 << 2;
    $8 = $6 + $1 | 0;
    $11 = lrintf(Math_fround(HEAPF32[$8 + 644 >> 2] * Math_fround(16384)));
    HEAP32[($7 + 32 | 0) + $6 >> 2] = lrintf(Math_fround(HEAPF32[$8 + 628 >> 2] * Math_fround(16384))) & 65535 | $11 << 16;
    HEAP32[($7 + 16 | 0) + $6 >> 2] = lrintf(Math_fround(HEAPF32[$8 + 660 >> 2] * Math_fround(16384)));
    HEAP32[$6 + $7 >> 2] = lrintf(Math_fround(HEAPF32[$8 + 676 >> 2] * Math_fround(16384)));
    $9 = $9 + 1 | 0;
    if (($10 | 0) != ($9 | 0)) {
     continue;
    }
    break;
   }
   $11 = lrintf(Math_fround(HEAPF32[$1 + 692 >> 2] * Math_fround(1024)));
   if (($10 | 0) < 1) {
    break label$1;
   }
   $6 = Math_imul($10, 5);
   $8 = ($6 | 0) > 1 ? $6 : 1;
   $6 = 0;
   while (1) {
    HEAP16[($7 + 240 | 0) + ($6 << 1) >> 1] = lrintf(Math_fround(HEAPF32[(($6 << 2) + $1 | 0) + 144 >> 2] * Math_fround(16384)));
    $6 = $6 + 1 | 0;
    if (($8 | 0) != ($6 | 0)) {
     continue;
    }
    break;
   }
   break label$1;
  }
  $11 = lrintf(Math_fround(HEAPF32[$1 + 692 >> 2] * Math_fround(1024)));
 }
 $6 = 0;
 $8 = HEAP32[$0 + 4640 >> 2];
 label$8 : {
  if (($8 | 0) <= 0) {
   break label$8;
  }
  while (1) {
   HEAP16[($7 + 288 | 0) + ($6 << 1) >> 1] = lrintf(Math_fround(HEAPF32[(($6 << 2) + $1 | 0) + 16 >> 2] * Math_fround(4096)));
   $6 = $6 + 1 | 0;
   if (($8 | 0) != ($6 | 0)) {
    continue;
   }
   break;
  }
  $6 = 0;
  if (($8 | 0) <= 0) {
   break label$8;
  }
  while (1) {
   HEAP16[(($6 << 1) + $7 | 0) + 320 >> 1] = lrintf(Math_fround(HEAPF32[(($6 << 2) + $1 | 0) + 80 >> 2] * Math_fround(4096)));
   $6 = $6 + 1 | 0;
   if (($8 | 0) != ($6 | 0)) {
    continue;
   }
   break;
  }
 }
 $6 = 0;
 if (($10 | 0) > 0) {
  while (1) {
   $8 = $6 << 2;
   HEAP32[$8 + ($7 + 352 | 0) >> 2] = lrintf(Math_fround(HEAPF32[$1 + $8 >> 2] * Math_fround(65536)));
   $6 = $6 + 1 | 0;
   if (($10 | 0) != ($6 | 0)) {
    continue;
   }
   break;
  }
 }
 $6 = 0;
 $9 = 0;
 $9 = HEAPU8[$2 + 29 | 0] == 2 ? HEAP16[(HEAP8[$2 + 33 | 0] << 1) + 5848 >> 1] : $9;
 $8 = HEAP32[$0 + 4584 >> 2];
 if (($8 | 0) >= 1) {
  while (1) {
   HEAP16[($7 + 368 | 0) + ($6 << 1) >> 1] = lrintf(HEAPF32[($6 << 2) + $5 >> 2]);
   $6 = $6 + 1 | 0;
   if (($8 | 0) != ($6 | 0)) {
    continue;
   }
   break;
  }
 }
 label$16 : {
  if (!(HEAP32[$0 + 4672 >> 2] < 1 ? HEAP32[$0 + 4628 >> 2] <= 1 : 0)) {
   silk_NSQ_del_dec_c($0, $3, $2, $7 + 368 | 0, $4, $7 + 288 | 0, $7 + 240 | 0, $7 + 48 | 0, $7, $7 + 16 | 0, $7 + 32 | 0, $7 + 352 | 0, $1 + 228 | 0, $11, $9);
   break label$16;
  }
  silk_NSQ_c($0, $3, $2, $7 + 368 | 0, $4, $7 + 288 | 0, $7 + 240 | 0, $7 + 48 | 0, $7, $7 + 16 | 0, $7 + 32 | 0, $7 + 352 | 0, $1 + 228 | 0, $11, $9);
 }
 __stack_pointer = $7 + 1008 | 0;
}
function ec_dec_uint($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 if ($1 >>> 0 > 1) {
  $10 = $1 - 1 | 0;
  label$2 : {
   if ($10 >>> 0 >= 256) {
    $4 = HEAP32[$0 + 28 >> 2];
    $7 = 24 - Math_clz32($10) | 0;
    $2 = $10 >>> $7 | 0;
    $3 = $2 + 1 | 0;
    $1 = ($4 >>> 0) / ($3 >>> 0) | 0;
    HEAP32[$0 + 36 >> 2] = $1;
    $5 = HEAP32[$0 + 32 >> 2];
    $8 = $5;
    $5 = ($5 >>> 0) / ($1 >>> 0) | 0;
    $6 = $5 + 1 | 0;
    $3 = $6 - $3 | 0;
    $11 = ($3 >>> 0 > $6 >>> 0 ? 0 : $3) + ($2 - $5 | 0) | 0;
    $2 = Math_imul($2 - $11 | 0, $1);
    $3 = $8 - $2 | 0;
    HEAP32[$0 + 32 >> 2] = $3;
    $2 = $11 ? $1 : $4 - $2 | 0;
    HEAP32[$0 + 28 >> 2] = $2;
    if ($2 >>> 0 <= 8388608) {
     $4 = HEAP32[$0 + 24 >> 2];
     $5 = HEAP32[$0 + 40 >> 2];
     $6 = HEAP32[$0 + 20 >> 2];
     $12 = HEAP32[$0 + 4 >> 2];
     while (1) {
      $8 = $2 << 8;
      HEAP32[$0 + 28 >> 2] = $8;
      $6 = $6 + 8 | 0;
      HEAP32[$0 + 20 >> 2] = $6;
      $1 = 0;
      if ($4 >>> 0 < $12 >>> 0) {
       $9 = $4 + 1 | 0;
       HEAP32[$0 + 24 >> 2] = $9;
       $1 = HEAPU8[HEAP32[$0 >> 2] + $4 | 0];
       $4 = $9;
      }
      HEAP32[$0 + 40 >> 2] = $1;
      $3 = (($5 << 8 | $1) >>> 1 & 255 | $3 << 8 & 2147483392) ^ 255;
      HEAP32[$0 + 32 >> 2] = $3;
      $9 = $2 >>> 0 < 32769;
      $5 = $1;
      $2 = $8;
      if ($9) {
       continue;
      }
      break;
     }
    }
    $8 = $11 << $7;
    $3 = HEAP32[$0 + 12 >> 2];
    $1 = HEAP32[$0 + 16 >> 2];
    label$7 : {
     if ($7 >>> 0 <= $1 >>> 0) {
      $6 = $1;
      break label$7;
     }
     $2 = HEAP32[$0 + 8 >> 2];
     $5 = HEAP32[$0 + 4 >> 2];
     while (1) {
      $4 = 0;
      if ($2 >>> 0 < $5 >>> 0) {
       $2 = $2 + 1 | 0;
       HEAP32[$0 + 8 >> 2] = $2;
       $4 = HEAPU8[HEAP32[$0 >> 2] + ($5 - $2 | 0) | 0];
      }
      $3 = $4 << $1 | $3;
      $4 = ($1 | 0) < 17;
      $6 = $1 + 8 | 0;
      $1 = $6;
      if ($4) {
       continue;
      }
      break;
     }
    }
    HEAP32[$0 + 16 >> 2] = $6 - $7;
    HEAP32[$0 + 12 >> 2] = $3 >>> $7;
    HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + $7;
    $7 = (-1 << $7 ^ -1) & $3 | $8;
    if ($10 >>> 0 >= $7 >>> 0) {
     break label$2;
    }
    HEAP32[$0 + 44 >> 2] = 1;
    return $10;
   }
   $4 = HEAP32[$0 + 28 >> 2];
   $2 = ($4 >>> 0) / ($1 >>> 0) | 0;
   HEAP32[$0 + 36 >> 2] = $2;
   $3 = HEAP32[$0 + 32 >> 2];
   $8 = $3;
   $3 = ($3 >>> 0) / ($2 >>> 0) | 0;
   $9 = ($3 ^ -1) + $1 | 0;
   $3 = $3 + 1 | 0;
   $5 = $3 - $1 | 0;
   $7 = $9 + ($3 >>> 0 < $5 >>> 0 ? 0 : $5) | 0;
   $1 = Math_imul(($7 ^ -1) + $1 | 0, $2);
   $3 = $8 - $1 | 0;
   HEAP32[$0 + 32 >> 2] = $3;
   $2 = $7 ? $2 : $4 - $1 | 0;
   HEAP32[$0 + 28 >> 2] = $2;
   if ($2 >>> 0 > 8388608) {
    break label$2;
   }
   $4 = HEAP32[$0 + 24 >> 2];
   $5 = HEAP32[$0 + 40 >> 2];
   $6 = HEAP32[$0 + 20 >> 2];
   $12 = HEAP32[$0 + 4 >> 2];
   while (1) {
    $8 = $2 << 8;
    HEAP32[$0 + 28 >> 2] = $8;
    $6 = $6 + 8 | 0;
    HEAP32[$0 + 20 >> 2] = $6;
    $1 = 0;
    if ($4 >>> 0 < $12 >>> 0) {
     $9 = $4 + 1 | 0;
     HEAP32[$0 + 24 >> 2] = $9;
     $1 = HEAPU8[HEAP32[$0 >> 2] + $4 | 0];
     $4 = $9;
    }
    HEAP32[$0 + 40 >> 2] = $1;
    $3 = (($5 << 8 | $1) >>> 1 & 255 | $3 << 8 & 2147483392) ^ 255;
    HEAP32[$0 + 32 >> 2] = $3;
    $9 = $2 >>> 0 < 32769;
    $5 = $1;
    $2 = $8;
    if ($9) {
     continue;
    }
    break;
   }
  }
  return $7;
 }
 celt_fatal(9274, 9298, 203);
 abort();
}
function downmix_and_resample($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 var $10 = Math_fround(0), $11 = 0, $12 = Math_fround(0), $13 = Math_fround(0), $14 = Math_fround(0), $15 = Math_fround(0), $16 = 0, $17 = Math_fround(0), $18 = Math_fround(0), $19 = Math_fround(0), $20 = 0;
 $11 = __stack_pointer;
 $16 = $11;
 if (!$4) {
  __stack_pointer = $16;
  return Math_fround(0);
 }
 label$2 : {
  if (($9 | 0) == 48e3) {
   $5 = $5 << 1;
   $4 = $4 << 1;
   break label$2;
  }
  if (($9 | 0) != 16e3) {
   break label$2;
  }
  $5 = ($5 << 1) / 3 | 0;
  $4 = ($4 << 1) / 3 | 0;
 }
 $11 = $11 - (($4 << 2) + 15 & -16) | 0;
 $20 = $11;
 __stack_pointer = $11;
 FUNCTION_TABLE[$0 | 0]($1, $11, $4, $5, $6, $7, $8);
 $10 = ($7 | 0) == -2 ? Math_fround(Math_fround(30517578125e-15) / Math_fround($8 | 0)) : ($7 | 0) > -1 ? Math_fround(152587890625e-16) : Math_fround(30517578125e-15);
 if (($4 | 0) >= 1) {
  $7 = 0;
  while (1) {
   $5 = ($7 << 2) + $11 | 0;
   HEAPF32[$5 >> 2] = $10 * HEAPF32[$5 >> 2];
   $7 = $7 + 1 | 0;
   if (($7 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
 }
 label$8 : {
  if (($9 | 0) == 48e3) {
   $9 = ($4 | 0) / 2 | 0;
   if (($4 | 0) < 2) {
    break label$8;
   }
   $7 = 0;
   while (1) {
    $5 = $7 << 3;
    $10 = HEAPF32[$11 + $5 >> 2];
    $12 = HEAPF32[$3 >> 2];
    $13 = Math_fround(Math_fround($10 - $12) * Math_fround(.6074370741844177));
    HEAPF32[$3 >> 2] = $10 + $13;
    $10 = HEAPF32[($5 | 4) + $11 >> 2];
    $14 = HEAPF32[$3 + 4 >> 2];
    $15 = Math_fround(Math_fround($10 - $14) * Math_fround(.15062999725341797));
    HEAPF32[$3 + 4 >> 2] = $10 + $15;
    $17 = HEAPF32[$3 + 8 >> 2];
    $18 = Math_fround(Math_fround(Math_fround(-$10) - $17) * Math_fround(.15062999725341797));
    HEAPF32[$3 + 8 >> 2] = $18 - $10;
    $10 = Math_fround($12 + $13);
    HEAPF32[($7 << 2) + $2 >> 2] = Math_fround(Math_fround($14 + $10) + $15) * Math_fround(.5);
    $10 = Math_fround(Math_fround($10 + $17) + $18);
    $19 = Math_fround($19 + Math_fround($10 * $10));
    $7 = $7 + 1 | 0;
    if (($9 | 0) != ($7 | 0)) {
     continue;
    }
    break;
   }
   break label$8;
  }
  if (($9 | 0) != 16e3) {
   if (($9 | 0) != 24e3) {
    break label$8;
   }
   memcpy($2, $11, $4 << 2);
   break label$8;
  }
  $1 = $20;
  $0 = Math_imul($4, 3);
  $8 = $1 - (($0 << 2) + 15 & -16) | 0;
  __stack_pointer = $8;
  if (($4 | 0) >= 1) {
   $7 = 0;
   while (1) {
    $5 = Math_imul($7, 12) + $8 | 0;
    $9 = HEAP32[($7 << 2) + $11 >> 2];
    HEAP32[$5 + 8 >> 2] = $9;
    HEAP32[$5 + 4 >> 2] = $9;
    HEAP32[$5 >> 2] = $9;
    $7 = $7 + 1 | 0;
    if (($7 | 0) != ($4 | 0)) {
     continue;
    }
    break;
   }
  }
  $5 = ($0 | 0) / 2 | 0;
  if (($0 | 0) >= 2) {
   $7 = 0;
   while (1) {
    $11 = $7 << 3;
    $10 = HEAPF32[$11 + $8 >> 2];
    $12 = HEAPF32[$3 >> 2];
    $13 = Math_fround(Math_fround($10 - $12) * Math_fround(.6074370741844177));
    HEAPF32[$3 >> 2] = $10 + $13;
    $10 = HEAPF32[($11 | 4) + $8 >> 2];
    $14 = HEAPF32[$3 + 4 >> 2];
    $15 = Math_fround(Math_fround($10 - $14) * Math_fround(.15062999725341797));
    HEAPF32[$3 + 4 >> 2] = $10 + $15;
    HEAPF32[$3 + 8 >> 2] = Math_fround(Math_fround(Math_fround(-$10) - HEAPF32[$3 + 8 >> 2]) * Math_fround(.15062999725341797)) - $10;
    HEAPF32[($7 << 2) + $2 >> 2] = Math_fround(Math_fround($14 + Math_fround($12 + $13)) + $15) * Math_fround(.5);
    $7 = $7 + 1 | 0;
    if (($7 | 0) != ($5 | 0)) {
     continue;
    }
    break;
   }
  }
 }
 __stack_pointer = $16;
 return $19;
}
function op_pvq_search_c($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = Math_fround(0), $7 = Math_fround(0), $8 = 0, $9 = Math_fround(0), $10 = Math_fround(0), $11 = 0, $12 = 0, $13 = Math_fround(0), $14 = 0, $15 = 0, $16 = Math_fround(0), $17 = 0, $18 = Math_fround(0);
 $4 = __stack_pointer;
 $17 = $4;
 $5 = ($3 << 2) + 15 & -16;
 $4 = $4 - $5 | 0;
 __stack_pointer = $4;
 $14 = $4 - $5 | 0;
 __stack_pointer = $14;
 $11 = ($3 | 0) > 1 ? $3 : 1;
 $12 = memset($4, 0, $11 << 2);
 $4 = 0;
 while (1) {
  $5 = $4 << 2;
  $8 = $5 + $0 | 0;
  $6 = HEAPF32[$8 >> 2];
  HEAP32[$5 + $14 >> 2] = $6 < Math_fround(0);
  HEAPF32[$8 >> 2] = Math_abs($6);
  HEAP32[$1 + $5 >> 2] = 0;
  $4 = $4 + 1 | 0;
  if (($11 | 0) != ($4 | 0)) {
   continue;
  }
  break;
 }
 $6 = Math_fround(0);
 if (($2 | 0) > $3 >> 1) {
  $4 = 0;
  while (1) {
   $6 = Math_fround($6 + HEAPF32[($4 << 2) + $0 >> 2]);
   $4 = $4 + 1 | 0;
   if (($11 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
  if (!($6 < Math_fround(64) ? !($6 > Math_fround(1.0000000036274937e-15) ^ 1) : 0)) {
   HEAP32[$0 >> 2] = 1065353216;
   memset($0 + 4 | 0, 0, ((($3 | 0) > 2 ? $3 : 2) << 2) - 4 | 0);
   $6 = Math_fround(1);
  }
  $9 = Math_fround(Math_fround(Math_fround($2 | 0) + Math_fround(.800000011920929)) * Math_fround(Math_fround(1) / $6));
  $5 = 0;
  $6 = Math_fround(0);
  while (1) {
   $8 = $5 << 2;
   $15 = $8 + $1 | 0;
   $10 = HEAPF32[$0 + $8 >> 2];
   $7 = Math_fround(Math_floor(Math_fround($9 * $10)));
   label$7 : {
    if (Math_fround(Math_abs($7)) < Math_fround(2147483648)) {
     $4 = ~~$7;
     break label$7;
    }
    $4 = -2147483648;
   }
   HEAP32[$15 >> 2] = $4;
   $7 = Math_fround($4 | 0);
   HEAPF32[$8 + $12 >> 2] = $7 + $7;
   $13 = Math_fround($13 + Math_fround($10 * $7));
   $2 = $2 - $4 | 0;
   $6 = Math_fround($6 + Math_fround($7 * $7));
   $5 = $5 + 1 | 0;
   if (($11 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
 }
 label$9 : {
  if (($3 + 3 | 0) < ($2 | 0)) {
   $10 = HEAPF32[$12 >> 2];
   HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + $2;
   $7 = Math_fround($2 | 0);
   $6 = Math_fround(Math_fround($6 + Math_fround($7 * $7)) + Math_fround($10 * $7));
   break label$9;
  }
  if (($2 | 0) < 1) {
   break label$9;
  }
  $15 = ($3 | 0) > 2 ? $3 : 2;
  $18 = HEAPF32[$0 >> 2];
  $3 = 0;
  while (1) {
   $16 = Math_fround($6 + Math_fround(1));
   $6 = Math_fround($16 + HEAPF32[$12 >> 2]);
   $7 = Math_fround($13 + $18);
   $7 = Math_fround($7 * $7);
   $4 = 1;
   $8 = 0;
   while (1) {
    $5 = $4 << 2;
    $10 = Math_fround($16 + HEAPF32[$12 + $5 >> 2]);
    $9 = Math_fround($13 + HEAPF32[$0 + $5 >> 2]);
    $9 = Math_fround($9 * $9);
    $5 = Math_fround($6 * $9) > Math_fround($7 * $10);
    $6 = $5 ? $10 : $6;
    $7 = $5 ? $9 : $7;
    $8 = $5 ? $4 : $8;
    $4 = $4 + 1 | 0;
    if (($15 | 0) != ($4 | 0)) {
     continue;
    }
    break;
   }
   $4 = $8 << 2;
   $7 = HEAPF32[$4 + $0 >> 2];
   $5 = $4 + $12 | 0;
   $6 = HEAPF32[$5 >> 2];
   HEAPF32[$5 >> 2] = $6 + Math_fround(2);
   $4 = $1 + $4 | 0;
   HEAP32[$4 >> 2] = HEAP32[$4 >> 2] + 1;
   $6 = Math_fround($16 + $6);
   $13 = Math_fround($13 + $7);
   $3 = $3 + 1 | 0;
   if (($3 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
 }
 $4 = 0;
 while (1) {
  $5 = $4 << 2;
  $8 = $5 + $1 | 0;
  $5 = HEAP32[$5 + $14 >> 2];
  HEAP32[$8 >> 2] = $5 + (HEAP32[$8 >> 2] ^ 0 - $5);
  $4 = $4 + 1 | 0;
  if (($11 | 0) != ($4 | 0)) {
   continue;
  }
  break;
 }
 __stack_pointer = $17;
 return $6;
}
function silk_LP_variable_cutoff($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 $11 = HEAP32[$0 + 12 >> 2];
 if ($11) {
  $12 = HEAP32[$0 + 8 >> 2];
  $3 = 262144 - ($12 << 10) | 0;
  label$2 : {
   if (($3 | 0) <= 262143) {
    $7 = $3 >> 16;
    $4 = $3 & 64512;
    if ($4) {
     $10 = $7 + 1 | 0;
     $3 = $4 << 16 >> 16;
     if ($4 >>> 0 >= 32768) {
      $4 = Math_imul($10, 12);
      $8 = HEAP32[$4 + 5896 >> 2];
      $6 = Math_imul($7, 12);
      $9 = $8 - HEAP32[$6 + 5896 >> 2] | 0;
      HEAP32[$5 + 24 >> 2] = (Math_imul($9 >> 16, $3) + $8 | 0) + (Math_imul($9 & 65535, $3) >> 16);
      $8 = HEAP32[$4 + 5892 >> 2];
      $9 = $8 - HEAP32[$6 + 5892 >> 2] | 0;
      HEAP32[$5 + 20 >> 2] = (Math_imul($9 >> 16, $3) + $8 | 0) + (Math_imul($9 & 65535, $3) >> 16);
      $4 = HEAP32[$4 + 5888 >> 2];
      $6 = $4 - HEAP32[$6 + 5888 >> 2] | 0;
      HEAP32[$5 + 16 >> 2] = (Math_imul($6 >> 16, $3) + $4 | 0) + (Math_imul($6 & 65535, $3) >> 16);
      $4 = $10 << 3;
      $10 = HEAP32[$4 + 5956 >> 2];
      $7 = $7 << 3;
      $6 = $10 - HEAP32[$7 + 5956 >> 2] | 0;
      HEAP32[$5 + 12 >> 2] = (Math_imul($6 >> 16, $3) + $10 | 0) + (Math_imul($6 & 65535, $3) >> 16);
      $4 = HEAP32[$4 + 5952 >> 2];
      $7 = $4 - HEAP32[$7 + 5952 >> 2] | 0;
      HEAP32[$5 + 8 >> 2] = (Math_imul($7 >> 16, $3) + $4 | 0) + (Math_imul($7 & 65535, $3) >> 16);
      break label$2;
     }
     $4 = Math_imul($10, 12);
     $6 = Math_imul($7, 12);
     $8 = HEAP32[$6 + 5896 >> 2];
     $9 = HEAP32[$4 + 5896 >> 2] - $8 | 0;
     HEAP32[$5 + 24 >> 2] = (Math_imul($9 >> 16, $3) + $8 | 0) + (Math_imul($9 & 65535, $3) >> 16);
     $8 = HEAP32[$6 + 5892 >> 2];
     $9 = HEAP32[$4 + 5892 >> 2] - $8 | 0;
     HEAP32[$5 + 20 >> 2] = (Math_imul($9 >> 16, $3) + $8 | 0) + (Math_imul($9 & 65535, $3) >> 16);
     $8 = HEAP32[$4 + 5888 >> 2];
     $4 = HEAP32[$6 + 5888 >> 2];
     $6 = $8 - $4 | 0;
     HEAP32[$5 + 16 >> 2] = (Math_imul($6 >> 16, $3) + $4 | 0) + (Math_imul($6 & 65535, $3) >> 16);
     $4 = $10 << 3;
     $7 = $7 << 3;
     $10 = HEAP32[$7 + 5956 >> 2];
     $6 = HEAP32[$4 + 5956 >> 2] - $10 | 0;
     HEAP32[$5 + 12 >> 2] = (Math_imul($6 >> 16, $3) + $10 | 0) + (Math_imul($6 & 65535, $3) >> 16);
     $7 = HEAP32[$7 + 5952 >> 2];
     $4 = HEAP32[$4 + 5952 >> 2] - $7 | 0;
     HEAP32[$5 + 8 >> 2] = (Math_imul($4 >> 16, $3) + $7 | 0) + (Math_imul($4 & 65535, $3) >> 16);
     break label$2;
    }
    $3 = Math_imul($7, 12);
    HEAP32[$5 + 24 >> 2] = HEAP32[$3 + 5896 >> 2];
    $6 = $3 + 5888 | 0;
    $4 = HEAP32[$6 >> 2];
    $3 = HEAP32[$6 + 4 >> 2];
    HEAP32[$5 + 16 >> 2] = $4;
    HEAP32[$5 + 20 >> 2] = $3;
    $6 = ($7 << 3) + 5952 | 0;
    $3 = HEAP32[$6 >> 2];
    $4 = HEAP32[$6 + 4 >> 2];
    HEAP32[$5 + 8 >> 2] = $3;
    HEAP32[$5 + 12 >> 2] = $4;
    break label$2;
   }
   HEAP32[$5 + 24 >> 2] = HEAP32[1486];
   $3 = HEAP32[1485];
   $4 = HEAP32[1484];
   HEAP32[$5 + 16 >> 2] = $4;
   HEAP32[$5 + 20 >> 2] = $3;
   $4 = HEAP32[1497];
   $3 = HEAP32[1496];
   HEAP32[$5 + 8 >> 2] = $3;
   HEAP32[$5 + 12 >> 2] = $4;
  }
  $3 = $11 + $12 | 0;
  $3 = ($3 | 0) > 0 ? $3 : 0;
  HEAP32[$0 + 8 >> 2] = ($3 | 0) < 256 ? $3 : 256;
  silk_biquad_alt_stride1($1, $5 + 16 | 0, $5 + 8 | 0, $0, $1, $2);
 }
 __stack_pointer = $5 + 32 | 0;
}
function silk_resampler_init($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 label$1 : {
  label$2 : {
   $4 = memset($0, 0, 300);
   $0 = $4;
   label$3 : {
    if ($3) {
     label$5 : {
      if (($1 | 0) <= 15999) {
       if (($1 | 0) == 8e3 | ($1 | 0) == 12e3) {
        break label$5;
       }
       break label$1;
      }
      if (($1 | 0) == 16e3 | ($1 | 0) == 48e3) {
       break label$5;
      }
      if (($1 | 0) != 24e3) {
       break label$1;
      }
     }
     if (($2 | 0) != 16e3 ? !(($2 | 0) == 8e3 | ($2 | 0) == 12e3) : 0) {
      break label$1;
     }
     $3 = (Math_imul(($1 >>> 12 | 0) - (($1 | 0) > 16e3) >> (($1 | 0) > 24e3), 3) + ($2 >>> 12 | 0) | 0) + 6487 | 0;
     break label$3;
    }
    if (($1 | 0) != 12e3 ? !(($1 | 0) == 8e3 | ($1 | 0) == 16e3) : 0) {
     break label$2;
    }
    label$9 : {
     if (($2 | 0) <= 15999) {
      if (($2 | 0) == 8e3 | ($2 | 0) == 12e3) {
       break label$9;
      }
      break label$2;
     }
     if (($2 | 0) == 16e3 | ($2 | 0) == 24e3) {
      break label$9;
     }
     if (($2 | 0) != 48e3) {
      break label$2;
     }
    }
    $3 = (Math_imul($1 >>> 12 | 0, 5) + (($2 >>> 12 | 0) - (($2 | 0) > 16e3) >> (($2 | 0) > 24e3)) | 0) + 6500 | 0;
   }
   HEAP32[$0 + 292 >> 2] = HEAP8[$3 | 0];
   HEAP32[$4 + 288 >> 2] = (($2 & 65535) >>> 0) / 1e3;
   $3 = (($1 & 65535) >>> 0) / 1e3 | 0;
   HEAP32[$4 + 284 >> 2] = $3;
   HEAP32[$4 + 268 >> 2] = Math_imul($3, 10);
   label$11 : {
    if (($1 | 0) < ($2 | 0)) {
     $5 = 1;
     if ($1 << 1 == ($2 | 0)) {
      HEAP32[$4 + 264 >> 2] = 1;
      $5 = 0;
      break label$11;
     }
     HEAP32[$4 + 264 >> 2] = 2;
     break label$11;
    }
    if (($1 | 0) > ($2 | 0)) {
     HEAP32[$4 + 264 >> 2] = 3;
     $3 = $2 << 2;
     if (($3 | 0) == (Math_imul($1, 3) | 0)) {
      HEAP32[$4 + 296 >> 2] = 6e3;
      HEAP32[$4 + 276 >> 2] = 18;
      HEAP32[$4 + 280 >> 2] = 3;
      break label$11;
     }
     $0 = Math_imul($2, 3);
     if (($0 | 0) == $1 << 1) {
      HEAP32[$4 + 296 >> 2] = 6064;
      HEAP32[$4 + 276 >> 2] = 18;
      HEAP32[$4 + 280 >> 2] = 2;
      break label$11;
     }
     if ($2 << 1 == ($1 | 0)) {
      HEAP32[$4 + 296 >> 2] = 6112;
      HEAP32[$4 + 276 >> 2] = 24;
      HEAP32[$4 + 280 >> 2] = 1;
      break label$11;
     }
     if (($0 | 0) == ($1 | 0)) {
      HEAP32[$4 + 296 >> 2] = 6144;
      HEAP32[$4 + 276 >> 2] = 36;
      HEAP32[$4 + 280 >> 2] = 1;
      break label$11;
     }
     if (($1 | 0) == ($3 | 0)) {
      HEAP32[$4 + 296 >> 2] = 6192;
      HEAP32[$4 + 276 >> 2] = 36;
      HEAP32[$4 + 280 >> 2] = 1;
      break label$11;
     }
     if ((Math_imul($2, 6) | 0) == ($1 | 0)) {
      HEAP32[$4 + 296 >> 2] = 6240;
      HEAP32[$4 + 276 >> 2] = 36;
      HEAP32[$4 + 280 >> 2] = 1;
      break label$11;
     }
     celt_fatal(6454, 6474, 154);
     abort();
    }
    HEAP32[$4 + 264 >> 2] = 0;
   }
   $0 = $1 << $5;
   $3 = $2 << 16 >> 16;
   $6 = ($2 >>> 15 | 0) + 1 >>> 1 | 0;
   $1 = ($1 << ($5 | 14)) / ($2 | 0) << 2;
   while (1) {
    $2 = $1;
    $1 = $2 + 1 | 0;
    if (((Math_imul($2 >> 16, $3) + Math_imul($2, $6) | 0) + (Math_imul($2 & 65535, $3) >> 16) | 0) < ($0 | 0)) {
     continue;
    }
    break;
   }
   HEAP32[$4 + 272 >> 2] = $2;
   return 0;
  }
  celt_fatal(6454, 6474, 101);
  abort();
 }
 celt_fatal(6454, 6474, 94);
 abort();
}
function comb_filter($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) {
 var $12 = Math_fround(0), $13 = Math_fround(0), $14 = Math_fround(0), $15 = Math_fround(0), $16 = 0, $17 = Math_fround(0), $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = Math_fround(0), $23 = Math_fround(0), $24 = Math_fround(0), $25 = Math_fround(0), $26 = Math_fround(0), $27 = Math_fround(0), $28 = Math_fround(0), $29 = Math_fround(0), $30 = Math_fround(0);
 label$1 : {
  if (!($5 != Math_fround(0) | $6 != Math_fround(0))) {
   if (($0 | 0) == ($1 | 0)) {
    break label$1;
   }
   memmove($0, $1, $4 << 2);
   return;
  }
  $11 = ($3 | 0) > 15 ? $3 : 15;
  $18 = -2 - $11 | 0;
  $19 = $11 ^ -1;
  $20 = 1 - $11 | 0;
  $21 = 0 - $11 | 0;
  $3 = Math_imul($8, 12);
  $22 = Math_fround(HEAPF32[$3 + 1704 >> 2] * $6);
  $23 = Math_fround(HEAPF32[$3 + 1700 >> 2] * $6);
  $24 = Math_fround(HEAPF32[$3 + 1696 >> 2] * $6);
  $3 = $5 == $6 ? ($7 | 0) == ($8 | 0) ? 0 : $10 : $10;
  $8 = ($2 | 0) > 15 ? $2 : 15;
  $3 = ($11 | 0) == ($8 | 0) ? $3 : $10;
  if (($3 | 0) >= 1) {
   $10 = Math_imul($7, 12);
   $25 = Math_fround(HEAPF32[$10 + 1704 >> 2] * $5);
   $26 = Math_fround(HEAPF32[$10 + 1700 >> 2] * $5);
   $27 = Math_fround(HEAPF32[$10 + 1696 >> 2] * $5);
   $7 = 2 - $11 | 0;
   $12 = HEAPF32[($20 << 2) + $1 >> 2];
   $13 = HEAPF32[($21 << 2) + $1 >> 2];
   $14 = HEAPF32[($19 << 2) + $1 >> 2];
   $5 = HEAPF32[($18 << 2) + $1 >> 2];
   $10 = 0;
   while (1) {
    $2 = $10 << 2;
    $16 = $2 + $0 | 0;
    $15 = HEAPF32[($7 + $10 << 2) + $1 >> 2];
    $17 = Math_fround($5 + $15);
    $5 = HEAPF32[$2 + $9 >> 2];
    $5 = Math_fround($5 * $5);
    $17 = Math_fround($17 * Math_fround($22 * $5));
    $28 = Math_fround(Math_fround($12 + $14) * Math_fround($23 * $5));
    $29 = Math_fround($13 * Math_fround($24 * $5));
    $30 = HEAPF32[$1 + $2 >> 2];
    $2 = ($10 - $8 << 2) + $1 | 0;
    $5 = Math_fround(Math_fround(1) - $5);
    HEAPF32[$16 >> 2] = $17 + Math_fround($28 + Math_fround($29 + Math_fround(Math_fround(Math_fround($30 + Math_fround(HEAPF32[$2 >> 2] * Math_fround($27 * $5))) + Math_fround(Math_fround($26 * $5) * Math_fround(HEAPF32[$2 + 4 >> 2] + HEAPF32[$2 - 4 >> 2]))) + Math_fround(Math_fround($25 * $5) * Math_fround(HEAPF32[$2 + 8 >> 2] + HEAPF32[$2 - 8 >> 2])))));
    $5 = $14;
    $14 = $13;
    $13 = $12;
    $12 = $15;
    $10 = $10 + 1 | 0;
    if (($10 | 0) != ($3 | 0)) {
     continue;
    }
    break;
   }
   $16 = $3;
  }
  if ($6 == Math_fround(0)) {
   if (($0 | 0) == ($1 | 0)) {
    break label$1;
   }
   $10 = $3 << 2;
   memmove($10 + $0 | 0, $1 + $10 | 0, $4 - $3 << 2);
   return;
  }
  $3 = $4 - $16 | 0;
  if (($3 | 0) < 1) {
   break label$1;
  }
  $10 = $16 << 2;
  $0 = $10 + $0 | 0;
  $9 = 2 - $11 | 0;
  $2 = $1 + $10 | 0;
  $14 = HEAPF32[$2 + ($18 << 2) >> 2];
  $5 = HEAPF32[($19 << 2) + $2 >> 2];
  $12 = HEAPF32[($21 << 2) + $2 >> 2];
  $13 = HEAPF32[($20 << 2) + $2 >> 2];
  $10 = 0;
  while (1) {
   $1 = $10 << 2;
   $15 = HEAPF32[($9 + $10 << 2) + $2 >> 2];
   HEAPF32[$1 + $0 >> 2] = Math_fround($22 * Math_fround($14 + $15)) + Math_fround(Math_fround($23 * Math_fround($5 + $13)) + Math_fround(Math_fround($24 * $12) + HEAPF32[$1 + $2 >> 2]));
   $14 = $5;
   $5 = $12;
   $12 = $13;
   $13 = $15;
   $10 = $10 + 1 | 0;
   if (($10 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
 }
}
function compute_stereo_width($0, $1, $2, $3) {
 var $4 = Math_fround(0), $5 = Math_fround(0), $6 = Math_fround(0), $7 = Math_fround(0), $8 = Math_fround(0), $9 = Math_fround(0), $10 = Math_fround(0), $11 = 0, $12 = Math_fround(0), $13 = Math_fround(0), $14 = Math_fround(0), $15 = Math_fround(0), $16 = Math_fround(0), $17 = 0;
 $11 = ($2 | 0) / ($1 | 0) | 0;
 $12 = Math_fround(Math_fround(Math_fround(-25) / Math_fround((($11 | 0) > 50 ? $11 : 50) | 0)) + Math_fround(1));
 label$1 : {
  label$2 : {
   if (($1 | 0) >= 4) {
    $17 = $1 - 3 | 0;
    $2 = 0;
    while (1) {
     $1 = $2 << 3;
     $4 = HEAPF32[$1 + $0 >> 2];
     $5 = HEAPF32[($1 | 4) + $0 >> 2];
     $6 = HEAPF32[($1 | 8) + $0 >> 2];
     $7 = HEAPF32[($1 | 12) + $0 >> 2];
     $8 = HEAPF32[($1 | 16) + $0 >> 2];
     $13 = HEAPF32[($1 | 20) + $0 >> 2];
     $14 = HEAPF32[($1 | 24) + $0 >> 2];
     $15 = HEAPF32[($1 | 28) + $0 >> 2];
     $16 = Math_fround($16 + Math_fround(Math_fround(Math_fround(Math_fround($4 * $5) + Math_fround($6 * $7)) + Math_fround($8 * $13)) + Math_fround($14 * $15)));
     $9 = Math_fround($9 + Math_fround(Math_fround(Math_fround(Math_fround($5 * $5) + Math_fround($7 * $7)) + Math_fround($13 * $13)) + Math_fround($15 * $15)));
     $10 = Math_fround($10 + Math_fround(Math_fround(Math_fround(Math_fround($4 * $4) + Math_fround($6 * $6)) + Math_fround($8 * $8)) + Math_fround($14 * $14)));
     $2 = $2 + 4 | 0;
     if (($17 | 0) > ($2 | 0)) {
      continue;
     }
     break;
    }
    if ($10 < Math_fround(1e9) ^ 1) {
     break label$2;
    }
   }
   if ($9 < Math_fround(1e9) ^ 1) {
    break label$2;
   }
   if ($9 == $9 & $10 == $10) {
    break label$1;
   }
  }
  $9 = Math_fround(0);
  $16 = Math_fround(0);
  $10 = Math_fround(0);
 }
 $4 = HEAPF32[$3 + 8 >> 2];
 $4 = Math_fround(Math_max(Math_fround($4 + Math_fround($12 * Math_fround($9 - $4))), Math_fround(0)));
 HEAPF32[$3 + 8 >> 2] = $4;
 $5 = HEAPF32[$3 + 4 >> 2];
 $6 = Math_fround(Math_max(Math_fround($5 + Math_fround($12 * Math_fround($16 - $5))), Math_fround(0)));
 HEAPF32[$3 + 4 >> 2] = $6;
 $5 = HEAPF32[$3 >> 2];
 $5 = Math_fround(Math_max(Math_fround($5 + Math_fround($12 * Math_fround($10 - $5))), Math_fround(0)));
 HEAPF32[$3 >> 2] = $5;
 label$6 : {
  if (!(($4 < $5 ? $5 : $4) > Math_fround(.0007999999797903001))) {
   $4 = HEAPF32[$3 + 16 >> 2];
   break label$6;
  }
  $5 = Math_fround(Math_sqrt($5));
  $7 = Math_fround(Math_sqrt($4));
  $4 = Math_fround($5 * $7);
  $6 = $4 > $6 ? $6 : $4;
  HEAPF32[$3 + 4 >> 2] = $6;
  $5 = Math_fround(Math_sqrt($5));
  $7 = Math_fround(Math_sqrt($7));
  $4 = Math_fround($6 / Math_fround($4 + Math_fround(1.0000000036274937e-15)));
  $8 = HEAPF32[$3 + 12 >> 2];
  $4 = Math_fround(Math_fround(Math_fround(Math_fround(Math_abs(Math_fround($5 - $7))) / Math_fround(Math_fround($5 + Math_fround(1.0000000036274937e-15)) + $7)) * Math_fround(Math_sqrt(Math_fround(Math_fround(1) - Math_fround($4 * $4))))) - $8);
  $5 = Math_fround($11 | 0);
  $4 = Math_fround($8 + Math_fround($4 / $5));
  HEAPF32[$3 + 12 >> 2] = $4;
  $5 = Math_fround(HEAPF32[$3 + 16 >> 2] + Math_fround(Math_fround(-.019999999552965164) / $5));
  $4 = $4 < $5 ? $5 : $4;
  HEAPF32[$3 + 16 >> 2] = $4;
 }
 return Math_fround(Math_min(Math_fround($4 * Math_fround(20)), Math_fround(1)));
}
function silk_process_gains_FLP($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = Math_fround(0), $7 = 0, $8 = 0, $9 = Math_fround(0), $10 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 label$1 : {
  if (HEAPU8[$0 + 4765 | 0] != 2) {
   $5 = HEAP32[$0 + 4580 >> 2];
   break label$1;
  }
  $8 = exp(+Math_fround(Math_fround(HEAPF32[$1 + 708 >> 2] + Math_fround(-12)) * Math_fround(-.25)));
  $5 = HEAP32[$0 + 4580 >> 2];
  if (($5 | 0) < 1) {
   break label$1;
  }
  $6 = Math_fround(Math_fround(Math_fround(1 / ($8 + 1)) * Math_fround(-.5)) + Math_fround(1));
  while (1) {
   $4 = ($3 << 2) + $1 | 0;
   HEAPF32[$4 >> 2] = $6 * HEAPF32[$4 >> 2];
   $3 = $3 + 1 | 0;
   if (($5 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
 }
 $3 = 0;
 $4 = HEAP32[$0 + 4588 >> 2];
 $8 = exp2(+Math_fround(Math_fround(Math_fround(Math_fround(HEAP32[$0 + 4716 >> 2]) * Math_fround(-.0078125)) + Math_fround(21)) * Math_fround(.33000001311302185)));
 label$4 : {
  if (($5 | 0) <= 0) {
   break label$4;
  }
  $9 = Math_fround($8 / +($4 | 0));
  while (1) {
   $4 = ($3 << 2) + $1 | 0;
   $6 = HEAPF32[$4 >> 2];
   $6 = Math_fround(Math_sqrt(Math_fround(Math_fround($6 * $6) + Math_fround(HEAPF32[$4 + 712 >> 2] * $9))));
   HEAPF32[$4 >> 2] = $6 < Math_fround(32767) ? $6 : Math_fround(32767);
   $3 = $3 + 1 | 0;
   if (($5 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
  $3 = 0;
  if (($5 | 0) <= 0) {
   break label$4;
  }
  while (1) {
   $4 = $3 << 2;
   $10 = $7 + $4 | 0;
   $6 = Math_fround(HEAPF32[$1 + $4 >> 2] * Math_fround(65536));
   label$7 : {
    if (Math_fround(Math_abs($6)) < Math_fround(2147483648)) {
     $4 = ~~$6;
     break label$7;
    }
    $4 = -2147483648;
   }
   HEAP32[$10 >> 2] = $4;
   $3 = $3 + 1 | 0;
   if (($5 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
 }
 memcpy($1 + 728 | 0, $7, $5 << 2);
 HEAP8[$1 + 744 | 0] = HEAPU8[$0 + 7168 | 0];
 silk_gains_quant($0 + 4736 | 0, $7, $0 + 7168 | 0, ($2 | 0) == 2, HEAP32[$0 + 4580 >> 2]);
 $5 = HEAP32[$0 + 4580 >> 2];
 if (($5 | 0) >= 1) {
  $3 = 0;
  while (1) {
   $4 = $3 << 2;
   HEAPF32[$4 + $1 >> 2] = Math_fround(HEAP32[$4 + $7 >> 2]) * Math_fround(152587890625e-16);
   $3 = $3 + 1 | 0;
   if (($5 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
 }
 $4 = HEAPU8[$0 + 4765 | 0];
 label$11 : {
  if (($4 | 0) != 2) {
   $3 = HEAP8[$0 + 4766 | 0];
   break label$11;
  }
  $3 = Math_fround(HEAPF32[$1 + 708 >> 2] + Math_fround(Math_fround(HEAP32[$0 + 4712 >> 2]) * Math_fround(30517578125e-15))) > Math_fround(1) ^ 1;
  HEAP8[$0 + 4766 | 0] = $3;
 }
 HEAPF32[$1 + 692 >> 2] = Math_fround(Math_fround(Math_fround(HEAP16[(($4 << 24 >> 24 << 1 & -4) + ($3 << 1) | 0) + 5840 >> 1]) * Math_fround(.0009765625)) * Math_fround(.800000011920929)) + Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(HEAP32[$0 + 4628 >> 2]) * Math_fround(-.05000000074505806)) + Math_fround(1.2000000476837158)) + Math_fround(Math_fround(Math_fround(HEAP32[$0 + 4532 >> 2]) * Math_fround(.20000000298023224)) * Math_fround(-.00390625))) + Math_fround(HEAPF32[$1 + 696 >> 2] * Math_fround(-.10000000149011612))) - Math_fround(HEAPF32[$1 + 700 >> 2] * Math_fround(.20000000298023224)));
 __stack_pointer = $7 + 16 | 0;
}
function silk_find_pred_coefs_FLP($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = Math_fround(0);
 $5 = __stack_pointer - 2064 | 0;
 __stack_pointer = $5;
 label$1 : {
  label$2 : {
   $7 = HEAP32[$0 + 4580 >> 2];
   label$3 : {
    if (($7 | 0) >= 1) {
     while (1) {
      $8 = $6 << 2;
      HEAPF32[$8 + ($5 + 1568 | 0) >> 2] = Math_fround(1) / HEAPF32[$1 + $8 >> 2];
      $6 = $6 + 1 | 0;
      if (($7 | 0) != ($6 | 0)) {
       continue;
      }
      break;
     }
     if (HEAPU8[$0 + 4765 | 0] == 2) {
      break label$3;
     }
     if (($7 | 0) < 1) {
      break label$2;
     }
     $4 = HEAP32[$0 + 4640 >> 2];
     $6 = $3 - ($4 << 2) | 0;
     $8 = HEAP32[$0 + 4588 >> 2];
     $3 = 0;
     $2 = $5;
     while (1) {
      silk_scale_copy_vector_FLP($2, $6, HEAPF32[($5 + 1568 | 0) + ($3 << 2) >> 2], $4 + $8 | 0);
      $8 = HEAP32[$0 + 4588 >> 2];
      $6 = ($8 << 2) + $6 | 0;
      $4 = HEAP32[$0 + 4640 >> 2];
      $2 = ($8 + $4 << 2) + $2 | 0;
      $3 = $3 + 1 | 0;
      $7 = HEAP32[$0 + 4580 >> 2];
      if (($3 | 0) < ($7 | 0)) {
       continue;
      }
      break;
     }
     break label$2;
    }
    if (HEAPU8[$0 + 4765 | 0] != 2) {
     break label$2;
    }
   }
   if ((HEAP32[$1 + 228 >> 2] + 2 | 0) <= (HEAP32[$0 + 4592 >> 2] - HEAP32[$0 + 4640 >> 2] | 0)) {
    $6 = $1 + 228 | 0;
    silk_find_LTP_FLP($5 + 1664 | 0, $5 + 1584 | 0, $2, $6, HEAP32[$0 + 4588 >> 2], $7);
    $8 = $1 + 144 | 0;
    silk_quant_LTP_gains_FLP($8, $0 + 4740 | 0, $0 + 4768 | 0, $0 + 4656 | 0, $1 + 708 | 0, $5 + 1664 | 0, $5 + 1584 | 0, HEAP32[$0 + 4588 >> 2], HEAP32[$0 + 4580 >> 2], HEAP32[$0 + 5092 >> 2]);
    silk_LTP_scale_ctrl_FLP($0, $1, $4);
    $7 = HEAP32[$0 + 4640 >> 2];
    silk_LTP_analysis_filter_FLP($5, $3 - ($7 << 2) | 0, $8, $6, $5 + 1568 | 0, HEAP32[$0 + 4588 >> 2], HEAP32[$0 + 4580 >> 2], $7);
    break label$1;
   }
   celt_fatal(16745, 16862, 62);
   abort();
  }
  memset($1 + 144 | 0, 0, Math_imul($7, 20));
  HEAP32[$1 + 708 >> 2] = 0;
  HEAP32[$0 + 4656 >> 2] = 0;
 }
 $9 = Math_fround(.009999999776482582);
 $2 = $0;
 $4 = $5 + 1536 | 0;
 $3 = $5;
 if (!HEAP32[$0 + 4664 >> 2]) {
  $9 = HEAPF32[$1 + 700 >> 2];
  $9 = Math_fround(Math_fround(Math_fround(exp2(+Math_fround(HEAPF32[$1 + 708 >> 2] / Math_fround(3)))) / Math_fround(1e4)) / Math_fround(Math_fround($9 * Math_fround(.75)) + Math_fround(.25)));
 }
 silk_find_LPC_FLP($2, $4, $3, $9);
 $6 = $1 + 16 | 0;
 silk_process_NLSFs_FLP($0, $6, $5 + 1536 | 0, $0 + 4500 | 0);
 silk_residual_energy_FLP($1 + 712 | 0, $5, $6, $1, HEAP32[$0 + 4588 >> 2], HEAP32[$0 + 4580 >> 2], HEAP32[$0 + 4640 >> 2]);
 $3 = $5 + 1560 | 0;
 $2 = HEAP32[$3 >> 2];
 $1 = HEAP32[$3 + 4 >> 2];
 $3 = $2;
 $2 = $0 + 4524 | 0;
 HEAP32[$2 >> 2] = $3;
 HEAP32[$2 + 4 >> 2] = $1;
 $3 = $5 + 1552 | 0;
 $1 = HEAP32[$3 >> 2];
 $2 = HEAP32[$3 + 4 >> 2];
 $3 = $1;
 $1 = $0 + 4516 | 0;
 HEAP32[$1 >> 2] = $3;
 HEAP32[$1 + 4 >> 2] = $2;
 $1 = HEAP32[$5 + 1548 >> 2];
 $2 = HEAP32[$5 + 1544 >> 2];
 $3 = $2;
 $2 = $0 + 4508 | 0;
 HEAP32[$2 >> 2] = $3;
 HEAP32[$2 + 4 >> 2] = $1;
 $2 = HEAP32[$5 + 1540 >> 2];
 $1 = HEAP32[$5 + 1536 >> 2];
 HEAP32[$0 + 4500 >> 2] = $1;
 HEAP32[$0 + 4504 >> 2] = $2;
 __stack_pointer = $5 + 2064 | 0;
}
function spreading_decision($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0, $12 = 0, $13 = 0, $14 = Math_fround(0), $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = Math_fround(0);
 label$1 : {
  label$2 : {
   if (($7 | 0) > 0) {
    $18 = HEAP32[$0 + 32 >> 2];
    $12 = $18 + ($7 << 1) | 0;
    label$4 : {
     if ((Math_imul(HEAP16[$12 >> 1] - HEAP16[$12 - 2 >> 1] | 0, $9) | 0) < 9) {
      break label$4;
     }
     $25 = Math_imul(HEAP32[$0 + 44 >> 2], $9);
     $26 = ($8 | 0) > 1 ? $8 : 1;
     $27 = HEAPU16[$18 >> 1];
     while (1) {
      $28 = (Math_imul($19, $25) << 2) + $1 | 0;
      $20 = $27;
      $15 = 0;
      while (1) {
       $11 = $20 << 16;
       $24 = $15 + 1 | 0;
       $20 = HEAP16[($24 << 1) + $18 >> 1];
       $11 = $11 >> 16;
       $13 = Math_imul($20 - $11 | 0, $9);
       if (($13 | 0) >= 9) {
        $29 = (Math_imul($9, $11) << 2) + $28 | 0;
        $30 = Math_fround($13 | 0);
        $21 = 0;
        $12 = 0;
        $16 = 0;
        $11 = 0;
        while (1) {
         $14 = HEAPF32[($11 << 2) + $29 >> 2];
         $14 = Math_fround(Math_fround($14 * $14) * $30);
         $21 = ($14 < Math_fround(.015625)) + $21 | 0;
         $12 = ($14 < Math_fround(.0625)) + $12 | 0;
         $16 = ($14 < Math_fround(.25)) + $16 | 0;
         $11 = $11 + 1 | 0;
         if (($13 | 0) != ($11 | 0)) {
          continue;
         }
         break;
        }
        $11 = HEAP32[($15 << 2) + $10 >> 2];
        $22 = Math_imul($11, (($12 << 1 >= ($13 | 0)) + ($16 << 1 >= ($13 | 0)) | 0) + ($21 << 1 >= ($13 | 0)) | 0) + $22 | 0;
        $23 = $11 + $23 | 0;
        $17 = (HEAP32[$0 + 8 >> 2] - 4 | 0) < ($15 | 0) ? (($12 + $16 << 5 >>> 0) / ($13 >>> 0) | 0) + $17 | 0 : $17;
       }
       $15 = $24;
       if (($15 | 0) != ($7 | 0)) {
        continue;
       }
       break;
      }
      $19 = $19 + 1 | 0;
      if (($26 | 0) != ($19 | 0)) {
       continue;
      }
      break;
     }
     if ($6) {
      $11 = $17 ? ($17 >>> 0) / (Math_imul(($7 - HEAP32[$0 + 8 >> 2] | 0) + 4 | 0, $8) >>> 0) | 0 : 0;
      $11 = $11 + HEAP32[$4 >> 2] >> 1;
      HEAP32[$4 >> 2] = $11;
      label$13 : {
       label$14 : {
        switch (HEAP32[$5 >> 2]) {
        case 2:
         $11 = $11 + 4 | 0;
         break label$13;
        case 0:
         break label$14;
        default:
         break label$13;
        }
       }
       $11 = $11 - 4 | 0;
      }
      HEAP32[$5 >> 2] = ($11 | 0) > 22 ? 2 : ($11 | 0) > 18;
     }
     if (($23 | 0) <= 0) {
      break label$2;
     }
     if (($22 | 0) <= -1) {
      break label$1;
     }
     $12 = HEAP32[$2 >> 2] + (($22 << 8 >>> 0) / ($23 >>> 0) | 0) >> 1;
     HEAP32[$2 >> 2] = $12;
     $11 = 3;
     $12 = (Math_imul($12, 3) - ($3 << 7) | 0) + 448 | 0;
     if (($12 | 0) < 318) {
      break label$4;
     }
     $11 = 2;
     if (($12 | 0) < 1022) {
      break label$4;
     }
     $11 = ($12 | 0) < 1534;
    }
    return $11;
   }
   celt_fatal(41813, 41800, 489);
   abort();
  }
  celt_fatal(41837, 41800, 545);
  abort();
 }
 celt_fatal(41865, 41800, 546);
 abort();
}
function decode_pulses($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = Math_fround(0), $7 = 0, $8 = Math_fround(0), $9 = 0, $10 = 0, $11 = 0;
 $4 = $2 + 1 | 0;
 $5 = ($1 | 0) > ($2 | 0);
 $5 = ec_dec_uint($3, HEAP32[HEAP32[(($5 ? $4 : $1) << 2) + 36320 >> 2] + ((($1 | 0) > ($4 | 0) ? $1 : $4) << 2) >> 2] + HEAP32[HEAP32[((($1 | 0) < ($2 | 0) ? $1 : $2) << 2) + 36320 >> 2] + (($5 ? $1 : $2) << 2) >> 2] | 0);
 label$1 : {
  if (($2 | 0) > 0) {
   if (($1 | 0) < 2) {
    break label$1;
   }
   if (($1 | 0) != 2) {
    while (1) {
     $9 = $1;
     label$5 : {
      if (($1 | 0) <= ($2 | 0)) {
       $3 = $2;
       $7 = $9 << 2;
       $10 = HEAP32[$7 + 36320 >> 2];
       $4 = HEAP32[($10 + ($2 << 2) | 0) + 4 >> 2];
       $11 = $5 >>> 0 >= $4 >>> 0 ? -1 : 0;
       $4 = $5 - ($4 & $11) | 0;
       label$7 : {
        if ($4 >>> 0 < HEAPU32[$7 + $10 >> 2]) {
         while (1) {
          $1 = $1 - 1 | 0;
          $5 = HEAP32[HEAP32[($1 << 2) + 36320 >> 2] + $7 >> 2];
          if ($5 >>> 0 > $4 >>> 0) {
           continue;
          }
          break label$7;
         }
        }
        while (1) {
         $1 = $3;
         $3 = $1 - 1 | 0;
         $5 = HEAP32[($1 << 2) + $10 >> 2];
         if ($5 >>> 0 > $4 >>> 0) {
          continue;
         }
         break;
        }
       }
       $3 = (($2 + $11 | 0) - $1 ^ $11) << 16 >> 16;
       HEAP32[$0 >> 2] = $3;
       $6 = Math_fround($3 | 0);
       $8 = Math_fround($8 + Math_fround($6 * $6));
       $2 = $1;
       $5 = $4 - $5 | 0;
       break label$5;
      }
      $4 = $9 << 2;
      $3 = $2 << 2;
      $1 = HEAP32[$4 + HEAP32[$3 + 36324 >> 2] >> 2];
      $3 = HEAP32[HEAP32[$3 + 36320 >> 2] + $4 >> 2];
      if (!($5 >>> 0 < $3 >>> 0 | $1 >>> 0 <= $5 >>> 0)) {
       HEAP32[$0 >> 2] = 0;
       $5 = $5 - $3 | 0;
       break label$5;
      }
      $7 = $1 >>> 0 <= $5 >>> 0 ? -1 : 0;
      $3 = $5 - ($7 & $1) | 0;
      $1 = $2;
      while (1) {
       $1 = $1 - 1 | 0;
       $5 = HEAP32[HEAP32[($1 << 2) + 36320 >> 2] + $4 >> 2];
       if ($5 >>> 0 > $3 >>> 0) {
        continue;
       }
       break;
      }
      $4 = (($2 + $7 | 0) - $1 ^ $7) << 16 >> 16;
      HEAP32[$0 >> 2] = $4;
      $6 = Math_fround($4 | 0);
      $8 = Math_fround($8 + Math_fround($6 * $6));
      $2 = $1;
      $5 = $3 - $5 | 0;
     }
     $1 = $9 - 1 | 0;
     $0 = $0 + 4 | 0;
     if (($9 | 0) > 3) {
      continue;
     }
     break;
    }
   }
   $1 = $2 << 1 | 1;
   $4 = $5 >>> 0 >= $1 >>> 0;
   $2 = $2 - $4 | 0;
   $4 = $4 ? -1 : 0;
   $3 = $5 - ($4 & $1) | 0;
   $5 = $3 + 1 | 0;
   $1 = $5 >>> 1 | 0;
   $4 = ($2 - $1 ^ $4) << 16 >> 16;
   HEAP32[$0 >> 2] = $4;
   $3 = $3 - ($1 ? ($5 & -2) - 1 | 0 : 0) | 0;
   $1 = ($1 - $3 ^ 0 - $3) << 16 >> 16;
   HEAP32[$0 + 4 >> 2] = $1;
   $6 = Math_fround($4 | 0);
   $6 = Math_fround($8 + Math_fround($6 * $6));
   $8 = Math_fround($1 | 0);
   return Math_fround($6 + Math_fround($8 * $8));
  }
  celt_fatal(36272, 36295, 469);
  abort();
 }
 celt_fatal(41504, 36295, 470);
 abort();
}
function resampler_basic_interpolate_single($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = Math_fround(0), $7 = Math_fround(0), $8 = Math_fround(0), $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = Math_fround(0), $14 = Math_fround(0), $15 = Math_fround(0), $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = Math_fround(0), $22 = Math_fround(0), $23 = 0, $24 = 0, $25 = 0, $26 = Math_fround(0), $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = Math_fround(0);
 $1 = $1 << 2;
 $16 = $1 + HEAP32[$0 + 64 >> 2] | 0;
 $12 = HEAP32[$16 >> 2];
 $17 = HEAP32[$0 + 60 >> 2] + $1 | 0;
 $9 = HEAP32[$17 >> 2];
 $18 = HEAP32[$3 >> 2];
 label$1 : {
  if (($9 | 0) >= ($18 | 0)) {
   break label$1;
  }
  $23 = HEAP32[$0 + 40 >> 2];
  $24 = HEAP32[$0 + 36 >> 2];
  $25 = HEAP32[$0 + 92 >> 2];
  $3 = HEAP32[$5 >> 2];
  $19 = ($3 | 0) > 0 ? $3 : 0;
  $10 = HEAP32[$0 + 12 >> 2];
  $26 = Math_fround($10 >>> 0);
  $20 = HEAP32[$0 + 24 >> 2];
  $27 = ($20 | 0) < 1;
  while (1) {
   if (($11 | 0) == ($19 | 0)) {
    $11 = $19;
    break label$1;
   }
   $5 = HEAP32[$0 + 48 >> 2];
   $3 = Math_imul($12, $5);
   $1 = $3;
   $3 = ($3 >>> 0) / ($10 >>> 0) | 0;
   $7 = Math_fround(Math_fround($1 - Math_imul($10, $3) >>> 0) / $26);
   label$4 : {
    if ($27) {
     $8 = Math_fround(0);
     $13 = Math_fround(0);
     $14 = Math_fround(0);
     $15 = Math_fround(0);
     break label$4;
    }
    $28 = ($9 << 2) + $2 | 0;
    $29 = 4 - $3 | 0;
    $30 = HEAP32[$0 + 76 >> 2];
    $3 = 0;
    $15 = Math_fround(0);
    $14 = Math_fround(0);
    $13 = Math_fround(0);
    $8 = Math_fround(0);
    while (1) {
     $6 = HEAPF32[($3 << 2) + $28 >> 2];
     $3 = $3 + 1 | 0;
     $1 = (Math_imul($5, $3) + $29 << 2) + $30 | 0;
     $14 = Math_fround($14 + Math_fround($6 * HEAPF32[$1 >> 2]));
     $15 = Math_fround($15 + Math_fround($6 * HEAPF32[$1 + 4 >> 2]));
     $13 = Math_fround($13 + Math_fround($6 * HEAPF32[$1 - 4 >> 2]));
     $8 = Math_fround($8 + Math_fround($6 * HEAPF32[$1 - 8 >> 2]));
     if (($3 | 0) != ($20 | 0)) {
      continue;
     }
     break;
    }
   }
   $6 = Math_fround($7 * Math_fround(.16666999459266663));
   $21 = Math_fround($7 * Math_fround($7 * $6));
   $22 = Math_fround($21 - $6);
   $31 = Math_fround($22 * $8);
   $6 = Math_fround($7 * Math_fround($7 * Math_fround(.5)));
   $8 = Math_fround(Math_fround($7 + $6) - Math_fround($7 * $6));
   $6 = Math_fround(Math_fround($6 + Math_fround($7 * Math_fround(-.3333300054073334))) - $21);
   HEAPF32[(Math_imul($11, $25) << 2) + $4 >> 2] = Math_fround(Math_fround($31 + Math_fround($8 * $13)) + Math_fround($14 * Math_fround(1 - +$22 - +$8 - +$6))) + Math_fround($6 * $15);
   $3 = $12 + $23 | 0;
   $12 = $3 - ($3 >>> 0 < $10 >>> 0 ? 0 : $10) | 0;
   $11 = $11 + 1 | 0;
   $9 = ($9 + $24 | 0) + ($3 >>> 0 >= $10 >>> 0) | 0;
   if (($18 | 0) > ($9 | 0)) {
    continue;
   }
   break;
  }
 }
 HEAP32[$17 >> 2] = $9;
 HEAP32[$16 >> 2] = $12;
 return $11 | 0;
}
function opus_encoder_init($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 $6 = -1;
 label$1 : {
  label$2 : {
   if (($1 | 0) <= 15999) {
    if (($1 | 0) == 8e3 | ($1 | 0) == 12e3) {
     break label$2;
    }
    break label$1;
   }
   if (($1 | 0) == 16e3 | ($1 | 0) == 48e3) {
    break label$2;
   }
   if (($1 | 0) != 24e3) {
    break label$1;
   }
  }
  if ($2 - 1 >>> 0 > 1) {
   break label$1;
  }
  $5 = $3 - 2048 | 0;
  if ($5 >>> 0 > 3 | ($5 | 0) == 2) {
   break label$1;
  }
  $5 = 0;
  if (!silk_Get_Encoder_Size($4 + 28 | 0)) {
   HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 28 >> 2] + 3 & -4;
   $5 = (celt_encoder_get_size($2) + HEAP32[$4 + 28 >> 2] | 0) + 18140 | 0;
  }
  $0 = memset($0, 0, $5);
  if (silk_Get_Encoder_Size($4 + 28 | 0)) {
   break label$1;
  }
  $6 = HEAP32[$4 + 28 >> 2] + 3 & -4;
  HEAP32[$4 + 28 >> 2] = $6;
  HEAP32[$0 + 14192 >> 2] = $2;
  HEAP32[$0 + 112 >> 2] = $2;
  HEAP32[$0 + 4 >> 2] = 18140;
  HEAP32[$0 + 180 >> 2] = 0;
  HEAP32[$0 + 144 >> 2] = $1;
  $5 = $6 + 18140 | 0;
  HEAP32[$0 >> 2] = $5;
  $6 = -3;
  if (silk_InitEncoder($0 + 18140 | 0, 0, $0 + 8 | 0)) {
   break label$1;
  }
  HEAP32[$0 + 8 >> 2] = $2;
  HEAP32[$0 + 12 >> 2] = $2;
  HEAP32[$0 + 76 >> 2] = 0;
  HEAP32[$0 + 56 >> 2] = 0;
  HEAP32[$0 + 60 >> 2] = 0;
  HEAP32[$0 + 44 >> 2] = 9;
  HEAP32[$0 + 48 >> 2] = 0;
  HEAP32[$0 + 36 >> 2] = 25e3;
  HEAP32[$0 + 40 >> 2] = 0;
  HEAP32[$0 + 28 >> 2] = 16e3;
  HEAP32[$0 + 32 >> 2] = 20;
  HEAP32[$0 + 20 >> 2] = 16e3;
  HEAP32[$0 + 24 >> 2] = 8e3;
  HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 144 >> 2];
  $5 = $0 + $5 | 0;
  if (celt_encoder_init($5, $1, $2, HEAP32[$0 + 180 >> 2])) {
   break label$1;
  }
  $6 = 0;
  HEAP32[$4 + 16 >> 2] = 0;
  opus_custom_encoder_ctl($5, 10016, $4 + 16 | 0);
  HEAP32[$4 >> 2] = HEAP32[$0 + 44 >> 2];
  opus_custom_encoder_ctl($5, 4010, $4);
  HEAP32[$0 + 148 >> 2] = 1;
  HEAP32[$0 + 152 >> 2] = 1;
  HEAP32[$0 + 160 >> 2] = Math_imul($1, $2) + 3e3;
  HEAP32[$0 + 128 >> 2] = -1e3;
  HEAP32[$0 + 132 >> 2] = 1105;
  HEAP32[$0 + 108 >> 2] = $3;
  HEAP32[$0 + 136 >> 2] = -1e3;
  HEAP32[$0 + 140 >> 2] = -1;
  HEAP32[$0 + 120 >> 2] = -1e3;
  HEAP32[$0 + 124 >> 2] = -1e3;
  HEAP32[$0 + 164 >> 2] = -1e3;
  HEAP32[$0 + 168 >> 2] = 24;
  HEAP32[$0 + 156 >> 2] = 5e3;
  HEAP32[$0 + 14204 >> 2] = 1065353216;
  HEAP16[$0 + 14196 >> 1] = 16384;
  $1 = HEAP32[$0 + 144 >> 2];
  HEAP32[$0 + 172 >> 2] = ($1 | 0) / 100;
  HEAP32[$0 + 116 >> 2] = ($1 | 0) / 250;
  $1 = silk_lin2log(60);
  HEAP32[$0 + 14252 >> 2] = 1;
  HEAP32[$0 + 14240 >> 2] = 1105;
  HEAP32[$0 + 14224 >> 2] = 1001;
  HEAP32[$0 + 14200 >> 2] = $1 << 8;
  tonality_analysis_init($0 + 188 | 0, HEAP32[$0 + 144 >> 2]);
  HEAP32[$0 + 192 >> 2] = HEAP32[$0 + 108 >> 2];
 }
 __stack_pointer = $4 + 32 | 0;
 return $6;
}
function resampler_basic_interpolate_double($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = Math_fround(0), $7 = 0, $8 = Math_fround(0), $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = Math_fround(0), $23 = 0, $24 = 0, $25 = 0, $26 = Math_fround(0), $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0;
 $1 = $1 << 2;
 $17 = $1 + HEAP32[$0 + 64 >> 2] | 0;
 $13 = HEAP32[$17 >> 2];
 $18 = HEAP32[$0 + 60 >> 2] + $1 | 0;
 $9 = HEAP32[$18 >> 2];
 $19 = HEAP32[$3 >> 2];
 label$1 : {
  if (($9 | 0) >= ($19 | 0)) {
   break label$1;
  }
  $23 = HEAP32[$0 + 40 >> 2];
  $24 = HEAP32[$0 + 36 >> 2];
  $25 = HEAP32[$0 + 92 >> 2];
  $3 = HEAP32[$5 >> 2];
  $20 = ($3 | 0) > 0 ? $3 : 0;
  $10 = HEAP32[$0 + 12 >> 2];
  $26 = Math_fround($10 >>> 0);
  $21 = HEAP32[$0 + 24 >> 2];
  $27 = ($21 | 0) < 1;
  while (1) {
   if (($12 | 0) == ($20 | 0)) {
    $12 = $20;
    break label$1;
   }
   $5 = HEAP32[$0 + 48 >> 2];
   $3 = Math_imul($13, $5);
   $1 = $3;
   $3 = ($3 >>> 0) / ($10 >>> 0) | 0;
   $8 = Math_fround(Math_fround($1 - Math_imul($10, $3) >>> 0) / $26);
   label$4 : {
    if ($27) {
     $7 = 0;
     $11 = 0;
     $14 = 0;
     $15 = 0;
     break label$4;
    }
    $28 = ($9 << 2) + $2 | 0;
    $29 = 4 - $3 | 0;
    $30 = HEAP32[$0 + 76 >> 2];
    $3 = 0;
    $15 = 0;
    $14 = 0;
    $11 = 0;
    $7 = 0;
    while (1) {
     $6 = HEAPF32[($3 << 2) + $28 >> 2];
     $3 = $3 + 1 | 0;
     $1 = (Math_imul($5, $3) + $29 << 2) + $30 | 0;
     $14 = $14 + +Math_fround($6 * HEAPF32[$1 >> 2]);
     $15 = $15 + +Math_fround($6 * HEAPF32[$1 + 4 >> 2]);
     $11 = $11 + +Math_fround($6 * HEAPF32[$1 - 4 >> 2]);
     $7 = $7 + +Math_fround($6 * HEAPF32[$1 - 8 >> 2]);
     if (($3 | 0) != ($21 | 0)) {
      continue;
     }
     break;
    }
   }
   $6 = Math_fround($8 * Math_fround(.16666999459266663));
   $22 = Math_fround($8 * Math_fround($8 * $6));
   $16 = +Math_fround($22 - $6);
   $31 = $7 * $16;
   $6 = Math_fround($8 * Math_fround($8 * Math_fround(.5)));
   $7 = +Math_fround(Math_fround($8 + $6) - Math_fround($8 * $6));
   $11 = $31 + $11 * $7;
   $16 = 1 - $16 - $7;
   $7 = +Math_fround(Math_fround($6 + Math_fround($8 * Math_fround(-.3333300054073334))) - $22);
   HEAPF32[(Math_imul($12, $25) << 2) + $4 >> 2] = $11 + $14 * +Math_fround($16 - $7) + $15 * $7;
   $3 = $13 + $23 | 0;
   $13 = $3 - ($3 >>> 0 < $10 >>> 0 ? 0 : $10) | 0;
   $12 = $12 + 1 | 0;
   $9 = ($9 + $24 | 0) + ($3 >>> 0 >= $10 >>> 0) | 0;
   if (($19 | 0) > ($9 | 0)) {
    continue;
   }
   break;
  }
 }
 HEAP32[$18 >> 2] = $9;
 HEAP32[$17 >> 2] = $13;
 return $12 | 0;
}
function silk_find_pitch_lags_FLP($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = Math_fround(0), $10 = 0, $11 = 0, $12 = 0;
 $5 = __stack_pointer - 1744 | 0;
 __stack_pointer = $5;
 $7 = HEAP32[$0 + 4548 >> 2];
 $8 = HEAP32[$0 + 4596 >> 2];
 $6 = $8 + HEAP32[$0 + 4584 >> 2] | 0;
 $10 = HEAP32[$0 + 4592 >> 2];
 $11 = $6 + $10 | 0;
 if (($7 | 0) <= ($11 | 0)) {
  $6 = (($6 << 2) + $3 | 0) - ($7 << 2) | 0;
  silk_apply_sine_window_FLP($5, $6, 1, $8);
  $8 = HEAP32[$0 + 4596 >> 2];
  $7 = $8 << 2;
  $12 = $7 + $5 | 0;
  $7 = $7 + $6 | 0;
  $6 = HEAP32[$0 + 4548 >> 2] - ($8 << 1) << 2;
  silk_apply_sine_window_FLP($6 + memcpy($12, $7, $6) | 0, $7 + $6 | 0, 2, $8);
  silk_autocorrelation_FLP($5 + 1664 | 0, $5, HEAP32[$0 + 4548 >> 2], HEAP32[$0 + 4648 >> 2] + 1 | 0);
  $9 = HEAPF32[$5 + 1664 >> 2];
  HEAPF32[$5 + 1664 >> 2] = $9 + Math_fround(Math_fround($9 * Math_fround(.0010000000474974513)) + Math_fround(1));
  $9 = silk_schur_FLP($5 + 1536 | 0, $5 + 1664 | 0, HEAP32[$0 + 4648 >> 2]);
  HEAPF32[$1 + 704 >> 2] = HEAPF32[$5 + 1664 >> 2] / ($9 > Math_fround(1) ? $9 : Math_fround(1));
  silk_k2a_FLP($5 + 1600 | 0, $5 + 1536 | 0, HEAP32[$0 + 4648 >> 2]);
  silk_bwexpander_FLP($5 + 1600 | 0, HEAP32[$0 + 4648 >> 2], Math_fround(.9900000095367432));
  silk_LPC_analysis_filter_FLP($2, $5 + 1600 | 0, $3 - ($10 << 2) | 0, $11, HEAP32[$0 + 4648 >> 2]);
  label$2 : {
   if (!(HEAP32[$0 + 4664 >> 2] | !HEAPU8[$0 + 4765 | 0])) {
    if (!silk_pitch_analysis_core_FLP($2, $1 + 228 | 0, $0 + 4762 | 0, $0 + 4764 | 0, $0 + 10060 | 0, HEAP32[$0 + 4544 >> 2], Math_fround(Math_fround(HEAP32[$0 + 4652 >> 2]) * Math_fround(152587890625e-16)), Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(Math_fround(HEAP32[$0 + 4648 >> 2]) * Math_fround(-.004000000189989805)) + Math_fround(.6000000238418579)) + Math_fround(Math_fround(Math_fround(HEAP32[$0 + 4532 >> 2]) * Math_fround(.10000000149011612)) * Math_fround(-.00390625))) + Math_fround(Math_fround(HEAP8[$0 + 4541 | 0] >> 1) * Math_fround(-.15000000596046448))) + Math_fround(Math_fround(Math_fround(HEAP32[$0 + 4712 >> 2]) * Math_fround(.10000000149011612)) * Math_fround(-30517578125e-15))), HEAP32[$0 + 4576 >> 2], HEAP32[$0 + 4644 >> 2], HEAP32[$0 + 4580 >> 2], $4)) {
     HEAP8[$0 + 4765 | 0] = 2;
     break label$2;
    }
    HEAP8[$0 + 4765 | 0] = 1;
    break label$2;
   }
   HEAP32[$1 + 228 >> 2] = 0;
   HEAP32[$1 + 232 >> 2] = 0;
   HEAP32[$1 + 236 >> 2] = 0;
   HEAP32[$1 + 240 >> 2] = 0;
   HEAP32[$0 + 10060 >> 2] = 0;
   HEAP8[$0 + 4764 | 0] = 0;
   HEAP16[$0 + 4762 >> 1] = 0;
  }
  __stack_pointer = $5 + 1744 | 0;
  return;
 }
 celt_fatal(10821, 10883, 59);
 abort();
}
function stereo_itheta($0, $1, $2, $3, $4) {
 var $5 = Math_fround(0), $6 = Math_fround(0), $7 = Math_fround(0), $8 = Math_fround(0), $9 = Math_fround(0);
 label$1 : {
  if ($2) {
   $6 = Math_fround(1.0000000036274937e-15);
   if (($3 | 0) < 1) {
    $5 = Math_fround(1.0000000036274937e-15);
    break label$1;
   }
   $2 = 0;
   $5 = Math_fround(1.0000000036274937e-15);
   while (1) {
    $4 = $2 << 2;
    $7 = HEAPF32[$4 + $0 >> 2];
    $8 = HEAPF32[$1 + $4 >> 2];
    $9 = Math_fround($7 - $8);
    $5 = Math_fround($5 + Math_fround($9 * $9));
    $7 = Math_fround($7 + $8);
    $6 = Math_fround($6 + Math_fround($7 * $7));
    $2 = $2 + 1 | 0;
    if (($3 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
   break label$1;
  }
  if (($3 | 0) < 1) {
   $5 = Math_fround(1.0000000036274937e-15);
   $6 = Math_fround(1.0000000036274937e-15);
   break label$1;
  }
  $2 = 0;
  while (1) {
   $5 = HEAPF32[($2 << 2) + $0 >> 2];
   $6 = Math_fround($6 + Math_fround($5 * $5));
   $2 = $2 + 1 | 0;
   if (($3 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
  $6 = Math_fround($6 + Math_fround(1.0000000036274937e-15));
  $2 = 0;
  $5 = Math_fround(0);
  while (1) {
   $7 = HEAPF32[($2 << 2) + $1 >> 2];
   $5 = Math_fround($5 + Math_fround($7 * $7));
   $2 = $2 + 1 | 0;
   if (($3 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
  $5 = Math_fround($5 + Math_fround(1.0000000036274937e-15));
 }
 $8 = Math_fround(Math_sqrt($5));
 $5 = Math_fround($8 * $8);
 $9 = Math_fround(Math_sqrt($6));
 $6 = Math_fround($9 * $9);
 $7 = Math_fround(0);
 label$8 : {
  if (Math_fround($5 + $6) < Math_fround(1.000000045813705e-18)) {
   break label$8;
  }
  $7 = Math_fround(Math_fround(1.5707963705062866) - Math_fround(Math_fround(Math_fround($8 * $9) * Math_fround($5 + Math_fround($6 * Math_fround(.43157973885536194)))) / Math_fround(Math_fround($5 + Math_fround($6 * Math_fround(.6784840226173401))) * Math_fround($5 + Math_fround($6 * Math_fround(.0859554186463356))))));
  if (!($5 > $6 ^ 1)) {
   break label$8;
  }
  $7 = Math_fround(Math_fround(Math_fround(Math_fround(Math_fround($8 * $9) * Math_fround($6 + Math_fround($5 * Math_fround(.43157973885536194)))) / Math_fround(Math_fround($6 + Math_fround($5 * Math_fround(.6784840226173401))) * Math_fround($6 + Math_fround($5 * Math_fround(.0859554186463356))))) + Math_fround(1.5707963705062866)) + Math_fround(-1.5707963705062866));
 }
 $6 = Math_fround(Math_floor(Math_fround(Math_fround($7 * Math_fround(10430.3818359375)) + Math_fround(.5))));
 if (Math_fround(Math_abs($6)) < Math_fround(2147483648)) {
  return ~~$6;
 }
 return -2147483648;
}
function silk_resampler_down2_3($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0;
 $6 = __stack_pointer - 1936 | 0;
 __stack_pointer = $6;
 $5 = $0;
 $7 = HEAP32[$5 >> 2];
 $4 = HEAP32[$5 + 4 >> 2];
 HEAP32[$6 >> 2] = $7;
 HEAP32[$6 + 4 >> 2] = $4;
 $7 = HEAP32[$5 + 12 >> 2];
 $4 = HEAP32[$5 + 8 >> 2];
 HEAP32[$6 + 8 >> 2] = $4;
 HEAP32[$6 + 12 >> 2] = $7;
 $20 = $5 + 16 | 0;
 $11 = HEAP16[3144];
 $15 = HEAP16[3145];
 $12 = HEAP16[3143];
 $13 = HEAP16[3142];
 $21 = $6 + 16 | 0;
 while (1) {
  $9 = ($3 | 0) < 480 ? $3 : 480;
  silk_resampler_private_AR2($20, $21, $2, 6280, $9);
  if (($9 | 0) >= 3) {
   $4 = HEAP32[$6 >> 2];
   $5 = $6;
   $7 = $9;
   while (1) {
    $14 = Math_imul($4 >> 16, $13) + (Math_imul($4 & 65535, $13) >> 16) | 0;
    $4 = HEAP32[$5 + 4 >> 2];
    $8 = $4 >> 16;
    $10 = $4 & 65535;
    $4 = HEAP32[$5 + 8 >> 2];
    $16 = (Math_imul($4 & 65535, $15) >> 16) + Math_imul($4 >> 16, $15) | 0;
    $4 = HEAP32[$5 + 12 >> 2];
    $17 = $4 >> 16;
    $18 = $4 & 65535;
    $14 = (($16 + ((Math_imul($8, $12) + $14 | 0) + (Math_imul($12, $10) >> 16) | 0) | 0) + Math_imul($17, $11) | 0) + (Math_imul($18, $11) >> 16) | 0;
    $19 = ($14 >> 5) + 1 >> 1;
    HEAP16[$1 >> 1] = ($14 | 0) > 2097119 ? 32767 : ($19 | 0) > -32768 ? $19 : -32768;
    $10 = (((Math_imul($12, $17) + (Math_imul($12, $18) >> 16) | 0) + Math_imul($8, $11) | 0) + $16 | 0) + (Math_imul($11, $10) >> 16) | 0;
    $8 = HEAP32[$5 + 16 >> 2];
    $8 = ($10 + Math_imul($8 >> 16, $13) | 0) + (Math_imul($8 & 65535, $13) >> 16) | 0;
    $10 = ($8 >> 5) + 1 >> 1;
    HEAP16[$1 + 2 >> 1] = ($8 | 0) > 2097119 ? 32767 : ($10 | 0) > -32768 ? $10 : -32768;
    $1 = $1 + 4 | 0;
    $5 = $5 + 12 | 0;
    $8 = ($7 | 0) > 5;
    $7 = $7 - 3 | 0;
    if ($8) {
     continue;
    }
    break;
   }
  }
  $3 = $3 - $9 | 0;
  if (($3 | 0) >= 1) {
   $5 = ($9 << 2) + $6 | 0;
   $7 = HEAP32[$5 >> 2];
   $4 = HEAP32[$5 + 4 >> 2];
   HEAP32[$6 >> 2] = $7;
   HEAP32[$6 + 4 >> 2] = $4;
   $7 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 8 >> 2];
   HEAP32[$6 + 8 >> 2] = $4;
   HEAP32[$6 + 12 >> 2] = $7;
   $2 = ($9 << 1) + $2 | 0;
   continue;
  }
  break;
 }
 $5 = ($9 << 2) + $6 | 0;
 $7 = HEAP32[$5 >> 2];
 $4 = HEAP32[$5 + 4 >> 2];
 $1 = $7;
 $7 = $0;
 HEAP32[$7 >> 2] = $1;
 HEAP32[$7 + 4 >> 2] = $4;
 $7 = HEAP32[$5 + 12 >> 2];
 $4 = HEAP32[$5 + 8 >> 2];
 $1 = $4;
 $4 = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 12 >> 2] = $7;
 __stack_pointer = $6 + 1936 | 0;
}
function memcpy($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 if ($2 >>> 0 >= 512) {
  emscripten_memcpy_big($0 | 0, $1 | 0, $2 | 0) | 0;
  return $0;
 }
 $4 = $0 + $2 | 0;
 label$2 : {
  if (!(($0 ^ $1) & 3)) {
   label$4 : {
    if (($2 | 0) < 1) {
     $2 = $0;
     break label$4;
    }
    if (!($0 & 3)) {
     $2 = $0;
     break label$4;
    }
    $2 = $0;
    while (1) {
     HEAP8[$2 | 0] = HEAPU8[$1 | 0];
     $1 = $1 + 1 | 0;
     $2 = $2 + 1 | 0;
     if ($4 >>> 0 <= $2 >>> 0) {
      break label$4;
     }
     if ($2 & 3) {
      continue;
     }
     break;
    }
   }
   $3 = $4 & -4;
   label$8 : {
    if ($3 >>> 0 < 64) {
     break label$8;
    }
    $5 = $3 + -64 | 0;
    if ($5 >>> 0 < $2 >>> 0) {
     break label$8;
    }
    while (1) {
     HEAP32[$2 >> 2] = HEAP32[$1 >> 2];
     HEAP32[$2 + 4 >> 2] = HEAP32[$1 + 4 >> 2];
     HEAP32[$2 + 8 >> 2] = HEAP32[$1 + 8 >> 2];
     HEAP32[$2 + 12 >> 2] = HEAP32[$1 + 12 >> 2];
     HEAP32[$2 + 16 >> 2] = HEAP32[$1 + 16 >> 2];
     HEAP32[$2 + 20 >> 2] = HEAP32[$1 + 20 >> 2];
     HEAP32[$2 + 24 >> 2] = HEAP32[$1 + 24 >> 2];
     HEAP32[$2 + 28 >> 2] = HEAP32[$1 + 28 >> 2];
     HEAP32[$2 + 32 >> 2] = HEAP32[$1 + 32 >> 2];
     HEAP32[$2 + 36 >> 2] = HEAP32[$1 + 36 >> 2];
     HEAP32[$2 + 40 >> 2] = HEAP32[$1 + 40 >> 2];
     HEAP32[$2 + 44 >> 2] = HEAP32[$1 + 44 >> 2];
     HEAP32[$2 + 48 >> 2] = HEAP32[$1 + 48 >> 2];
     HEAP32[$2 + 52 >> 2] = HEAP32[$1 + 52 >> 2];
     HEAP32[$2 + 56 >> 2] = HEAP32[$1 + 56 >> 2];
     HEAP32[$2 + 60 >> 2] = HEAP32[$1 + 60 >> 2];
     $1 = $1 - -64 | 0;
     $2 = $2 - -64 | 0;
     if ($5 >>> 0 >= $2 >>> 0) {
      continue;
     }
     break;
    }
   }
   if ($2 >>> 0 >= $3 >>> 0) {
    break label$2;
   }
   while (1) {
    HEAP32[$2 >> 2] = HEAP32[$1 >> 2];
    $1 = $1 + 4 | 0;
    $2 = $2 + 4 | 0;
    if ($3 >>> 0 > $2 >>> 0) {
     continue;
    }
    break;
   }
   break label$2;
  }
  if ($4 >>> 0 < 4) {
   $2 = $0;
   break label$2;
  }
  $3 = $4 - 4 | 0;
  if ($3 >>> 0 < $0 >>> 0) {
   $2 = $0;
   break label$2;
  }
  $2 = $0;
  while (1) {
   HEAP8[$2 | 0] = HEAPU8[$1 | 0];
   HEAP8[$2 + 1 | 0] = HEAPU8[$1 + 1 | 0];
   HEAP8[$2 + 2 | 0] = HEAPU8[$1 + 2 | 0];
   HEAP8[$2 + 3 | 0] = HEAPU8[$1 + 3 | 0];
   $1 = $1 + 4 | 0;
   $2 = $2 + 4 | 0;
   if ($3 >>> 0 >= $2 >>> 0) {
    continue;
   }
   break;
  }
 }
 if ($2 >>> 0 < $4 >>> 0) {
  while (1) {
   HEAP8[$2 | 0] = HEAPU8[$1 | 0];
   $1 = $1 + 1 | 0;
   $2 = $2 + 1 | 0;
   if (($4 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
 }
 return $0;
}
function silk_VQ_WMat_EC_c($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) {
 var $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0;
 $12 = HEAP32[$5 + 8 >> 2];
 $13 = HEAP32[$5 + 4 >> 2];
 $15 = HEAP32[$5 >> 2];
 $14 = HEAP32[$5 + 12 >> 2];
 $5 = HEAP32[$5 + 16 >> 2];
 HEAP32[$2 >> 2] = 2147483647;
 HEAP32[$1 >> 2] = 2147483647;
 HEAP8[$0 | 0] = 0;
 if (($11 | 0) >= 1) {
  $17 = $5 << 8;
  $18 = $14 << 7;
  $19 = $15 << 7;
  $20 = $13 << 7;
  $21 = $12 << 7;
  $22 = $9 << 16 >> 16;
  $15 = 0;
  while (1) {
   $14 = HEAP8[$6 | 0];
   $13 = HEAP8[$6 + 1 | 0];
   $12 = HEAP8[$6 + 2 | 0];
   $9 = HEAP8[$6 + 3 | 0];
   $5 = HEAP8[$6 + 4 | 0];
   $16 = Math_imul($14, HEAP32[$4 >> 2]) + ((((Math_imul($13, HEAP32[$4 + 4 >> 2]) - $19 | 0) + Math_imul($12, HEAP32[$4 + 8 >> 2]) | 0) + Math_imul($9, HEAP32[$4 + 12 >> 2]) | 0) + Math_imul($5, HEAP32[$4 + 16 >> 2]) << 1) | 0;
   $16 = Math_imul($16 >> 16, $14) + (Math_imul($16 & 65535, $14) >> 16) | 0;
   $14 = Math_imul(HEAP32[$4 + 24 >> 2], $13) + (((Math_imul(HEAP32[$4 + 28 >> 2], $12) - $20 | 0) + Math_imul(HEAP32[$4 + 32 >> 2], $9) | 0) + Math_imul(HEAP32[$4 + 36 >> 2], $5) << 1) | 0;
   $14 = ($16 + Math_imul($14 >> 16, $13) | 0) + (Math_imul($14 & 65535, $13) >> 16) | 0;
   $13 = Math_imul(HEAP32[$4 + 48 >> 2], $12) + ((Math_imul(HEAP32[$4 + 52 >> 2], $9) - $21 | 0) + Math_imul(HEAP32[$4 + 56 >> 2], $5) << 1) | 0;
   $14 = ($14 + Math_imul($13 >> 16, $12) | 0) + (Math_imul($13 & 65535, $12) >> 16) | 0;
   $12 = Math_imul(HEAP32[$4 + 96 >> 2], $5) - $17 | 0;
   $13 = Math_imul(HEAP32[$4 + 72 >> 2], $9) + (Math_imul(HEAP32[$4 + 76 >> 2], $5) - $18 << 1) | 0;
   $5 = (((($14 + Math_imul($12 >> 16, $5) | 0) + Math_imul($13 >> 16, $9) | 0) + (Math_imul($12 & 65535, $5) >> 16) | 0) + (Math_imul($13 & 65535, $9) >> 16) | 0) + 32801 | 0;
   label$3 : {
    if (($5 | 0) < 0) {
     break label$3;
    }
    $12 = HEAPU8[$7 + $15 | 0];
    $9 = $12 - $10 | 0;
    $5 = ((($9 | 0) > 0 ? $9 : 0) << 11) + $5 | 0;
    $9 = Math_imul((silk_lin2log($5) << 16) - 125829120 >> 16, $22) + (HEAPU8[$8 + $15 | 0] << 2) | 0;
    if (($9 | 0) > HEAP32[$2 >> 2]) {
     break label$3;
    }
    HEAP32[$2 >> 2] = $9;
    HEAP32[$1 >> 2] = $5;
    HEAP8[$0 | 0] = $15;
    HEAP32[$3 >> 2] = $12;
   }
   $6 = $6 + 5 | 0;
   $15 = $15 + 1 | 0;
   if (($15 | 0) != ($11 | 0)) {
    continue;
   }
   break;
  }
 }
}
function silk_quant_LTP_gains($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 $11 = __stack_pointer - 16 | 0;
 __stack_pointer = $11;
 $19 = ($8 | 0) < 1;
 $18 = 2147483647;
 while (1) {
  $12 = HEAP32[$3 >> 2];
  label$2 : {
   if ($19) {
    $16 = 0;
    $15 = 0;
    $9 = $12;
    break label$2;
   }
   $20 = HEAP8[$17 + 7916 | 0];
   $10 = $17 << 2;
   $21 = HEAP32[$10 + 7904 >> 2];
   $22 = HEAP32[$10 + 7824 >> 2];
   $23 = HEAP32[$10 + 7520 >> 2];
   $10 = 0;
   $15 = 0;
   $16 = 0;
   $13 = $6;
   $14 = $5;
   while (1) {
    silk_VQ_WMat_EC_c(($11 + 12 | 0) + $10 | 0, $11 + 8 | 0, $11 + 4 | 0, $11, $14, $13, $22, $21, $23, $7, silk_log2lin(6229 - $12 | 0) - 51 | 0, $20);
    $15 = HEAP32[$11 + 4 >> 2] + $15 | 0;
    $24 = ($15 | 0) > -1;
    $16 = HEAP32[$11 + 8 >> 2] + $16 | 0;
    $25 = ($16 | 0) > -1;
    $9 = 0;
    if ((silk_lin2log(HEAP32[$11 >> 2] + 51 | 0) + $12 | 0) >= 896) {
     $9 = (silk_lin2log(HEAP32[$11 >> 2] + 51 | 0) + $12 | 0) - 896 | 0;
    }
    $15 = $24 ? $15 : 2147483647;
    $16 = $25 ? $16 : 2147483647;
    $13 = $13 + 20 | 0;
    $14 = $14 + 100 | 0;
    $12 = $9;
    $10 = $10 + 1 | 0;
    if (($10 | 0) != ($8 | 0)) {
     continue;
    }
    break;
   }
  }
  if (($15 | 0) <= ($18 | 0)) {
   HEAP8[$2 | 0] = $17;
   memcpy($1, $11 + 12 | 0, $8);
   $26 = $9;
   $18 = $15;
  }
  $17 = $17 + 1 | 0;
  if (($17 | 0) != 3) {
   continue;
  }
  break;
 }
 if (($8 | 0) >= 1) {
  $12 = HEAP32[(HEAP8[$2 | 0] << 2) + 7824 >> 2];
  $14 = 0;
  while (1) {
   $10 = Math_imul($14, 10) + $0 | 0;
   $13 = $1 + $14 | 0;
   HEAP16[$10 >> 1] = HEAP8[Math_imul(HEAP8[$13 | 0], 5) + $12 | 0] << 7;
   HEAP16[$10 + 2 >> 1] = HEAP8[(Math_imul(HEAP8[$13 | 0], 5) + $12 | 0) + 1 | 0] << 7;
   HEAP16[$10 + 4 >> 1] = HEAP8[(Math_imul(HEAP8[$13 | 0], 5) + $12 | 0) + 2 | 0] << 7;
   HEAP16[$10 + 6 >> 1] = HEAP8[(Math_imul(HEAP8[$13 | 0], 5) + $12 | 0) + 3 | 0] << 7;
   HEAP16[$10 + 8 >> 1] = HEAP8[(Math_imul(HEAP8[$13 | 0], 5) + $12 | 0) + 4 | 0] << 7;
   $14 = $14 + 1 | 0;
   if (($14 | 0) != ($8 | 0)) {
    continue;
   }
   break;
  }
 }
 HEAP32[$3 >> 2] = $26;
 HEAP32[$4 >> 2] = Math_imul((silk_lin2log($16 >> (($8 | 0) == 2 ? 1 : 2)) << 16) - 125829120 >> 16, -3);
 __stack_pointer = $11 + 16 | 0;
}
function silk_insertion_sort_decreasing_FLP($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = Math_fround(0), $10 = Math_fround(0), $11 = 0;
 label$1 : {
  label$2 : {
   if (($3 | 0) > 0) {
    if (($2 | 0) <= 0) {
     break label$2;
    }
    if (($2 | 0) < ($3 | 0)) {
     break label$1;
    }
    while (1) {
     HEAP32[($4 << 2) + $1 >> 2] = $4;
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($3 | 0)) {
      continue;
     }
     break;
    }
    $6 = 1;
    if (($3 | 0) > 1) {
     while (1) {
      $9 = HEAPF32[($6 << 2) + $0 >> 2];
      $4 = $6;
      label$7 : {
       while (1) {
        $7 = $4 - 1 | 0;
        $5 = $7 << 2;
        $10 = HEAPF32[$5 + $0 >> 2];
        if ($10 < $9 ^ 1) {
         break label$7;
        }
        $8 = $4 << 2;
        HEAPF32[$8 + $0 >> 2] = $10;
        HEAP32[$1 + $8 >> 2] = HEAP32[$1 + $5 >> 2];
        $5 = ($4 | 0) > 1;
        $4 = $7;
        if ($5) {
         continue;
        }
        break;
       }
       $4 = 0;
      }
      $4 = $4 << 2;
      HEAPF32[$4 + $0 >> 2] = $9;
      HEAP32[$1 + $4 >> 2] = $6;
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($3 | 0)) {
       continue;
      }
      break;
     }
    }
    if (($2 | 0) > ($3 | 0)) {
     $6 = $3 - 2 | 0;
     $11 = (($3 << 2) + $0 | 0) - 4 | 0;
     $8 = $3;
     while (1) {
      $9 = HEAPF32[($8 << 2) + $0 >> 2];
      if (!($9 > HEAPF32[$11 >> 2] ^ 1)) {
       $4 = $6;
       $5 = $4;
       label$12 : {
        if (($3 | 0) < 2) {
         break label$12;
        }
        while (1) {
         $7 = $4 << 2;
         $10 = HEAPF32[$7 + $0 >> 2];
         if ($10 < $9 ^ 1) {
          $5 = $4;
          break label$12;
         }
         $5 = $7 + 4 | 0;
         HEAPF32[$5 + $0 >> 2] = $10;
         HEAP32[$1 + $5 >> 2] = HEAP32[$1 + $7 >> 2];
         $5 = -1;
         $7 = ($4 | 0) > 0;
         $4 = $4 - 1 | 0;
         if ($7) {
          continue;
         }
         break;
        }
       }
       $4 = ($5 << 2) + 4 | 0;
       HEAPF32[$4 + $0 >> 2] = $9;
       HEAP32[$1 + $4 >> 2] = $8;
      }
      $8 = $8 + 1 | 0;
      if (($8 | 0) != ($2 | 0)) {
       continue;
      }
      break;
     }
    }
    return;
   }
   celt_fatal(9912, 9936, 50);
   abort();
  }
  celt_fatal(9958, 9936, 51);
  abort();
 }
 celt_fatal(9982, 9936, 52);
 abort();
}
function silk_insertion_sort_increasing($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 label$1 : {
  label$2 : {
   if (($3 | 0) > 0) {
    if (($2 | 0) <= 0) {
     break label$2;
    }
    if (($2 | 0) < ($3 | 0)) {
     break label$1;
    }
    while (1) {
     HEAP32[($4 << 2) + $1 >> 2] = $4;
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($3 | 0)) {
      continue;
     }
     break;
    }
    $6 = 1;
    if (($3 | 0) > 1) {
     while (1) {
      $7 = HEAP32[($6 << 2) + $0 >> 2];
      $4 = $6;
      label$7 : {
       while (1) {
        $8 = $4 - 1 | 0;
        $5 = $8 << 2;
        $10 = HEAP32[$5 + $0 >> 2];
        if (($10 | 0) <= ($7 | 0)) {
         break label$7;
        }
        $9 = $4 << 2;
        HEAP32[$9 + $0 >> 2] = $10;
        HEAP32[$1 + $9 >> 2] = HEAP32[$1 + $5 >> 2];
        $5 = ($4 | 0) > 1;
        $4 = $8;
        if ($5) {
         continue;
        }
        break;
       }
       $4 = 0;
      }
      $4 = $4 << 2;
      HEAP32[$4 + $0 >> 2] = $7;
      HEAP32[$1 + $4 >> 2] = $6;
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($3 | 0)) {
       continue;
      }
      break;
     }
    }
    if (($2 | 0) > ($3 | 0)) {
     $6 = $3 - 2 | 0;
     $11 = (($3 << 2) + $0 | 0) - 4 | 0;
     $7 = $3;
     while (1) {
      $9 = HEAP32[($7 << 2) + $0 >> 2];
      if (($9 | 0) < HEAP32[$11 >> 2]) {
       $4 = $6;
       $5 = $4;
       label$12 : {
        if (($3 | 0) < 2) {
         break label$12;
        }
        while (1) {
         $8 = $4 << 2;
         $5 = HEAP32[$8 + $0 >> 2];
         if (($9 | 0) >= ($5 | 0)) {
          $5 = $4;
          break label$12;
         }
         $10 = $8 + 4 | 0;
         HEAP32[$10 + $0 >> 2] = $5;
         HEAP32[$1 + $10 >> 2] = HEAP32[$1 + $8 >> 2];
         $5 = -1;
         $8 = ($4 | 0) > 0;
         $4 = $4 - 1 | 0;
         if ($8) {
          continue;
         }
         break;
        }
       }
       $4 = ($5 << 2) + 4 | 0;
       HEAP32[$4 + $0 >> 2] = $9;
       HEAP32[$1 + $4 >> 2] = $7;
      }
      $7 = $7 + 1 | 0;
      if (($7 | 0) != ($2 | 0)) {
       continue;
      }
      break;
     }
    }
    return;
   }
   celt_fatal(15635, 15659, 51);
   abort();
  }
  celt_fatal(15671, 15659, 52);
  abort();
 }
 celt_fatal(15695, 15659, 53);
 abort();
}
function silk_stereo_quant_pred($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 $13 = 1;
 while (1) {
  $10 = ($4 << 2) + $0 | 0;
  $7 = Math_imul($4, 3) + $1 | 0;
  $11 = $7;
  $3 = 2147483647;
  $4 = 0;
  label$2 : {
   label$3 : {
    while (1) {
     $14 = $4 + 1 | 0;
     $6 = HEAP16[($4 << 1) + 5744 >> 1];
     $5 = HEAP16[($14 << 1) + 5744 >> 1] - $6 | 0;
     $15 = Math_imul($5 & 65535, 6554) >>> 16 | 0;
     $16 = $5 >> 16;
     $5 = Math_imul($16, 6554) + $15 | 0;
     $12 = $5 + $6 | 0;
     $2 = HEAP32[$10 >> 2] - $12 | 0;
     $8 = $2;
     $2 = $2 >> 31;
     $2 = $2 ^ $2 + $8;
     if (($2 | 0) >= ($3 | 0)) {
      $4 = HEAPU8[$7 | 0];
      break label$2;
     }
     HEAP8[$7 | 0] = $4;
     HEAP8[$11 + 1 | 0] = 0;
     $9 = Math_imul($5, 3) + $6 | 0;
     $3 = HEAP32[$10 >> 2] - $9 | 0;
     $8 = $3;
     $3 = $3 >> 31;
     $3 = $3 ^ $3 + $8;
     if (($2 | 0) <= ($3 | 0)) {
      $9 = $12;
      break label$2;
     }
     HEAP8[$7 | 0] = $4;
     HEAP8[$11 + 1 | 0] = 1;
     $17 = Math_imul($5, 5) + $6 | 0;
     $2 = HEAP32[$10 >> 2] - $17 | 0;
     $8 = $2;
     $2 = $2 >> 31;
     $2 = $2 ^ $2 + $8;
     if (($2 | 0) >= ($3 | 0)) {
      break label$2;
     }
     HEAP8[$7 | 0] = $4;
     HEAP8[$11 + 1 | 0] = 2;
     $9 = Math_imul($5, 7) + $6 | 0;
     $3 = HEAP32[$10 >> 2] - $9 | 0;
     $8 = $3;
     $3 = $3 >> 31;
     $12 = $3 ^ $3 + $8;
     if (($12 | 0) >= ($2 | 0)) {
      break label$3;
     }
     HEAP8[$7 | 0] = $4;
     HEAP8[$11 + 1 | 0] = 3;
     $5 = HEAP32[$10 >> 2] - (Math_imul($5, 9) + $6 | 0) | 0;
     $2 = $5;
     $5 = $5 >> 31;
     $3 = $5 ^ $5 + $2;
     if (($12 | 0) <= ($3 | 0)) {
      break label$2;
     }
     $9 = (Math_imul($16, 58986) + Math_imul($15, 9) | 0) + $6 | 0;
     HEAP8[$7 | 0] = $4;
     HEAP8[$11 + 1 | 0] = 4;
     $4 = $14;
     if (($4 | 0) != 15) {
      continue;
     }
     break;
    }
    $4 = 14;
    break label$2;
   }
   $9 = $17;
  }
  $6 = ($4 << 24 >> 24) / 3 | 0;
  HEAP8[$7 + 2 | 0] = $6;
  HEAP8[$7 | 0] = Math_imul($6, -3) + $4;
  HEAP32[$10 >> 2] = $9;
  $4 = 1;
  $6 = $13;
  $13 = 0;
  if ($6) {
   continue;
  }
  break;
 }
 HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - HEAP32[$0 + 4 >> 2];
}
function quant_energy_finalise($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = Math_fround(0), $17 = 0, $18 = 0, $19 = 0;
 $17 = ($9 | 0) > 1 ? $9 : 1;
 $18 = ($1 | 0) >= ($2 | 0);
 label$1 : {
  if ($18 | ($7 | 0) < ($9 | 0)) {
   break label$1;
  }
  $11 = $1;
  while (1) {
   $10 = $11 << 2;
   $19 = $10 + $5 | 0;
   if (!(HEAP32[$19 >> 2] > 7 | HEAP32[$6 + $10 >> 2])) {
    $12 = HEAP32[$0 + 8 >> 2];
    $10 = 0;
    while (1) {
     $13 = HEAPF32[(Math_imul($10, $12) + $11 << 2) + $4 >> 2] < Math_fround(0);
     ec_enc_bits($8, $13 ^ 1, 1);
     $12 = HEAP32[$0 + 8 >> 2];
     $14 = Math_imul($12, $10) + $11 << 2;
     $15 = $14 + $3 | 0;
     $16 = Math_fround(Math_fround(($13 ? Math_fround(-.5) : Math_fround(.5)) * Math_fround(1 << 13 - HEAP32[$19 >> 2])) * Math_fround(6103515625e-14));
     HEAPF32[$15 >> 2] = HEAPF32[$15 >> 2] + $16;
     $13 = $4 + $14 | 0;
     HEAPF32[$13 >> 2] = HEAPF32[$13 >> 2] - $16;
     $10 = $10 + 1 | 0;
     if (($17 | 0) != ($10 | 0)) {
      continue;
     }
     break;
    }
    $7 = $7 - $17 | 0;
   }
   $11 = $11 + 1 | 0;
   if (($11 | 0) >= ($2 | 0)) {
    break label$1;
   }
   if (($7 | 0) >= ($9 | 0)) {
    continue;
   }
   break;
  }
 }
 label$5 : {
  if (($7 | 0) < ($9 | 0) | $18) {
   break label$5;
  }
  while (1) {
   $10 = $1 << 2;
   $15 = $10 + $5 | 0;
   if (!(HEAP32[$15 >> 2] > 7 | HEAP32[$6 + $10 >> 2] != 1)) {
    $11 = HEAP32[$0 + 8 >> 2];
    $10 = 0;
    while (1) {
     $12 = HEAPF32[(Math_imul($10, $11) + $1 << 2) + $4 >> 2] < Math_fround(0);
     ec_enc_bits($8, $12 ^ 1, 1);
     $11 = HEAP32[$0 + 8 >> 2];
     $13 = Math_imul($11, $10) + $1 << 2;
     $14 = $13 + $3 | 0;
     $16 = Math_fround(Math_fround(($12 ? Math_fround(-.5) : Math_fround(.5)) * Math_fround(1 << 13 - HEAP32[$15 >> 2])) * Math_fround(6103515625e-14));
     HEAPF32[$14 >> 2] = HEAPF32[$14 >> 2] + $16;
     $12 = $4 + $13 | 0;
     HEAPF32[$12 >> 2] = HEAPF32[$12 >> 2] - $16;
     $10 = $10 + 1 | 0;
     if (($17 | 0) != ($10 | 0)) {
      continue;
     }
     break;
    }
    $7 = $7 - $17 | 0;
   }
   $1 = $1 + 1 | 0;
   if (($2 | 0) <= ($1 | 0)) {
    break label$5;
   }
   if (($7 | 0) >= ($9 | 0)) {
    continue;
   }
   break;
  }
 }
}



function silk_resampler_private_IIR_FIR($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $6 = __stack_pointer;
 $11 = $6;
 $4 = HEAP32[$0 + 268 >> 2];
 $7 = $6 - (($4 << 2) + 31 & -16) | 0;
 __stack_pointer = $7;
 $6 = HEAP32[$0 + 36 >> 2];
 $5 = HEAP32[$0 + 32 >> 2];
 HEAP32[$7 + 8 >> 2] = $5;
 HEAP32[$7 + 12 >> 2] = $6;
 $5 = HEAP32[$0 + 28 >> 2];
 $6 = HEAP32[$0 + 24 >> 2];
 HEAP32[$7 >> 2] = $6;
 HEAP32[$7 + 4 >> 2] = $5;
 $12 = $7 + 16 | 0;
 $13 = HEAP32[$0 + 272 >> 2];
 while (1) {
  $8 = ($3 | 0) < ($4 | 0) ? $3 : $4;
  silk_resampler_private_up2_HQ($0, $12, $2, $8);
  $6 = 0;
  $9 = $8 << 17;
  if (($9 | 0) >= 1) {
   while (1) {
    $10 = Math_imul($6 & 65535, 12) >>> 16 | 0;
    $5 = $10 << 3;
    $4 = ($6 >> 16 << 1) + $7 | 0;
    $14 = ((Math_imul(HEAP16[$5 + 6306 >> 1], HEAP16[$4 + 2 >> 1]) + Math_imul(HEAP16[$5 + 6304 >> 1], HEAP16[$4 >> 1]) | 0) + Math_imul(HEAP16[$5 + 6308 >> 1], HEAP16[$4 + 4 >> 1]) | 0) + Math_imul(HEAP16[$5 + 6310 >> 1], HEAP16[$4 + 6 >> 1]) | 0;
    $5 = 11 - $10 << 3;
    $4 = ((($14 + Math_imul(HEAP16[$5 + 6310 >> 1], HEAP16[$4 + 8 >> 1]) | 0) + Math_imul(HEAP16[$5 + 6308 >> 1], HEAP16[$4 + 10 >> 1]) | 0) + Math_imul(HEAP16[$5 + 6306 >> 1], HEAP16[$4 + 12 >> 1]) | 0) + Math_imul(HEAP16[$5 + 6304 >> 1], HEAP16[$4 + 14 >> 1]) | 0;
    $5 = ($4 >> 14) + 1 >> 1;
    HEAP16[$1 >> 1] = ($4 | 0) > 1073725439 ? 32767 : ($5 | 0) > -32768 ? $5 : -32768;
    $1 = $1 + 2 | 0;
    $6 = $6 + $13 | 0;
    if (($9 | 0) > ($6 | 0)) {
     continue;
    }
    break;
   }
  }
  $3 = $3 - $8 | 0;
  if (($3 | 0) >= 1) {
   $4 = ($8 << 2) + $7 | 0;
   $6 = HEAP32[$4 + 4 >> 2];
   $5 = HEAP32[$4 >> 2];
   HEAP32[$7 >> 2] = $5;
   HEAP32[$7 + 4 >> 2] = $6;
   $5 = HEAP32[$4 + 12 >> 2];
   $6 = HEAP32[$4 + 8 >> 2];
   HEAP32[$7 + 8 >> 2] = $6;
   HEAP32[$7 + 12 >> 2] = $5;
   $2 = ($8 << 1) + $2 | 0;
   $4 = HEAP32[$0 + 268 >> 2];
   continue;
  }
  break;
 }
 $4 = ($8 << 2) + $7 | 0;
 $6 = HEAP32[$4 + 4 >> 2];
 $5 = HEAP32[$4 >> 2];
 HEAP32[$0 + 24 >> 2] = $5;
 HEAP32[$0 + 28 >> 2] = $6;
 $5 = HEAP32[$4 + 12 >> 2];
 $6 = HEAP32[$4 + 8 >> 2];
 HEAP32[$0 + 32 >> 2] = $6;
 HEAP32[$0 + 36 >> 2] = $5;
 __stack_pointer = $11;
}
function silk_shell_encoder($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $2 = HEAP32[$1 + 4 >> 2] + HEAP32[$1 >> 2] | 0;
 $9 = HEAP32[$1 + 12 >> 2] + HEAP32[$1 + 8 >> 2] | 0;
 $3 = $2 + $9 | 0;
 $4 = HEAP32[$1 + 20 >> 2] + HEAP32[$1 + 16 >> 2] | 0;
 $10 = HEAP32[$1 + 28 >> 2] + HEAP32[$1 + 24 >> 2] | 0;
 $11 = $4 + $10 | 0;
 $5 = $3 + $11 | 0;
 $6 = HEAP32[$1 + 36 >> 2] + HEAP32[$1 + 32 >> 2] | 0;
 $12 = HEAP32[$1 + 44 >> 2] + HEAP32[$1 + 40 >> 2] | 0;
 $7 = $6 + $12 | 0;
 $8 = HEAP32[$1 + 52 >> 2] + HEAP32[$1 + 48 >> 2] | 0;
 $13 = HEAP32[$1 + 60 >> 2] + HEAP32[$1 + 56 >> 2] | 0;
 $14 = $8 + $13 | 0;
 $15 = $7 + $14 | 0;
 $16 = $5 + $15 | 0;
 if (($16 | 0) >= 1) {
  ec_enc_icdf($0, $5, HEAPU8[$16 + 9200 | 0] + 9040 | 0, 8);
 }
 if (($5 | 0) >= 1) {
  ec_enc_icdf($0, $3, HEAPU8[$5 + 9200 | 0] + 8880 | 0, 8);
 }
 if (($3 | 0) >= 1) {
  ec_enc_icdf($0, $2, HEAPU8[$3 + 9200 | 0] + 8720 | 0, 8);
 }
 if (($2 | 0) >= 1) {
  ec_enc_icdf($0, HEAP32[$1 >> 2], HEAPU8[$2 + 9200 | 0] + 8560 | 0, 8);
 }
 if (($9 | 0) >= 1) {
  ec_enc_icdf($0, HEAP32[$1 + 8 >> 2], HEAPU8[$9 + 9200 | 0] + 8560 | 0, 8);
 }
 if (($11 | 0) >= 1) {
  ec_enc_icdf($0, $4, HEAPU8[$11 + 9200 | 0] + 8720 | 0, 8);
 }
 if (($4 | 0) >= 1) {
  ec_enc_icdf($0, HEAP32[$1 + 16 >> 2], HEAPU8[$4 + 9200 | 0] + 8560 | 0, 8);
 }
 if (($10 | 0) >= 1) {
  ec_enc_icdf($0, HEAP32[$1 + 24 >> 2], HEAPU8[$10 + 9200 | 0] + 8560 | 0, 8);
 }
 if (($15 | 0) >= 1) {
  ec_enc_icdf($0, $7, HEAPU8[$15 + 9200 | 0] + 8880 | 0, 8);
 }
 if (($7 | 0) >= 1) {
  ec_enc_icdf($0, $6, HEAPU8[$7 + 9200 | 0] + 8720 | 0, 8);
 }
 if (($6 | 0) >= 1) {
  ec_enc_icdf($0, HEAP32[$1 + 32 >> 2], HEAPU8[$6 + 9200 | 0] + 8560 | 0, 8);
 }
 if (($12 | 0) >= 1) {
  ec_enc_icdf($0, HEAP32[$1 + 40 >> 2], HEAPU8[$12 + 9200 | 0] + 8560 | 0, 8);
 }
 if (($14 | 0) >= 1) {
  ec_enc_icdf($0, $8, HEAPU8[$14 + 9200 | 0] + 8720 | 0, 8);
 }
 if (($8 | 0) >= 1) {
  ec_enc_icdf($0, HEAP32[$1 + 48 >> 2], HEAPU8[$8 + 9200 | 0] + 8560 | 0, 8);
 }
 if (($13 | 0) >= 1) {
  ec_enc_icdf($0, HEAP32[$1 + 56 >> 2], HEAPU8[$13 + 9200 | 0] + 8560 | 0, 8);
 }
}
function silk_process_NLSFs($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $5 = __stack_pointer - 96 | 0;
 __stack_pointer = $5;
 label$1 : {
  label$2 : {
   if (!(HEAPU8[$0 + 4767 | 0] != 4 ? HEAP32[$0 + 4632 >> 2] != 1 : 0)) {
    $4 = HEAP16[$0 + 4532 >> 1];
    $4 = (Math_imul($4, -5) + (Math_imul($4, 59246) >> 16) | 0) + 3146 | 0;
    $6 = $4 + (HEAP32[$0 + 4580 >> 2] == 2 ? $4 >> 1 : 0) | 0;
    if (($6 | 0) <= 0) {
     break label$2;
    }
    silk_NLSF_VQ_weights_laroia($5 + 32 | 0, $2, HEAP32[$0 + 4640 >> 2]);
    label$5 : {
     if (HEAP32[$0 + 4632 >> 2] != 1) {
      break label$5;
     }
     $4 = HEAP8[$0 + 4767 | 0];
     if (($4 | 0) > 3) {
      break label$5;
     }
     silk_interpolate($5 - -64 | 0, $3, $2, $4, HEAP32[$0 + 4640 >> 2]);
     silk_NLSF_VQ_weights_laroia($5, $5 - -64 | 0, HEAP32[$0 + 4640 >> 2]);
     $10 = 1;
     $7 = HEAP32[$0 + 4640 >> 2];
     if (($7 | 0) < 1) {
      break label$5;
     }
     $4 = HEAP8[$0 + 4767 | 0];
     $11 = Math_imul($4, $4) << 27 >> 16;
     $4 = 0;
     while (1) {
      $8 = $4 << 1;
      $9 = $8 + ($5 + 32 | 0) | 0;
      HEAP16[$9 >> 1] = (HEAP16[$9 >> 1] >>> 1) + (Math_imul(HEAP16[$5 + $8 >> 1], $11) >>> 16);
      $4 = $4 + 1 | 0;
      if (($7 | 0) != ($4 | 0)) {
       continue;
      }
      break;
     }
    }
    silk_NLSF_encode($0 + 4744 | 0, $2, HEAP32[$0 + 4692 >> 2], $5 + 32 | 0, $6, HEAP32[$0 + 4660 >> 2], HEAP8[$0 + 4765 | 0]);
    $4 = $1 + 32 | 0;
    silk_NLSF2A($4, $2, HEAP32[$0 + 4640 >> 2], HEAP32[$0 + 5092 >> 2]);
    label$7 : {
     if ($10) {
      silk_interpolate($5 - -64 | 0, $3, $2, HEAP8[$0 + 4767 | 0], HEAP32[$0 + 4640 >> 2]);
      silk_NLSF2A($1, $5 - -64 | 0, HEAP32[$0 + 4640 >> 2], HEAP32[$0 + 5092 >> 2]);
      break label$7;
     }
     $0 = HEAP32[$0 + 4640 >> 2];
     if (($0 | 0) >= 17) {
      break label$1;
     }
     memcpy($1, $4, $0 << 1);
    }
    __stack_pointer = $5 + 96 | 0;
    return;
   }
   celt_fatal(15848, 15951, 51);
   abort();
  }
  celt_fatal(15972, 15951, 63);
  abort();
 }
 celt_fatal(16006, 15951, 104);
 abort();
}
function encode_multiframe_packet($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0;
 $9 = __stack_pointer - 304 | 0;
 $12 = $9;
 __stack_pointer = $9;
 $14 = $2 - 1 | 0;
 $10 = ($2 | 0) == 2 ? 3 : ($14 << 1) + 2 | 0;
 if (!(HEAP32[$0 + 148 >> 2] | HEAP32[$0 + 164 >> 2] == -1)) {
  $11 = (Math_imul(HEAP32[$0 + 160 >> 2], 3) | 0) / ((Math_imul(HEAP32[$0 + 144 >> 2], 24) | 0) / (Math_imul($2, $3) | 0) | 0) | 0;
  $5 = ($5 | 0) > ($11 | 0) ? $11 : $5;
 }
 $10 = ($5 - $10 | 0) / ($2 | 0) | 0;
 $10 = ($10 | 0) < 1276 ? $10 + 1 | 0 : 1276;
 $15 = $9 - (Math_imul($10, $2) + 15 & -16) | 0;
 __stack_pointer = $15;
 opus_repacketizer_init($12);
 $18 = HEAP32[$0 + 136 >> 2];
 HEAP32[$0 + 136 >> 2] = HEAP32[$0 + 14224 >> 2];
 $19 = HEAP32[$0 + 128 >> 2];
 HEAP32[$0 + 128 >> 2] = HEAP32[$0 + 14240 >> 2];
 $20 = HEAP32[$0 + 120 >> 2];
 $9 = HEAP32[$0 + 14192 >> 2];
 HEAP32[$0 + 120 >> 2] = $9;
 $16 = HEAP32[$0 + 68 >> 2];
 label$2 : {
  if ($16) {
   HEAP32[$0 + 120 >> 2] = 1;
   break label$2;
  }
  HEAP32[$0 + 14232 >> 2] = $9;
 }
 label$4 : {
  if (($2 | 0) >= 1) {
   $9 = 0;
   while (1) {
    HEAP32[$0 + 68 >> 2] = 0;
    HEAP32[$0 + 18132 >> 2] = ($9 | 0) < ($14 | 0);
    if (!(!$6 | ($9 | 0) != ($14 | 0))) {
     HEAP32[$0 + 136 >> 2] = 1002;
    }
    $13 = -3;
    $11 = Math_imul($9, $10) + $15 | 0;
    $17 = opus_encode_native($0, (Math_imul(HEAP32[$0 + 112 >> 2], Math_imul($3, $9)) << 2) + $1 | 0, $3, $11, $10, $7, 0, 0, 0, 0, 0, 0, $8);
    if (($17 | 0) < 0) {
     break label$4;
    }
    if ((opus_repacketizer_cat($12, $11, $17) | 0) < 0) {
     break label$4;
    }
    $9 = $9 + 1 | 0;
    if (($9 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  $13 = opus_repacketizer_out_range_impl($12, 0, $2, $4, $5, 0, !HEAP32[$0 + 148 >> 2]);
  if (($13 | 0) < 0) {
   $13 = -3;
   break label$4;
  }
  HEAP32[$0 + 128 >> 2] = $19;
  HEAP32[$0 + 136 >> 2] = $18;
  HEAP32[$0 + 120 >> 2] = $20;
  HEAP32[$0 + 68 >> 2] = $16;
 }
 __stack_pointer = $12 + 304 | 0;
 return $13;
}
function log10($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 wasm2js_scratch_store_f64(+$0);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 $3 = wasm2js_scratch_load_i32(0) | 0;
 $5 = $2;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     if (($2 | 0) > 0 ? 1 : ($2 | 0) >= 0) {
      $1 = $5;
      if ($1 >>> 0 > 1048575) {
       break label$4;
      }
     }
     $2 = $5;
     $1 = $2 & 2147483647;
     if (!($1 | $3)) {
      return -1 / ($0 * $0);
     }
     $1 = $5;
     if (($1 | 0) > -1) {
      break label$3;
     }
     return ($0 - $0) / 0;
    }
    if ($1 >>> 0 > 2146435071) {
     break label$1;
    }
    $2 = 1072693248;
    $9 = -1023;
    if (($1 | 0) != 1072693248) {
     $2 = $1;
     break label$2;
    }
    if ($3) {
     break label$2;
    }
    return 0;
   }
   wasm2js_scratch_store_f64(+($0 * 0x40000000000000));
   $2 = wasm2js_scratch_load_i32(1) | 0;
   $3 = wasm2js_scratch_load_i32(0) | 0;
   $9 = -1077;
  }
  $1 = $2 + 614242 | 0;
  $10 = +(($1 >>> 20 | 0) + $9 | 0);
  $4 = $10 * .30102999566361177;
  $1 = ($1 & 1048575) + 1072079006 | 0;
  $2 = 0;
  $1 = $2 | $1;
  wasm2js_scratch_store_i32(0, $3 | 0);
  wasm2js_scratch_store_i32(1, $1 | 0);
  $0 = +wasm2js_scratch_load_f64() + -1;
  $7 = $0 * ($0 * .5);
  wasm2js_scratch_store_f64(+($0 - $7));
  $1 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  wasm2js_scratch_store_i32(0, 0);
  wasm2js_scratch_store_i32(1, $1 | 0);
  $8 = +wasm2js_scratch_load_f64();
  $6 = $8 * .4342944818781689;
  $11 = $4 + $6;
  $12 = $6 + ($4 - $11);
  $13 = $0 - $8 - $7;
  $0 = $0 / ($0 + 2);
  $6 = $0;
  $4 = $0 * $0;
  $0 = $4 * $4;
  $0 = $13 + $6 * ($7 + ($0 * ($0 * ($0 * .15313837699209373 + .22222198432149784) + .3999999999940942) + $4 * ($0 * ($0 * ($0 * .14798198605116586 + .1818357216161805) + .2857142874366239) + .6666666666666735)));
  $0 = $11 + ($12 + ($0 * .4342944818781689 + ($10 * 3.694239077158931e-13 + ($0 + $8) * 2.5082946711645275e-11)));
 }
 return $0;
}
function silk_LPC_fit($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $7 = $3 - $2 | 0;
 $10 = $7 - 1 | 0;
 $11 = ($4 | 0) < 1;
 label$1 : {
  label$2 : {
   while (1) {
    $3 = 0;
    $2 = 0;
    if (!$11) {
     while (1) {
      $6 = HEAP32[($3 << 2) + $1 >> 2];
      $8 = $6;
      $6 = $6 >> 31;
      $6 = $6 ^ $6 + $8;
      $8 = $6;
      $6 = ($2 | 0) < ($6 | 0);
      $2 = $6 ? $8 : $2;
      $5 = $6 ? $3 : $5;
      $3 = $3 + 1 | 0;
      if (($4 | 0) != ($3 | 0)) {
       continue;
      }
      break;
     }
    }
    $3 = ($7 | 0) == 1 ? ($2 & 1) + ($2 >> 1) | 0 : ($2 >> $10) + 1 >> 1;
    if (($3 | 0) >= 32768) {
     $3 = ($3 | 0) < 163838 ? $3 : 163838;
     silk_bwexpander_32($1, $4, 65470 - ((($3 << 14) - 536854528 | 0) / (Math_imul($5 + 1 | 0, $3) >> 2) | 0) | 0);
     $9 = $9 + 1 | 0;
     if (($9 | 0) != 10) {
      continue;
     }
     break label$2;
    }
    break;
   }
   if (($9 | 0) == 10) {
    break label$2;
   }
   $3 = 0;
   if (($4 | 0) <= 0) {
    break label$1;
   }
   $5 = ($7 | 0) != 1;
   while (1) {
    $2 = HEAP32[($3 << 2) + $1 >> 2];
    $2 = $5 ? ($2 >> $10) + 1 >> 1 : ($2 & 1) + ($2 >> 1) | 0;
    HEAP16[($3 << 1) + $0 >> 1] = $2;
    $3 = $3 + 1 | 0;
    if (($4 | 0) != ($3 | 0)) {
     continue;
    }
    break;
   }
   break label$1;
  }
  if (($4 | 0) < 1) {
   break label$1;
  }
  $3 = 0;
  $9 = ($7 | 0) != 1;
  while (1) {
   $6 = ($3 << 2) + $1 | 0;
   $5 = HEAP32[$6 >> 2];
   $8 = ($3 << 1) + $0 | 0;
   label$13 : {
    if (!$9) {
     $5 = ($5 & 1) + ($5 >> 1) | 0;
     $2 = 32767;
     if (($5 | 0) > 32767) {
      break label$13;
     }
     $2 = ($5 | 0) > -32768 ? $5 : -32768;
     break label$13;
    }
    $5 = $5 >> $10;
    $2 = 32767;
    if (($5 | 0) > 65534) {
     break label$13;
    }
    $2 = $5 + 1 >> 1;
    $2 = ($2 | 0) > -32768 ? $2 : -32768;
   }
   HEAP16[$8 >> 1] = $2;
   HEAP32[$6 >> 2] = $2 << 16 >> 16 << $7;
   $3 = $3 + 1 | 0;
   if (($4 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
 }
}
function silk_control_audio_bandwidth($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = HEAP32[$0 + 4576 >> 2];
 if (!$2) {
  $2 = HEAP32[$0 + 32 >> 2];
 }
 $3 = $2 << 16;
 if (!$3) {
  $2 = HEAP32[$0 + 4572 >> 2];
  $0 = HEAP32[$0 + 4556 >> 2];
  return ((($0 | 0) > ($2 | 0) ? $2 : $0) | 0) / 1e3 | 0;
 }
 $3 = Math_imul($3 >> 16, 1e3);
 $4 = HEAP32[$0 + 4556 >> 2];
 $5 = HEAP32[$0 + 4564 >> 2];
 if (!(HEAP32[$0 + 4568 >> 2] <= ($3 | 0) ? !(($3 | 0) > ($4 | 0) | ($5 | 0) < ($3 | 0)) : 0)) {
  $2 = ($4 | 0) < ($5 | 0) ? $4 : $5;
  $0 = HEAP32[$0 + 4568 >> 2];
  return ((($0 | 0) < ($2 | 0) ? $2 : $0) | 0) / 1e3 | 0;
 }
 $4 = HEAP32[$0 + 24 >> 2];
 if (($4 | 0) >= 256) {
  HEAP32[$0 + 28 >> 2] = 0;
 }
 label$7 : {
  label$8 : {
   if (HEAP32[$1 + 64 >> 2] ? 0 : !HEAP32[$0 + 4536 >> 2]) {
    break label$8;
   }
   $5 = HEAP32[$0 + 4572 >> 2];
   if (($5 | 0) < ($3 | 0)) {
    label$11 : {
     label$12 : {
      if (HEAP32[$0 + 28 >> 2]) {
       if (HEAP32[$1 + 64 >> 2]) {
        break label$12;
       }
       if (($4 | 0) > 0) {
        break label$11;
       }
       break label$7;
      }
      HEAP32[$0 + 16 >> 2] = 0;
      HEAP32[$0 + 20 >> 2] = 0;
      HEAP32[$0 + 24 >> 2] = 256;
      if (!HEAP32[$1 + 64 >> 2]) {
       break label$11;
      }
     }
     HEAP32[$0 + 28 >> 2] = 0;
     return ($2 | 0) == 16 ? 12 : 8;
    }
    HEAP32[$0 + 28 >> 2] = -2;
    return $2;
   }
   if (($3 | 0) < ($5 | 0)) {
    if (HEAP32[$1 + 64 >> 2]) {
     HEAP32[$0 + 16 >> 2] = 0;
     HEAP32[$0 + 20 >> 2] = 0;
     HEAP32[$0 + 24 >> 2] = 0;
     HEAP32[$0 + 28 >> 2] = 1;
     return ($2 | 0) == 8 ? 12 : 16;
    }
    if (!HEAP32[$0 + 28 >> 2]) {
     break label$7;
    }
    HEAP32[$0 + 28 >> 2] = 1;
    return $2;
   }
   if (HEAP32[$0 + 28 >> 2] > -1) {
    break label$8;
   }
   HEAP32[$0 + 28 >> 2] = 1;
  }
  return $2;
 }
 HEAP32[$1 + 88 >> 2] = 1;
 $0 = HEAP32[$1 + 56 >> 2];
 HEAP32[$1 + 56 >> 2] = $0 - ((Math_imul($0, 5) | 0) / (HEAP32[$1 + 24 >> 2] + 5 | 0) | 0);
 return $2;
}
function silk_A2NLSF_init($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $4 = $3 << 2;
 HEAP32[$4 + $1 >> 2] = 65536;
 HEAP32[$2 + $4 >> 2] = 65536;
 $4 = 0;
 label$1 : {
  if (($3 | 0) <= 0) {
   break label$1;
  }
  while (1) {
   $5 = $4 << 2;
   $6 = ($3 + $4 << 2) + $0 | 0;
   $7 = (($4 ^ -1) + $3 << 2) + $0 | 0;
   HEAP32[$5 + $1 >> 2] = 0 - (HEAP32[$6 >> 2] + HEAP32[$7 >> 2] | 0);
   HEAP32[$2 + $5 >> 2] = HEAP32[$6 >> 2] - HEAP32[$7 >> 2];
   $4 = $4 + 1 | 0;
   if (($4 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
  if (($3 | 0) <= 0) {
   break label$1;
  }
  $4 = $3;
  while (1) {
   $0 = $4 - 1 | 0;
   $5 = $0 << 2;
   $6 = $5 + $1 | 0;
   $7 = $6;
   $8 = HEAP32[$6 >> 2];
   $6 = $4 << 2;
   HEAP32[$7 >> 2] = $8 - HEAP32[$6 + $1 >> 2];
   $5 = $2 + $5 | 0;
   HEAP32[$5 >> 2] = HEAP32[$5 >> 2] + HEAP32[$2 + $6 >> 2];
   $5 = ($4 | 0) > 1;
   $4 = $0;
   if ($5) {
    continue;
   }
   break;
  }
  $7 = 2;
  if (($3 | 0) < 2) {
   break label$1;
  }
  while (1) {
   $4 = $3;
   if (($7 | 0) < ($4 | 0)) {
    while (1) {
     $0 = ($4 << 2) + $1 | 0;
     $5 = $0 - 8 | 0;
     HEAP32[$5 >> 2] = HEAP32[$5 >> 2] - HEAP32[$0 >> 2];
     $4 = $4 - 1 | 0;
     if (($7 | 0) < ($4 | 0)) {
      continue;
     }
     break;
    }
   }
   $6 = 2;
   $4 = ($7 << 2) + $1 | 0;
   $0 = $4 - 8 | 0;
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - (HEAP32[$4 >> 2] << 1);
   $4 = ($3 | 0) != ($7 | 0);
   $7 = $7 + 1 | 0;
   if ($4) {
    continue;
   }
   break;
  }
  while (1) {
   $4 = $3;
   if (($6 | 0) < ($4 | 0)) {
    while (1) {
     $0 = ($4 << 2) + $2 | 0;
     $5 = $0 - 8 | 0;
     HEAP32[$5 >> 2] = HEAP32[$5 >> 2] - HEAP32[$0 >> 2];
     $4 = $4 - 1 | 0;
     if (($6 | 0) < ($4 | 0)) {
      continue;
     }
     break;
    }
   }
   $4 = ($6 << 2) + $2 | 0;
   $0 = $4 - 8 | 0;
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - (HEAP32[$4 >> 2] << 1);
   $4 = ($3 | 0) != ($6 | 0);
   $6 = $6 + 1 | 0;
   if ($4) {
    continue;
   }
   break;
  }
 }
}
function resampler_basic_direct_double($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 $1 = $1 << 2;
 $16 = $1 + HEAP32[$0 + 64 >> 2] | 0;
 $9 = HEAP32[$16 >> 2];
 $17 = HEAP32[$0 + 60 >> 2] + $1 | 0;
 $6 = HEAP32[$17 >> 2];
 $18 = HEAP32[$3 >> 2];
 label$1 : {
  if (($6 | 0) >= ($18 | 0)) {
   break label$1;
  }
  $13 = HEAP32[$0 + 12 >> 2];
  $20 = HEAP32[$0 + 40 >> 2];
  $21 = HEAP32[$0 + 36 >> 2];
  $22 = HEAP32[$0 + 92 >> 2];
  $23 = HEAP32[$0 + 76 >> 2];
  $3 = HEAP32[$5 >> 2];
  $19 = ($3 | 0) > 0 ? $3 : 0;
  $14 = HEAP32[$0 + 24 >> 2];
  $24 = ($14 | 0) < 1;
  while (1) {
   if (($7 | 0) == ($19 | 0)) {
    $7 = $19;
    break label$1;
   }
   $15 = 0;
   label$4 : {
    if ($24) {
     $10 = 0;
     $11 = 0;
     $12 = 0;
     break label$4;
    }
    $3 = ($6 << 2) + $2 | 0;
    $1 = (Math_imul($9, $14) << 2) + $23 | 0;
    $5 = 0;
    $12 = 0;
    $11 = 0;
    $10 = 0;
    while (1) {
     $0 = $5 << 2;
     $10 = $10 + +Math_fround(HEAPF32[$1 + $0 >> 2] * HEAPF32[$0 + $3 >> 2]);
     $8 = $0 | 12;
     $15 = $15 + +Math_fround(HEAPF32[$8 + $1 >> 2] * HEAPF32[$3 + $8 >> 2]);
     $8 = $0 | 8;
     $12 = $12 + +Math_fround(HEAPF32[$8 + $1 >> 2] * HEAPF32[$3 + $8 >> 2]);
     $0 = $0 | 4;
     $11 = $11 + +Math_fround(HEAPF32[$1 + $0 >> 2] * HEAPF32[$0 + $3 >> 2]);
     $5 = $5 + 4 | 0;
     if (($14 | 0) > ($5 | 0)) {
      continue;
     }
     break;
    }
   }
   HEAPF32[(Math_imul($7, $22) << 2) + $4 >> 2] = $10 + $11 + $12 + $15;
   $0 = $9 + $20 | 0;
   $9 = $0 - ($0 >>> 0 < $13 >>> 0 ? 0 : $13) | 0;
   $7 = $7 + 1 | 0;
   $6 = ($6 + $21 | 0) + ($0 >>> 0 >= $13 >>> 0) | 0;
   if (($18 | 0) > ($6 | 0)) {
    continue;
   }
   break;
  }
 }
 HEAP32[$17 >> 2] = $6;
 HEAP32[$16 >> 2] = $9;
 return $7 | 0;
}
function silk_find_LPC_FLP($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = Math_fround(0), $9 = Math_fround(0), $10 = 0, $11 = 0, $12 = 0;
 $4 = __stack_pointer - 1696 | 0;
 __stack_pointer = $4;
 HEAP8[$0 + 4767 | 0] = 4;
 $6 = HEAP32[$0 + 4640 >> 2];
 $7 = $6 + HEAP32[$0 + 4588 >> 2] | 0;
 $8 = silk_burg_modified_FLP($4 + 1632 | 0, $2, $3, $7, HEAP32[$0 + 4580 >> 2], $6);
 label$1 : {
  if (HEAP32[$0 + 4664 >> 2] | !HEAP32[$0 + 4632 >> 2] | HEAP32[$0 + 4580 >> 2] != 4) {
   break label$1;
  }
  $5 = 3;
  $3 = silk_burg_modified_FLP($4 + 1536 | 0, ($7 << 3) + $2 | 0, $3, $7, 2, HEAP32[$0 + 4640 >> 2]);
  silk_A2NLSF_FLP($1, $4 + 1536 | 0, HEAP32[$0 + 4640 >> 2]);
  $10 = $0 + 4500 | 0;
  $11 = $7 << 1;
  $8 = Math_fround($8 - $3);
  $9 = Math_fround(3.4028234663852886e+38);
  while (1) {
   $6 = $5;
   silk_interpolate($4 + 1600 | 0, $10, $1, $6, HEAP32[$0 + 4640 >> 2]);
   silk_NLSF2A_FLP($4 + 1536 | 0, $4 + 1600 | 0, HEAP32[$0 + 4640 >> 2], HEAP32[$0 + 5092 >> 2]);
   silk_LPC_analysis_filter_FLP($4, $4 + 1536 | 0, $2, $11, HEAP32[$0 + 4640 >> 2]);
   $5 = HEAP32[$0 + 4640 >> 2];
   $12 = silk_energy_FLP(($5 << 2) + $4 | 0, $7 - $5 | 0);
   $5 = HEAP32[$0 + 4640 >> 2];
   $3 = Math_fround($12 + silk_energy_FLP((($5 << 2) + $4 | 0) + ($7 << 2) | 0, $7 - $5 | 0));
   label$3 : {
    if (!($8 > $3 ^ 1)) {
     HEAP8[$0 + 4767 | 0] = $6;
     $8 = $3;
     break label$3;
    }
    if ($3 > $9) {
     break label$1;
    }
   }
   $5 = $6 - 1 | 0;
   $9 = $3;
   if ($6) {
    continue;
   }
   break;
  }
 }
 label$5 : {
  if (HEAPU8[$0 + 4767 | 0] == 4) {
   silk_A2NLSF_FLP($1, $4 + 1632 | 0, HEAP32[$0 + 4640 >> 2]);
   if (HEAPU8[$0 + 4767 | 0] == 4) {
    break label$5;
   }
  }
  if (HEAP32[$0 + 4580 >> 2] == 4 ? !(HEAP32[$0 + 4664 >> 2] | !HEAP32[$0 + 4632 >> 2]) : 0) {
   break label$5;
  }
  celt_fatal(16554, 16719, 103);
  abort();
 }
 __stack_pointer = $4 + 1696 | 0;
}
function ec_enc_icdf($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = HEAP32[$0 + 28 >> 2];
 $3 = $4 >>> $3 | 0;
 $5 = $0;
 label$1 : {
  if (($1 | 0) >= 1) {
   $1 = $1 + $2 | 0;
   $2 = $1 - 1 | 0;
   HEAP32[$0 + 32 >> 2] = (HEAP32[$0 + 32 >> 2] + $4 | 0) - Math_imul(HEAPU8[$2 | 0], $3);
   $3 = Math_imul(HEAPU8[$2 | 0] - HEAPU8[$1 | 0] | 0, $3);
   break label$1;
  }
  $3 = $4 - Math_imul(HEAPU8[$1 + $2 | 0], $3) | 0;
 }
 HEAP32[$5 + 28 >> 2] = $3;
 if ($3 >>> 0 <= 8388608) {
  $1 = HEAP32[$0 + 32 >> 2];
  while (1) {
   $5 = $1 >>> 23 | 0;
   label$5 : {
    if (($5 | 0) != 255) {
     $3 = $1 >>> 31 | 0;
     $2 = HEAP32[$0 + 40 >> 2];
     if (($2 | 0) >= 0) {
      $1 = -1;
      $4 = HEAP32[$0 + 24 >> 2];
      if (HEAPU32[$0 + 4 >> 2] > $4 + HEAP32[$0 + 8 >> 2] >>> 0) {
       HEAP32[$0 + 24 >> 2] = $4 + 1;
       HEAP8[HEAP32[$0 >> 2] + $4 | 0] = $2 + $3;
       $1 = 0;
      }
      HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] | $1;
     }
     $1 = HEAP32[$0 + 36 >> 2];
     if ($1) {
      $4 = $3 - 1 | 0;
      while (1) {
       $3 = -1;
       $2 = HEAP32[$0 + 24 >> 2];
       if (HEAPU32[$0 + 4 >> 2] > $2 + HEAP32[$0 + 8 >> 2] >>> 0) {
        HEAP32[$0 + 24 >> 2] = $2 + 1;
        HEAP8[HEAP32[$0 >> 2] + $2 | 0] = $4;
        $3 = 0;
        $1 = HEAP32[$0 + 36 >> 2];
       }
       $1 = $1 - 1 | 0;
       HEAP32[$0 + 36 >> 2] = $1;
       HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] | $3;
       if ($1) {
        continue;
       }
       break;
      }
     }
     HEAP32[$0 + 40 >> 2] = $5 & 255;
     $3 = HEAP32[$0 + 28 >> 2];
     $1 = HEAP32[$0 + 32 >> 2];
     break label$5;
    }
    HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
   }
   $3 = $3 << 8;
   HEAP32[$0 + 28 >> 2] = $3;
   $1 = $1 << 8 & 2147483392;
   HEAP32[$0 + 32 >> 2] = $1;
   HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + 8;
   if ($3 >>> 0 < 8388609) {
    continue;
   }
   break;
  }
 }
}
function exp($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $4 = wasm2js_scratch_load_i32(0) | 0;
 $5 = $1 >>> 31 | 0;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     $3 = $0;
     label$5 : {
      label$6 : {
       $6 = $1;
       $1 = $6 & 2147483647;
       label$7 : {
        if ($1 >>> 0 >= 1082532651) {
         $4 = __DOUBLE_BITS($0);
         $6 = $4;
         $1 = i64toi32_i32$HIGH_BITS;
         $4 = $1 & 2147483647;
         $1 = $6;
         if (($4 | 0) == 2146435072 & ($1 | 0) != 0 | $4 >>> 0 > 2146435072) {
          return $0;
         }
         if (!($0 > 709.782712893384 ^ 1)) {
          return $0 * 8.98846567431158e+307;
         }
         if (!($0 < -745.1332191019411) | $0 < -708.3964185322641 ^ 1) {
          break label$7;
         }
         break label$2;
        }
        if ($1 >>> 0 < 1071001155) {
         break label$4;
        }
        if ($1 >>> 0 < 1072734898) {
         break label$6;
        }
       }
       $2 = $0 * 1.4426950408889634 + HEAPF64[($5 << 3) + 10928 >> 3];
       if (Math_abs($2) < 2147483648) {
        $1 = ~~$2;
        break label$5;
       }
       $1 = -2147483648;
       break label$5;
      }
      $1 = ($5 ^ 1) - $5 | 0;
     }
     $2 = +($1 | 0);
     $0 = $3 + $2 * -.6931471803691238;
     $7 = $2 * 1.9082149292705877e-10;
     $3 = $0 - $7;
     break label$3;
    }
    if ($1 >>> 0 <= 1043333120) {
     break label$1;
    }
    $1 = 0;
    $3 = $0;
   }
   $2 = $3 * $3;
   $2 = $3 - $2 * ($2 * ($2 * ($2 * ($2 * 4.1381367970572385e-8 + -16533902205465252e-22) + 6613756321437934e-20) + -.0027777777777015593) + .16666666666666602);
   $2 = $0 + ($3 * $2 / (2 - $2) - $7) + 1;
   if (!$1) {
    break label$2;
   }
   $2 = scalbn($2, $1);
  }
  return $2;
 }
 return $0 + 1;
}
function memmove($0, $1, $2) {
 var $3 = 0;
 label$1 : {
  if (($0 | 0) == ($1 | 0)) {
   break label$1;
  }
  if (($1 - $0 | 0) - $2 >>> 0 <= 0 - ($2 << 1) >>> 0) {
   return memcpy($0, $1, $2);
  }
  $3 = ($0 ^ $1) & 3;
  label$3 : {
   label$4 : {
    if ($0 >>> 0 < $1 >>> 0) {
     if ($3) {
      $3 = $0;
      break label$3;
     }
     if (!($0 & 3)) {
      $3 = $0;
      break label$4;
     }
     $3 = $0;
     while (1) {
      if (!$2) {
       break label$1;
      }
      HEAP8[$3 | 0] = HEAPU8[$1 | 0];
      $1 = $1 + 1 | 0;
      $2 = $2 - 1 | 0;
      $3 = $3 + 1 | 0;
      if ($3 & 3) {
       continue;
      }
      break;
     }
     break label$4;
    }
    label$9 : {
     if ($3) {
      break label$9;
     }
     if ($0 + $2 & 3) {
      while (1) {
       if (!$2) {
        break label$1;
       }
       $2 = $2 - 1 | 0;
       $3 = $2 + $0 | 0;
       HEAP8[$3 | 0] = HEAPU8[$1 + $2 | 0];
       if ($3 & 3) {
        continue;
       }
       break;
      }
     }
     if ($2 >>> 0 <= 3) {
      break label$9;
     }
     while (1) {
      $2 = $2 - 4 | 0;
      HEAP32[$2 + $0 >> 2] = HEAP32[$1 + $2 >> 2];
      if ($2 >>> 0 > 3) {
       continue;
      }
      break;
     }
    }
    if (!$2) {
     break label$1;
    }
    while (1) {
     $2 = $2 - 1 | 0;
     HEAP8[$2 + $0 | 0] = HEAPU8[$1 + $2 | 0];
     if ($2) {
      continue;
     }
     break;
    }
    break label$1;
   }
   if ($2 >>> 0 <= 3) {
    break label$3;
   }
   while (1) {
    HEAP32[$3 >> 2] = HEAP32[$1 >> 2];
    $1 = $1 + 4 | 0;
    $3 = $3 + 4 | 0;
    $2 = $2 - 4 | 0;
    if ($2 >>> 0 > 3) {
     continue;
    }
    break;
   }
  }
  if (!$2) {
   break label$1;
  }
  while (1) {
   HEAP8[$3 | 0] = HEAPU8[$1 | 0];
   $3 = $3 + 1 | 0;
   $1 = $1 + 1 | 0;
   $2 = $2 - 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
 return $0;
}
function silk_resampler_private_up2_HQ($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 if (($3 | 0) >= 1) {
  $9 = HEAP32[$0 + 20 >> 2];
  $7 = HEAP32[$0 + 16 >> 2];
  $4 = HEAP32[$0 + 12 >> 2];
  $6 = HEAP32[$0 + 8 >> 2];
  $8 = HEAP32[$0 + 4 >> 2];
  $5 = HEAP32[$0 >> 2];
  while (1) {
   $13 = HEAP16[($12 << 1) + $2 >> 1] << 10;
   $10 = $13 - $5 | 0;
   $10 = (Math_imul($10 & 65535, 1746) >>> 16 | 0) + Math_imul($10 >> 16, 1746) | 0;
   $14 = $10 + $5 | 0;
   $5 = $14 - $8 | 0;
   $15 = (Math_imul($5 & 65535, 14986) >>> 16 | 0) + Math_imul($5 >> 16, 14986) | 0;
   $5 = $15 + $8 | 0;
   $8 = $5 - $6 | 0;
   $11 = $12 << 2;
   $5 = (Math_imul($8 >> 16, -26453) + (Math_imul($8 & 65535, -26453) >> 16) | 0) + $5 | 0;
   $6 = ($5 >> 9) + 1 >> 1;
   HEAP16[$11 + $1 >> 1] = ($5 | 0) > 33553919 ? 32767 : ($6 | 0) > -32768 ? $6 : -32768;
   $18 = ($11 | 2) + $1 | 0;
   $6 = $13 - $4 | 0;
   $11 = (Math_imul($6 & 65535, 6854) >>> 16 | 0) + Math_imul($6 >> 16, 6854) | 0;
   $16 = $11 + $4 | 0;
   $4 = $16 - $7 | 0;
   $17 = (Math_imul($4 & 65535, 25769) >>> 16 | 0) + Math_imul($4 >> 16, 25769) | 0;
   $4 = $17 + $7 | 0;
   $7 = $4 - $9 | 0;
   $4 = (Math_imul($7 >> 16, -9994) + (Math_imul($7 & 65535, -9994) >> 16) | 0) + $4 | 0;
   $9 = ($4 >> 9) + 1 >> 1;
   HEAP16[$18 >> 1] = ($4 | 0) > 33553919 ? 32767 : ($9 | 0) > -32768 ? $9 : -32768;
   $9 = $4 + $7 | 0;
   $6 = $5 + $8 | 0;
   $7 = $16 + $17 | 0;
   $8 = $14 + $15 | 0;
   $4 = $13 + $11 | 0;
   $5 = $13 + $10 | 0;
   $12 = $12 + 1 | 0;
   if (($12 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
  HEAP32[$0 + 20 >> 2] = $9;
  HEAP32[$0 + 16 >> 2] = $7;
  HEAP32[$0 + 12 >> 2] = $4;
  HEAP32[$0 + 8 >> 2] = $6;
  HEAP32[$0 + 4 >> 2] = $8;
  HEAP32[$0 >> 2] = $5;
 }
}
function ec_encode_bin($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = -1 << $3;
 $5 = HEAP32[$0 + 28 >> 2];
 $3 = $5 >>> $3 | 0;
 $6 = $0;
 label$1 : {
  if ($1) {
   HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 32 >> 2] + (Math_imul($1 + $4 | 0, $3) + $5 | 0);
   $3 = Math_imul($2 - $1 | 0, $3);
   break label$1;
  }
  $3 = Math_imul($2 + $4 | 0, $3) + $5 | 0;
 }
 HEAP32[$6 + 28 >> 2] = $3;
 if ($3 >>> 0 <= 8388608) {
  $1 = HEAP32[$0 + 32 >> 2];
  while (1) {
   $5 = $1 >>> 23 | 0;
   label$5 : {
    if (($5 | 0) != 255) {
     $3 = $1 >>> 31 | 0;
     $2 = HEAP32[$0 + 40 >> 2];
     if (($2 | 0) >= 0) {
      $1 = -1;
      $4 = HEAP32[$0 + 24 >> 2];
      if (HEAPU32[$0 + 4 >> 2] > $4 + HEAP32[$0 + 8 >> 2] >>> 0) {
       HEAP32[$0 + 24 >> 2] = $4 + 1;
       HEAP8[HEAP32[$0 >> 2] + $4 | 0] = $2 + $3;
       $1 = 0;
      }
      HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] | $1;
     }
     $1 = HEAP32[$0 + 36 >> 2];
     if ($1) {
      $4 = $3 - 1 | 0;
      while (1) {
       $3 = -1;
       $2 = HEAP32[$0 + 24 >> 2];
       if (HEAPU32[$0 + 4 >> 2] > $2 + HEAP32[$0 + 8 >> 2] >>> 0) {
        HEAP32[$0 + 24 >> 2] = $2 + 1;
        HEAP8[HEAP32[$0 >> 2] + $2 | 0] = $4;
        $3 = 0;
        $1 = HEAP32[$0 + 36 >> 2];
       }
       $1 = $1 - 1 | 0;
       HEAP32[$0 + 36 >> 2] = $1;
       HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] | $3;
       if ($1) {
        continue;
       }
       break;
      }
     }
     HEAP32[$0 + 40 >> 2] = $5 & 255;
     $3 = HEAP32[$0 + 28 >> 2];
     $1 = HEAP32[$0 + 32 >> 2];
     break label$5;
    }
    HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
   }
   $3 = $3 << 8;
   HEAP32[$0 + 28 >> 2] = $3;
   $1 = $1 << 8 & 2147483392;
   HEAP32[$0 + 32 >> 2] = $1;
   HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + 8;
   if ($3 >>> 0 < 8388609) {
    continue;
   }
   break;
  }
 }
}
function ec_encode($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $5 = HEAP32[$0 + 28 >> 2];
 $4 = ($5 >>> 0) / ($3 >>> 0) | 0;
 $6 = $0;
 label$1 : {
  if ($1) {
   HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 32 >> 2] + (Math_imul($1 - $3 | 0, $4) + $5 | 0);
   $3 = Math_imul($2 - $1 | 0, $4);
   break label$1;
  }
  $3 = Math_imul($2 - $3 | 0, $4) + $5 | 0;
 }
 HEAP32[$6 + 28 >> 2] = $3;
 if ($3 >>> 0 <= 8388608) {
  $1 = HEAP32[$0 + 32 >> 2];
  while (1) {
   $5 = $1 >>> 23 | 0;
   label$5 : {
    if (($5 | 0) != 255) {
     $3 = $1 >>> 31 | 0;
     $4 = HEAP32[$0 + 40 >> 2];
     if (($4 | 0) >= 0) {
      $1 = -1;
      $2 = HEAP32[$0 + 24 >> 2];
      if (HEAPU32[$0 + 4 >> 2] > $2 + HEAP32[$0 + 8 >> 2] >>> 0) {
       HEAP32[$0 + 24 >> 2] = $2 + 1;
       HEAP8[HEAP32[$0 >> 2] + $2 | 0] = $3 + $4;
       $1 = 0;
      }
      HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] | $1;
     }
     $1 = HEAP32[$0 + 36 >> 2];
     if ($1) {
      $2 = $3 - 1 | 0;
      while (1) {
       $3 = -1;
       $4 = HEAP32[$0 + 24 >> 2];
       if (HEAPU32[$0 + 4 >> 2] > $4 + HEAP32[$0 + 8 >> 2] >>> 0) {
        HEAP32[$0 + 24 >> 2] = $4 + 1;
        HEAP8[HEAP32[$0 >> 2] + $4 | 0] = $2;
        $3 = 0;
        $1 = HEAP32[$0 + 36 >> 2];
       }
       $1 = $1 - 1 | 0;
       HEAP32[$0 + 36 >> 2] = $1;
       HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] | $3;
       if ($1) {
        continue;
       }
       break;
      }
     }
     HEAP32[$0 + 40 >> 2] = $5 & 255;
     $3 = HEAP32[$0 + 28 >> 2];
     $1 = HEAP32[$0 + 32 >> 2];
     break label$5;
    }
    HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
   }
   $3 = $3 << 8;
   HEAP32[$0 + 28 >> 2] = $3;
   $1 = $1 << 8 & 2147483392;
   HEAP32[$0 + 32 >> 2] = $1;
   HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + 8;
   if ($3 >>> 0 < 8388609) {
    continue;
   }
   break;
  }
 }
}
function silk_setup_resamplers($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $2 = __stack_pointer - 304 | 0;
 $8 = $2;
 __stack_pointer = $2;
 $3 = HEAP32[$0 + 4576 >> 2];
 label$1 : {
  if (($3 | 0) == ($1 | 0)) {
   $5 = 0;
   if (HEAP32[$0 + 4560 >> 2] == HEAP32[$0 + 4556 >> 2]) {
    break label$1;
   }
  }
  if (!$3) {
   $5 = silk_resampler_init($0 + 5776 | 0, HEAP32[$0 + 4556 >> 2], Math_imul($1, 1e3), 1);
   break label$1;
  }
  $9 = Math_imul(HEAP32[$0 + 4580 >> 2], 10) + 5 | 0;
  $6 = Math_imul($9, $3);
  $5 = Math_imul($1, $9);
  $7 = $2 - (((($5 | 0) < ($6 | 0) ? $6 : $5) << 1) + 15 & -16) | 0;
  $10 = $7;
  __stack_pointer = $7;
  if (($6 | 0) >= 1) {
   $2 = $6;
   while (1) {
    $3 = $2 - 1 | 0;
    $11 = ($3 << 1) + $7 | 0;
    $4 = lrintf(HEAPF32[(($3 << 2) + $0 | 0) + 7180 >> 2]);
    $4 = ($4 | 0) > -32768 ? $4 : -32768;
    HEAP16[$11 >> 1] = ($4 | 0) < 32767 ? $4 : 32767;
    $4 = ($2 | 0) > 1;
    $2 = $3;
    if ($4) {
     continue;
    }
    break;
   }
  }
  $3 = silk_resampler_init($8, Math_imul(HEAP16[$0 + 4576 >> 1], 1e3), HEAP32[$0 + 4556 >> 2], 0);
  $4 = Math_imul(HEAP32[$0 + 4556 >> 2] / 1e3 | 0, $9);
  $2 = $10 - (($4 << 1) + 15 & -16) | 0;
  __stack_pointer = $2;
  $6 = silk_resampler($8, $2, $7, $6) + $3 | 0;
  $3 = $0 + 5776 | 0;
  $1 = $6 + silk_resampler_init($3, HEAP32[$0 + 4556 >> 2], Math_imul($1 << 16 >> 16, 1e3), 1) | 0;
  $4 = silk_resampler($3, $7, $2, $4);
  if (($5 | 0) >= 1) {
   while (1) {
    $2 = $5 - 1 | 0;
    HEAPF32[(($2 << 2) + $0 | 0) + 7180 >> 2] = HEAP16[($2 << 1) + $7 >> 1];
    $3 = ($5 | 0) > 1;
    $5 = $2;
    if ($3) {
     continue;
    }
    break;
   }
  }
  $5 = $1 + $4 | 0;
 }
 HEAP32[$0 + 4560 >> 2] = HEAP32[$0 + 4556 >> 2];
 __stack_pointer = $8 + 304 | 0;
 return $5;
}
function compute_mdcts($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = Math_fround(0);
 $10 = HEAP32[$0 + 44 >> 2];
 $12 = HEAP32[$0 + 4 >> 2];
 if ($1) {
  $15 = HEAP32[$0 + 36 >> 2];
 } else {
  $10 = $10 << $6;
  $1 = 1;
  $15 = HEAP32[$0 + 36 >> 2] - $6 | 0;
 }
 $16 = ($5 | 0) > 1 ? $5 : 1;
 $17 = $0 - -64 | 0;
 $9 = Math_imul($1, $10);
 $18 = $12 + $9 | 0;
 while (1) {
  if (($1 | 0) >= 1) {
   $11 = Math_imul($9, $13);
   $14 = (Math_imul($13, $18) << 2) + $2 | 0;
   $6 = 0;
   while (1) {
    clt_mdct_forward_c($17, (Math_imul($6, $10) << 2) + $14 | 0, ($6 + $11 << 2) + $3 | 0, HEAP32[$0 + 60 >> 2], $12, $15, $1, $8);
    $6 = $6 + 1 | 0;
    if (($6 | 0) != ($1 | 0)) {
     continue;
    }
    break;
   }
  }
  $13 = $13 + 1 | 0;
  if (($16 | 0) != ($13 | 0)) {
   continue;
  }
  break;
 }
 if (!(($4 | 0) != 1 | ($5 | 0) != 2 | ($9 | 0) < 1)) {
  $6 = 0;
  while (1) {
   $1 = ($6 << 2) + $3 | 0;
   HEAPF32[$1 >> 2] = Math_fround(HEAPF32[$1 >> 2] * Math_fround(.5)) + Math_fround(HEAPF32[($6 + $9 << 2) + $3 >> 2] * Math_fround(.5));
   $6 = $6 + 1 | 0;
   if (($9 | 0) != ($6 | 0)) {
    continue;
   }
   break;
  }
 }
 if (($7 | 0) != 1) {
  $10 = ($4 | 0) > 1 ? $4 : 1;
  $11 = ($9 | 0) / ($7 | 0) | 0;
  $12 = $9 - $11 << 2;
  $19 = Math_fround($7 | 0);
  $0 = 0;
  while (1) {
   $14 = Math_imul($0, $9);
   $6 = 0;
   if (($11 | 0) >= 1) {
    while (1) {
     $1 = ($6 + $14 << 2) + $3 | 0;
     HEAPF32[$1 >> 2] = HEAPF32[$1 >> 2] * $19;
     $6 = $6 + 1 | 0;
     if (($11 | 0) != ($6 | 0)) {
      continue;
     }
     break;
    }
   }
   memset(($11 + $14 << 2) + $3 | 0, 0, $12);
   $0 = $0 + 1 | 0;
   if (($10 | 0) != ($0 | 0)) {
    continue;
   }
   break;
  }
 }
}
function celt_preemphasis($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = Math_fround(0), $9 = Math_fround(0), $10 = 0, $11 = Math_fround(0), $12 = Math_fround(0);
 $9 = HEAPF32[$6 >> 2];
 $11 = HEAPF32[$5 >> 2];
 label$1 : {
  if (!(($4 | 0) != 1 | $7 | HEAPF32[$5 + 4 >> 2] != Math_fround(0))) {
   if (($2 | 0) < 1) {
    break label$1;
   }
   $5 = 0;
   while (1) {
    $8 = Math_fround(HEAPF32[(Math_imul($3, $5) << 2) + $0 >> 2] * Math_fround(32768));
    HEAPF32[($5 << 2) + $1 >> 2] = $8 - $9;
    $9 = Math_fround($11 * $8);
    $5 = $5 + 1 | 0;
    if (($5 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
   break label$1;
  }
  $10 = ($2 | 0) / ($4 | 0) | 0;
  if (($4 | 0) != 1) {
   memset($1, 0, $2 << 2);
  }
  label$5 : {
   if (($10 | 0) < 1) {
    break label$5;
   }
   $5 = 0;
   while (1) {
    HEAPF32[(Math_imul($4, $5) << 2) + $1 >> 2] = HEAPF32[(Math_imul($3, $5) << 2) + $0 >> 2] * Math_fround(32768);
    $5 = $5 + 1 | 0;
    if (($10 | 0) != ($5 | 0)) {
     continue;
    }
    break;
   }
   if (!$7 | ($10 | 0) < 1) {
    break label$5;
   }
   $5 = 0;
   while (1) {
    $0 = (Math_imul($4, $5) << 2) + $1 | 0;
    $7 = $0;
    $8 = HEAPF32[$0 >> 2];
    $0 = $8 > Math_fround(65536);
    $3 = ($0 ? Math_fround(65536) : $8) < Math_fround(-65536);
    $12 = $3 ? Math_fround(-65536) : Math_fround(65536);
    HEAPF32[$7 >> 2] = $0 ? $12 : $3 ? $12 : $8;
    $5 = $5 + 1 | 0;
    if (($10 | 0) != ($5 | 0)) {
     continue;
    }
    break;
   }
  }
  if (($2 | 0) < 1) {
   break label$1;
  }
  $5 = 0;
  while (1) {
   $0 = ($5 << 2) + $1 | 0;
   $8 = HEAPF32[$0 >> 2];
   HEAPF32[$0 >> 2] = $8 - $9;
   $9 = Math_fround($11 * $8);
   $5 = $5 + 1 | 0;
   if (($5 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
 }
 HEAPF32[$6 >> 2] = $9;
}
function silk_LTP_analysis_filter_FLP($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = Math_fround(0), $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = Math_fround(0);
 $9 = __stack_pointer - 32 | 0;
 if (($6 | 0) >= 1) {
  $14 = $5 + $7 | 0;
  $15 = ($14 | 0) < 1;
  while (1) {
   $7 = $13 << 2;
   $16 = HEAPF32[$7 + $4 >> 2];
   $11 = HEAP32[$3 + $7 >> 2];
   $7 = Math_imul($13, 20) + $2 | 0;
   HEAP32[$9 + 16 >> 2] = HEAP32[$7 + 16 >> 2];
   $12 = HEAP32[$7 + 4 >> 2];
   $10 = HEAP32[$7 >> 2];
   HEAP32[$9 >> 2] = $10;
   HEAP32[$9 + 4 >> 2] = $12;
   $10 = HEAP32[$7 + 12 >> 2];
   $12 = HEAP32[$7 + 8 >> 2];
   HEAP32[$9 + 8 >> 2] = $12;
   HEAP32[$9 + 12 >> 2] = $10;
   if (!$15) {
    $7 = $1 - ($11 << 2) | 0;
    $12 = 0;
    while (1) {
     $10 = $12 << 2;
     $11 = $10 + $0 | 0;
     $10 = $1 + $10 | 0;
     $8 = HEAPF32[$10 >> 2];
     $10 = HEAP32[$10 >> 2];
     HEAP32[$11 >> 2] = $10;
     $8 = Math_fround($8 - Math_fround(HEAPF32[$9 >> 2] * HEAPF32[$7 + 8 >> 2]));
     HEAPF32[$11 >> 2] = $8;
     $8 = Math_fround($8 - Math_fround(HEAPF32[$9 + 4 >> 2] * HEAPF32[$7 + 4 >> 2]));
     HEAPF32[$11 >> 2] = $8;
     $8 = Math_fround($8 - Math_fround(HEAPF32[$9 + 8 >> 2] * HEAPF32[$7 >> 2]));
     HEAPF32[$11 >> 2] = $8;
     $8 = Math_fround($8 - Math_fround(HEAPF32[$9 + 12 >> 2] * HEAPF32[$7 - 4 >> 2]));
     HEAPF32[$11 >> 2] = $8;
     HEAPF32[$11 >> 2] = $16 * Math_fround($8 - Math_fround(HEAPF32[$9 + 16 >> 2] * HEAPF32[$7 - 8 >> 2]));
     $7 = $7 + 4 | 0;
     $12 = $12 + 1 | 0;
     if (($14 | 0) != ($12 | 0)) {
      continue;
     }
     break;
    }
   }
   $1 = ($5 << 2) + $1 | 0;
   $0 = ($14 << 2) + $0 | 0;
   $13 = $13 + 1 | 0;
   if (($13 | 0) != ($6 | 0)) {
    continue;
   }
   break;
  }
 }
}
function __stdio_write($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 $4 = HEAP32[$0 + 28 >> 2];
 HEAP32[$3 + 16 >> 2] = $4;
 $5 = HEAP32[$0 + 20 >> 2];
 HEAP32[$3 + 28 >> 2] = $2;
 HEAP32[$3 + 24 >> 2] = $1;
 $1 = $5 - $4 | 0;
 HEAP32[$3 + 20 >> 2] = $1;
 $8 = $1 + $2 | 0;
 $9 = 2;
 $1 = $3 + 16 | 0;
 label$1 : {
  label$2 : {
   label$3 : {
    if (!__wasi_syscall_ret(__wasi_fd_write(HEAP32[$0 + 60 >> 2], $3 + 16 | 0, 2, $3 + 12 | 0) | 0)) {
     while (1) {
      $4 = HEAP32[$3 + 12 >> 2];
      if (($8 | 0) == ($4 | 0)) {
       break label$3;
      }
      if (($4 | 0) <= -1) {
       break label$2;
      }
      $6 = HEAP32[$1 + 4 >> 2];
      $5 = $6 >>> 0 < $4 >>> 0;
      $7 = ($5 << 3) + $1 | 0;
      $6 = $4 - ($5 ? $6 : 0) | 0;
      HEAP32[$7 >> 2] = $6 + HEAP32[$7 >> 2];
      $7 = ($5 ? 12 : 4) + $1 | 0;
      HEAP32[$7 >> 2] = HEAP32[$7 >> 2] - $6;
      $8 = $8 - $4 | 0;
      $1 = $5 ? $1 + 8 | 0 : $1;
      $9 = $9 - $5 | 0;
      if (!__wasi_syscall_ret(__wasi_fd_write(HEAP32[$0 + 60 >> 2], $1 | 0, $9 | 0, $3 + 12 | 0) | 0)) {
       continue;
      }
      break;
     }
    }
    if (($8 | 0) != -1) {
     break label$2;
    }
   }
   $1 = HEAP32[$0 + 44 >> 2];
   HEAP32[$0 + 28 >> 2] = $1;
   HEAP32[$0 + 20 >> 2] = $1;
   HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 48 >> 2] + $1;
   $0 = $2;
   break label$1;
  }
  HEAP32[$0 + 28 >> 2] = 0;
  HEAP32[$0 + 16 >> 2] = 0;
  HEAP32[$0 + 20 >> 2] = 0;
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | 32;
  $0 = 0;
  if (($9 | 0) == 2) {
   break label$1;
  }
  $0 = $2 - HEAP32[$1 + 4 >> 2] | 0;
 }
 __stack_pointer = $3 + 32 | 0;
 $4 = $0;
 return $4 | 0;
}
function ec_enc_bit_logp($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = HEAP32[$0 + 28 >> 2];
 $2 = $3 >>> $2 | 0;
 $3 = $3 - $2 | 0;
 label$1 : {
  if (!$1) {
   $2 = $3;
   break label$1;
  }
  HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 32 >> 2] + $3;
 }
 HEAP32[$0 + 28 >> 2] = $2;
 if ($2 >>> 0 <= 8388608) {
  $1 = HEAP32[$0 + 32 >> 2];
  while (1) {
   $5 = $1 >>> 23 | 0;
   label$5 : {
    if (($5 | 0) != 255) {
     $2 = $1 >>> 31 | 0;
     $3 = HEAP32[$0 + 40 >> 2];
     if (($3 | 0) >= 0) {
      $1 = -1;
      $4 = HEAP32[$0 + 24 >> 2];
      if (HEAPU32[$0 + 4 >> 2] > $4 + HEAP32[$0 + 8 >> 2] >>> 0) {
       HEAP32[$0 + 24 >> 2] = $4 + 1;
       HEAP8[HEAP32[$0 >> 2] + $4 | 0] = $2 + $3;
       $1 = 0;
      }
      HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] | $1;
     }
     $1 = HEAP32[$0 + 36 >> 2];
     if ($1) {
      $4 = $2 - 1 | 0;
      while (1) {
       $2 = -1;
       $3 = HEAP32[$0 + 24 >> 2];
       if (HEAPU32[$0 + 4 >> 2] > $3 + HEAP32[$0 + 8 >> 2] >>> 0) {
        HEAP32[$0 + 24 >> 2] = $3 + 1;
        HEAP8[HEAP32[$0 >> 2] + $3 | 0] = $4;
        $2 = 0;
        $1 = HEAP32[$0 + 36 >> 2];
       }
       $1 = $1 - 1 | 0;
       HEAP32[$0 + 36 >> 2] = $1;
       HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] | $2;
       if ($1) {
        continue;
       }
       break;
      }
     }
     HEAP32[$0 + 40 >> 2] = $5 & 255;
     $2 = HEAP32[$0 + 28 >> 2];
     $1 = HEAP32[$0 + 32 >> 2];
     break label$5;
    }
    HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
   }
   $2 = $2 << 8;
   HEAP32[$0 + 28 >> 2] = $2;
   $1 = $1 << 8 & 2147483392;
   HEAP32[$0 + 32 >> 2] = $1;
   HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + 8;
   if ($2 >>> 0 < 8388609) {
    continue;
   }
   break;
  }
 }
}
function silk_gains_quant($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 if (($4 | 0) >= 1) {
  while (1) {
   $10 = ($9 << 2) + $1 | 0;
   silk_lin2log(HEAP32[$10 >> 2]);
   $6 = $0 + $9 | 0;
   $7 = Math_imul((silk_lin2log(HEAP32[$10 >> 2]) << 16) - 136970240 >> 16, 2251);
   $5 = $7 >>> 16 | 0;
   HEAP8[$6 | 0] = $5;
   if (HEAP8[$2 | 0] > $7 << 8 >> 24) {
    $5 = $5 + 1 | 0;
    HEAP8[$6 | 0] = $5;
   }
   $5 = $5 << 24 >> 24 > 0 ? $5 : 0;
   $7 = $5 << 24 >> 24 < 63 ? $5 : 63;
   HEAP8[$6 | 0] = $7;
   $5 = HEAP8[$2 | 0];
   label$4 : {
    if (!($3 | $9)) {
     $8 = $5 - 4 | 0;
     $7 = $7 & 255;
     $5 = ($5 | 0) > 67 ? 63 : ($7 | 0) < ($8 | 0) ? $8 : $7;
     HEAP8[$6 | 0] = $5;
     HEAP8[$2 | 0] = $5;
     break label$4;
    }
    $5 = $7 - $5 | 0;
    HEAP8[$6 | 0] = $5;
    $7 = HEAP8[$2 | 0] + 8 | 0;
    $8 = $5 << 24 >> 24;
    if (($7 | 0) < ($8 | 0)) {
     $5 = (($8 - $7 | 0) + 1 >>> 1 | 0) + $7 | 0;
     HEAP8[$6 | 0] = $5;
    }
    $5 = $5 << 24 >> 24 > -4 ? $5 : -4;
    $5 = $5 << 24 >> 24 < 36 ? $5 : 36;
    HEAP8[$6 | 0] = $5;
    $11 = $2;
    $8 = $5 << 24 >> 24;
    label$7 : {
     if (($8 | 0) > ($7 | 0)) {
      $5 = HEAPU8[$2 | 0] + (($8 << 1) - $7 | 0) | 0;
      HEAP8[$2 | 0] = $5;
      $5 = $5 << 24 >> 24 < 63 ? $5 : 63;
      break label$7;
     }
     $5 = HEAPU8[$2 | 0] + $5 | 0;
    }
    HEAP8[$11 | 0] = $5;
    HEAP8[$6 | 0] = HEAPU8[$6 | 0] + 4;
    $5 = HEAPU8[$2 | 0];
   }
   $6 = $5 << 24 >> 24;
   $6 = (Math_imul($6, 7281) >> 16) + Math_imul($6, 29) | 0;
   HEAP32[$10 >> 2] = silk_log2lin((($6 | 0) < 1877 ? $6 : 1877) + 2090 | 0);
   $9 = $9 + 1 | 0;
   if (($9 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
 }
}
function silk_warped_autocorrelation_FLP($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
 $5 = __stack_pointer - 416 | 0;
 __stack_pointer = $5;
 memset($5 + 208 | 0, 0, 200);
 $5 = memset($5, 0, 200);
 if (!($4 & 1)) {
  if (($3 | 0) >= 1) {
   $6 = $4 << 3;
   $11 = $6 + $5 | 0;
   $18 = ($5 + 208 | 0) + $6 | 0;
   $12 = +$2;
   $19 = ($4 | 0) < 1;
   while (1) {
    $8 = +HEAPF32[($9 << 2) + $1 >> 2];
    $6 = 0;
    if (!$19) {
     while (1) {
      $7 = $6 << 3;
      $13 = $7 | 8;
      $14 = $13 + ($5 + 208 | 0) | 0;
      $15 = HEAPF64[$14 >> 3];
      HEAPF64[($5 + 208 | 0) + $7 >> 3] = $8;
      $7 = $5 + $7 | 0;
      $16 = HEAPF64[$5 + 208 >> 3];
      HEAPF64[$7 >> 3] = HEAPF64[$7 >> 3] + $8 * $16;
      $6 = $6 + 2 | 0;
      $17 = HEAPF64[($5 + 208 | 0) + ($6 << 3) >> 3];
      $8 = $10 + ($15 - $8) * $12;
      HEAPF64[$14 >> 3] = $8;
      $7 = $5 + $13 | 0;
      HEAPF64[$7 >> 3] = $16 * $8 + HEAPF64[$7 >> 3];
      $8 = $15 + ($17 - $8) * $12;
      $10 = $17;
      if (($4 | 0) > ($6 | 0)) {
       continue;
      }
      break;
     }
    }
    HEAPF64[$18 >> 3] = $8;
    $10 = HEAPF64[$5 + 208 >> 3];
    HEAPF64[$11 >> 3] = HEAPF64[$11 >> 3] + $8 * $10;
    $9 = $9 + 1 | 0;
    if (($9 | 0) != ($3 | 0)) {
     continue;
    }
    break;
   }
  }
  $6 = 0;
  if (($4 | 0) >= 0) {
   while (1) {
    HEAPF32[($6 << 2) + $0 >> 2] = HEAPF64[($6 << 3) + $5 >> 3];
    $7 = ($4 | 0) != ($6 | 0);
    $6 = $6 + 1 | 0;
    if ($7) {
     continue;
    }
    break;
   }
  }
  __stack_pointer = $5 + 416 | 0;
  return;
 }
 celt_fatal(10944, 10981, 49);
 abort();
}
function pop_arg($0, $1, $2, $3) {
 label$1 : {
  if ($1 >>> 0 > 20) {
   break label$1;
  }
  label$2 : {
   switch ($1 - 9 | 0) {
   case 0:
    $1 = HEAP32[$2 >> 2];
    HEAP32[$2 >> 2] = $1 + 4;
    HEAP32[$0 >> 2] = HEAP32[$1 >> 2];
    return;
   case 1:
    $1 = HEAP32[$2 >> 2];
    HEAP32[$2 >> 2] = $1 + 4;
    $1 = HEAP32[$1 >> 2];
    $2 = $1 >> 31;
    HEAP32[$0 >> 2] = $1;
    HEAP32[$0 + 4 >> 2] = $2;
    return;
   case 2:
    $1 = HEAP32[$2 >> 2];
    HEAP32[$2 >> 2] = $1 + 4;
    $2 = HEAP32[$1 >> 2];
    HEAP32[$0 >> 2] = $2;
    HEAP32[$0 + 4 >> 2] = 0;
    return;
   case 3:
    $1 = HEAP32[$2 >> 2] + 7 & -8;
    HEAP32[$2 >> 2] = $1 + 8;
    $2 = HEAP32[$1 + 4 >> 2];
    $1 = HEAP32[$1 >> 2];
    HEAP32[$0 >> 2] = $1;
    HEAP32[$0 + 4 >> 2] = $2;
    return;
   case 4:
    $1 = HEAP32[$2 >> 2];
    HEAP32[$2 >> 2] = $1 + 4;
    $2 = HEAP16[$1 >> 1];
    $1 = $2 >> 31;
    HEAP32[$0 >> 2] = $2;
    HEAP32[$0 + 4 >> 2] = $1;
    return;
   case 5:
    $1 = HEAP32[$2 >> 2];
    HEAP32[$2 >> 2] = $1 + 4;
    $1 = HEAPU16[$1 >> 1];
    HEAP32[$0 >> 2] = $1;
    HEAP32[$0 + 4 >> 2] = 0;
    return;
   case 6:
    $1 = HEAP32[$2 >> 2];
    HEAP32[$2 >> 2] = $1 + 4;
    $2 = HEAP8[$1 | 0];
    $1 = $2 >> 31;
    HEAP32[$0 >> 2] = $2;
    HEAP32[$0 + 4 >> 2] = $1;
    return;
   case 7:
    $1 = HEAP32[$2 >> 2];
    HEAP32[$2 >> 2] = $1 + 4;
    $1 = HEAPU8[$1 | 0];
    HEAP32[$0 >> 2] = $1;
    HEAP32[$0 + 4 >> 2] = 0;
    return;
   case 8:
    $1 = HEAP32[$2 >> 2] + 7 & -8;
    HEAP32[$2 >> 2] = $1 + 8;
    HEAPF64[$0 >> 3] = HEAPF64[$1 >> 3];
    return;
   case 9:
    break label$2;
   default:
    break label$1;
   }
  }
  FUNCTION_TABLE[$3 | 0]($0, $2);
 }
}
function speex_resampler_init_frac($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0;
 label$1 : {
  label$2 : {
   if (!(!$2 | (!$0 | !$1))) {
    if ($5 >>> 0 < 11) {
     break label$2;
    }
   }
   if (!$6) {
    break label$1;
   }
   HEAP32[$6 >> 2] = 3;
   return 0;
  }
  $7 = dlcalloc(96, 1);
  if (!$7) {
   $7 = 0;
   if (!$6) {
    break label$1;
   }
   HEAP32[$6 >> 2] = 1;
   return 0;
  }
  HEAP32[$7 >> 2] = 0;
  HEAP32[$7 + 4 >> 2] = 0;
  HEAP32[$7 + 44 >> 2] = 1065353216;
  HEAP32[$7 + 16 >> 2] = -1;
  HEAP32[$7 + 88 >> 2] = 1;
  HEAP32[$7 + 92 >> 2] = 1;
  HEAP32[$7 + 20 >> 2] = $0;
  HEAP32[$7 + 32 >> 2] = 160;
  HEAP32[$7 + 8 >> 2] = 0;
  HEAP32[$7 + 12 >> 2] = 0;
  $0 = $0 << 2;
  $8 = dlcalloc($0, 1);
  HEAP32[$7 + 60 >> 2] = $8;
  label$5 : {
   if (!$8) {
    break label$5;
   }
   $8 = dlcalloc($0, 1);
   HEAP32[$7 + 68 >> 2] = $8;
   if (!$8) {
    break label$5;
   }
   $0 = dlcalloc($0, 1);
   HEAP32[$7 + 64 >> 2] = $0;
   if (!$0) {
    break label$5;
   }
   HEAP32[$7 + 16 >> 2] = $5;
   speex_resampler_set_rate_frac($7, $1, $2, $3, $4);
   $0 = update_filter($7);
   label$6 : {
    if (!$0) {
     HEAP32[$7 + 52 >> 2] = 1;
     break label$6;
    }
    dlfree(HEAP32[$7 + 72 >> 2]);
    dlfree(HEAP32[$7 + 76 >> 2]);
    dlfree(HEAP32[$7 + 60 >> 2]);
    dlfree(HEAP32[$7 + 68 >> 2]);
    dlfree(HEAP32[$7 + 64 >> 2]);
    dlfree($7);
    $7 = 0;
   }
   if (!$6) {
    break label$1;
   }
   HEAP32[$6 >> 2] = $0;
   return $7;
  }
  if ($6) {
   HEAP32[$6 >> 2] = 1;
  }
  dlfree(HEAP32[$7 + 76 >> 2]);
  dlfree(HEAP32[$7 + 60 >> 2]);
  dlfree(HEAP32[$7 + 68 >> 2]);
  dlfree(HEAP32[$7 + 64 >> 2]);
  dlfree($7);
  $7 = 0;
 }
 return $7;
}
function speex_resampler_set_rate_frac($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $6 = 3;
 label$1 : {
  if (!$1 | !$2) {
   break label$1;
  }
  if (!(HEAP32[$0 >> 2] != ($3 | 0) | HEAP32[$0 + 4 >> 2] != ($4 | 0) | HEAP32[$0 + 8 >> 2] != ($1 | 0))) {
   $6 = 0;
   if (HEAP32[$0 + 12 >> 2] == ($2 | 0)) {
    break label$1;
   }
  }
  HEAP32[$0 + 8 >> 2] = $1;
  HEAP32[$0 + 4 >> 2] = $4;
  HEAP32[$0 >> 2] = $3;
  $7 = HEAP32[$0 + 12 >> 2];
  HEAP32[$0 + 12 >> 2] = $2;
  $5 = $1;
  $3 = $2;
  while (1) {
   $4 = $3;
   $3 = ($5 >>> 0) % ($3 >>> 0) | 0;
   $5 = $4;
   if ($3) {
    continue;
   }
   break;
  }
  $3 = ($2 >>> 0) / ($4 >>> 0) | 0;
  HEAP32[$0 + 12 >> 2] = $3;
  HEAP32[$0 + 8 >> 2] = ($1 >>> 0) / ($4 >>> 0);
  label$4 : {
   if (!$7 | !HEAP32[$0 + 20 >> 2]) {
    break label$4;
   }
   $9 = HEAP32[$0 + 64 >> 2];
   $4 = 0;
   while (1) {
    $6 = 5;
    $2 = 4294967295 / ($3 >>> 0) | 0;
    $1 = ($4 << 2) + $9 | 0;
    $5 = HEAP32[$1 >> 2];
    $8 = $5;
    $5 = ($5 >>> 0) / ($7 >>> 0) | 0;
    $8 = $8 - Math_imul($7, $5) | 0;
    if ($2 >>> 0 < $8 >>> 0 | $2 >>> 0 < $5 >>> 0) {
     break label$1;
    }
    $5 = Math_imul($3, $5);
    $3 = (Math_imul($3, $8) >>> 0) / ($7 >>> 0) | 0;
    if ($5 >>> 0 > ($3 ^ -1) >>> 0) {
     break label$1;
    }
    $3 = $3 + $5 | 0;
    HEAP32[$1 >> 2] = $3;
    $5 = HEAP32[$0 + 12 >> 2];
    if ($5 >>> 0 <= $3 >>> 0) {
     HEAP32[$1 >> 2] = $5 - 1;
    }
    $4 = $4 + 1 | 0;
    if ($4 >>> 0 >= HEAPU32[$0 + 20 >> 2]) {
     break label$4;
    }
    $3 = HEAP32[$0 + 12 >> 2];
    continue;
   }
  }
  if (!HEAP32[$0 + 52 >> 2]) {
   return 0;
  }
  $6 = update_filter($0);
 }
 return $6;
}
function log($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 wasm2js_scratch_store_f64(+$0);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 $4 = wasm2js_scratch_load_i32(0) | 0;
 $5 = $2;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     if (($2 | 0) > 0 ? 1 : ($2 | 0) >= 0) {
      $1 = $5;
      if ($1 >>> 0 > 1048575) {
       break label$4;
      }
     }
     $2 = $5;
     $1 = $2 & 2147483647;
     if (!($1 | $4)) {
      return -1 / ($0 * $0);
     }
     $1 = $5;
     if (($1 | 0) > -1) {
      break label$3;
     }
     return ($0 - $0) / 0;
    }
    if ($1 >>> 0 > 2146435071) {
     break label$1;
    }
    $2 = 1072693248;
    $6 = -1023;
    if (($1 | 0) != 1072693248) {
     $2 = $1;
     break label$2;
    }
    if ($4) {
     break label$2;
    }
    return 0;
   }
   wasm2js_scratch_store_f64(+($0 * 0x40000000000000));
   $2 = wasm2js_scratch_load_i32(1) | 0;
   $4 = wasm2js_scratch_load_i32(0) | 0;
   $6 = -1077;
  }
  $1 = $2 + 614242 | 0;
  $3 = +(($1 >>> 20 | 0) + $6 | 0);
  $8 = $3 * .6931471803691238;
  $1 = ($1 & 1048575) + 1072079006 | 0;
  $2 = 0;
  $1 = $2 | $1;
  wasm2js_scratch_store_i32(0, $4 | 0);
  wasm2js_scratch_store_i32(1, $1 | 0);
  $0 = +wasm2js_scratch_load_f64() + -1;
  $9 = $0;
  $10 = $3 * 1.9082149292705877e-10;
  $3 = $0 / ($0 + 2);
  $11 = $3;
  $7 = $0 * ($0 * .5);
  $3 = $3 * $3;
  $0 = $3 * $3;
  $0 = $8 + ($9 + ($10 + $11 * ($7 + ($0 * ($0 * ($0 * .15313837699209373 + .22222198432149784) + .3999999999940942) + $3 * ($0 * ($0 * ($0 * .14798198605116586 + .1818357216161805) + .2857142874366239) + .6666666666666735))) - $7));
 }
 return $0;
}
function memset($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1 : {
  if (!$2) {
   break label$1;
  }
  $3 = $0 + $2 | 0;
  HEAP8[$3 - 1 | 0] = $1;
  HEAP8[$0 | 0] = $1;
  if ($2 >>> 0 < 3) {
   break label$1;
  }
  HEAP8[$3 - 2 | 0] = $1;
  HEAP8[$0 + 1 | 0] = $1;
  HEAP8[$3 - 3 | 0] = $1;
  HEAP8[$0 + 2 | 0] = $1;
  if ($2 >>> 0 < 7) {
   break label$1;
  }
  HEAP8[$3 - 4 | 0] = $1;
  HEAP8[$0 + 3 | 0] = $1;
  if ($2 >>> 0 < 9) {
   break label$1;
  }
  $4 = 0 - $0 & 3;
  $3 = $4 + $0 | 0;
  $1 = Math_imul($1 & 255, 16843009);
  HEAP32[$3 >> 2] = $1;
  $4 = $2 - $4 & -4;
  $2 = $4 + $3 | 0;
  HEAP32[$2 - 4 >> 2] = $1;
  if ($4 >>> 0 < 9) {
   break label$1;
  }
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$2 - 8 >> 2] = $1;
  HEAP32[$2 - 12 >> 2] = $1;
  if ($4 >>> 0 < 25) {
   break label$1;
  }
  HEAP32[$3 + 24 >> 2] = $1;
  HEAP32[$3 + 20 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $1;
  HEAP32[$3 + 12 >> 2] = $1;
  HEAP32[$2 - 16 >> 2] = $1;
  HEAP32[$2 - 20 >> 2] = $1;
  HEAP32[$2 - 24 >> 2] = $1;
  HEAP32[$2 - 28 >> 2] = $1;
  $6 = $3 & 4 | 24;
  $2 = $4 - $6 | 0;
  if ($2 >>> 0 < 32) {
   break label$1;
  }
  $5 = __wasm_i64_mul($1, 0, 1, 1);
  $4 = i64toi32_i32$HIGH_BITS;
  $7 = $4;
  $1 = $3 + $6 | 0;
  while (1) {
   HEAP32[$1 + 24 >> 2] = $5;
   $4 = $7;
   HEAP32[$1 + 28 >> 2] = $4;
   HEAP32[$1 + 16 >> 2] = $5;
   HEAP32[$1 + 20 >> 2] = $4;
   HEAP32[$1 + 8 >> 2] = $5;
   HEAP32[$1 + 12 >> 2] = $4;
   HEAP32[$1 >> 2] = $5;
   HEAP32[$1 + 4 >> 2] = $4;
   $1 = $1 + 32 | 0;
   $2 = $2 - 32 | 0;
   if ($2 >>> 0 > 31) {
    continue;
   }
   break;
  }
 }
 return $0;
}
function silk_LPC_analysis_filter($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 label$1 : {
  label$2 : {
   if (($4 | 0) > 5) {
    if ($4 & 1) {
     break label$2;
    }
    if (($3 | 0) < ($4 | 0)) {
     break label$1;
    }
    if (($3 | 0) > ($4 | 0)) {
     $12 = ($4 | 0) < 7;
     $5 = $4;
     while (1) {
      $11 = $5 << 1;
      $7 = $11 + $1 | 0;
      $8 = $7 - 2 | 0;
      $9 = ((((Math_imul(HEAP16[$2 + 2 >> 1], HEAP16[$7 - 4 >> 1]) + Math_imul(HEAP16[$2 >> 1], HEAP16[$8 >> 1]) | 0) + Math_imul(HEAP16[$2 + 4 >> 1], HEAP16[$7 - 6 >> 1]) | 0) + Math_imul(HEAP16[$2 + 6 >> 1], HEAP16[$7 - 8 >> 1]) | 0) + Math_imul(HEAP16[$2 + 8 >> 1], HEAP16[$7 - 10 >> 1]) | 0) + Math_imul(HEAP16[$2 + 10 >> 1], HEAP16[$7 - 12 >> 1]) | 0;
      $6 = 6;
      if (!$12) {
       while (1) {
        $10 = $6 << 1;
        $9 = (Math_imul(HEAP16[$10 + $2 >> 1], HEAP16[$8 - $10 >> 1]) + $9 | 0) + Math_imul(HEAP16[($10 | 2) + $2 >> 1], HEAP16[(($6 ^ -1) << 1) + $8 >> 1]) | 0;
        $6 = $6 + 2 | 0;
        if (($6 | 0) < ($4 | 0)) {
         continue;
        }
        break;
       }
      }
      $6 = ((HEAP16[$7 >> 1] << 12) - $9 >> 11) + 1 >> 1;
      $6 = ($6 | 0) > -32768 ? $6 : -32768;
      HEAP16[$0 + $11 >> 1] = ($6 | 0) < 32767 ? $6 : 32767;
      $5 = $5 + 1 | 0;
      if (($5 | 0) != ($3 | 0)) {
       continue;
      }
      break;
     }
    }
    memset($0, 0, $4 << 1);
    return;
   }
   celt_fatal(16065, 16090, 67);
   abort();
  }
  celt_fatal(16117, 16090, 68);
  abort();
 }
 celt_fatal(16148, 16090, 69);
 abort();
}
function silk_corrMatrix_FLP($0, $1, $2, $3) {
 var $4 = 0, $5 = Math_fround(0), $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = Math_fround(0);
 $10 = $2 - 1 | 0;
 $8 = ($10 << 2) + $0 | 0;
 $6 = silk_energy_FLP($8, $1);
 HEAPF32[$3 >> 2] = $6;
 label$1 : {
  if (($2 | 0) < 2) {
   break label$1;
  }
  $4 = 1;
  while (1) {
   $5 = HEAPF32[$8 - ($4 << 2) >> 2];
   $12 = Math_fround($5 * $5);
   $5 = HEAPF32[($1 - $4 << 2) + $8 >> 2];
   $6 = $6 + +Math_fround($12 - Math_fround($5 * $5));
   HEAPF32[(Math_imul($2, $4) + $4 << 2) + $3 >> 2] = $6;
   $4 = $4 + 1 | 0;
   if (($4 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
  if (($2 | 0) < 2) {
   break label$1;
  }
  $0 = (($2 << 2) + $0 | 0) - 8 | 0;
  $7 = 1;
  while (1) {
   $4 = (Math_imul($2, $7) << 2) + $3 | 0;
   $6 = silk_inner_product_FLP($8, $0, $1);
   $5 = Math_fround($6);
   HEAPF32[$4 >> 2] = $5;
   HEAPF32[($7 << 2) + $3 >> 2] = $5;
   $4 = 1;
   if (($2 - $7 | 0) >= 2) {
    while (1) {
     $11 = $4 + $7 | 0;
     $9 = $4 << 2;
     $5 = Math_fround(HEAPF32[$8 - $9 >> 2] * HEAPF32[$0 - $9 >> 2]);
     $9 = $1 - $4 << 2;
     $6 = $6 + +Math_fround($5 - Math_fround(HEAPF32[$9 + $8 >> 2] * HEAPF32[$0 + $9 >> 2]));
     $5 = Math_fround($6);
     HEAPF32[(Math_imul($11, $2) + $4 << 2) + $3 >> 2] = $5;
     HEAPF32[(Math_imul($2, $4) + $11 << 2) + $3 >> 2] = $5;
     $4 = $4 + 1 | 0;
     if (($10 | 0) != ($4 | 0)) {
      continue;
     }
     break;
    }
   }
   $10 = $10 - 1 | 0;
   $0 = $0 - 4 | 0;
   $7 = $7 + 1 | 0;
   if (($7 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
 }
}
function quant_fine_energy($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = Math_fround(0), $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = Math_fround(0), $19 = Math_fround(0);
 if (($1 | 0) < ($2 | 0)) {
  $16 = ($7 | 0) > 1 ? $7 : 1;
  while (1) {
   $14 = ($1 << 2) + $5 | 0;
   $9 = HEAP32[$14 >> 2];
   if (($9 | 0) >= 1) {
    $12 = 65536 << $9 >> 16;
    $17 = $12 - 1 | 0;
    $18 = Math_fround($12 | 0);
    $8 = HEAP32[$0 + 8 >> 2];
    $7 = 0;
    while (1) {
     $13 = $6;
     $10 = Math_fround(Math_floor(Math_fround(Math_fround(HEAPF32[(Math_imul($7, $8) + $1 << 2) + $4 >> 2] + Math_fround(.5)) * $18)));
     label$5 : {
      if (Math_fround(Math_abs($10)) < Math_fround(2147483648)) {
       $8 = ~~$10;
       break label$5;
      }
      $8 = -2147483648;
     }
     $8 = ($8 | 0) < ($12 | 0) ? $8 : $17;
     $11 = ($8 | 0) > 0 ? $8 : 0;
     ec_enc_bits($13, $11, $9);
     $8 = HEAP32[$0 + 8 >> 2];
     $15 = Math_imul($8, $7) + $1 << 2;
     $9 = $15 + $3 | 0;
     $13 = $9;
     $19 = HEAPF32[$9 >> 2];
     $9 = HEAP32[$14 >> 2];
     $10 = Math_fround(Math_fround(Math_fround(Math_fround(Math_fround($11 | 0) + Math_fround(.5)) * Math_fround(1 << 14 - $9)) * Math_fround(6103515625e-14)) + Math_fround(-.5));
     HEAPF32[$13 >> 2] = $19 + $10;
     $11 = $4 + $15 | 0;
     HEAPF32[$11 >> 2] = HEAPF32[$11 >> 2] - $10;
     $7 = $7 + 1 | 0;
     if (($16 | 0) != ($7 | 0)) {
      continue;
     }
     break;
    }
   }
   $1 = $1 + 1 | 0;
   if (($2 | 0) != ($1 | 0)) {
    continue;
   }
   break;
  }
 }
}
function silk_HP_variable_cutoff($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 if (HEAPU8[$0 + 4541 | 0] == 2) {
  $1 = silk_lin2log((Math_imul(HEAP32[$0 + 4576 >> 2], 65536e3) | 0) / HEAP32[$0 + 4544 >> 2] | 0);
  $2 = HEAP32[$0 + 4696 >> 2];
  $3 = silk_lin2log(3932160);
  $6 = silk_lin2log(3932160);
  $4 = 0 - ($2 << 2) | 0;
  $5 = HEAP32[$0 + 8 >> 2];
  $2 = $2 << 16 >> 16;
  $2 = (Math_imul($2, $4 & 65532) >> 16) + Math_imul($4 >> 16, $2) | 0;
  $1 = ((($1 - ($5 >> 8) | 0) + Math_imul($2 >> 16, $1 - $3 << 16 >> 16) | 0) + (Math_imul($2 & 65535, $1 - $6 << 16 >> 16) >> 16) | 0) - 2048 | 0;
  $1 = ($1 | 0) < 0 ? Math_imul($1, 3) : $1;
  $1 = ($1 | 0) > -51 ? $1 : -51;
  $1 = Math_imul(HEAP16[$0 + 4532 >> 1], ($1 | 0) < 51 ? $1 : 51);
  HEAP32[$0 + 8 >> 2] = Math_imul($1 >> 16, 6554) + $5 + (Math_imul($1 & 65535, 6554) >>> 16);
  $1 = silk_lin2log(60);
  $2 = silk_lin2log(100);
  $3 = HEAP32[$0 + 8 >> 2];
  $4 = $0;
  label$2 : {
   label$3 : {
    if ($1 << 8 > $2 << 8) {
     if (silk_lin2log(60) << 8 < ($3 | 0)) {
      $1 = silk_lin2log(60) << 8;
      break label$2;
     }
     if (HEAP32[$0 + 8 >> 2] >= silk_lin2log(100) << 8) {
      break label$3;
     }
     $1 = silk_lin2log(100) << 8;
     break label$2;
    }
    if (silk_lin2log(100) << 8 < ($3 | 0)) {
     $1 = silk_lin2log(100) << 8;
     break label$2;
    }
    if (HEAP32[$0 + 8 >> 2] >= silk_lin2log(60) << 8) {
     break label$3;
    }
    $1 = silk_lin2log(60) << 8;
    break label$2;
   }
   $1 = HEAP32[$0 + 8 >> 2];
  }
  HEAP32[$4 + 8 >> 2] = $1;
 }
}
function silk_A2NLSF_eval_poly($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = $1 << 4;
 $3 = HEAP32[($2 << 2) + $0 >> 2];
 if (($2 | 0) != 8) {
  if (($2 | 0) >= 1) {
   $1 = $1 << 20 >> 16;
   $5 = ($4 >> 15) + 1 >> 1;
   while (1) {
    $4 = $2 - 1 | 0;
    $3 = HEAP32[($4 << 2) + $0 >> 2] + ((Math_imul($3 >> 16, $1) + Math_imul($3, $5) | 0) + (Math_imul($3 & 65535, $1) >> 16) | 0) | 0;
    $6 = ($2 | 0) > 1;
    $2 = $4;
    if ($6) {
     continue;
    }
    break;
   }
  }
  return $3;
 }
 $2 = $1 << 20 >> 16;
 $1 = ($4 >> 15) + 1 >> 1;
 $3 = HEAP32[$0 + 28 >> 2] + ((Math_imul($2, $3 >> 16) + Math_imul($3, $1) | 0) + (Math_imul($3 & 65535, $2) >> 16) | 0) | 0;
 $3 = ((HEAP32[$0 + 24 >> 2] + Math_imul($1, $3) | 0) + Math_imul($3 >> 16, $2) | 0) + (Math_imul($3 & 65535, $2) >> 16) | 0;
 $3 = ((HEAP32[$0 + 20 >> 2] + Math_imul($3, $1) | 0) + Math_imul($3 >> 16, $2) | 0) + (Math_imul($3 & 65535, $2) >> 16) | 0;
 $3 = ((HEAP32[$0 + 16 >> 2] + Math_imul($3, $1) | 0) + Math_imul($3 >> 16, $2) | 0) + (Math_imul($3 & 65535, $2) >> 16) | 0;
 $3 = ((HEAP32[$0 + 12 >> 2] + Math_imul($3, $1) | 0) + Math_imul($3 >> 16, $2) | 0) + (Math_imul($3 & 65535, $2) >> 16) | 0;
 $3 = ((HEAP32[$0 + 8 >> 2] + Math_imul($3, $1) | 0) + Math_imul($3 >> 16, $2) | 0) + (Math_imul($3 & 65535, $2) >> 16) | 0;
 $3 = ((HEAP32[$0 + 4 >> 2] + Math_imul($3, $1) | 0) + Math_imul($3 >> 16, $2) | 0) + (Math_imul($3 & 65535, $2) >> 16) | 0;
 return ((HEAP32[$0 >> 2] + Math_imul($3, $1) | 0) + Math_imul($3 >> 16, $2) | 0) + (Math_imul($3 & 65535, $2) >> 16) | 0;
}
function resampler_basic_direct_single($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = Math_fround(0), $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0;
 $1 = $1 << 2;
 $11 = $1 + HEAP32[$0 + 64 >> 2] | 0;
 $8 = HEAP32[$11 >> 2];
 $12 = HEAP32[$0 + 60 >> 2] + $1 | 0;
 $6 = HEAP32[$12 >> 2];
 $13 = HEAP32[$3 >> 2];
 label$1 : {
  if (($6 | 0) >= ($13 | 0)) {
   break label$1;
  }
  $9 = HEAP32[$0 + 12 >> 2];
  $15 = HEAP32[$0 + 40 >> 2];
  $16 = HEAP32[$0 + 36 >> 2];
  $17 = HEAP32[$0 + 92 >> 2];
  $18 = HEAP32[$0 + 76 >> 2];
  $3 = HEAP32[$5 >> 2];
  $14 = ($3 | 0) > 0 ? $3 : 0;
  $1 = HEAP32[$0 + 24 >> 2];
  $19 = ($1 | 0) < 1;
  while (1) {
   if (($7 | 0) == ($14 | 0)) {
    $7 = $14;
    break label$1;
   }
   $10 = Math_fround(0);
   if (!$19) {
    $5 = ($6 << 2) + $2 | 0;
    $20 = (Math_imul($1, $8) << 2) + $18 | 0;
    $0 = 0;
    while (1) {
     $3 = $0 << 2;
     $10 = Math_fround($10 + Math_fround(HEAPF32[$20 + $3 >> 2] * HEAPF32[$3 + $5 >> 2]));
     $0 = $0 + 1 | 0;
     if (($1 | 0) != ($0 | 0)) {
      continue;
     }
     break;
    }
   }
   HEAPF32[(Math_imul($7, $17) << 2) + $4 >> 2] = $10;
   $0 = $8 + $15 | 0;
   $8 = $0 - ($0 >>> 0 < $9 >>> 0 ? 0 : $9) | 0;
   $7 = $7 + 1 | 0;
   $6 = ($6 + $16 | 0) + ($0 >>> 0 >= $9 >>> 0) | 0;
   if (($13 | 0) > ($6 | 0)) {
    continue;
   }
   break;
  }
 }
 HEAP32[$12 >> 2] = $6;
 HEAP32[$11 >> 2] = $8;
 return $7 | 0;
}
function silk_schur_FLP($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $6 = __stack_pointer - 400 | 0;
 __stack_pointer = $6;
 if ($2 >>> 0 <= 24) {
  while (1) {
   $4 = ($3 << 4) + $6 | 0;
   $5 = +HEAPF32[($3 << 2) + $1 >> 2];
   HEAPF64[$4 >> 3] = $5;
   HEAPF64[$4 + 8 >> 3] = $5;
   $4 = ($2 | 0) != ($3 | 0);
   $3 = $3 + 1 | 0;
   if ($4) {
    continue;
   }
   break;
  }
  if ($2) {
   $1 = 0;
   $9 = $2;
   while (1) {
    $3 = $1;
    $1 = $3 + 1 | 0;
    $4 = ($1 << 4) + $6 | 0;
    $7 = HEAPF64[$6 + 8 >> 3];
    $5 = -HEAPF64[$4 >> 3] / ($7 > 9.999999717180685e-10 ? $7 : 9.999999717180685e-10);
    HEAPF32[($3 << 2) + $0 >> 2] = $5;
    label$5 : {
     if (($2 | 0) <= ($3 | 0)) {
      break label$5;
     }
     $8 = HEAPF64[$4 >> 3];
     HEAPF64[$4 >> 3] = $8 + $5 * $7;
     HEAPF64[$6 + 8 >> 3] = $7 + $5 * $8;
     $3 = 1;
     if (($9 | 0) == 1) {
      break label$5;
     }
     while (1) {
      $4 = ($1 + $3 << 4) + $6 | 0;
      $10 = $4;
      $7 = HEAPF64[$4 >> 3];
      $4 = ($3 << 4) + $6 | 0;
      $8 = HEAPF64[$4 + 8 >> 3];
      HEAPF64[$10 >> 3] = $7 + $5 * $8;
      HEAPF64[$4 + 8 >> 3] = $8 + $5 * $7;
      $3 = $3 + 1 | 0;
      if (($9 | 0) != ($3 | 0)) {
       continue;
      }
      break;
     }
    }
    $9 = $9 - 1 | 0;
    if (($1 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  __stack_pointer = $6 + 400 | 0;
  $5 = HEAPF64[$6 + 8 >> 3];
  return Math_fround($5);
 }
 celt_fatal(9497, 9557, 44);
 abort();
}
function gain_fade($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = Math_fround(0), $10 = 0, $11 = 0;
 $10 = 48e3 / ($8 | 0) | 0;
 $11 = ($4 | 0) / ($10 | 0) | 0;
 label$1 : {
  if (($6 | 0) != 1) {
   $4 = 0;
   if (($11 | 0) <= 0) {
    break label$1;
   }
   while (1) {
    $8 = $4 << 3;
    $9 = HEAPF32[(Math_imul($4, $10) << 2) + $7 >> 2];
    $9 = Math_fround($9 * $9);
    $9 = Math_fround(Math_fround($9 * $3) + Math_fround(Math_fround(Math_fround(1) - $9) * $2));
    HEAPF32[$8 + $1 >> 2] = HEAPF32[$0 + $8 >> 2] * $9;
    $8 = $8 | 4;
    HEAPF32[$8 + $1 >> 2] = HEAPF32[$0 + $8 >> 2] * $9;
    $4 = $4 + 1 | 0;
    if (($11 | 0) != ($4 | 0)) {
     continue;
    }
    break;
   }
   break label$1;
  }
  if (($11 | 0) < 1) {
   break label$1;
  }
  $4 = 0;
  while (1) {
   $8 = $4 << 2;
   $9 = HEAPF32[(Math_imul($4, $10) << 2) + $7 >> 2];
   $9 = Math_fround($9 * $9);
   HEAPF32[$8 + $1 >> 2] = HEAPF32[$0 + $8 >> 2] * Math_fround(Math_fround($9 * $3) + Math_fround(Math_fround(Math_fround(1) - $9) * $2));
   $4 = $4 + 1 | 0;
   if (($11 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
 }
 $10 = ($6 | 0) > 1 ? $6 : 1;
 $7 = 0;
 while (1) {
  $4 = $11;
  if (($5 | 0) > ($4 | 0)) {
   while (1) {
    $8 = Math_imul($4, $6) + $7 << 2;
    HEAPF32[$8 + $1 >> 2] = HEAPF32[$0 + $8 >> 2] * $3;
    $4 = $4 + 1 | 0;
    if (($5 | 0) != ($4 | 0)) {
     continue;
    }
    break;
   }
  }
  $7 = $7 + 1 | 0;
  if (($10 | 0) != ($7 | 0)) {
   continue;
  }
  break;
 }
}
function _celt_lpc($0, $1, $2) {
 var $3 = Math_fround(0), $4 = 0, $5 = Math_fround(0), $6 = 0, $7 = 0, $8 = 0, $9 = Math_fround(0), $10 = Math_fround(0), $11 = 0, $12 = 0, $13 = 0;
 $5 = HEAPF32[$1 >> 2];
 $0 = memset($0, 0, $2 << 2);
 label$1 : {
  if (HEAPF32[$1 >> 2] == Math_fround(0)) {
   break label$1;
  }
  $11 = ($2 | 0) > 0 ? $2 : 0;
  $7 = 1;
  while (1) {
   if (($4 | 0) == ($11 | 0)) {
    break label$1;
   }
   $2 = 0;
   $3 = Math_fround(0);
   if ($4) {
    while (1) {
     $3 = Math_fround($3 + Math_fround(HEAPF32[($2 << 2) + $0 >> 2] * HEAPF32[($4 - $2 << 2) + $1 >> 2]));
     $2 = $2 + 1 | 0;
     if (($4 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   $8 = $4 + 1 | 0;
   $3 = Math_fround(Math_fround(-Math_fround($3 + HEAPF32[($8 << 2) + $1 >> 2])) / $5);
   HEAPF32[($4 << 2) + $0 >> 2] = $3;
   if ($4) {
    $12 = $7 >>> 1 | 0;
    $2 = 0;
    while (1) {
     $6 = ($2 << 2) + $0 | 0;
     $13 = $6;
     $9 = HEAPF32[$6 >> 2];
     $6 = (($2 ^ -1) + $4 << 2) + $0 | 0;
     $10 = HEAPF32[$6 >> 2];
     HEAPF32[$13 >> 2] = $9 + Math_fround($3 * $10);
     HEAPF32[$6 >> 2] = $10 + Math_fround($3 * $9);
     $2 = $2 + 1 | 0;
     if (($12 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   $7 = $7 + 1 | 0;
   $4 = $8;
   $5 = Math_fround($5 - Math_fround($5 * Math_fround($3 * $3)));
   if ($5 < Math_fround(HEAPF32[$1 >> 2] * Math_fround(.0010000000474974513)) ^ 1) {
    continue;
   }
   break;
  }
 }
}
function silk_resampler($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 label$1 : {
  $4 = HEAP32[$0 + 284 >> 2];
  if (($4 | 0) <= ($3 | 0)) {
   $6 = HEAP32[$0 + 292 >> 2];
   if (($6 | 0) > ($4 | 0)) {
    break label$1;
   }
   $5 = $0 + 168 | 0;
   $4 = $4 - $6 << 1;
   memcpy($5 + ($6 << 1) | 0, $2, $4);
   label$3 : {
    label$4 : {
     switch (HEAP32[$0 + 264 >> 2] - 1 | 0) {
     case 0:
      silk_resampler_private_up2_HQ_wrapper($0, $1, $5, HEAP32[$0 + 284 >> 2]);
      silk_resampler_private_up2_HQ_wrapper($0, (HEAP32[$0 + 288 >> 2] << 1) + $1 | 0, $2 + $4 | 0, $3 - HEAP32[$0 + 284 >> 2] | 0);
      break label$3;
     case 1:
      silk_resampler_private_IIR_FIR($0, $1, $5, HEAP32[$0 + 284 >> 2]);
      silk_resampler_private_IIR_FIR($0, (HEAP32[$0 + 288 >> 2] << 1) + $1 | 0, $2 + $4 | 0, $3 - HEAP32[$0 + 284 >> 2] | 0);
      break label$3;
     case 2:
      silk_resampler_private_down_FIR($0, $1, $5, HEAP32[$0 + 284 >> 2]);
      silk_resampler_private_down_FIR($0, (HEAP32[$0 + 288 >> 2] << 1) + $1 | 0, $2 + $4 | 0, $3 - HEAP32[$0 + 284 >> 2] | 0);
      break label$3;
     default:
      break label$4;
     }
    }
    memcpy(memcpy($1, $5, HEAP32[$0 + 284 >> 2] << 1) + (HEAP32[$0 + 288 >> 2] << 1) | 0, $2 + $4 | 0, $3 - HEAP32[$0 + 284 >> 2] << 1);
   }
   $0 = HEAP32[$0 + 292 >> 2];
   memcpy($5, ($3 - $0 << 1) + $2 | 0, $0 << 1);
   return 0;
  }
  celt_fatal(6521, 6474, 184);
  abort();
 }
 celt_fatal(6561, 6474, 186);
 abort();
}
function silk_quant_LTP_gains_FLP($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $11 = __stack_pointer - 528 | 0;
 __stack_pointer = $11;
 $13 = Math_imul($8, 25);
 if (($13 | 0) > 0) {
  while (1) {
   $12 = $10 << 2;
   HEAP32[$12 + ($11 + 80 | 0) >> 2] = lrintf(Math_fround(HEAPF32[$5 + $12 >> 2] * Math_fround(131072)));
   $10 = $10 + 1 | 0;
   if (($13 | 0) != ($10 | 0)) {
    continue;
   }
   break;
  }
 }
 label$3 : {
  if (($8 | 0) >= 1) {
   $10 = Math_imul($8, 5);
   $5 = ($10 | 0) > 1 ? $10 : 1;
   $10 = 0;
   while (1) {
    $12 = $10 << 2;
    HEAP32[$12 + $11 >> 2] = lrintf(Math_fround(HEAPF32[$6 + $12 >> 2] * Math_fround(131072)));
    $10 = $10 + 1 | 0;
    if (($10 | 0) != ($5 | 0)) {
     continue;
    }
    break;
   }
   silk_quant_LTP_gains($11 + 480 | 0, $1, $2, $3, $11 + 524 | 0, $11 + 80 | 0, $11, $7, $8, $9);
   if (($8 | 0) < 1) {
    break label$3;
   }
   $10 = Math_imul($8, 5);
   $12 = ($10 | 0) > 1 ? $10 : 1;
   $10 = 0;
   while (1) {
    HEAPF32[($10 << 2) + $0 >> 2] = Math_fround(HEAP16[($11 + 480 | 0) + ($10 << 1) >> 1]) * Math_fround(6103515625e-14);
    $10 = $10 + 1 | 0;
    if (($12 | 0) != ($10 | 0)) {
     continue;
    }
    break;
   }
   break label$3;
  }
  silk_quant_LTP_gains($11 + 480 | 0, $1, $2, $3, $11 + 524 | 0, $11 + 80 | 0, $11, $7, $8, $9);
 }
 HEAPF32[$4 >> 2] = Math_fround(HEAP32[$11 + 524 >> 2]) * Math_fround(.0078125);
 __stack_pointer = $11 + 528 | 0;
}
function __vfprintf_internal($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 208 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 204 >> 2] = $2;
 $2 = 0;
 memset($5 + 160 | 0, 0, 40);
 HEAP32[$5 + 200 >> 2] = HEAP32[$5 + 204 >> 2];
 label$1 : {
  if ((printf_core(0, $1, $5 + 200 | 0, $5 + 80 | 0, $5 + 160 | 0, $3, $4) | 0) < 0) {
   $1 = -1;
   break label$1;
  }
  if (HEAP32[$0 + 76 >> 2] >= 0) {
   $2 = __lockfile($0);
  }
  $6 = HEAP32[$0 >> 2];
  if (HEAP8[$0 + 74 | 0] <= 0) {
   HEAP32[$0 >> 2] = $6 & -33;
  }
  $6 = $6 & 32;
  label$5 : {
   if (HEAP32[$0 + 48 >> 2]) {
    $4 = printf_core($0, $1, $5 + 200 | 0, $5 + 80 | 0, $5 + 160 | 0, $3, $4);
    break label$5;
   }
   HEAP32[$0 + 48 >> 2] = 80;
   HEAP32[$0 + 16 >> 2] = $5 + 80;
   HEAP32[$0 + 28 >> 2] = $5;
   HEAP32[$0 + 20 >> 2] = $5;
   $7 = HEAP32[$0 + 44 >> 2];
   HEAP32[$0 + 44 >> 2] = $5;
   $1 = printf_core($0, $1, $5 + 200 | 0, $5 + 80 | 0, $5 + 160 | 0, $3, $4);
   $4 = $1;
   if (!$7) {
    break label$5;
   }
   FUNCTION_TABLE[HEAP32[$0 + 36 >> 2]]($0, 0, 0) | 0;
   HEAP32[$0 + 48 >> 2] = 0;
   HEAP32[$0 + 44 >> 2] = $7;
   HEAP32[$0 + 28 >> 2] = 0;
   HEAP32[$0 + 16 >> 2] = 0;
   $3 = HEAP32[$0 + 20 >> 2];
   HEAP32[$0 + 20 >> 2] = 0;
   $4 = $3 ? $1 : -1;
  }
  $3 = HEAP32[$0 >> 2];
  HEAP32[$0 >> 2] = $6 | $3;
  $1 = $4;
  $1 = $3 & 32 ? -1 : $1;
  if (!$2) {
   break label$1;
  }
  __unlockfile($0);
 }
 __stack_pointer = $5 + 208 | 0;
 return $1;
}
function _celt_autocorr($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = Math_fround(0), $10 = 0, $11 = 0;
 $7 = __stack_pointer;
 $11 = $7;
 $7 = $7 - (($5 << 2) + 15 & -16) | 0;
 __stack_pointer = $7;
 label$1 : {
  if (($5 | 0) > 0) {
   if (($3 | 0) <= -1) {
    break label$1;
   }
   if ($3) {
    $10 = memcpy($7, $0, $5 << 2);
    $7 = 0;
    while (1) {
     $8 = $7 << 2;
     $9 = HEAPF32[$8 + $2 >> 2];
     HEAPF32[$8 + $10 >> 2] = HEAPF32[$0 + $8 >> 2] * $9;
     $8 = ($7 ^ -1) + $5 << 2;
     HEAPF32[$10 + $8 >> 2] = $9 * HEAPF32[$0 + $8 >> 2];
     $7 = $7 + 1 | 0;
     if (($7 | 0) != ($3 | 0)) {
      continue;
     }
     break;
    }
    $0 = $10;
   }
   $2 = $5 - $4 | 0;
   celt_pitch_xcorr_c($0, $0, $1, $2, $4 + 1 | 0, $6);
   $8 = 0;
   if (($4 | 0) >= 0) {
    while (1) {
     $9 = Math_fround(0);
     $7 = $8 + $2 | 0;
     if (($7 | 0) < ($5 | 0)) {
      while (1) {
       $9 = Math_fround($9 + Math_fround(HEAPF32[($7 << 2) + $0 >> 2] * HEAPF32[($7 - $8 << 2) + $0 >> 2]));
       $7 = $7 + 1 | 0;
       if (($7 | 0) != ($5 | 0)) {
        continue;
       }
       break;
      }
     }
     $7 = ($8 << 2) + $1 | 0;
     HEAPF32[$7 >> 2] = $9 + HEAPF32[$7 >> 2];
     $7 = ($4 | 0) != ($8 | 0);
     $8 = $8 + 1 | 0;
     if ($7) {
      continue;
     }
     break;
    }
   }
   __stack_pointer = $11;
   return 0;
  }
  celt_fatal(9687, 9671, 228);
  abort();
 }
 celt_fatal(9709, 9671, 229);
 abort();
}
function silk_biquad_alt_stride1($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 if (($5 | 0) >= 1) {
  $7 = 0 - HEAP32[$2 + 4 >> 2] | 0;
  $11 = $7 & 16383;
  $2 = 0 - HEAP32[$2 >> 2] | 0;
  $12 = $2 & 16383;
  $13 = $7 << 2 >> 16;
  $14 = $2 << 2 >> 16;
  $6 = HEAP32[$3 + 4 >> 2];
  $8 = HEAP32[$3 >> 2];
  while (1) {
   $15 = $10 << 1;
   $2 = HEAP16[$15 + $0 >> 1];
   $7 = HEAP32[$1 >> 2];
   $7 = (Math_imul($2, $7 >> 16) + $8 | 0) + (Math_imul($7 & 65535, $2) >> 16) << 2;
   $8 = $7 >> 16;
   $9 = Math_imul($14, $8) + $6 | 0;
   $6 = $7 & 65532;
   $16 = ($9 + (Math_imul($14, $6) >> 16) | 0) + ((Math_imul($8, $12) + (Math_imul($6, $12) >>> 16 | 0) >> 13) + 1 >> 1) | 0;
   HEAP32[$3 >> 2] = $16;
   $9 = HEAP32[$1 + 4 >> 2];
   $6 = (Math_imul($8, $13) + (Math_imul($6, $13) >> 16) | 0) + ((Math_imul($8, $11) + (Math_imul($6, $11) >>> 16 | 0) >> 13) + 1 >> 1) | 0;
   HEAP32[$3 + 4 >> 2] = $6;
   $8 = (Math_imul($9 >> 16, $2) + (Math_imul($9 & 65535, $2) >> 16) | 0) + $16 | 0;
   HEAP32[$3 >> 2] = $8;
   $9 = HEAP32[$1 + 8 >> 2];
   $6 = ((Math_imul($9 & 65535, $2) >> 16) + Math_imul($9 >> 16, $2) | 0) + $6 | 0;
   HEAP32[$3 + 4 >> 2] = $6;
   $2 = $7 + 16383 >> 14;
   HEAP16[$4 + $15 >> 1] = ($7 | 0) > 536854528 ? 32767 : ($2 | 0) > -32768 ? $2 : -32768;
   $10 = $10 + 1 | 0;
   if (($10 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
 }
}
function downmix_float($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 var $7 = 0, $8 = 0;
 label$1 : {
  label$2 : {
   if (($2 | 0) >= 1) {
    while (1) {
     HEAPF32[($7 << 2) + $1 >> 2] = HEAPF32[(Math_imul($3 + $7 | 0, $6) + $4 << 2) + $0 >> 2] * Math_fround(32768);
     $7 = $7 + 1 | 0;
     if (($7 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
    if (($5 | 0) <= -1) {
     break label$2;
    }
    if (($2 | 0) < 1) {
     break label$1;
    }
    $7 = 0;
    while (1) {
     $4 = ($7 << 2) + $1 | 0;
     HEAPF32[$4 >> 2] = HEAPF32[$4 >> 2] + Math_fround(HEAPF32[(Math_imul($3 + $7 | 0, $6) + $5 << 2) + $0 >> 2] * Math_fround(32768));
     $7 = $7 + 1 | 0;
     if (($7 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
    break label$1;
   }
   if (($5 | 0) > -1) {
    break label$1;
   }
  }
  if (($5 | 0) != -2 | ($6 | 0) < 2) {
   break label$1;
  }
  $5 = 1;
  $8 = ($2 | 0) < 1;
  while (1) {
   $7 = 0;
   if (!$8) {
    while (1) {
     $4 = ($7 << 2) + $1 | 0;
     HEAPF32[$4 >> 2] = HEAPF32[$4 >> 2] + Math_fround(HEAPF32[(Math_imul($3 + $7 | 0, $6) + $5 << 2) + $0 >> 2] * Math_fround(32768));
     $7 = $7 + 1 | 0;
     if (($7 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   $5 = $5 + 1 | 0;
   if (($6 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
 }
}
function alg_quant($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = Math_fround(0);
 $8 = __stack_pointer;
 $10 = $8;
 label$1 : {
  if (($2 | 0) > 0) {
   if (($1 | 0) <= 1) {
    break label$1;
   }
   $8 = $8 - (($1 << 2) + 27 & -16) | 0;
   __stack_pointer = $8;
   exp_rotation($0, $1, 1, $4, $2, $3);
   $11 = op_pvq_search_c($0, $8, $2, $1, $5);
   encode_pulses($8, $1, $2, $5);
   if ($7) {
    $6 = Math_fround(Math_fround(Math_fround(1) / Math_fround(Math_sqrt($11))) * $6);
    $5 = 0;
    while (1) {
     $7 = $5 << 2;
     HEAPF32[$7 + $0 >> 2] = $6 * Math_fround(HEAP32[$7 + $8 >> 2]);
     $5 = $5 + 1 | 0;
     if (($5 | 0) != ($1 | 0)) {
      continue;
     }
     break;
    }
    exp_rotation($0, $1, -1, $4, $2, $3);
   }
   $3 = 1;
   if (($4 | 0) >= 2) {
    $9 = ($1 >>> 0) / ($4 >>> 0) | 0;
    $0 = ($9 | 0) > 1 ? $9 : 1;
    $3 = 0;
    $2 = 0;
    while (1) {
     $1 = Math_imul($2, $9);
     $5 = 0;
     $7 = 0;
     while (1) {
      $7 = HEAP32[($1 + $5 << 2) + $8 >> 2] | $7;
      $5 = $5 + 1 | 0;
      if (($5 | 0) != ($0 | 0)) {
       continue;
      }
      break;
     }
     $3 = (($7 | 0) != 0) << $2 | $3;
     $2 = $2 + 1 | 0;
     if (($4 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   __stack_pointer = $10;
   return $3;
  }
  celt_fatal(41540, 41599, 338);
  abort();
 }
 celt_fatal(41609, 41599, 339);
 abort();
}
function silk_NLSF_VQ_weights_laroia($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1 : {
  if (($2 | 0) > 0) {
   $3 = 1;
   if ($2 & 1) {
    break label$1;
   }
   $5 = HEAP16[$1 >> 1];
   $4 = HEAP16[$1 + 2 >> 1] - $5 | 0;
   $4 = 131072 / ((($4 | 0) > 1 ? $4 : 1) >>> 0) | 0;
   $5 = $4 + (131072 / ((($5 | 0) > 1 ? $5 : 1) >>> 0) | 0) | 0;
   HEAP16[$0 >> 1] = $5 >>> 0 < 32767 ? $5 : 32767;
   $6 = $2 - 1 | 0;
   if (($2 | 0) >= 3) {
    while (1) {
     $2 = $3 << 1;
     $8 = $2 + $0 | 0;
     $5 = $2 + 2 | 0;
     $7 = $5 + $1 | 0;
     $2 = HEAP16[$7 >> 1] - HEAP16[$1 + $2 >> 1] | 0;
     $2 = 131072 / ((($2 | 0) > 1 ? $2 : 1) >>> 0) | 0;
     $4 = $4 + $2 | 0;
     HEAP16[$8 >> 1] = $4 >>> 0 < 32767 ? $4 : 32767;
     $3 = $3 + 2 | 0;
     $4 = HEAP16[($3 << 1) + $1 >> 1] - HEAP16[$7 >> 1] | 0;
     $4 = 131072 / ((($4 | 0) > 1 ? $4 : 1) >>> 0) | 0;
     $2 = $4 + $2 | 0;
     HEAP16[$0 + $5 >> 1] = $2 >>> 0 < 32767 ? $2 : 32767;
     if (($3 | 0) < ($6 | 0)) {
      continue;
     }
     break;
    }
   }
   $3 = $6 << 1;
   $0 = $3 + $0 | 0;
   $3 = 32768 - HEAP16[$1 + $3 >> 1] | 0;
   $3 = (131072 / ((($3 | 0) > 1 ? $3 : 1) >>> 0) | 0) + $4 | 0;
   HEAP16[$0 >> 1] = $3 >>> 0 < 32767 ? $3 : 32767;
   return;
  }
  celt_fatal(15465, 15489, 51);
  abort();
 }
 celt_fatal(15519, 15489, 52);
 abort();
}
function silk_NLSF_decode($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $6 = __stack_pointer - 80 | 0;
 __stack_pointer = $6;
 silk_NLSF_unpack($6 + 32 | 0, $6 - -64 | 0, $2, HEAP8[$1 | 0]);
 $4 = HEAPU16[$2 + 2 >> 1];
 $7 = $4 << 16 >> 16;
 $9 = ($7 | 0) < 1;
 if (!$9) {
  $8 = HEAP16[$2 + 4 >> 1];
  while (1) {
   $5 = HEAP8[$1 + $4 | 0];
   $3 = $5 << 10;
   $5 = ($5 | 0) > 0 ? $3 - 102 | 0 : ($3 | 102) & $5 >> 31;
   $3 = $4 - 1 | 0;
   $10 = (Math_imul($5 >> 16, $8) + (Math_imul(HEAPU8[$3 + ($6 - -64 | 0) | 0], $10 << 16 >> 16) >> 8) | 0) + (Math_imul($5 & 65534, $8) >> 16) | 0;
   HEAP16[($3 << 1) + $6 >> 1] = $10;
   $5 = ($4 | 0) > 1;
   $4 = $3;
   if ($5) {
    continue;
   }
   break;
  }
 }
 if (!$9) {
  $4 = Math_imul(HEAP8[$1 | 0], $7);
  $5 = $4 + HEAP32[$2 + 8 >> 2] | 0;
  $8 = HEAP32[$2 + 12 >> 2] + ($4 << 1) | 0;
  $4 = 0;
  while (1) {
   $3 = $4 << 1;
   $1 = $3 + $0 | 0;
   $3 = ((HEAP16[$3 + $6 >> 1] << 14) / HEAP16[$3 + $8 >> 1] | 0) + (HEAPU8[$4 + $5 | 0] << 7) | 0;
   $3 = ($3 | 0) > 0 ? $3 : 0;
   HEAP16[$1 >> 1] = ($3 | 0) < 32767 ? $3 : 32767;
   $4 = $4 + 1 | 0;
   $7 = HEAP16[$2 + 2 >> 1];
   if (($4 | 0) < ($7 | 0)) {
    continue;
   }
   break;
  }
 }
 silk_NLSF_stabilize($0, HEAP32[$2 + 36 >> 2], $7);
 __stack_pointer = $6 + 80 | 0;
}
function ec_enc_uint($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1 : {
  if ($2 >>> 0 > 1) {
   $3 = $2 - 1 | 0;
   if ($3 >>> 0 >= 256) {
    $4 = 24 - Math_clz32($3) | 0;
    $2 = $1 >>> $4 | 0;
    ec_encode($0, $2, $2 + 1 | 0, ($3 >>> $4 | 0) + 1 | 0);
    if (!$4) {
     break label$1;
    }
    $7 = (-1 << $4 ^ -1) & $1;
    $1 = HEAP32[$0 + 12 >> 2];
    $2 = HEAP32[$0 + 16 >> 2];
    $3 = $4 + $2 | 0;
    label$4 : {
     if ($3 >>> 0 < 33) {
      $5 = $2;
      break label$4;
     }
     while (1) {
      $3 = -1;
      $6 = HEAP32[$0 + 4 >> 2];
      $5 = HEAP32[$0 + 8 >> 2];
      if ($6 >>> 0 > $5 + HEAP32[$0 + 24 >> 2] >>> 0) {
       $3 = $5 + 1 | 0;
       HEAP32[$0 + 8 >> 2] = $3;
       HEAP8[HEAP32[$0 >> 2] + ($6 - $3 | 0) | 0] = $1;
       $3 = 0;
      }
      HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] | $3;
      $1 = $1 >>> 8 | 0;
      $3 = ($2 | 0) > 15;
      $5 = $2 - 8 | 0;
      $2 = $5;
      if ($3) {
       continue;
      }
      break;
     }
     $3 = $4 + $5 | 0;
    }
    HEAP32[$0 + 16 >> 2] = $3;
    HEAP32[$0 + 12 >> 2] = $7 << $5 | $1;
    HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + $4;
    return;
   }
   ec_encode($0, $1, $1 + 1 | 0, $2);
   return;
  }
  celt_fatal(6995, 7019, 180);
  abort();
 }
 celt_fatal(7033, 7019, 198);
 abort();
}
function opus_encoder_create($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     if (($0 | 0) <= 15999) {
      if (($0 | 0) == 8e3 | ($0 | 0) == 12e3) {
       break label$4;
      }
      break label$3;
     }
     if (($0 | 0) == 16e3 | ($0 | 0) == 48e3) {
      break label$4;
     }
     if (($0 | 0) != 24e3) {
      break label$3;
     }
    }
    if ($1 - 1 >>> 0 > 1) {
     break label$3;
    }
    $4 = $2 - 2048 | 0;
    if ($4 >>> 0 > 3) {
     break label$3;
    }
    if (($4 | 0) != 2) {
     break label$2;
    }
   }
   $4 = 0;
   if (!$3) {
    break label$1;
   }
   HEAP32[$3 >> 2] = -1;
   break label$1;
  }
  $4 = 0;
  if (!silk_Get_Encoder_Size($5 + 12 | 0)) {
   HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 3 & -4;
   $4 = (celt_encoder_get_size($1) + HEAP32[$5 + 12 >> 2] | 0) + 18140 | 0;
  }
  $4 = dlmalloc($4);
  if (!$4) {
   $4 = 0;
   if (!$3) {
    break label$1;
   }
   HEAP32[$3 >> 2] = -7;
   break label$1;
  }
  $0 = opus_encoder_init($4, $0, $1, $2);
  if ($3) {
   HEAP32[$3 >> 2] = $0;
  }
  if (!$0) {
   break label$1;
  }
  dlfree($4);
  $4 = 0;
 }
 __stack_pointer = $5 + 16 | 0;
 return $4 | 0;
}
function deinterleave_hadamard($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $5 = __stack_pointer;
 $9 = $5;
 $8 = Math_imul($1, $2);
 $5 = $5 - (($8 << 2) + 15 & -16) | 0;
 __stack_pointer = $5;
 if (($2 | 0) > 0) {
  label$2 : {
   if (!$3) {
    $6 = ($1 | 0) < 1;
    while (1) {
     if (!$6) {
      $7 = Math_imul($1, $4);
      $3 = 0;
      while (1) {
       HEAP32[($3 + $7 << 2) + $5 >> 2] = HEAP32[(Math_imul($2, $3) + $4 << 2) + $0 >> 2];
       $3 = $3 + 1 | 0;
       if (($3 | 0) != ($1 | 0)) {
        continue;
       }
       break;
      }
     }
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
    break label$2;
   }
   $10 = ($2 << 2) + 41976 | 0;
   $6 = ($1 | 0) < 1;
   while (1) {
    if (!$6) {
     $7 = Math_imul(HEAP32[($4 << 2) + $10 >> 2], $1);
     $3 = 0;
     while (1) {
      HEAP32[($3 + $7 << 2) + $5 >> 2] = HEAP32[(Math_imul($2, $3) + $4 << 2) + $0 >> 2];
      $3 = $3 + 1 | 0;
      if (($3 | 0) != ($1 | 0)) {
       continue;
      }
      break;
     }
    }
    $4 = $4 + 1 | 0;
    if (($4 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  memcpy($0, $5, $8 << 2);
  __stack_pointer = $9;
  return;
 }
 celt_fatal(41952, 41800, 591);
 abort();
}
function ec_laplace_encode($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 label$1 : {
  label$2 : {
   $7 = HEAP32[$1 >> 2];
   if ($7) {
    $5 = 1;
    $4 = Math_imul(16384 - $3 | 0, 32736 - $2 | 0) >>> 15 | 0;
    $6 = $7 >> 31;
    $8 = $6 ^ $6 + $7;
    label$5 : {
     if (!$4 | ($8 | 0) < 2) {
      break label$5;
     }
     while (1) {
      $9 = $4 << 1;
      $4 = Math_imul($9, $3) >>> 15 | 0;
      $2 = ($2 + $9 | 0) + 2 | 0;
      $5 = $5 + 1 | 0;
      if (($8 | 0) <= ($5 | 0)) {
       break label$5;
      }
      if ($4) {
       continue;
      }
      break;
     }
    }
    label$7 : {
     if (!$4) {
      $3 = $5 + $6 | 0;
      $4 = $8 - $5 | 0;
      $5 = (($7 >>> 31 | 32768) - $2 >> 1) - 1 | 0;
      $4 = ($4 | 0) < ($5 | 0) ? $4 : $5;
      HEAP32[$1 >> 2] = $3 + $4 ^ $6;
      $4 = ($2 + $6 | 0) + ($4 << 1 | 1) | 0;
      $2 = ($4 | 0) != 32768;
      break label$7;
     }
     $5 = $4 + 1 | 0;
     $4 = ($5 & ($6 ^ -1)) + $2 | 0;
     $2 = $5;
    }
    if ($2 + $4 >>> 0 >= 32769) {
     break label$2;
    }
    if (!$2) {
     break label$1;
    }
   }
   ec_encode_bin($0, $4, $2 + $4 | 0, 15);
   return;
  }
  celt_fatal(32848, 32879, 88);
  abort();
 }
 celt_fatal(32894, 32879, 89);
 abort();
}
function alg_unquant($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $7 = __stack_pointer;
 $10 = $7;
 label$1 : {
  if (($2 | 0) > 0) {
   if (($1 | 0) <= 1) {
    break label$1;
   }
   $8 = $7 - (($1 << 2) + 15 & -16) | 0;
   __stack_pointer = $8;
   $6 = Math_fround(Math_fround(Math_fround(1) / Math_fround(Math_sqrt(decode_pulses($8, $1, $2, $5)))) * $6);
   $5 = 0;
   while (1) {
    $7 = $5 << 2;
    HEAPF32[$7 + $0 >> 2] = $6 * Math_fround(HEAP32[$7 + $8 >> 2]);
    $5 = $5 + 1 | 0;
    if (($5 | 0) != ($1 | 0)) {
     continue;
    }
    break;
   }
   exp_rotation($0, $1, -1, $4, $2, $3);
   $3 = 1;
   if (($4 | 0) >= 2) {
    $9 = ($1 >>> 0) / ($4 >>> 0) | 0;
    $0 = ($9 | 0) > 1 ? $9 : 1;
    $3 = 0;
    $2 = 0;
    while (1) {
     $1 = Math_imul($2, $9);
     $5 = 0;
     $7 = 0;
     while (1) {
      $7 = HEAP32[($1 + $5 << 2) + $8 >> 2] | $7;
      $5 = $5 + 1 | 0;
      if (($5 | 0) != ($0 | 0)) {
       continue;
      }
      break;
     }
     $3 = (($7 | 0) != 0) << $2 | $3;
     $2 = $2 + 1 | 0;
     if (($4 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   __stack_pointer = $10;
   return $3;
  }
  celt_fatal(41673, 41599, 371);
  abort();
 }
 celt_fatal(41734, 41599, 372);
 abort();
}
function interleave_hadamard($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $5 = __stack_pointer;
 $9 = $5;
 $8 = Math_imul($1, $2);
 $5 = $5 - (($8 << 2) + 15 & -16) | 0;
 __stack_pointer = $5;
 label$1 : {
  if (!$3) {
   if (($2 | 0) < 1) {
    break label$1;
   }
   $6 = ($1 | 0) < 1;
   while (1) {
    if (!$6) {
     $7 = Math_imul($1, $4);
     $3 = 0;
     while (1) {
      HEAP32[(Math_imul($2, $3) + $4 << 2) + $5 >> 2] = HEAP32[($3 + $7 << 2) + $0 >> 2];
      $3 = $3 + 1 | 0;
      if (($3 | 0) != ($1 | 0)) {
       continue;
      }
      break;
     }
    }
    $4 = $4 + 1 | 0;
    if (($4 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
   break label$1;
  }
  if (($2 | 0) < 1) {
   break label$1;
  }
  $10 = ($2 << 2) + 41976 | 0;
  $6 = ($1 | 0) < 1;
  while (1) {
   if (!$6) {
    $7 = Math_imul(HEAP32[($4 << 2) + $10 >> 2], $1);
    $3 = 0;
    while (1) {
     HEAP32[(Math_imul($2, $3) + $4 << 2) + $5 >> 2] = HEAP32[($3 + $7 << 2) + $0 >> 2];
     $3 = $3 + 1 | 0;
     if (($3 | 0) != ($1 | 0)) {
      continue;
     }
     break;
    }
   }
   $4 = $4 + 1 | 0;
   if (($4 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
 }
 memcpy($0, $5, $8 << 2);
 __stack_pointer = $9;
}
function encode_pulses($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 label$1 : {
  if (($2 | 0) > 0) {
   if (($1 | 0) <= 1) {
    break label$1;
   }
   $8 = $1 - 1 | 0;
   $4 = HEAP32[($8 << 2) + $0 >> 2];
   $5 = $4 >> 31;
   $5 = $5 ^ $4 + $5;
   $7 = $4 >>> 31 | 0;
   while (1) {
    $9 = $8 - 1 | 0;
    $4 = $1 - $9 | 0;
    $7 = HEAP32[HEAP32[((($4 | 0) < ($5 | 0) ? $4 : $5) << 2) + 36320 >> 2] + ((($4 | 0) > ($5 | 0) ? $4 : $5) << 2) >> 2] + $7 | 0;
    $6 = HEAP32[($9 << 2) + $0 >> 2];
    $10 = $6 >> 31;
    $5 = ($10 ^ $6 + $10) + $5 | 0;
    if (($6 | 0) <= -1) {
     $6 = $5 + 1 | 0;
     $7 = HEAP32[HEAP32[((($4 | 0) > ($5 | 0) ? $6 : $4) << 2) + 36320 >> 2] + ((($4 | 0) > ($6 | 0) ? $4 : $6) << 2) >> 2] + $7 | 0;
    }
    $4 = ($8 | 0) > 1;
    $8 = $9;
    if ($4) {
     continue;
    }
    break;
   }
   $5 = $2 + 1 | 0;
   $4 = ($1 | 0) > ($2 | 0);
   ec_enc_uint($3, $7, HEAP32[HEAP32[(($4 ? $5 : $1) << 2) + 36320 >> 2] + ((($1 | 0) > ($5 | 0) ? $1 : $5) << 2) >> 2] + HEAP32[HEAP32[((($1 | 0) < ($2 | 0) ? $1 : $2) << 2) + 36320 >> 2] + (($4 ? $1 : $2) << 2) >> 2] | 0);
   return;
  }
  celt_fatal(36272, 36295, 459);
  abort();
 }
 celt_fatal(36380, 36295, 444);
 abort();
}
function silk_apply_sine_window_FLP($0, $1, $2, $3) {
 var $4 = Math_fround(0), $5 = Math_fround(0), $6 = 0, $7 = Math_fround(0), $8 = 0;
 label$1 : {
  if ($2 - 1 >>> 0 < 2) {
   if ($3 & 3) {
    break label$1;
   }
   if (($3 | 0) >= 1) {
    $4 = Math_fround(Math_fround(3.1415927410125732) / Math_fround($3 + 1 | 0));
    $7 = Math_fround(Math_fround(2) - Math_fround($4 * $4));
    $2 = ($2 | 0) < 2;
    $4 = $2 ? $4 : Math_fround($7 * Math_fround(.5));
    $5 = $2 ? Math_fround(0) : Math_fround(1);
    while (1) {
     $2 = $8 << 2;
     HEAPF32[$2 + $0 >> 2] = Math_fround($5 + $4) * Math_fround(HEAPF32[$1 + $2 >> 2] * Math_fround(.5));
     $6 = $2 | 4;
     HEAPF32[$6 + $0 >> 2] = $4 * HEAPF32[$1 + $6 >> 2];
     $6 = $2 | 8;
     $5 = Math_fround(Math_fround($7 * $4) - $5);
     HEAPF32[$6 + $0 >> 2] = Math_fround($4 + $5) * Math_fround(HEAPF32[$1 + $6 >> 2] * Math_fround(.5));
     $2 = $2 | 12;
     HEAPF32[$2 + $0 >> 2] = $5 * HEAPF32[$1 + $2 >> 2];
     $4 = Math_fround(Math_fround($7 * $5) - $4);
     $8 = $8 + 4 | 0;
     if (($8 | 0) < ($3 | 0)) {
      continue;
     }
     break;
    }
   }
   return;
  }
  celt_fatal(9375, 9424, 48);
  abort();
 }
 celt_fatal(9459, 9424, 51);
 abort();
}
function silk_sum_sqr_shift($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $9 = $3 - 1 | 0;
 $10 = Math_clz32($3);
 $7 = 31 - $10 | 0;
 label$1 : {
  if (($3 | 0) < 2) {
   $5 = $3;
   break label$1;
  }
  $5 = $3;
  while (1) {
   $6 = $4 << 1;
   $8 = HEAP16[($6 | 2) + $2 >> 1];
   $6 = HEAP16[$2 + $6 >> 1];
   $5 = (Math_imul($8, $8) + Math_imul($6, $6) >>> $7 | 0) + $5 | 0;
   $4 = $4 + 2 | 0;
   if (($9 | 0) > ($4 | 0)) {
    continue;
   }
   break;
  }
  $4 = $3 & -2;
 }
 $6 = 0;
 if (($3 | 0) > ($4 | 0)) {
  $4 = HEAP16[($4 << 1) + $2 >> 1];
  $5 = (Math_imul($4, $4) >>> $7 | 0) + $5 | 0;
 }
 $4 = 34 - (Math_clz32($5) + $10 | 0) | 0;
 $7 = ($4 | 0) > 0 ? $4 : 0;
 if (($3 | 0) < 2) {
  $4 = 0;
 } else {
  $4 = 0;
  while (1) {
   $5 = $4 << 1;
   $8 = HEAP16[($5 | 2) + $2 >> 1];
   $5 = HEAP16[$2 + $5 >> 1];
   $6 = (Math_imul($8, $8) + Math_imul($5, $5) >>> $7 | 0) + $6 | 0;
   $4 = $4 + 2 | 0;
   if (($9 | 0) > ($4 | 0)) {
    continue;
   }
   break;
  }
  $4 = $3 & -2;
 }
 if (($4 | 0) < ($3 | 0)) {
  $2 = HEAP16[($4 << 1) + $2 >> 1];
  $6 = (Math_imul($2, $2) >>> $7 | 0) + $6 | 0;
 }
 HEAP32[$1 >> 2] = $7;
 HEAP32[$0 >> 2] = $6;
}
function sinc($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = Math_fround(0), $9 = 0, $10 = Math_fround(0), $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $4 = +$1;
 $6 = Math_abs($4);
 if ($6 < 1e-6) {
  return $0;
 }
 $7 = +($2 | 0);
 if (!($7 * .5 < $6)) {
  $1 = Math_fround($0 * $1);
  $2 = HEAP32[$3 >> 2];
  $8 = Math_fround(Math_fround(Math_abs(Math_fround(($4 + $4) / $7))) * Math_fround(HEAP32[$3 + 4 >> 2]));
  $10 = Math_fround(Math_floor($8));
  label$3 : {
   if (Math_fround(Math_abs($10)) < Math_fround(2147483648)) {
    $3 = ~~$10;
    break label$3;
   }
   $3 = -2147483648;
  }
  $2 = $2 + ($3 << 3) | 0;
  $6 = HEAPF64[$2 + 8 >> 3];
  $7 = HEAPF64[$2 >> 3];
  $13 = HEAPF64[$2 + 16 >> 3];
  $9 = HEAPF64[$2 + 24 >> 3];
  $4 = +$1 * 3.141592653589793;
  $14 = sin($4) * +$0 / $4;
  $1 = Math_fround($8 - Math_fround($3 | 0));
  $0 = Math_fround($1 * $1);
  $5 = +Math_fround($1 * $0);
  $11 = $5 * .1666666667;
  $4 = +$1;
  $12 = $11 - $4 * .1666666667;
  $15 = $9 * $12;
  $9 = +$0 * .5;
  $5 = $9 + $4 - $5 * .5;
  $4 = $9 + $4 * -.3333333333 - $11;
  $8 = Math_fround($14 * ($15 + ($13 * $5 + ($7 * $4 + $6 * (1 - $12 - $5 - $4)))));
 }
 return $8;
}
function compute_band_energies($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = Math_fround(0), $10 = 0, $11 = 0, $12 = 0, $13 = Math_fround(0), $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $14 = ($4 | 0) > 1 ? $4 : 1;
 $15 = HEAP32[$0 + 44 >> 2] << $5;
 $10 = HEAP32[$0 + 32 >> 2];
 while (1) {
  if (($3 | 0) >= 1) {
   $16 = Math_imul($7, $15);
   $17 = Math_imul(HEAP32[$0 + 8 >> 2], $7);
   $8 = HEAPU16[$10 >> 1];
   $6 = 0;
   while (1) {
    $4 = $8 << 16;
    $9 = Math_fround(0);
    $11 = $6 + 1 | 0;
    $8 = HEAP16[($11 << 1) + $10 >> 1];
    $4 = $4 >> 16;
    $12 = $8 - $4 << $5;
    if (($12 | 0) >= 1) {
     $18 = (($4 << $5) + $16 << 2) + $1 | 0;
     $4 = 0;
     while (1) {
      $13 = HEAPF32[($4 << 2) + $18 >> 2];
      $9 = Math_fround($9 + Math_fround($13 * $13));
      $4 = $4 + 1 | 0;
      if (($12 | 0) != ($4 | 0)) {
       continue;
      }
      break;
     }
    }
    HEAPF32[($6 + $17 << 2) + $2 >> 2] = Math_sqrt(Math_fround($9 + Math_fround(1.0000000272452012e-27)));
    $6 = $11;
    if (($6 | 0) != ($3 | 0)) {
     continue;
    }
    break;
   }
  }
  $7 = $7 + 1 | 0;
  if (($14 | 0) != ($7 | 0)) {
   continue;
  }
  break;
 }
}
function opus_encode_float($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $9 = -1;
 $5 = HEAP32[$0 + 144 >> 2];
 $7 = ($5 | 0) / 400 | 0;
 label$1 : {
  if (($7 | 0) > ($2 | 0)) {
   break label$1;
  }
  $6 = $2;
  $8 = HEAP32[$0 + 156 >> 2];
  if (($8 | 0) != 5e3) {
   $6 = $8 - 5001 | 0;
   if ($6 >>> 0 > 8) {
    break label$1;
   }
   $6 = ($8 | 0) <= 5005 ? $7 << $6 : (Math_imul($8 - 5003 | 0, $5) | 0) / 50 | 0;
   if (($6 | 0) > ($2 | 0)) {
    break label$1;
   }
  }
  label$5 : {
   if ((Math_imul($6, 100) | 0) == ($5 | 0) | (Math_imul($6, 400) | 0) == ($5 | 0) | (Math_imul($6, 200) | 0) == ($5 | 0)) {
    break label$5;
   }
   $7 = Math_imul($6, 50);
   if (($7 | 0) == (Math_imul($5, 6) | 0) | (Math_imul($5, 5) | 0) == ($7 | 0) | ($5 << 2 == ($7 | 0) | (Math_imul($5, 3) | 0) == ($7 | 0))) {
    break label$5;
   }
   if (($5 | 0) == ($7 | 0)) {
    break label$5;
   }
   if ((Math_imul($6, 25) | 0) != ($5 | 0)) {
    break label$1;
   }
  }
  $9 = $6;
 }
 return opus_encode_native($0, $1, $9, $3, $4, 24, $1, $2, 0, -2, HEAP32[$0 + 112 >> 2], 4, 1) | 0;
}
function silk_InitEncoder($0, $1, $2) {
 var $3 = 0;
 label$1 : {
  $0 = memset($0, 0, 20216);
  if (silk_init_encoder($0, $1)) {
   break label$1;
  }
  if (silk_init_encoder($0 + 10064 | 0, $1)) {
   break label$1;
  }
  HEAP32[$0 + 20192 >> 2] = 1;
  HEAP32[$0 + 20196 >> 2] = 1;
  HEAP32[$2 >> 2] = 1;
  HEAP32[$2 + 4 >> 2] = 1;
  HEAP32[$2 + 8 >> 2] = HEAP32[$0 + 4556 >> 2];
  HEAP32[$2 + 12 >> 2] = HEAP32[$0 + 4564 >> 2];
  HEAP32[$2 + 16 >> 2] = HEAP32[$0 + 4568 >> 2];
  HEAP32[$2 + 20 >> 2] = HEAP32[$0 + 4572 >> 2];
  HEAP32[$2 + 24 >> 2] = HEAP32[$0 + 4612 >> 2];
  HEAP32[$2 + 28 >> 2] = HEAP32[$0 + 4608 >> 2];
  HEAP32[$2 + 32 >> 2] = HEAP32[$0 + 4616 >> 2];
  HEAP32[$2 + 36 >> 2] = HEAP32[$0 + 4624 >> 2];
  HEAP32[$2 + 40 >> 2] = HEAP32[$0 + 6088 >> 2];
  HEAP32[$2 + 48 >> 2] = HEAP32[$0 + 6076 >> 2];
  HEAP32[$2 + 52 >> 2] = HEAP32[$0 + 4676 >> 2];
  $3 = HEAP32[$0 + 4576 >> 2];
  HEAP32[$2 + 72 >> 2] = Math_imul($3 << 16 >> 16, 1e3);
  HEAP32[$2 + 76 >> 2] = HEAP32[$0 + 4536 >> 2];
  $1 = 0;
  $1 = ($3 | 0) == 16 ? !HEAP32[$0 + 28 >> 2] : $1;
  HEAP32[$2 + 80 >> 2] = $1;
  return 0;
 }
 celt_fatal(17487, 17507, 85);
 abort();
}
function silk_NLSF_VQ($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 if (!($5 & 1)) {
  if (($4 | 0) >= 1) {
   $12 = ($5 | 0) < 2;
   while (1) {
    $10 = $5;
    $6 = 0;
    $7 = 0;
    if (!$12) {
     while (1) {
      $8 = $10 - 1 | 0;
      $9 = $8 << 1;
      $8 = Math_imul(HEAPU16[$9 + $1 >> 1] - (HEAPU8[$2 + $8 | 0] << 7) << 16 >> 16, HEAP16[$3 + $9 >> 1]);
      $6 = $8 - ($6 >> 1) | 0;
      $9 = $6;
      $6 = $6 >> 31;
      $13 = ($6 ^ $6 + $9) + $7 | 0;
      $6 = $10 - 2 | 0;
      $7 = $6 << 1;
      $9 = Math_imul(HEAPU16[$7 + $1 >> 1] - (HEAPU8[$2 + $6 | 0] << 7) << 16 >> 16, HEAP16[$3 + $7 >> 1]);
      $7 = $9 - ($8 >> 1) | 0;
      $8 = $7;
      $7 = $7 >> 31;
      $7 = ($7 ^ $7 + $8) + $13 | 0;
      $8 = ($10 | 0) > 3;
      $10 = $6;
      $6 = $9;
      if ($8) {
       continue;
      }
      break;
     }
    }
    HEAP32[($11 << 2) + $0 >> 2] = $7;
    $2 = $2 + $5 | 0;
    $3 = ($5 << 1) + $3 | 0;
    $11 = $11 + 1 | 0;
    if (($11 | 0) != ($4 | 0)) {
     continue;
    }
    break;
   }
  }
  return;
 }
 celt_fatal(15720, 15761, 49);
 abort();
}
function exp2($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 label$1 : {
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  $5 = wasm2js_scratch_load_i32(0) | 0;
  $3 = $1;
  $1 = $1 & 2147483647;
  label$2 : {
   if ($1 >>> 0 >= 1083174912) {
    if (!(($3 | 0) < 0 | $1 >>> 0 < 1083179008)) {
     return $0 * 8.98846567431158e+307;
    }
    if ($1 >>> 0 >= 2146435072) {
     return -1 / $0;
    }
    if ($0 <= -1075 ^ 1) {
     break label$1;
    }
    $1 = $3;
    $2 = 0;
    if (($1 | 0) < -1 ? 1 : ($1 | 0) <= -1) {
     break label$2;
    }
    break label$1;
   }
   if ($1 >>> 0 > 1016070143) {
    break label$1;
   }
   $2 = $0 + 1;
  }
  return $2;
 }
 $2 = $0 + 26388279066624;
 wasm2js_scratch_store_f64(+$2);
 wasm2js_scratch_load_i32(1) | 0;
 $1 = (wasm2js_scratch_load_i32(0) | 0) + 128 | 0;
 $3 = $1 << 4 & 4080;
 $4 = HEAPF64[$3 + 11024 >> 3];
 $0 = $0 - ($2 + -26388279066624) - HEAPF64[($3 | 8) + 11024 >> 3];
 return scalbn($4 + $4 * $0 * ($0 * ($0 * ($0 * ($0 * .0013333559164630223 + .009618129842126066) + .0555041086648214) + .2402265069591) + .6931471805599453), ($1 & -256) / 256 | 0);
}
function normalise_bands($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = Math_fround(0);
 $13 = ($5 | 0) > 1 ? $5 : 1;
 $14 = Math_imul(HEAP32[$0 + 44 >> 2], $6);
 $11 = HEAP32[$0 + 32 >> 2];
 while (1) {
  if (($4 | 0) >= 1) {
   $15 = Math_imul($8, $14);
   $16 = Math_imul(HEAP32[$0 + 8 >> 2], $8);
   $10 = HEAP16[$11 >> 1];
   $9 = 0;
   while (1) {
    $5 = Math_imul($6, $10);
    $7 = $9;
    $9 = $7 + 1 | 0;
    $10 = HEAP16[($9 << 1) + $11 >> 1];
    $12 = Math_imul($10, $6);
    if (($5 | 0) < ($12 | 0)) {
     $17 = Math_fround(Math_fround(1) / Math_fround(HEAPF32[($7 + $16 << 2) + $3 >> 2] + Math_fround(1.0000000272452012e-27)));
     while (1) {
      $7 = $5 + $15 << 2;
      HEAPF32[$7 + $2 >> 2] = $17 * HEAPF32[$1 + $7 >> 2];
      $5 = $5 + 1 | 0;
      if (($12 | 0) > ($5 | 0)) {
       continue;
      }
      break;
     }
    }
    if (($4 | 0) != ($9 | 0)) {
     continue;
    }
    break;
   }
  }
  $8 = $8 + 1 | 0;
  if (($13 | 0) != ($8 | 0)) {
   continue;
  }
  break;
 }
}
function silk_ana_filt_bank_1($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 if (($4 | 0) >= 2) {
  $4 = $4 >> 1;
  $12 = ($4 | 0) > 1 ? $4 : 1;
  $5 = HEAP32[$1 + 4 >> 2];
  $6 = HEAP32[$1 >> 2];
  $4 = 0;
  while (1) {
   $7 = $4 << 2;
   $9 = HEAP16[($7 | 2) + $0 >> 1] << 10;
   $8 = $9 - $5 | 0;
   $8 = (Math_imul($8 & 65535, 10788) >>> 16 | 0) + Math_imul($8 >> 16, 10788) | 0;
   $10 = $8 + $5 | 0;
   $5 = HEAP16[$0 + $7 >> 1] << 10;
   $6 = $5 - $6 | 0;
   $11 = $4 << 1;
   $7 = (Math_imul($6 >> 16, -24290) + (Math_imul($6 & 65535, -24290) >> 16) | 0) + $5 | 0;
   $5 = $10 + $7 | 0;
   HEAP16[$11 + $2 >> 1] = ($5 | 0) > 67107839 ? 32767 : ($5 | 0) < -67109888 ? -32768 : ($5 >>> 10 | 0) + 1 >>> 1 | 0;
   $5 = $10 - $7 | 0;
   HEAP16[$3 + $11 >> 1] = ($5 | 0) > 67107839 ? 32767 : ($5 | 0) < -67109888 ? -32768 : ($5 >>> 10 | 0) + 1 >>> 1 | 0;
   $5 = $8 + $9 | 0;
   $6 = $6 + $7 | 0;
   $4 = $4 + 1 | 0;
   if (($12 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
  HEAP32[$1 + 4 >> 2] = $5;
  HEAP32[$1 >> 2] = $6;
 }
}
function memchr($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = ($2 | 0) != 0;
 label$1 : {
  label$2 : {
   label$3 : {
    if (!$2 | !($0 & 3)) {
     break label$3;
    }
    $4 = $1 & 255;
    while (1) {
     if (HEAPU8[$0 | 0] == ($4 | 0)) {
      break label$2;
     }
     $0 = $0 + 1 | 0;
     $2 = $2 - 1 | 0;
     $3 = ($2 | 0) != 0;
     if (!$2) {
      break label$3;
     }
     if ($0 & 3) {
      continue;
     }
     break;
    }
   }
   if (!$3) {
    break label$1;
   }
  }
  label$5 : {
   if (HEAPU8[$0 | 0] == ($1 & 255) | $2 >>> 0 < 4) {
    break label$5;
   }
   $4 = Math_imul($1 & 255, 16843009);
   while (1) {
    $3 = HEAP32[$0 >> 2] ^ $4;
    if (($3 ^ -1) & $3 - 16843009 & -2139062144) {
     break label$5;
    }
    $0 = $0 + 4 | 0;
    $2 = $2 - 4 | 0;
    if ($2 >>> 0 > 3) {
     continue;
    }
    break;
   }
  }
  if (!$2) {
   break label$1;
  }
  $3 = $1 & 255;
  while (1) {
   if (HEAPU8[$0 | 0] == ($3 | 0)) {
    return $0;
   }
   $0 = $0 + 1 | 0;
   $2 = $2 - 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
 return 0;
}
function resampler_basic_zero($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $2 = $1 << 2;
 $7 = $2 + HEAP32[$0 + 64 >> 2] | 0;
 $6 = HEAP32[$7 >> 2];
 $1 = 0;
 $8 = HEAP32[$0 + 60 >> 2] + $2 | 0;
 $2 = HEAP32[$8 >> 2];
 $9 = HEAP32[$3 >> 2];
 label$1 : {
  if (($2 | 0) >= ($9 | 0)) {
   break label$1;
  }
  $3 = HEAP32[$0 + 12 >> 2];
  $10 = HEAP32[$0 + 40 >> 2];
  $11 = HEAP32[$0 + 36 >> 2];
  $12 = HEAP32[$0 + 92 >> 2];
  $1 = HEAP32[$5 >> 2];
  $5 = ($1 | 0) > 0 ? $1 : 0;
  $1 = 0;
  while (1) {
   if (($1 | 0) == ($5 | 0)) {
    $1 = $5;
    break label$1;
   }
   HEAP32[(Math_imul($1, $12) << 2) + $4 >> 2] = 0;
   $0 = $6 + $10 | 0;
   $6 = $0 - ($0 >>> 0 < $3 >>> 0 ? 0 : $3) | 0;
   $1 = $1 + 1 | 0;
   $2 = ($2 + $11 | 0) + ($0 >>> 0 >= $3 >>> 0) | 0;
   if (($9 | 0) > ($2 | 0)) {
    continue;
   }
   break;
  }
 }
 HEAP32[$8 >> 2] = $2;
 HEAP32[$7 >> 2] = $6;
 return $1 | 0;
}
function ec_dec_bit_logp($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $2 = HEAP32[$0 + 28 >> 2];
 $1 = $2 >>> $1 | 0;
 $3 = HEAP32[$0 + 32 >> 2];
 $6 = $1 >>> 0 > $3 >>> 0;
 if (!$6) {
  $3 = $3 - $1 | 0;
  HEAP32[$0 + 32 >> 2] = $3;
 }
 $2 = $6 ? $1 : $2 - $1 | 0;
 HEAP32[$0 + 28 >> 2] = $2;
 if ($2 >>> 0 <= 8388608) {
  $4 = HEAP32[$0 + 24 >> 2];
  $8 = HEAP32[$0 + 40 >> 2];
  $7 = HEAP32[$0 + 20 >> 2];
  $10 = HEAP32[$0 + 4 >> 2];
  while (1) {
   $9 = $2 << 8;
   HEAP32[$0 + 28 >> 2] = $9;
   $7 = $7 + 8 | 0;
   HEAP32[$0 + 20 >> 2] = $7;
   $1 = 0;
   if ($4 >>> 0 < $10 >>> 0) {
    $5 = $4 + 1 | 0;
    HEAP32[$0 + 24 >> 2] = $5;
    $1 = HEAPU8[HEAP32[$0 >> 2] + $4 | 0];
    $4 = $5;
   }
   HEAP32[$0 + 40 >> 2] = $1;
   $3 = ($3 << 8 & 2147483392 | ($8 << 8 | $1) >>> 1 & 255) ^ 255;
   HEAP32[$0 + 32 >> 2] = $3;
   $5 = $2 >>> 0 < 32769;
   $8 = $1;
   $2 = $9;
   if ($5) {
    continue;
   }
   break;
  }
 }
 return $6;
}
function ec_dec_update($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $4 = HEAP32[$0 + 36 >> 2];
 $3 = Math_imul($4, $3 - $2 | 0);
 $5 = HEAP32[$0 + 32 >> 2] - $3 | 0;
 HEAP32[$0 + 32 >> 2] = $5;
 $2 = $1 ? Math_imul($2 - $1 | 0, $4) : HEAP32[$0 + 28 >> 2] - $3 | 0;
 HEAP32[$0 + 28 >> 2] = $2;
 if ($2 >>> 0 <= 8388608) {
  $3 = HEAP32[$0 + 24 >> 2];
  $4 = HEAP32[$0 + 40 >> 2];
  $7 = HEAP32[$0 + 20 >> 2];
  $9 = HEAP32[$0 + 4 >> 2];
  while (1) {
   $8 = $2 << 8;
   HEAP32[$0 + 28 >> 2] = $8;
   $7 = $7 + 8 | 0;
   HEAP32[$0 + 20 >> 2] = $7;
   $1 = 0;
   if ($3 >>> 0 < $9 >>> 0) {
    $6 = $3 + 1 | 0;
    HEAP32[$0 + 24 >> 2] = $6;
    $1 = HEAPU8[HEAP32[$0 >> 2] + $3 | 0];
    $3 = $6;
   }
   HEAP32[$0 + 40 >> 2] = $1;
   $5 = ($5 << 8 & 2147483392 | ($4 << 8 | $1) >>> 1 & 255) ^ 255;
   HEAP32[$0 + 32 >> 2] = $5;
   $6 = $2 >>> 0 < 32769;
   $4 = $1;
   $2 = $8;
   if ($6) {
    continue;
   }
   break;
  }
 }
}
function wcrtomb($0, $1, $2) {
 $2 = 1;
 label$1 : {
  if ($0) {
   if ($1 >>> 0 <= 127) {
    break label$1;
   }
   label$3 : {
    if (!HEAP32[HEAP32[__pthread_self() + 172 >> 2] >> 2]) {
     if (($1 & -128) == 57216) {
      break label$1;
     }
     break label$3;
    }
    if ($1 >>> 0 <= 2047) {
     HEAP8[$0 + 1 | 0] = $1 & 63 | 128;
     HEAP8[$0 | 0] = $1 >>> 6 | 192;
     return 2;
    }
    if (!(($1 & -8192) != 57344 ? $1 >>> 0 >= 55296 : 0)) {
     HEAP8[$0 + 2 | 0] = $1 & 63 | 128;
     HEAP8[$0 | 0] = $1 >>> 12 | 224;
     HEAP8[$0 + 1 | 0] = $1 >>> 6 & 63 | 128;
     return 3;
    }
    if ($1 - 65536 >>> 0 <= 1048575) {
     HEAP8[$0 + 3 | 0] = $1 & 63 | 128;
     HEAP8[$0 | 0] = $1 >>> 18 | 240;
     HEAP8[$0 + 2 | 0] = $1 >>> 6 & 63 | 128;
     HEAP8[$0 + 1 | 0] = $1 >>> 12 & 63 | 128;
     return 4;
    }
   }
   HEAP32[__errno_location() >> 2] = 25;
   $2 = -1;
  }
  return $2;
 }
 HEAP8[$0 | 0] = $1;
 return 1;
}
function opus_repacketizer_cat_impl($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $4 = -4;
 label$1 : {
  if (($2 | 0) < 1) {
   break label$1;
  }
  label$2 : {
   if (!HEAP32[$0 + 4 >> 2]) {
    HEAP8[$0 | 0] = HEAPU8[$1 | 0];
    HEAP32[$0 + 296 >> 2] = opus_packet_get_samples_per_frame($1, 8e3);
    break label$2;
   }
   if ((HEAPU8[$1 | 0] ^ HEAPU8[$0 | 0]) >>> 0 > 3) {
    break label$1;
   }
  }
  $6 = opus_packet_get_nb_frames($1, $2);
  if (($6 | 0) < 1) {
   break label$1;
  }
  $7 = HEAP32[$0 + 4 >> 2];
  if ((Math_imul(HEAP32[$0 + 296 >> 2], $7 + $6 | 0) | 0) > 960) {
   break label$1;
  }
  $4 = opus_packet_parse_impl($1, $2, $3, $5 + 15 | 0, (($7 << 2) + $0 | 0) + 8 | 0, (($7 << 1) + $0 | 0) + 200 | 0, 0, 0);
  if (($4 | 0) < 1) {
   break label$1;
  }
  HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + $6;
  $4 = 0;
 }
 __stack_pointer = $5 + 16 | 0;
 return $4;
}
function cos($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 wasm2js_scratch_store_f64(+$0);
 $3 = wasm2js_scratch_load_i32(1) | 0;
 wasm2js_scratch_load_i32(0) | 0;
 $3 = $3 & 2147483647;
 label$1 : {
  if ($3 >>> 0 <= 1072243195) {
   $2 = 1;
   if ($3 >>> 0 < 1044816030) {
    break label$1;
   }
   $2 = __cos($0, 0);
   break label$1;
  }
  $2 = $0 - $0;
  if ($3 >>> 0 >= 2146435072) {
   break label$1;
  }
  label$3 : {
   switch (__rem_pio2($0, $1) & 3) {
   case 0:
    $2 = __cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
    break label$1;
   case 1:
    $2 = -__sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
    break label$1;
   case 2:
    $2 = -__cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
    break label$1;
   default:
    break label$3;
   }
  }
  $2 = __sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
 }
 __stack_pointer = $1 + 16 | 0;
 return $2;
}
function silk_resampler_down2($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 if (($3 | 0) >= 2) {
  $3 = $3 >> 1;
  $10 = ($3 | 0) > 1 ? $3 : 1;
  $4 = HEAP32[$0 + 4 >> 2];
  $5 = HEAP32[$0 >> 2];
  $3 = 0;
  while (1) {
   $6 = $3 << 2;
   $7 = HEAP16[$6 + $2 >> 1] << 10;
   $5 = $7 - $5 | 0;
   $7 = (Math_imul($5 >> 16, -25727) + (Math_imul($5 & 65535, -25727) >> 16) | 0) + $7 | 0;
   $8 = $7 + $4 | 0;
   $6 = HEAP16[($6 | 2) + $2 >> 1] << 10;
   $4 = $6 - $4 | 0;
   $4 = (Math_imul($4 & 65535, 9872) >>> 16 | 0) + Math_imul($4 >> 16, 9872) | 0;
   $8 = $8 + $4 | 0;
   $9 = ($8 >> 10) + 1 >> 1;
   HEAP16[($3 << 1) + $1 >> 1] = ($8 | 0) > 67107839 ? 32767 : ($9 | 0) > -32768 ? $9 : -32768;
   $4 = $4 + $6 | 0;
   $5 = $5 + $7 | 0;
   $3 = $3 + 1 | 0;
   if (($10 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
  HEAP32[$0 + 4 >> 2] = $4;
  HEAP32[$0 >> 2] = $5;
 }
}
function celt_encoder_init($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $5 = -1;
 $4 = opus_custom_mode_create(48e3, 960, 0);
 label$1 : {
  if ($2 >>> 0 > 2) {
   break label$1;
  }
  $5 = -7;
  if (!$0 | !$4) {
   break label$1;
  }
  $5 = 0;
  $0 = memset($0, 0, Math_imul(((HEAP32[$4 + 4 >> 2] << 2) + (HEAP32[$4 + 8 >> 2] << 4) | 0) + 4096 | 0, $2) + 244 | 0);
  HEAP32[$0 + 28 >> 2] = 1;
  HEAP32[$0 + 32 >> 2] = 0;
  HEAP32[$0 + 8 >> 2] = $2;
  HEAP32[$0 + 4 >> 2] = $2;
  HEAP32[$0 >> 2] = $4;
  $2 = HEAP32[$4 + 12 >> 2];
  HEAP32[$0 + 24 >> 2] = 5;
  HEAP32[$0 + 60 >> 2] = 24;
  HEAP32[$0 + 12 >> 2] = 0;
  HEAP32[$0 + 16 >> 2] = 1;
  HEAP32[$0 + 40 >> 2] = -1;
  HEAP32[$0 + 44 >> 2] = 0;
  HEAP32[$0 + 72 >> 2] = $3;
  HEAP32[$0 + 48 >> 2] = 1;
  HEAP32[$0 + 52 >> 2] = 1;
  HEAP32[$0 + 36 >> 2] = $2;
  opus_custom_encoder_ctl($0, 4028, 0);
  HEAP32[$0 + 28 >> 2] = resampling_factor($1);
 }
 return $5;
}
function __fwritex($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = HEAP32[$2 + 16 >> 2];
 label$1 : {
  if (!$3) {
   if (__towrite($2)) {
    break label$1;
   }
   $3 = HEAP32[$2 + 16 >> 2];
  }
  $5 = HEAP32[$2 + 20 >> 2];
  if ($3 - $5 >>> 0 < $1 >>> 0) {
   return FUNCTION_TABLE[HEAP32[$2 + 36 >> 2]]($2, $0, $1) | 0;
  }
  label$5 : {
   if (HEAP8[$2 + 75 | 0] < 0) {
    $3 = 0;
    break label$5;
   }
   $4 = $1;
   while (1) {
    $3 = $4;
    if (!$3) {
     $3 = 0;
     break label$5;
    }
    $4 = $3 - 1 | 0;
    if (HEAPU8[$4 + $0 | 0] != 10) {
     continue;
    }
    break;
   }
   $4 = FUNCTION_TABLE[HEAP32[$2 + 36 >> 2]]($2, $0, $3) | 0;
   if ($4 >>> 0 < $3 >>> 0) {
    break label$1;
   }
   $0 = $0 + $3 | 0;
   $1 = $1 - $3 | 0;
   $5 = HEAP32[$2 + 20 >> 2];
  }
  memcpy($5, $0, $1);
  HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + $1;
  $4 = $1 + $3 | 0;
 }
 return $4;
}
function sin($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 wasm2js_scratch_store_f64(+$0);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 wasm2js_scratch_load_i32(0) | 0;
 $2 = $2 & 2147483647;
 label$1 : {
  if ($2 >>> 0 <= 1072243195) {
   if ($2 >>> 0 < 1045430272) {
    break label$1;
   }
   $0 = __sin($0, 0, 0);
   break label$1;
  }
  if ($2 >>> 0 >= 2146435072) {
   $0 = $0 - $0;
   break label$1;
  }
  label$4 : {
   switch (__rem_pio2($0, $1) & 3) {
   case 0:
    $0 = __sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
    break label$1;
   case 1:
    $0 = __cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
    break label$1;
   case 2:
    $0 = -__sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
    break label$1;
   default:
    break label$4;
   }
  }
  $0 = -__cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}
function ec_enc_bits($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 if ($2) {
  $6 = HEAP32[$0 + 12 >> 2];
  $5 = HEAP32[$0 + 16 >> 2];
  $3 = $5 + $2 | 0;
  label$2 : {
   if ($3 >>> 0 < 33) {
    $4 = $5;
    break label$2;
   }
   while (1) {
    $3 = -1;
    $7 = HEAP32[$0 + 4 >> 2];
    $4 = HEAP32[$0 + 8 >> 2];
    if ($7 >>> 0 > $4 + HEAP32[$0 + 24 >> 2] >>> 0) {
     $3 = $4 + 1 | 0;
     HEAP32[$0 + 8 >> 2] = $3;
     HEAP8[HEAP32[$0 >> 2] + ($7 - $3 | 0) | 0] = $6;
     $3 = 0;
    }
    HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] | $3;
    $6 = $6 >>> 8 | 0;
    $3 = ($5 | 0) > 15;
    $4 = $5 - 8 | 0;
    $5 = $4;
    if ($3) {
     continue;
    }
    break;
   }
   $3 = $2 + $4 | 0;
  }
  HEAP32[$0 + 16 >> 2] = $3;
  HEAP32[$0 + 12 >> 2] = $1 << $4 | $6;
  HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + $2;
  return;
 }
 celt_fatal(7033, 7019, 198);
 abort();
}
function speex_resampler_process_interleaved_float($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $7 = HEAP32[$0 + 92 >> 2];
 $8 = HEAP32[$2 >> 2];
 $9 = HEAP32[$4 >> 2];
 $5 = HEAP32[$0 + 20 >> 2];
 HEAP32[$0 + 92 >> 2] = $5;
 $10 = HEAP32[$0 + 88 >> 2];
 HEAP32[$0 + 88 >> 2] = $5;
 if ($5) {
  $5 = 0;
  while (1) {
   HEAP32[$4 >> 2] = $9;
   HEAP32[$2 >> 2] = $8;
   label$3 : {
    if ($1) {
     $6 = $5 << 2;
     speex_resampler_process_float($0, $5, $6 + $1 | 0, $2, $3 + $6 | 0, $4);
     break label$3;
    }
    speex_resampler_process_float($0, $5, 0, $2, ($5 << 2) + $3 | 0, $4);
   }
   $5 = $5 + 1 | 0;
   if ($5 >>> 0 < HEAPU32[$0 + 20 >> 2]) {
    continue;
   }
   break;
  }
 }
 HEAP32[$0 + 92 >> 2] = $7;
 HEAP32[$0 + 88 >> 2] = $10;
 return HEAP32[$0 + 84 >> 2] == 9 | 0;
}
function silk_VAD_Init($0) {
 var $1 = 0;
 $1 = $0;
 HEAP32[$1 >> 2] = 0;
 HEAP32[$1 + 4 >> 2] = 0;
 HEAP32[$1 + 56 >> 2] = 0;
 HEAP32[$1 + 60 >> 2] = 5e3;
 HEAP32[$1 + 32 >> 2] = 0;
 HEAP32[$1 + 36 >> 2] = 0;
 HEAP32[$1 + 24 >> 2] = 0;
 HEAP32[$1 + 28 >> 2] = 0;
 HEAP32[$1 + 16 >> 2] = 0;
 HEAP32[$1 + 20 >> 2] = 0;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP32[$1 + 12 >> 2] = 0;
 HEAP32[$1 + 96 >> 2] = 25;
 HEAP32[$1 + 100 >> 2] = 16;
 HEAP32[$1 + 80 >> 2] = 858993;
 HEAP32[$1 + 84 >> 2] = 1342177;
 $1 = $1 - -64 | 0;
 HEAP32[$1 >> 2] = 2500;
 HEAP32[$1 + 4 >> 2] = 1600;
 $1 = $0;
 HEAP32[$1 + 104 >> 2] = 12;
 HEAP32[$1 + 108 >> 2] = 15;
 HEAP32[$1 + 88 >> 2] = 1789569;
 HEAP32[$1 + 92 >> 2] = 50;
 HEAP32[$1 + 72 >> 2] = 1200;
 HEAP32[$1 + 76 >> 2] = 429496;
 HEAP32[$1 + 40 >> 2] = 25600;
 HEAP32[$1 + 44 >> 2] = 25600;
 HEAP32[$1 + 48 >> 2] = 25600;
 HEAP32[$1 + 52 >> 2] = 25600;
 return 0;
}
function silk_residual_energy_FLP($0, $1, $2, $3, $4, $5, $6) {
 var $7 = Math_fround(0), $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $8 = __stack_pointer - 768 | 0;
 __stack_pointer = $8;
 $9 = $4 + $6 | 0;
 $10 = $9 << 1;
 silk_LPC_analysis_filter_FLP($8, $2, $1, $10, $6);
 $7 = HEAPF32[$3 >> 2];
 $11 = ($6 << 2) + $8 | 0;
 HEAPF32[$0 >> 2] = silk_energy_FLP($11, $4) * +Math_fround($7 * $7);
 $7 = HEAPF32[$3 + 4 >> 2];
 $9 = ($9 << 2) + $11 | 0;
 HEAPF32[$0 + 4 >> 2] = silk_energy_FLP($9, $4) * +Math_fround($7 * $7);
 if (($5 | 0) == 4) {
  silk_LPC_analysis_filter_FLP($8, $2 - -64 | 0, ($10 << 2) + $1 | 0, $10, $6);
  $7 = HEAPF32[$3 + 8 >> 2];
  HEAPF32[$0 + 8 >> 2] = silk_energy_FLP($11, $4) * +Math_fround($7 * $7);
  $7 = HEAPF32[$3 + 12 >> 2];
  HEAPF32[$0 + 12 >> 2] = silk_energy_FLP($9, $4) * +Math_fround($7 * $7);
 }
 __stack_pointer = $8 + 768 | 0;
}
function silk_gains_dequant($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 if (($4 | 0) >= 1) {
  while (1) {
   $5 = HEAP8[$1 + $7 | 0];
   $9 = $2;
   label$3 : {
    if (!($3 | $7)) {
     $6 = HEAP8[$2 | 0] - 16 | 0;
     $5 = ($5 | 0) > ($6 | 0) ? $5 : $6;
     break label$3;
    }
    $5 = $5 - 4 | 0;
    $6 = HEAP8[$2 | 0];
    $8 = $6 + 8 | 0;
    if (($5 | 0) > ($8 | 0)) {
     $5 = (($5 << 1) - $8 | 0) + $6 | 0;
     break label$3;
    }
    $5 = $5 + $6 | 0;
   }
   $5 = $5 << 24 >> 24 > 0 ? $5 : 0;
   $5 = $5 << 24 >> 24 < 63 ? $5 : 63;
   HEAP8[$9 | 0] = $5;
   $5 = $5 & 255;
   $5 = (Math_imul($5, 7281) >>> 16 | 0) + Math_imul($5, 29) | 0;
   HEAP32[($7 << 2) + $0 >> 2] = silk_log2lin(($5 >>> 0 < 1877 ? $5 : 1877) + 2090 | 0);
   $7 = $7 + 1 | 0;
   if (($7 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
 }
}
function silk_k2a_FLP($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = Math_fround(0), $8 = 0, $9 = 0, $10 = Math_fround(0), $11 = Math_fround(0), $12 = 0, $13 = 0;
 $6 = 1;
 if (($2 | 0) >= 1) {
  while (1) {
   $8 = $5 << 2;
   $7 = HEAPF32[$8 + $1 >> 2];
   $9 = $5 + 1 | 0;
   if ($9 & 2147483646) {
    $12 = $6 >>> 1 | 0;
    $3 = 0;
    while (1) {
     $4 = ($3 << 2) + $0 | 0;
     $13 = $4;
     $10 = HEAPF32[$4 >> 2];
     $4 = (($3 ^ -1) + $5 << 2) + $0 | 0;
     $11 = HEAPF32[$4 >> 2];
     HEAPF32[$13 >> 2] = $10 + Math_fround($7 * $11);
     HEAPF32[$4 >> 2] = $11 + Math_fround($7 * $10);
     $3 = $3 + 1 | 0;
     if (($12 | 0) != ($3 | 0)) {
      continue;
     }
     break;
    }
   }
   HEAPF32[$0 + $8 >> 2] = -$7;
   $6 = $6 + 1 | 0;
   $5 = $9;
   if (($5 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
 }
}
function silk_encode_signs($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 HEAP8[$6 + 15 | 0] = 0;
 if (($2 | 0) >= 8) {
  $8 = Math_imul(($3 << 1) + $4 << 16 >> 16, 7) + 9232 | 0;
  $2 = $2 + 8 >> 4;
  $3 = ($2 | 0) > 1 ? $2 : 1;
  while (1) {
   $2 = HEAP32[($7 << 2) + $5 >> 2];
   if (($2 | 0) >= 1) {
    $2 = $2 & 31;
    HEAP8[$6 + 14 | 0] = HEAPU8[($2 >>> 0 < 6 ? $2 : 6) + $8 | 0];
    $2 = 0;
    while (1) {
     $4 = HEAPU8[$1 + $2 | 0];
     if ($4) {
      ec_enc_icdf($0, ($4 << 24 >> 24 >>> 7 | 0) + 1 & 255, $6 + 14 | 0, 8);
     }
     $2 = $2 + 1 | 0;
     if (($2 | 0) != 16) {
      continue;
     }
     break;
    }
   }
   $1 = $1 + 16 | 0;
   $7 = $7 + 1 | 0;
   if (($7 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $6 + 16 | 0;
}
function haar1($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = Math_fround(0), $6 = Math_fround(0), $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 if (($2 | 0) >= 1) {
  $3 = $1 >> 1;
  $7 = ($3 | 0) > 1 ? $3 : 1;
  $8 = $2 << 1;
  $3 = 0;
  $9 = ($1 | 0) < 2;
  while (1) {
   $1 = 0;
   if (!$9) {
    while (1) {
     $4 = (Math_imul($1, $8) + $3 << 2) + $0 | 0;
     $10 = $4;
     $5 = Math_fround(HEAPF32[$4 >> 2] * Math_fround(.7071067690849304));
     $4 = (Math_imul($1 << 1 | 1, $2) + $3 << 2) + $0 | 0;
     $6 = Math_fround(HEAPF32[$4 >> 2] * Math_fround(.7071067690849304));
     HEAPF32[$10 >> 2] = $5 + $6;
     HEAPF32[$4 >> 2] = $5 - $6;
     $1 = $1 + 1 | 0;
     if (($7 | 0) != ($1 | 0)) {
      continue;
     }
     break;
    }
   }
   $3 = $3 + 1 | 0;
   if (($3 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
 }
}
function silk_find_LTP_FLP($0, $1, $2, $3, $4, $5) {
 var $6 = Math_fround(0), $7 = 0, $8 = 0, $9 = Math_fround(0), $10 = 0;
 if (($5 | 0) >= 1) {
  $10 = $4 + 5 | 0;
  while (1) {
   $8 = ($2 - (HEAP32[($7 << 2) + $3 >> 2] << 2) | 0) - 8 | 0;
   silk_corrMatrix_FLP($8, $4, 5, $0);
   silk_corrVector_FLP($8, $2, $4, 5, $1);
   $6 = Math_fround(silk_energy_FLP($2, $10));
   $9 = Math_fround(Math_fround(Math_fround(HEAPF32[$0 >> 2] + HEAPF32[$0 + 96 >> 2]) * Math_fround(.014999999664723873)) + Math_fround(1));
   $6 = Math_fround(Math_fround(1) / ($6 > $9 ? $6 : $9));
   silk_scale_vector_FLP($0, $6, 25);
   silk_scale_vector_FLP($1, $6, 5);
   $1 = $1 + 20 | 0;
   $0 = $0 + 100 | 0;
   $2 = ($4 << 2) + $2 | 0;
   $7 = $7 + 1 | 0;
   if (($7 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
 }
}
function silk_stereo_encode_pred($0, $1) {
 var $2 = 0;
 label$1 : {
  label$2 : {
   $2 = HEAP8[$1 + 5 | 0] + Math_imul(HEAP8[$1 + 2 | 0], 5) | 0;
   if (($2 | 0) < 25) {
    ec_enc_icdf($0, $2, 5776, 8);
    $2 = HEAP8[$1 | 0];
    if (($2 | 0) >= 3) {
     break label$2;
    }
    if (HEAP8[$1 + 1 | 0] >= 5) {
     break label$1;
    }
    ec_enc_icdf($0, $2, 5854, 8);
    ec_enc_icdf($0, HEAP8[$1 + 1 | 0], 5861, 8);
    $2 = HEAP8[$1 + 3 | 0];
    if (($2 | 0) > 2) {
     break label$2;
    }
    if (HEAP8[$1 + 4 | 0] > 4) {
     break label$1;
    }
    ec_enc_icdf($0, $2, 5854, 8);
    ec_enc_icdf($0, HEAP8[$1 + 4 | 0], 5861, 8);
    return;
   }
   celt_fatal(7150, 7175, 44);
   abort();
  }
  celt_fatal(7201, 7175, 47);
  abort();
 }
 celt_fatal(7236, 7175, 48);
 abort();
}
function silk_encode_do_VAD_FLP($0, $1) {
 var $2 = 0;
 silk_VAD_GetSA_Q8_c($0, $0 + 5098 | 0);
 $2 = HEAP32[$0 + 4532 >> 2];
 label$1 : {
  label$2 : {
   label$3 : {
    if (!$1) {
     if (($2 | 0) < 13) {
      break label$3;
     }
     HEAP32[$0 + 4532 >> 2] = 12;
     break label$3;
    }
    if (($2 | 0) > 12) {
     break label$2;
    }
   }
   $1 = 0;
   HEAP8[$0 + 4765 | 0] = 0;
   $2 = HEAP32[$0 + 6084 >> 2];
   HEAP32[$0 + 6084 >> 2] = $2 + 1;
   if (($2 | 0) >= 10) {
    if (($2 | 0) < 30) {
     break label$1;
    }
    HEAP32[$0 + 6084 >> 2] = 10;
   }
   HEAP32[$0 + 6080 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 6080 >> 2] = 0;
  HEAP32[$0 + 6084 >> 2] = 0;
  $1 = 1;
  HEAP8[$0 + 4765 | 0] = 1;
 }
 HEAP8[(HEAP32[$0 + 5748 >> 2] + $0 | 0) + 4720 | 0] = $1;
}
function amp2Log2($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $8 = ($5 | 0) > 1 ? $5 : 1;
 while (1) {
  if (($1 | 0) >= 1) {
   $9 = Math_imul(HEAP32[$0 + 8 >> 2], $6);
   $5 = 0;
   while (1) {
    $7 = $5 + $9 << 2;
    HEAPF32[$7 + $4 >> 2] = Math_fround(log(+HEAPF32[$3 + $7 >> 2]) * 1.4426950408889634) - HEAPF32[($5 << 2) + 32928 >> 2];
    $5 = $5 + 1 | 0;
    if (($5 | 0) != ($1 | 0)) {
     continue;
    }
    break;
   }
  }
  if (($1 | 0) < ($2 | 0)) {
   $7 = Math_imul(HEAP32[$0 + 8 >> 2], $6);
   $5 = $1;
   while (1) {
    HEAP32[($5 + $7 << 2) + $4 >> 2] = -1050673152;
    $5 = $5 + 1 | 0;
    if (($5 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  $6 = $6 + 1 | 0;
  if (($8 | 0) != ($6 | 0)) {
   continue;
  }
  break;
 }
}
function silk_process_NLSFs_FLP($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 silk_process_NLSFs($0, $4, $2, $3);
 $2 = HEAP32[$0 + 4640 >> 2];
 label$1 : {
  if (($2 | 0) < 1) {
   break label$1;
  }
  $0 = 0;
  while (1) {
   HEAPF32[($0 << 2) + $1 >> 2] = Math_fround(HEAP16[($0 << 1) + $4 >> 1]) * Math_fround(.000244140625);
   $0 = $0 + 1 | 0;
   if (($2 | 0) != ($0 | 0)) {
    continue;
   }
   break;
  }
  if (($2 | 0) < 1) {
   break label$1;
  }
  $0 = 0;
  while (1) {
   HEAPF32[(($0 << 2) + $1 | 0) - -64 >> 2] = Math_fround(HEAP16[(($0 << 1) + $4 | 0) + 32 >> 1]) * Math_fround(.000244140625);
   $0 = $0 + 1 | 0;
   if (($2 | 0) != ($0 | 0)) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $4 - -64 | 0;
}
function silk_inner_product_FLP($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 if (($2 | 0) > 3) {
  $7 = $2 - 3 | 0;
  while (1) {
   $3 = $4 << 2;
   $5 = $3 | 4;
   $8 = +HEAPF32[$0 + $3 >> 2] * +HEAPF32[$1 + $3 >> 2] + +HEAPF32[$0 + $5 >> 2] * +HEAPF32[$1 + $5 >> 2];
   $5 = $3 | 8;
   $3 = $3 | 12;
   $6 = $6 + ($8 + +HEAPF32[$5 + $0 >> 2] * +HEAPF32[$1 + $5 >> 2] + +HEAPF32[$3 + $0 >> 2] * +HEAPF32[$1 + $3 >> 2]);
   $4 = $4 + 4 | 0;
   if (($7 | 0) > ($4 | 0)) {
    continue;
   }
   break;
  }
  $4 = $2 & -4;
 }
 if (($2 | 0) > ($4 | 0)) {
  while (1) {
   $3 = $4 << 2;
   $6 = $6 + +HEAPF32[$3 + $0 >> 2] * +HEAPF32[$1 + $3 >> 2];
   $4 = $4 + 1 | 0;
   if (($4 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
 }
 return $6;
}
function silk_bwexpander_32($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $4 = $2 >> 16;
 $5 = $1 - 1 | 0;
 if (($1 | 0) >= 2) {
  $7 = $2 - 65536 | 0;
  $1 = 0;
  while (1) {
   $3 = ($1 << 2) + $0 | 0;
   $8 = $3;
   $3 = HEAP32[$3 >> 2];
   $6 = $3 << 16 >> 16;
   HEAP32[$8 >> 2] = ((Math_imul($6, $2 & 65535) >> 16) + Math_imul($4, $6) | 0) + Math_imul(($3 >> 15) + 1 >> 1, $2);
   $2 = ((Math_imul($2, $7) >> 15) + 1 >> 1) + $2 | 0;
   $4 = $2 >> 16;
   $1 = $1 + 1 | 0;
   if (($5 | 0) != ($1 | 0)) {
    continue;
   }
   break;
  }
 }
 $1 = ($5 << 2) + $0 | 0;
 $0 = $1;
 $1 = HEAP32[$1 >> 2];
 $3 = $1 << 16 >> 16;
 HEAP32[$0 >> 2] = ((Math_imul($3, $2 & 65535) >> 16) + Math_imul($3, $4) | 0) + Math_imul(($1 >> 15) + 1 >> 1, $2);
}
function silk_NLSF_unpack($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = HEAP16[$2 + 2 >> 1];
 if (($4 | 0) >= 1) {
  $5 = HEAP32[$2 + 24 >> 2] + ((Math_imul($4 & 65535, $3) | 0) / 2 | 0) | 0;
  $3 = 0;
  while (1) {
   $4 = HEAPU8[$5 | 0];
   HEAP16[($3 << 1) + $0 >> 1] = Math_imul($4 >>> 1 & 7, 9);
   HEAP8[$1 + $3 | 0] = HEAPU8[HEAP32[$2 + 20 >> 2] + (Math_imul(HEAP16[$2 + 2 >> 1] - 1 | 0, $4 & 1) + $3 | 0) | 0];
   $6 = $3 | 1;
   HEAP16[($6 << 1) + $0 >> 1] = Math_imul($4 >>> 5 | 0, 9);
   HEAP8[$1 + $6 | 0] = HEAPU8[HEAP32[$2 + 20 >> 2] + (Math_imul(HEAP16[$2 + 2 >> 1] - 1 | 0, $4 >>> 4 & 1) + $6 | 0) | 0];
   $5 = $5 + 1 | 0;
   $3 = $3 + 2 | 0;
   if (($3 | 0) < HEAP16[$2 + 2 >> 1]) {
    continue;
   }
   break;
  }
 }
}
function silk_insertion_sort_increasing_all_values_int16($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = 1;
 if (($1 | 0) >= 1) {
  if (($1 | 0) != 1) {
   while (1) {
    $5 = HEAP16[($3 << 1) + $0 >> 1];
    $2 = $3;
    label$4 : {
     while (1) {
      $6 = $2 - 1 | 0;
      $4 = HEAP16[($6 << 1) + $0 >> 1];
      if (($5 | 0) >= ($4 | 0)) {
       break label$4;
      }
      HEAP16[($2 << 1) + $0 >> 1] = $4;
      $4 = ($2 | 0) > 1;
      $2 = $6;
      if ($4) {
       continue;
      }
      break;
     }
     $2 = 0;
    }
    HEAP16[($2 << 1) + $0 >> 1] = $5;
    $3 = $3 + 1 | 0;
    if (($3 | 0) != ($1 | 0)) {
     continue;
    }
    break;
   }
  }
  return;
 }
 celt_fatal(15671, 15659, 144);
 abort();
}
function ec_dec_bits($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = HEAP32[$0 + 12 >> 2];
 $2 = HEAP32[$0 + 16 >> 2];
 label$1 : {
  if ($2 >>> 0 >= $1 >>> 0) {
   $6 = $2;
   break label$1;
  }
  $3 = HEAP32[$0 + 8 >> 2];
  $7 = HEAP32[$0 + 4 >> 2];
  while (1) {
   $5 = 0;
   if ($3 >>> 0 < $7 >>> 0) {
    $3 = $3 + 1 | 0;
    HEAP32[$0 + 8 >> 2] = $3;
    $5 = HEAPU8[HEAP32[$0 >> 2] + ($7 - $3 | 0) | 0];
   }
   $4 = $5 << $2 | $4;
   $5 = ($2 | 0) < 17;
   $6 = $2 + 8 | 0;
   $2 = $6;
   if ($5) {
    continue;
   }
   break;
  }
 }
 HEAP32[$0 + 16 >> 2] = $6 - $1;
 HEAP32[$0 + 12 >> 2] = $4 >>> $1;
 HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + $1;
 return (-1 << $1 ^ -1) & $4;
}
function silk_scale_vector_FLP($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $6 = $2 & 65532;
 if ($6) {
  while (1) {
   $3 = $4 << 2;
   $5 = $3 + $0 | 0;
   HEAPF32[$5 >> 2] = HEAPF32[$5 >> 2] * $1;
   $5 = ($3 | 4) + $0 | 0;
   HEAPF32[$5 >> 2] = HEAPF32[$5 >> 2] * $1;
   $5 = ($3 | 8) + $0 | 0;
   HEAPF32[$5 >> 2] = HEAPF32[$5 >> 2] * $1;
   $3 = ($3 | 12) + $0 | 0;
   HEAPF32[$3 >> 2] = HEAPF32[$3 >> 2] * $1;
   $4 = $4 + 4 | 0;
   if ($6 >>> 0 > $4 >>> 0) {
    continue;
   }
   break;
  }
 }
 if (($2 | 0) > ($4 | 0)) {
  while (1) {
   $3 = ($4 << 2) + $0 | 0;
   HEAPF32[$3 >> 2] = HEAPF32[$3 >> 2] * $1;
   $4 = $4 + 1 | 0;
   if (($4 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
 }
}
function silk_scale_copy_vector_FLP($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $7 = $3 & 65532;
 if ($7) {
  while (1) {
   $4 = $5 << 2;
   HEAPF32[$4 + $0 >> 2] = HEAPF32[$1 + $4 >> 2] * $2;
   $6 = $4 | 4;
   HEAPF32[$6 + $0 >> 2] = HEAPF32[$1 + $6 >> 2] * $2;
   $6 = $4 | 8;
   HEAPF32[$6 + $0 >> 2] = HEAPF32[$1 + $6 >> 2] * $2;
   $4 = $4 | 12;
   HEAPF32[$4 + $0 >> 2] = HEAPF32[$1 + $4 >> 2] * $2;
   $5 = $5 + 4 | 0;
   if ($7 >>> 0 > $5 >>> 0) {
    continue;
   }
   break;
  }
 }
 if (($3 | 0) > ($5 | 0)) {
  while (1) {
   $4 = $5 << 2;
   HEAPF32[$4 + $0 >> 2] = HEAPF32[$1 + $4 >> 2] * $2;
   $5 = $5 + 1 | 0;
   if (($5 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
 }
}
function fmt_u($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 label$1 : {
  if ($1 >>> 0 < 1) {
   $5 = $0;
   $3 = $1;
   $6 = $3;
   break label$1;
  }
  while (1) {
   $2 = $2 - 1 | 0;
   $3 = $1;
   $5 = __wasm_i64_udiv($0, $3, 10, 0);
   $3 = i64toi32_i32$HIGH_BITS;
   $6 = $3;
   $4 = __wasm_i64_mul($5, $3, 10, 0);
   $3 = $1;
   HEAP8[$2 | 0] = $0 - $4 | 48;
   $4 = $3 >>> 0 > 9;
   $0 = $5;
   $3 = $6;
   $1 = $3;
   if ($4) {
    continue;
   }
   break;
  }
 }
 $4 = $5;
 if ($4) {
  while (1) {
   $2 = $2 - 1 | 0;
   $0 = ($4 >>> 0) / 10 | 0;
   HEAP8[$2 | 0] = $4 - Math_imul($0, 10) | 48;
   $1 = $4 >>> 0 > 9;
   $4 = $0;
   if ($1) {
    continue;
   }
   break;
  }
 }
 return $2;
}
function silk_energy_FLP($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 if (($1 | 0) > 3) {
  $7 = $1 - 3 | 0;
  while (1) {
   $5 = $3 << 2;
   $2 = +HEAPF32[$5 + $0 >> 2];
   $4 = $2 * $2;
   $2 = +HEAPF32[($5 | 4) + $0 >> 2];
   $4 = $4 + $2 * $2;
   $2 = +HEAPF32[($5 | 8) + $0 >> 2];
   $4 = $4 + $2 * $2;
   $2 = +HEAPF32[($5 | 12) + $0 >> 2];
   $6 = $6 + ($4 + $2 * $2);
   $3 = $3 + 4 | 0;
   if (($7 | 0) > ($3 | 0)) {
    continue;
   }
   break;
  }
  $3 = $1 & -4;
 }
 if (($1 | 0) > ($3 | 0)) {
  while (1) {
   $2 = +HEAPF32[($3 << 2) + $0 >> 2];
   $6 = $6 + $2 * $2;
   $3 = $3 + 1 | 0;
   if (($3 | 0) != ($1 | 0)) {
    continue;
   }
   break;
  }
 }
 return $6;
}
function renormalise_vector($0, $1, $2, $3) {
 var $4 = 0, $5 = Math_fround(0), $6 = Math_fround(0);
 label$1 : {
  if (($1 | 0) < 1) {
   break label$1;
  }
  while (1) {
   $6 = HEAPF32[($4 << 2) + $0 >> 2];
   $5 = Math_fround($5 + Math_fround($6 * $6));
   $4 = $4 + 1 | 0;
   if (($4 | 0) != ($1 | 0)) {
    continue;
   }
   break;
  }
  if (($1 | 0) < 1) {
   break label$1;
  }
  $5 = Math_fround(Math_fround(Math_fround(1) / Math_fround(Math_sqrt(Math_fround($5 + Math_fround(1.0000000036274937e-15))))) * $2);
  $4 = 0;
  while (1) {
   HEAPF32[$0 >> 2] = $5 * HEAPF32[$0 >> 2];
   $0 = $0 + 4 | 0;
   $4 = $4 + 1 | 0;
   if (($4 | 0) != ($1 | 0)) {
    continue;
   }
   break;
  }
 }
}
function hysteresis_decision($0, $1, $2, $3, $4) {
 var $5 = 0;
 label$1 : {
  if (($3 | 0) < 1) {
   break label$1;
  }
  while (1) {
   if (HEAPF32[($5 << 2) + $1 >> 2] > $0) {
    break label$1;
   }
   $5 = $5 + 1 | 0;
   if (($5 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
  $5 = $3;
 }
 label$3 : {
  label$4 : {
   if (($4 | 0) < ($5 | 0)) {
    $3 = $4 << 2;
    if (Math_fround(HEAPF32[$3 + $1 >> 2] + HEAPF32[$2 + $3 >> 2]) > $0) {
     break label$4;
    }
   }
   if (($4 | 0) <= ($5 | 0)) {
    break label$3;
   }
   $3 = ($4 << 2) - 4 | 0;
   if (Math_fround(HEAPF32[$3 + $1 >> 2] - HEAPF32[$2 + $3 >> 2]) < $0 ^ 1) {
    break label$3;
   }
  }
  $5 = $4;
 }
 return $5;
}
function silk_LTP_scale_ctrl_FLP($0, $1, $2) {
 var $3 = 0, $4 = Math_fround(0), $5 = 0;
 $5 = $0 + 4769 | 0;
 $3 = 0;
 label$1 : {
  if ($2) {
   break label$1;
  }
  $3 = 2;
  $4 = Math_fround(Math_fround(HEAPF32[$1 + 708 >> 2] * Math_fround(HEAP32[$0 + 5744 >> 2] + HEAP32[$0 + 4616 >> 2] | 0)) * Math_fround(.10000000149011612));
  if ($4 > Math_fround(2)) {
   break label$1;
  }
  $3 = 0;
  if ($4 < Math_fround(0)) {
   break label$1;
  }
  $3 = ~~$4;
  if (Math_fround(Math_abs($4)) < Math_fround(2147483648)) {
   break label$1;
  }
  $3 = -2147483648;
 }
 HEAP8[$5 | 0] = $3;
 HEAPF32[$1 + 224 >> 2] = Math_fround(HEAP16[($3 << 1) + 5848 >> 1]) * Math_fround(6103515625e-14);
}
function scalbn($0, $1) {
 label$1 : {
  if (($1 | 0) >= 1024) {
   $0 = $0 * 8.98846567431158e+307;
   if (($1 | 0) < 2047) {
    $1 = $1 - 1023 | 0;
    break label$1;
   }
   $0 = $0 * 8.98846567431158e+307;
   $1 = (($1 | 0) < 3069 ? $1 : 3069) - 2046 | 0;
   break label$1;
  }
  if (($1 | 0) > -1023) {
   break label$1;
  }
  $0 = $0 * 2.2250738585072014e-308;
  if (($1 | 0) > -2045) {
   $1 = $1 + 1022 | 0;
   break label$1;
  }
  $0 = $0 * 2.2250738585072014e-308;
  $1 = (($1 | 0) > -3066 ? $1 : -3066) + 2044 | 0;
 }
 $1 = $1 + 1023 << 20;
 wasm2js_scratch_store_i32(0, 0);
 wasm2js_scratch_store_i32(1, $1 | 0);
 return $0 * +wasm2js_scratch_load_f64();
}
function silk_resampler_private_AR2($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 if (($4 | 0) >= 1) {
  $5 = HEAP32[$0 >> 2];
  $6 = HEAP16[$3 + 2 >> 1];
  $7 = HEAP16[$3 >> 1];
  $3 = 0;
  while (1) {
   $5 = (HEAP16[($3 << 1) + $2 >> 1] << 8) + $5 | 0;
   HEAP32[($3 << 2) + $1 >> 2] = $5;
   $9 = HEAP32[$0 + 4 >> 2];
   $5 = $5 << 2;
   $8 = $5 & 65532;
   $5 = $5 >> 16;
   HEAP32[$0 + 4 >> 2] = (Math_imul($8, $6) >> 16) + Math_imul($6, $5);
   $5 = (Math_imul($5, $7) + $9 | 0) + (Math_imul($7, $8) >> 16) | 0;
   HEAP32[$0 >> 2] = $5;
   $3 = $3 + 1 | 0;
   if (($4 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
 }
}
function silk_control_SNR($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 HEAP32[$0 + 4608 >> 2] = $1;
 $2 = HEAP32[$0 + 4576 >> 2];
 $1 = HEAP32[$0 + 4580 >> 2] == 2 ? ((($2 | 0) / -16 | 0) + $1 | 0) - 2e3 | 0 : $1;
 $4 = 17024;
 $3 = 106;
 label$2 : {
  label$3 : {
   switch ($2 - 8 | 0) {
   case 4:
    $4 = 17136;
    $3 = 154;
    break label$2;
   case 0:
    break label$2;
   default:
    break label$3;
   }
  }
  $4 = 17296;
  $3 = 190;
 }
 $2 = 0;
 $1 = (($1 + 200 | 0) / 400 | 0) - 10 | 0;
 $1 = ($1 | 0) < ($3 | 0) ? $1 : $3;
 if (($1 | 0) >= 1) {
  $2 = Math_imul(HEAPU8[$1 + $4 | 0], 21);
 }
 HEAP32[$0 + 4716 >> 2] = $2;
 return 0;
}
function opus_fft_c($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = Math_fround(0), $6 = 0, $7 = 0, $8 = 0, $9 = Math_fround(0);
 if (($1 | 0) != ($2 | 0)) {
  $4 = HEAP32[$0 >> 2];
  if (($4 | 0) >= 1) {
   $5 = HEAPF32[$0 + 4 >> 2];
   $8 = HEAP32[$0 + 44 >> 2];
   while (1) {
    $6 = ($3 << 3) + $1 | 0;
    $9 = HEAPF32[$6 >> 2];
    $7 = (HEAP16[($3 << 1) + $8 >> 1] << 3) + $2 | 0;
    HEAPF32[$7 + 4 >> 2] = $5 * HEAPF32[$6 + 4 >> 2];
    HEAPF32[$7 >> 2] = $5 * $9;
    $3 = $3 + 1 | 0;
    if (($4 | 0) != ($3 | 0)) {
     continue;
    }
    break;
   }
  }
  opus_fft_impl($0, $2);
  return;
 }
 celt_fatal(42376, 42433, 580);
 abort();
}
function ec_enc_patch_initial_bits($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 if ($2 >>> 0 < 9) {
  $3 = 8 - $2 | 0;
  $4 = (-1 << $2 ^ -1) << $3;
  if (HEAP32[$0 + 24 >> 2]) {
   $2 = HEAP32[$0 >> 2];
   HEAP8[$2 | 0] = HEAPU8[$2 | 0] & ($4 ^ -1) | $1 << $3;
   return;
  }
  $5 = HEAP32[$0 + 40 >> 2];
  if (($5 | 0) >= 0) {
   HEAP32[$0 + 40 >> 2] = ($4 ^ -1) & $5 | $1 << $3;
   return;
  }
  if (HEAPU32[$0 + 28 >> 2] <= -2147483648 >>> $2 >>> 0) {
   HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 32 >> 2] & ($4 << 23 ^ -1) | $1 << 31 - $2;
   return;
  }
  HEAP32[$0 + 44 >> 2] = -1;
  return;
 }
 celt_fatal(7059, 7019, 217);
 abort();
}
function init_caps($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $4 = HEAP32[$0 + 8 >> 2];
 if (($4 | 0) >= 1) {
  $9 = (($2 << 1) + $3 | 0) - 1 | 0;
  $10 = HEAP32[$0 + 104 >> 2];
  $7 = HEAP32[$0 + 32 >> 2];
  $6 = HEAPU16[$7 >> 1];
  while (1) {
   $11 = $6 << 16;
   $8 = $5 + 1 | 0;
   $6 = HEAP16[($8 << 1) + $7 >> 1];
   HEAP32[($5 << 2) + $1 >> 2] = Math_imul(HEAPU8[(Math_imul($4, $9) + $5 | 0) + $10 | 0] - -64 | 0, Math_imul($6 - ($11 >> 16) << $2, $3)) >> 2;
   $5 = $8;
   $4 = HEAP32[$0 + 8 >> 2];
   if (($5 | 0) < ($4 | 0)) {
    continue;
   }
   break;
  }
 }
}
function opus_packet_pad($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 304 | 0;
 __stack_pointer = $3;
 $4 = -1;
 label$1 : {
  if (($1 | 0) < 1) {
   break label$1;
  }
  $4 = 0;
  if (($1 | 0) == ($2 | 0)) {
   break label$1;
  }
  $4 = -1;
  if (($1 | 0) > ($2 | 0)) {
   break label$1;
  }
  HEAP32[$3 + 4 >> 2] = 0;
  $4 = opus_repacketizer_cat_impl($3, memmove(($0 + $2 | 0) - $1 | 0, $0, $1), $1, 0);
  if ($4) {
   break label$1;
  }
  $1 = opus_repacketizer_out_range_impl($3, 0, HEAP32[$3 + 4 >> 2], $0, $2, 0, 1);
  $4 = $1 & $1 >> 31;
 }
 __stack_pointer = $3 + 304 | 0;
 return $4;
}
function resampling_factor($0) {
 var $1 = 0;
 label$1 : {
  label$2 : {
   label$3 : {
    label$4 : {
     if (($0 | 0) <= 15999) {
      if (($0 | 0) == 8e3) {
       break label$4;
      }
      if (($0 | 0) != 12e3) {
       break label$3;
      }
      return 4;
     }
     if (($0 | 0) == 16e3) {
      break label$2;
     }
     $1 = 1;
     if (($0 | 0) == 48e3) {
      break label$1;
     }
     if (($0 | 0) != 24e3) {
      break label$3;
     }
     return 2;
    }
    return 6;
   }
   celt_fatal(1659, 1679, 84);
   abort();
  }
  $1 = 3;
 }
 return $1;
}
function silk_interpolate($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 label$1 : {
  if (($3 | 0) > -1) {
   if (($3 | 0) > 4) {
    break label$1;
   }
   if (($4 | 0) > 0) {
    while (1) {
     $6 = $5 << 1;
     $7 = HEAPU16[$6 + $1 >> 1];
     HEAP16[$0 + $6 >> 1] = (Math_imul(HEAPU16[$2 + $6 >> 1] - $7 << 16 >> 16, $3) >>> 2 | 0) + $7;
     $5 = $5 + 1 | 0;
     if (($5 | 0) != ($4 | 0)) {
      continue;
     }
     break;
    }
   }
   return;
  }
  celt_fatal(15552, 15584, 45);
  abort();
 }
 celt_fatal(15603, 15584, 46);
 abort();
}
function opus_custom_mode_create($0, $1, $2) {
 var $3 = 0;
 label$1 : {
  label$2 : {
   $3 = ($0 | 0) != 48e3;
   if ((($1 | 0) == 960 ? !$3 : 0) | (($1 & 2147483647) == 480 ? !$3 : 0)) {
    break label$2;
   }
   $0 = ($0 | 0) != 48e3;
   if ((($1 & 1073741823) == 240 ? !$0 : 0) | (($1 & 536870911) == 120 ? !$0 : 0)) {
    break label$2;
   }
   $1 = 0;
   if (!$2) {
    break label$1;
   }
   HEAP32[$2 >> 2] = -1;
   break label$1;
  }
  $1 = 17996;
  if (!$2) {
   break label$1;
  }
  HEAP32[$2 >> 2] = 0;
  return 17996;
 }
 return $1;
}
function _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = $2 >>> 16 | 0;
 $5 = $0 >>> 16 | 0;
 $3 = (Math_imul($4, $5) + Math_imul($1, $2) | 0) + Math_imul($3, $0) | 0;
 $2 = $2 & 65535;
 $0 = $0 & 65535;
 $1 = Math_imul($2, $0);
 $2 = ($1 >>> 16 | 0) + Math_imul($2, $5) | 0;
 $3 = $3 + ($2 >>> 16 | 0) | 0;
 $2 = Math_imul($0, $4) + ($2 & 65535) | 0;
 i64toi32_i32$HIGH_BITS = $3 + ($2 >>> 16 | 0) | 0;
 return $1 & 65535 | $2 << 16;
}
function is_digital_silence($0, $1, $2, $3) {
 var $4 = Math_fround(0), $5 = Math_fround(0), $6 = Math_fround(0);
 $1 = Math_imul($1, $2);
 if (($1 | 0) >= 1) {
  $2 = 0;
  while (1) {
   $4 = HEAPF32[($2 << 2) + $0 >> 2];
   $6 = $4 > $6 ? $6 : $4;
   $5 = $4 < $5 ? $5 : $4;
   $2 = $2 + 1 | 0;
   if (($2 | 0) != ($1 | 0)) {
    continue;
   }
   break;
  }
 }
 $4 = Math_fround(-$6);
 return Math_fround(Math_fround(1) / Math_fround(1 << $3)) >= ($4 < $5 ? $5 : $4);
}
function dlrealloc($0, $1) {
 var $2 = 0, $3 = 0;
 if (!$0) {
  return dlmalloc($1);
 }
 if ($1 >>> 0 >= 4294967232) {
  HEAP32[__errno_location() >> 2] = 48;
  return 0;
 }
 $2 = try_realloc_chunk($0 - 8 | 0, $1 >>> 0 < 11 ? 16 : $1 + 11 & -8);
 if ($2) {
  return $2 + 8 | 0;
 }
 $2 = dlmalloc($1);
 if (!$2) {
  return 0;
 }
 $3 = HEAP32[$0 - 4 >> 2];
 $3 = ($3 & 3 ? -4 : -8) + ($3 & -8) | 0;
 memcpy($2, $0, $1 >>> 0 > $3 >>> 0 ? $3 : $1);
 dlfree($0);
 return $2;
}
function silk_bwexpander_FLP($0, $1, $2) {
 var $3 = Math_fround(0), $4 = 0, $5 = 0;
 $4 = $1 - 1 | 0;
 label$1 : {
  if (($1 | 0) < 2) {
   $3 = $2;
   break label$1;
  }
  $1 = 0;
  $3 = $2;
  while (1) {
   $5 = ($1 << 2) + $0 | 0;
   HEAPF32[$5 >> 2] = $3 * HEAPF32[$5 >> 2];
   $3 = Math_fround($3 * $2);
   $1 = $1 + 1 | 0;
   if (($4 | 0) != ($1 | 0)) {
    continue;
   }
   break;
  }
 }
 $1 = ($4 << 2) + $0 | 0;
 HEAPF32[$1 >> 2] = $3 * HEAPF32[$1 >> 2];
}
function silk_log2lin($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = 0;
 label$1 : {
  if (($0 | 0) < 0) {
   break label$1;
  }
  $1 = 2147483647;
  if (($0 | 0) > 3966) {
   break label$1;
  }
  $1 = $0 & 127;
  $2 = $0 >>> 7 | 0;
  $3 = 1 << $2;
  $0 = ($0 | 0) <= 2047 ? (Math_imul(Math_imul(128 - $1 | 0, $1), -174) >> 16) + $1 << $2 >> 7 : Math_imul((Math_imul(Math_imul(128 - $1 | 0, $1), -174) >> 16) + $1 | 0, $3 >>> 7 | 0);
  $1 = $3 + $0 | 0;
 }
 return $1;
}
function silk_sigm_Q15($0) {
 var $1 = 0;
 label$1 : {
  if (($0 | 0) <= -1) {
   $1 = 0;
   if (($0 | 0) < -191) {
    break label$1;
   }
   $0 = 0 - $0 | 0;
   $1 = $0 >>> 3 & 536870908;
   return HEAP32[$1 + 1024 >> 2] - Math_imul(HEAP16[$1 + 1056 >> 1], $0 & 31) | 0;
  }
  $1 = 32767;
  if (($0 | 0) > 191) {
   break label$1;
  }
  $1 = $0 >>> 3 & 536870908;
  $1 = Math_imul(HEAP16[$1 + 1056 >> 1], $0 & 31) + HEAP32[$1 + 1088 >> 2] | 0;
 }
 return $1;
}
function pad($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 256 | 0;
 __stack_pointer = $5;
 if (!($4 & 73728 | ($2 | 0) <= ($3 | 0))) {
  $2 = $2 - $3 | 0;
  $3 = $2 >>> 0 < 256;
  memset($5, $1 & 255, $3 ? $2 : 256);
  if (!$3) {
   while (1) {
    out($0, $5, 256);
    $2 = $2 - 256 | 0;
    if ($2 >>> 0 > 255) {
     continue;
    }
    break;
   }
  }
  out($0, $5, $2);
 }
 __stack_pointer = $5 + 256 | 0;
}
function __stdio_seek($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $0 = __wasi_syscall_ret(legalfunc$__wasi_fd_seek(HEAP32[$0 + 60 >> 2], $1, $2, $3 & 255, $4 + 8 | 0));
 __stack_pointer = $4 + 16 | 0;
 $2 = HEAP32[$4 + 12 >> 2];
 i64toi32_i32$HIGH_BITS = $0 ? -1 : $2;
 $1 = HEAP32[$4 + 8 >> 2];
 return ($0 ? -1 : $1) | 0;
}
function silk_A2NLSF_FLP($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 if (($2 | 0) >= 1) {
  while (1) {
   $5 = $4 << 2;
   HEAP32[$5 + $3 >> 2] = lrintf(Math_fround(HEAPF32[$1 + $5 >> 2] * Math_fround(65536)));
   $4 = $4 + 1 | 0;
   if (($4 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
 }
 silk_A2NLSF($0, $3, $2);
 __stack_pointer = $3 - -64 | 0;
}
function silk_NLSF2A_FLP($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 silk_NLSF2A($4, $1, $2, $3);
 if (($2 | 0) >= 1) {
  $1 = 0;
  while (1) {
   HEAPF32[($1 << 2) + $0 >> 2] = Math_fround(HEAP16[($1 << 1) + $4 >> 1]) * Math_fround(.000244140625);
   $1 = $1 + 1 | 0;
   if (($2 | 0) != ($1 | 0)) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $4 + 32 | 0;
}
function sbrk($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[13136];
 $2 = $0 + 3 & -4;
 $0 = $1 + $2 | 0;
 label$1 : {
  if ($0 >>> 0 <= $1 >>> 0 ? ($2 | 0) >= 1 : 0) {
   break label$1;
  }
  if (__wasm_memory_size() << 16 >>> 0 < $0 >>> 0) {
   if (!(emscripten_resize_heap($0 | 0) | 0)) {
    break label$1;
   }
  }
  HEAP32[13136] = $0;
  return $1;
 }
 HEAP32[__errno_location() >> 2] = 48;
 return -1;
}
function __wasm_nearest_f32($0) {
 var $1 = Math_fround(0), $2 = Math_fround(0);
 $1 = Math_fround(Math_floor($0));
 $2 = Math_fround($0 - $1);
 if (!($2 < Math_fround(.5))) {
  $0 = Math_fround(Math_ceil($0));
  if ($2 > Math_fround(.5)) {
   return $0;
  }
  $2 = Math_fround($1 * Math_fround(.5));
  $1 = Math_fround($2 - Math_fround(Math_floor($2))) == Math_fround(0) ? $1 : $0;
 }
 return $1;
}
function __sin($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = $0 * $0;
 $5 = $3 * ($3 * $3) * ($3 * 1.58969099521155e-10 + -2.5050760253406863e-8) + ($3 * ($3 * 27557313707070068e-22 + -.0001984126982985795) + .00833333333332249);
 $4 = $3 * $0;
 if (!$2) {
  return $4 * ($3 * $5 + -.16666666666666632) + $0;
 }
 return $0 - ($3 * ($1 * .5 - $4 * $5) - $1 + $4 * .16666666666666632);
}
function opus_packet_get_nb_frames($0, $1) {
 var $2 = 0;
 $2 = 1;
 if (($1 | 0) < 1) {
  return -1;
 }
 label$2 : {
  label$3 : {
   switch ((HEAPU8[$0 | 0] & 3) - 1 | 0) {
   case 0:
   case 1:
    return 2;
   case 2:
    break label$3;
   default:
    break label$2;
   }
  }
  $2 = -4;
  if (($1 | 0) < 2) {
   break label$2;
  }
  $2 = HEAPU8[$0 + 1 | 0] & 63;
 }
 return $2;
}
function dlcalloc($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = 0;
 label$2 : {
  if (!$0) {
   break label$2;
  }
  $3 = __wasm_i64_mul($0, 0, $1, 0);
  $4 = i64toi32_i32$HIGH_BITS;
  $2 = $3;
  if (($0 | $1) >>> 0 < 65536) {
   break label$2;
  }
  $2 = $4 ? -1 : $3;
 }
 $3 = $2;
 $0 = dlmalloc($3);
 if (!(!$0 | !(HEAPU8[$0 - 4 | 0] & 3))) {
  memset($0, 0, $3);
 }
 return $0;
}
function __towrite($0) {
 var $1 = 0;
 $1 = HEAPU8[$0 + 74 | 0];
 HEAP8[$0 + 74 | 0] = $1 | $1 - 1;
 $1 = HEAP32[$0 >> 2];
 if ($1 & 8) {
  HEAP32[$0 >> 2] = $1 | 32;
  return -1;
 }
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 $1 = HEAP32[$0 + 44 >> 2];
 HEAP32[$0 + 28 >> 2] = $1;
 HEAP32[$0 + 20 >> 2] = $1;
 HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 48 >> 2] + $1;
 return 0;
}
function silk_lin2log($0) {
 var $1 = 0, $2 = 0;
 $1 = Math_clz32($0);
 $2 = 24 - $1 | 0;
 label$1 : {
  if (!$2) {
   break label$1;
  }
  if ($0 >>> 0 <= 127) {
   $0 = $0 << 0 - $2 | $0 >>> 56 - $1;
   break label$1;
  }
  $0 = $0 << $1 + 8 | $0 >>> $2;
 }
 $0 = $0 & 127;
 return ($0 - ($1 << 7) + (Math_imul(Math_imul(128 - $0 | 0, $0), 179) >>> 16) | 0) + 3968 | 0;
}
function isqrt32($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = 31 - Math_clz32($0) >> 1;
 $3 = 1 << $2;
 while (1) {
  $1 = ($4 << 1) + $3 << $2;
  $5 = $1;
  $1 = $0 >>> 0 < $1 >>> 0;
  $0 = $0 - ($1 ? 0 : $5) | 0;
  $4 = ($1 ? 0 : $3) + $4 | 0;
  $1 = ($2 | 0) > 0;
  $3 = $3 >>> 1 | 0;
  $2 = $2 - 1 | 0;
  if ($1) {
   continue;
  }
  break;
 }
 return $4;
}
function ec_enc_init($0, $1, $2) {
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = -2147483648;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 33;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 >> 2] = $1;
 HEAP32[$0 + 32 >> 2] = 0;
 HEAP32[$0 + 36 >> 2] = 0;
 HEAP32[$0 + 40 >> 2] = -1;
 HEAP32[$0 + 44 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = $2;
}
function opus_packet_get_samples_per_frame($0, $1) {
 $0 = HEAPU8[$0 | 0];
 if ($0 & 128) {
  return ($1 << ($0 >>> 3 & 3)) / 400 | 0;
 }
 if (($0 & 96) == 96) {
  if ($0 & 8) {
   return ($1 | 0) / 50 | 0;
  }
  return ($1 | 0) / 100 | 0;
 }
 $0 = $0 >>> 3 & 3;
 if (($0 | 0) == 3) {
  return (Math_imul($1, 60) | 0) / 1e3 | 0;
 }
 return ($1 << $0) / 100 | 0;
}
function __cos($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = $0 * $0;
 $3 = $2 * .5;
 $4 = 1 - $3;
 $5 = 1 - $4 - $3;
 $3 = $2 * $2;
 return $4 + ($5 + ($2 * ($2 * ($2 * ($2 * 2480158728947673e-20 + -.001388888888887411) + .0416666666666666) + $3 * $3 * ($2 * ($2 * -1.1359647557788195e-11 + 2.087572321298175e-9) + -2.7557314351390663e-7)) - $0 * $1));
}
function silk_autocorrelation_FLP($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = ($2 | 0) < ($3 | 0) ? $2 : $3;
 if (($4 | 0) >= 1) {
  $3 = 0;
  while (1) {
   $5 = $3 << 2;
   HEAPF32[$5 + $0 >> 2] = silk_inner_product_FLP($1, $1 + $5 | 0, $2 - $3 | 0);
   $3 = $3 + 1 | 0;
   if (($4 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
 }
}
function silk_inner_prod_aligned_scale($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 if (($3 | 0) >= 1) {
  while (1) {
   $5 = $4 << 1;
   $6 = (Math_imul(HEAP16[$5 + $1 >> 1], HEAP16[$0 + $5 >> 1]) >> $2) + $6 | 0;
   $4 = $4 + 1 | 0;
   if (($4 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
 }
 return $6;
}
function silk_corrVector_FLP($0, $1, $2, $3, $4) {
 var $5 = 0;
 if (($3 | 0) >= 1) {
  $0 = (($3 << 2) + $0 | 0) - 4 | 0;
  while (1) {
   HEAPF32[($5 << 2) + $4 >> 2] = silk_inner_product_FLP($0, $1, $2);
   $0 = $0 - 4 | 0;
   $5 = $5 + 1 | 0;
   if (($5 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
 }
}
function getint($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 if (isdigit(HEAP8[HEAP32[$0 >> 2]])) {
  while (1) {
   $1 = HEAP32[$0 >> 2];
   $3 = HEAP8[$1 | 0];
   HEAP32[$0 >> 2] = $1 + 1;
   $2 = (Math_imul($2, 10) + $3 | 0) - 48 | 0;
   if (isdigit(HEAP8[$1 + 1 | 0])) {
    continue;
   }
   break;
  }
 }
 return $2;
}
function ec_tell_frac($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = HEAP32[$0 + 20 >> 2] << 3;
 $0 = HEAP32[$0 + 28 >> 2];
 $1 = Math_clz32($0);
 $0 = $0 >>> 16 - $1 | 0;
 $3 = $0;
 $0 = ($0 >>> 12 | 0) - 8 | 0;
 return ((($2 + ($1 << 3) | 0) - ($3 >>> 0 > HEAPU32[($0 << 2) + 32816 >> 2]) | 0) - $0 | 0) - 256 | 0;
}
function ec_enc_shrink($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAP32[$0 + 8 >> 2];
 if ($2 + HEAP32[$0 + 24 >> 2] >>> 0 > $1 >>> 0) {
  celt_fatal(7097, 7019, 238);
  abort();
 }
 $3 = HEAP32[$0 >> 2];
 memmove(($3 + $1 | 0) - $2 | 0, (HEAP32[$0 + 4 >> 2] + $3 | 0) - $2 | 0, $2);
 HEAP32[$0 + 4 >> 2] = $1;
}
function silk_init_encoder($0, $1) {
 $0 = memset($0, 0, 10064);
 HEAP32[$0 + 5092 >> 2] = $1;
 $1 = silk_lin2log(3932160);
 HEAP32[$0 + 4664 >> 2] = 1;
 $1 = ($1 << 8) - 524288 | 0;
 HEAP32[$0 + 12 >> 2] = $1;
 HEAP32[$0 + 8 >> 2] = $1;
 return silk_VAD_Init($0 + 36 | 0);
}
function ec_decode($0, $1) {
 var $2 = 0;
 $2 = HEAPU32[$0 + 28 >> 2] / ($1 >>> 0) | 0;
 HEAP32[$0 + 36 >> 2] = $2;
 $0 = HEAPU32[$0 + 32 >> 2] / ($2 >>> 0) | 0;
 $2 = ($0 ^ -1) + $1 | 0;
 $0 = $0 + 1 | 0;
 $1 = $0 - $1 | 0;
 return $2 + ($0 >>> 0 < $1 >>> 0 ? 0 : $1) | 0;
}
function fmt_x($0, $1, $2, $3) {
 if ($0 | $1) {
  while (1) {
   $2 = $2 - 1 | 0;
   HEAP8[$2 | 0] = HEAPU8[($0 & 15) + 1600 | 0] | $3;
   $0 = ($1 & 15) << 28 | $0 >>> 4;
   $1 = $1 >>> 4 | 0;
   if ($0 | $1) {
    continue;
   }
   break;
  }
 }
 return $2;
}
function fmt_o($0, $1, $2) {
 if ($0 | $1) {
  while (1) {
   $2 = $2 - 1 | 0;
   HEAP8[$2 | 0] = $0 & 7 | 48;
   $0 = ($1 & 7) << 29 | $0 >>> 3;
   $1 = $1 >>> 3 | 0;
   if ($0 | $1) {
    continue;
   }
   break;
  }
 }
 return $2;
}
function silk_gains_ID($0, $1) {
 var $2 = 0, $3 = 0;
 if (($1 | 0) >= 1) {
  while (1) {
   $3 = HEAP8[$0 + $2 | 0] + ($3 << 8) | 0;
   $2 = $2 + 1 | 0;
   if (($2 | 0) != ($1 | 0)) {
    continue;
   }
   break;
  }
 }
 return $3;
}
function celt_fatal($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 8 >> 2] = $0;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 >> 2] = $1;
 fiprintf(HEAP32[278], 1616, $3);
 abort();
 abort();
}
function legalstub$dynCall_jiji($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $0 = dynCall_jiji($0, $1, $2, $3, $4);
 $2 = i64toi32_i32$HIGH_BITS;
 setTempRet0($2 | 0);
 return $0 | 0;
}
function speex_resampler_destroy($0) {
 $0 = $0 | 0;
 dlfree(HEAP32[$0 + 72 >> 2]);
 dlfree(HEAP32[$0 + 76 >> 2]);
 dlfree(HEAP32[$0 + 60 >> 2]);
 dlfree(HEAP32[$0 + 68 >> 2]);
 dlfree(HEAP32[$0 + 64 >> 2]);
 dlfree($0);
}
function __DOUBLE_BITS($0) {
 var $1 = 0, $2 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $2 = wasm2js_scratch_load_i32(0) | 0;
 i64toi32_i32$HIGH_BITS = $1;
 return $2;
}
function celt_encoder_get_size($0) {
 var $1 = 0;
 $1 = opus_custom_mode_create(48e3, 960, 0);
 return Math_imul(((HEAP32[$1 + 4 >> 2] << 2) + (HEAP32[$1 + 8 >> 2] << 4) | 0) + 4096 | 0, $0) + 244 | 0;
}
function fiprintf($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $2;
 $2 = vfiprintf($0, $1, $2);
 __stack_pointer = $3 + 16 | 0;
 return $2;
}
function encode_size($0, $1) {
 var $2 = 0;
 if (($0 | 0) <= 251) {
  HEAP8[$1 | 0] = $0;
  return 1;
 }
 $2 = $0 | -4;
 HEAP8[$1 | 0] = $2;
 HEAP8[$1 + 1 | 0] = $0 - ($2 & 255) >>> 2;
 return 2;
}
function speex_resampler_init($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 return speex_resampler_init_frac($0, $1, $2, $1, $2, $3, $4) | 0;
}
function __wasm_i64_udiv($0, $1, $2, $3) {
 $3 = _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E($0, $1, $2, $3);
 return $3;
}
function __wasm_rotl_i32($0, $1) {
 var $2 = 0;
 $2 = $1 & 31;
 $1 = 0 - $1 & 31;
 return (-1 >>> $2 & $0) << $2 | (-1 << $1 & $0) >>> $1;
}
function lrintf($0) {
 $0 = rintf($0);
 if (Math_fround(Math_abs($0)) < Math_fround(2147483648)) {
  return ~~$0;
 }
 return -2147483648;
}
function legalfunc$__wasi_fd_seek($0, $1, $2, $3, $4) {
 return legalimport$__wasi_fd_seek($0 | 0, $1 | 0, $2 | 0, $3 | 0, $4 | 0) | 0;
}
function __wasm_i64_mul($0, $1, $2, $3) {
 $3 = _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE($0, $1, $2, $3);
 return $3;
}
function tonality_analysis_init($0, $1) {
 HEAP32[$0 + 8 >> 2] = $1;
 HEAP32[$0 >> 2] = 0;
 memset($0 + 12 | 0, 0, 13992);
}
function stackAlloc($0) {
 $0 = $0 | 0;
 $0 = __stack_pointer - $0 & -16;
 __stack_pointer = $0;
 return $0 | 0;
}
function silk_resampler_private_up2_HQ_wrapper($0, $1, $2, $3) {
 silk_resampler_private_up2_HQ($0, $1, $2, $3);
}
function __wasi_syscall_ret($0) {
 if (!$0) {
  return 0;
 }
 HEAP32[__errno_location() >> 2] = $0;
 return -1;
}
function dynCall_jiji($0, $1, $2, $3, $4) {
 $3 = FUNCTION_TABLE[$0 | 0]($1, $2, $3, $4) | 0;
 return $3;
}
function __stdio_close($0) {
 $0 = $0 | 0;
 return __wasi_fd_close(dummy(HEAP32[$0 + 60 >> 2]) | 0) | 0;
}
function __wasm_ctz_i32($0) {
 if ($0) {
  return 31 - Math_clz32($0 - 1 ^ $0) | 0;
 }
 return 32;
}



function opus_repacketizer_cat($0, $1, $2) {
 return opus_repacketizer_cat_impl($0, $1, $2, 0);
}
function out($0, $1, $2) {
 if (!(HEAPU8[$0 | 0] & 32)) {
  __fwritex($1, $2, $0);
 }
}
function wctomb($0, $1) {
 if (!$0) {
  return 0;
 }
 return wcrtomb($0, $1, 0);
}
function vfiprintf($0, $1, $2) {
 return __vfprintf_internal($0, $1, $2, 0, 0);
}
function silk_stereo_encode_mid_only($0, $1) {
 ec_enc_icdf($0, $1, 5801, 8);
}
function opus_repacketizer_init($0) {
 HEAP32[$0 + 4 >> 2] = 0;
 return $0;
}
function silk_Get_Encoder_Size($0) {
 HEAP32[$0 >> 2] = 20216;
 return 0;
}
function tonality_analysis_reset($0) {
 memset($0 + 12 | 0, 0, 13992);
}
function stackRestore($0) {
 $0 = $0 | 0;
 __stack_pointer = $0;
}
function opus_encoder_destroy($0) {
 $0 = $0 | 0;
 dlfree($0);
}
function rintf($0) {
 return __wasm_nearest_f32($0);
}
function stackSave() {
 return __stack_pointer | 0;
}
function isdigit($0) {
 return $0 - 48 >>> 0 < 10;
}
function floor($0) {
 return Math_floor($0);
}
function __errno_location() {
 return 52924;
}
function __pthread_self() {
 return 52696;
}
function __lockfile($0) {
 return 1;
}
function dummy($0) {
 return $0;
}
function __wasm_call_ctors() {}
function __unlockfile($0) {}

// EMSCRIPTEN_END_FUNCS

;
 bufferView = HEAPU8;
 initActiveSegments(env);
 var FUNCTION_TABLE = Table([null, __stdio_close, __stdio_write, __stdio_seek, downmix_float, resampler_basic_direct_double, resampler_basic_direct_single, resampler_basic_interpolate_double, resampler_basic_interpolate_single, resampler_basic_zero]);
 function __wasm_memory_size() {
  return buffer.byteLength / 65536 | 0;
}
 
 return {
  "__wasm_call_ctors": __wasm_call_ctors, 
  "opus_encoder_create": opus_encoder_create, 
  "opus_encode_float": opus_encode_float, 
  "opus_encoder_ctl": opus_encoder_ctl, 
  "opus_encoder_destroy": opus_encoder_destroy, 
  "speex_resampler_init": speex_resampler_init, 
  "speex_resampler_destroy": speex_resampler_destroy, 
  "speex_resampler_process_interleaved_float": speex_resampler_process_interleaved_float, 
  "__errno_location": __errno_location, 
  "stackSave": stackSave, 
  "stackRestore": stackRestore, 
  "stackAlloc": stackAlloc, 
  "malloc": dlmalloc, 
  "free": dlfree, 
  "__indirect_function_table": FUNCTION_TABLE, 
  "dynCall_jiji": legalstub$dynCall_jiji
};
}

  return asmFunc(asmLibraryArg);
}
// EMSCRIPTEN_END_ASM




)(asmLibraryArg);
  },

  instantiate: /** @suppress{checkTypes} */ function(binary, info) {
    return {
      then: function(ok) {
        var module = new WebAssembly.Module(binary);
        ok({
          'instance': new WebAssembly.Instance(module)
        });
      }
    };
  },

  RuntimeError: Error
};

// We don't need to actually download a wasm binary, mark it as present but empty.
wasmBinary = [];

// end include: wasm2js.js
if (typeof WebAssembly !== 'object') {
  abort('no native wasm support detected');
}

// include: runtime_safe_heap.js


// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.
// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)

/** @param {number} ptr
    @param {number} value
    @param {string} type
    @param {number|boolean=} noSafe */
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)] = value; break;
      case 'i8': HEAP8[((ptr)>>0)] = value; break;
      case 'i16': HEAP16[((ptr)>>1)] = value; break;
      case 'i32': HEAP32[((ptr)>>2)] = value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)] = value; break;
      case 'double': HEAPF64[((ptr)>>3)] = value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

/** @param {number} ptr
    @param {string} type
    @param {number|boolean=} noSafe */
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}

// end include: runtime_safe_heap.js
// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
/** @param {string|null=} returnType
    @param {Array=} argTypes
    @param {Arguments|Array=} args
    @param {Object=} opts */
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);

  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);
  return ret;
}

/** @param {string=} returnType
    @param {Array=} argTypes
    @param {Object=} opts */
function cwrap(ident, returnType, argTypes, opts) {
  argTypes = argTypes || [];
  // When the function takes numbers and returns a number, we can just return
  // the original function
  var numericArgs = argTypes.every(function(type){ return type === 'number'});
  var numericRet = returnType !== 'string';
  if (numericRet && numericArgs && !opts) {
    return getCFunc(ident);
  }
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data.
// @allocator: How to allocate memory, see ALLOC_*
/** @type {function((Uint8Array|Array<number>), number)} */
function allocate(slab, allocator) {
  var ret;

  if (allocator == ALLOC_STACK) {
    ret = stackAlloc(slab.length);
  } else {
    ret = _malloc(slab.length);
  }

  if (slab.subarray || slab.slice) {
    HEAPU8.set(/** @type {!Uint8Array} */(slab), ret);
  } else {
    HEAPU8.set(new Uint8Array(slab), ret);
  }
  return ret;
}

// include: runtime_strings.js


// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

/**
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heap, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(heap.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = heap[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = heap[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = heap[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}

// end include: runtime_strings.js
// include: runtime_strings_extra.js


// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;

function UTF16ToString(ptr, maxBytesToRead) {
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  var maxIdx = idx + maxBytesToRead / 2;
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var str = '';

    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition
    // will always evaluate to true. The loop is then terminated on the first null char.
    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) break;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }

    return str;
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)] = codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr, maxBytesToRead) {
  var i = 0;

  var str = '';
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(i >= maxBytesToRead / 4)) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0) break;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
  return str;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)] = codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated
    @param {boolean=} dontAddNull */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  HEAP8.set(array, buffer);
}

/** @param {boolean=} dontAddNull */
function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    HEAP8[((buffer++)>>0)] = str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;
}

// end include: runtime_strings_extra.js
// Memory management

function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}

var HEAP,
/** @type {ArrayBuffer} */
  buffer,
/** @type {Int8Array} */
  HEAP8,
/** @type {Uint8Array} */
  HEAPU8,
/** @type {Int16Array} */
  HEAP16,
/** @type {Uint16Array} */
  HEAPU16,
/** @type {Int32Array} */
  HEAP32,
/** @type {Uint32Array} */
  HEAPU32,
/** @type {Float32Array} */
  HEAPF32,
/** @type {Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var TOTAL_STACK = 5242880;

var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;

// In non-standalone/normal mode, we create the memory here.
// include: runtime_init_memory.js


// Create the wasm memory. (Note: this only applies if IMPORTED_MEMORY is defined)

  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_MEMORY / 65536
      ,
      'maximum': INITIAL_MEMORY / 65536
    });
  }

if (wasmMemory) {
  buffer = wasmMemory.buffer;
}

// If the user provides an incorrect length, just use that length instead rather than providing the user to
// specifically provide the memory length with Module['INITIAL_MEMORY'].
INITIAL_MEMORY = buffer.byteLength;
updateGlobalBufferAndViews(buffer);

// end include: runtime_init_memory.js

// include: runtime_init_table.js
// In regular non-RELOCATABLE mode the table is exported
// from the wasm module and this will be assigned once
// the exports are available.
var wasmTable;

// end include: runtime_init_table.js
// include: runtime_stack_check.js


// end include: runtime_stack_check.js
// include: runtime_assertions.js


// end include: runtime_assertions.js
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;
var runtimeExited = false;

__ATINIT__.push({ func: function() { ___wasm_call_ctors() } });

function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  runtimeInitialized = true;
  
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  runtimeExited = true;
}

function postRun() {

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// include: runtime_math.js


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data

/** @param {string|number=} what */
function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  what += '';
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  what = 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.';

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  var e = new WebAssembly.RuntimeError(what);

  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// {{MEM_INITIALIZER}}

// include: memoryprofiler.js


// end include: memoryprofiler.js
// include: URIUtils.js


function hasPrefix(str, prefix) {
  return String.prototype.startsWith ?
      str.startsWith(prefix) :
      str.indexOf(prefix) === 0;
}

// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  return hasPrefix(filename, dataURIPrefix);
}

var fileURIPrefix = "file://";

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return hasPrefix(filename, fileURIPrefix);
}

// end include: URIUtils.js
var wasmBinaryFile = '<<< WASM_BINARY_FILE >>>';
if (!isDataURI(wasmBinaryFile)) {
  wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinary(file) {
  try {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    var binary = tryParseAsDataURI(file);
    if (binary) {
      return binary;
    }
    if (readBinary) {
      return readBinary(file);
    } else {
      throw "sync fetching of the wasm failed: you can preload it to Module['wasmBinary'] manually, or emcc.py will do that for you when generating HTML (but not JS)";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, try to to load it asynchronously.
  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
  // See https://github.com/github/fetch/pull/92#issuecomment-140665932
  // Cordova or Electron apps are typically loaded from a file:// url.
  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch === 'function'
      && !isFileURI(wasmBinaryFile)
    ) {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(function () {
          return getBinary(wasmBinaryFile);
      });
    }
    else {
      if (readAsync) {
        // fetch is not available or url is file => try XHR (readAsync uses XHR internally)
        return new Promise(function(resolve, reject) {
          readAsync(wasmBinaryFile, function(response) { resolve(new Uint8Array(/** @type{!ArrayBuffer} */(response))) }, reject)
        });
      }
    }
  }
    
  // Otherwise, getBinary should be able to get it synchronously
  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });
}

function instantiateSync(file, info) {
  var instance;
  var module;
  var binary;
  try {
    binary = getBinary(file);
    module = new WebAssembly.Module(binary);
    instance = new WebAssembly.Instance(module, info);
  } catch (e) {
    var str = e.toString();
    err('failed to compile wasm module: ' + str);
    if (str.indexOf('imported Memory') >= 0 ||
        str.indexOf('memory import') >= 0) {
      err('Memory size incompatibility issues may be due to changing INITIAL_MEMORY at runtime to something too large. Use ALLOW_MEMORY_GROWTH to allow any size memory (and also make sure not to set INITIAL_MEMORY at runtime to something smaller than it was at compile time).');
    }
    throw e;
  }
  return [instance, module];
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg,
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;

    Module['asm'] = exports;

    wasmTable = Module['asm']['__indirect_function_table'];

    removeRunDependency('wasm-instantiate');
  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');

  function receiveInstantiatedSource(output) {
    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(output['instance']);
  }

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);

      abort(reason);
    });
  }

  // Prefer streaming instantiation if available.

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  var result = instantiateSync(wasmBinaryFile, info);
  receiveInstance(result[0], result[1]);
  return Module['asm']; // exports were assigned here
}

// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  
};






  function callRuntimeCallbacks(callbacks) {
      while(callbacks.length > 0) {
        var callback = callbacks.shift();
        if (typeof callback == 'function') {
          callback(Module); // Pass the module as the first argument.
          continue;
        }
        var func = callback.func;
        if (typeof func === 'number') {
          if (callback.arg === undefined) {
            wasmTable.get(func)();
          } else {
            wasmTable.get(func)(callback.arg);
          }
        } else {
          func(callback.arg === undefined ? null : callback.arg);
        }
      }
    }

  function demangle(func) {
      return func;
    }

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }

  function jsStackTrace() {
      var error = new Error();
      if (!error.stack) {
        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
        // so try that as a special-case.
        try {
          throw new Error();
        } catch(e) {
          error = e;
        }
        if (!error.stack) {
          return '(no stack trace available)';
        }
      }
      return error.stack.toString();
    }

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }

  function _abort() {
      abort();
    }

  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }

  function _emscripten_get_heap_size() {
      return HEAPU8.length;
    }
  
  function abortOnCannotGrowMemory(requestedSize) {
      abort('OOM');
    }
  function _emscripten_resize_heap(requestedSize) {
      abortOnCannotGrowMemory(requestedSize);
    }

  var SYSCALLS={mappings:{},buffers:[null,[],[]],printChar:function(stream, curr) {
        var buffer = SYSCALLS.buffers[stream];
        if (curr === 0 || curr === 10) {
          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
          buffer.length = 0;
        } else {
          buffer.push(curr);
        }
      },varargs:undefined,get:function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },get64:function(low, high) {
        return low;
      }};
  function _fd_close(fd) {
      return 0;
    }

  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
  }

  function flush_NO_FILESYSTEM() {
      // flush anything remaining in the buffers during shutdown
      if (typeof _fflush !== 'undefined') _fflush(0);
      var buffers = SYSCALLS.buffers;
      if (buffers[1].length) SYSCALLS.printChar(1, 10);
      if (buffers[2].length) SYSCALLS.printChar(2, 10);
    }
  function _fd_write(fd, iov, iovcnt, pnum) {
      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0
      var num = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAP32[(((iov)+(i*8))>>2)];
        var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
        for (var j = 0; j < len; j++) {
          SYSCALLS.printChar(fd, HEAPU8[ptr+j]);
        }
        num += len;
      }
      HEAP32[((pnum)>>2)] = num
      return 0;
    }

  function _setTempRet0($i) {
      setTempRet0(($i) | 0);
    }
var ASSERTIONS = false;



/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

/**
 * Decodes a base64 string.
 * @param {string} input The string to decode.
 */
var decodeBase64 = typeof atob === 'function' ? atob : function (input) {
  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  var output = '';
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0;
  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  do {
    enc1 = keyStr.indexOf(input.charAt(i++));
    enc2 = keyStr.indexOf(input.charAt(i++));
    enc3 = keyStr.indexOf(input.charAt(i++));
    enc4 = keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 !== 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
      output = output + String.fromCharCode(chr3);
    }
  } while (i < input.length);
  return output;
};

// Converts a string of base64 into a byte array.
// Throws error on invalid input.
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {
    var buf;
    try {
      // TODO: Update Node.js externs, Closure does not recognize the following Buffer.from()
      /**@suppress{checkTypes}*/
      buf = Buffer.from(s, 'base64');
    } catch (_) {
      buf = new Buffer(s, 'base64');
    }
    return new Uint8Array(buf['buffer'], buf['byteOffset'], buf['byteLength']);
  }

  try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0 ; i < decoded.length ; ++i) {
      bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
  } catch (_) {
    throw new Error('Converting base64 string to bytes failed.');
  }
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}


var asmLibraryArg = {
  "abort": _abort,
  "emscripten_memcpy_big": _emscripten_memcpy_big,
  "emscripten_resize_heap": _emscripten_resize_heap,
  "fd_close": _fd_close,
  "fd_seek": _fd_seek,
  "fd_write": _fd_write,
  "getTempRet0": getTempRet0,
  "memory": wasmMemory,
  "setTempRet0": setTempRet0
};
var asm = createWasm();
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = asm["__wasm_call_ctors"]

/** @type {function(...*):?} */
var _opus_encoder_create = Module["_opus_encoder_create"] = asm["opus_encoder_create"]

/** @type {function(...*):?} */
var _opus_encode_float = Module["_opus_encode_float"] = asm["opus_encode_float"]

/** @type {function(...*):?} */
var _opus_encoder_ctl = Module["_opus_encoder_ctl"] = asm["opus_encoder_ctl"]

/** @type {function(...*):?} */
var _opus_encoder_destroy = Module["_opus_encoder_destroy"] = asm["opus_encoder_destroy"]

/** @type {function(...*):?} */
var _speex_resampler_init = Module["_speex_resampler_init"] = asm["speex_resampler_init"]

/** @type {function(...*):?} */
var _speex_resampler_destroy = Module["_speex_resampler_destroy"] = asm["speex_resampler_destroy"]

/** @type {function(...*):?} */
var _speex_resampler_process_interleaved_float = Module["_speex_resampler_process_interleaved_float"] = asm["speex_resampler_process_interleaved_float"]

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = asm["__errno_location"]

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = asm["stackSave"]

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = asm["stackRestore"]

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = asm["stackAlloc"]

/** @type {function(...*):?} */
var _malloc = Module["_malloc"] = asm["malloc"]

/** @type {function(...*):?} */
var _free = Module["_free"] = asm["free"]

/** @type {function(...*):?} */
var dynCall_jiji = Module["dynCall_jiji"] = asm["dynCall_jiji"]





// === Auto-generated postamble setup entry stuff ===



var calledRun;

/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
}
Module['run'] = run;

/** @param {boolean|number=} implicit */
function exit(status, implicit) {

  // if this is just main exit-ing implicitly, and the status is 0, then we
  // don't need to do anything here and can just leave. if the status is
  // non-zero, though, then we need to report it.
  // (we may have warned about this earlier, if a situation justifies doing so)
  if (implicit && noExitRuntime && status === 0) {
    return;
  }

  if (noExitRuntime) {
  } else {

    EXITSTATUS = status;

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);

    ABORT = true;
  }

  quit_(status, new ExitStatus(status));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

run();






return Module;
}, 'OpusEncoderLib'));//END: UMD wrapper

